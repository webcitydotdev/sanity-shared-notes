import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import * as React$2 from "react";
import React__default, { useContext, useMemo, useRef, useDebugValue, createElement, forwardRef, useLayoutEffect, useEffect, createContext, useInsertionEffect, useCallback, Fragment, useId, useState, cloneElement, Children, isValidElement, useImperativeHandle, memo as memo$1, useReducer, useSyncExternalStore } from "react";
import { definePlugin, useClient } from "sanity";
const defaultThemeConfig = {
  _version: 2,
  avatar: {
    sizes: [
      { distance: -4, size: 19 },
      { distance: -4, size: 25 },
      { distance: -8, size: 33 },
      { distance: -12, size: 49 }
    ],
    focusRing: { offset: 1, width: 1 }
  },
  button: {
    textWeight: "medium",
    border: { width: 1 },
    focusRing: { offset: -1, width: 1 }
  },
  card: {
    border: { width: 1 },
    focusRing: { offset: -1, width: 1 },
    shadow: { outline: 0.5 }
  },
  container: [320, 640, 960, 1280, 1600, 1920],
  media: [360, 600, 900, 1200, 1800, 2400],
  layer: {
    dialog: { zOffset: 600 },
    popover: { zOffset: 400 },
    tooltip: { zOffset: 200 }
  },
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadow: [
    null,
    { umbra: [0, 0, 0, 0], penumbra: [0, 0, 0, 0], ambient: [0, 0, 0, 0] },
    { umbra: [0, 3, 5, -2], penumbra: [0, 6, 10, 0], ambient: [0, 1, 18, 1] },
    { umbra: [0, 7, 8, -4], penumbra: [0, 12, 17, 2], ambient: [0, 5, 22, 4] },
    { umbra: [0, 9, 11, -5], penumbra: [0, 18, 28, 2], ambient: [0, 7, 34, 6] },
    { umbra: [0, 11, 15, -7], penumbra: [0, 24, 38, 3], ambient: [0, 9, 46, 8] }
  ],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    border: {
      width: 1
    },
    checkbox: {
      size: 17,
      focusRing: { offset: -1, width: 1 }
    },
    radio: {
      size: 17,
      markSize: 9,
      focusRing: { offset: -1, width: 1 }
    },
    switch: {
      width: 25,
      height: 17,
      padding: 5,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out",
      focusRing: { offset: 1, width: 1 }
    },
    select: {
      focusRing: { offset: -1, width: 1 }
    },
    text: {
      focusRing: { offset: -1, width: 1 }
    }
  },
  style: {
    button: {
      root: {
        transition: "background-color 100ms,border-color 100ms,color 100ms"
      }
    }
    // card: {
    //   root: {
    //     transition: 'background-color 100ms,border-color 100ms,color 100ms',
    //   },
    // },
  }
}, cache$1$1 = /* @__PURE__ */ new WeakMap();
function themeColor_v0_v2(color_v0) {
  var _a, _b, _c;
  const cached_v2 = cache$1$1.get(color_v0);
  if (cached_v2) return cached_v2;
  const base = stateThemeColor_v0_v2(color_v0, color_v0.card.enabled), color_v2 = {
    _blend: color_v0._blend || (color_v0.dark ? "screen" : "multiply"),
    _dark: color_v0.dark,
    accent: base.accent,
    avatar: base.avatar,
    backdrop: color_v0.base.shadow.ambient,
    badge: base.badge,
    bg: color_v0.base.bg,
    border: color_v0.base.border,
    button: {
      default: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.default),
      ghost: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.ghost),
      bleed: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.bleed)
    },
    code: base.code,
    fg: color_v0.base.fg,
    focusRing: color_v0.base.focusRing,
    icon: base.muted.fg,
    input: {
      default: inputStatesThemeColor_v0_v2(color_v0.input.default),
      invalid: inputStatesThemeColor_v0_v2(color_v0.input.invalid)
    },
    kbd: base.kbd,
    link: base.link,
    muted: {
      ...base.muted,
      bg: ((_a = color_v0.selectable) == null ? void 0 : _a.default.enabled.bg2) || color_v0.base.bg
    },
    selectable: stateTonesThemeColor_v0_v2(color_v0, color_v0.selectable || color_v0.muted),
    shadow: color_v0.base.shadow,
    skeleton: {
      from: ((_b = color_v0.skeleton) == null ? void 0 : _b.from) || color_v0.base.border,
      to: ((_c = color_v0.skeleton) == null ? void 0 : _c.to) || color_v0.base.border
    },
    syntax: color_v0.syntax
  };
  return cache$1$1.set(color_v0, color_v2), color_v2;
}
function stateTonesThemeColor_v0_v2(v0, t) {
  return {
    default: {
      enabled: stateThemeColor_v0_v2(v0, t.default.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.default.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.default.pressed),
      selected: stateThemeColor_v0_v2(v0, t.default.selected),
      disabled: stateThemeColor_v0_v2(v0, t.default.disabled)
    },
    primary: {
      enabled: stateThemeColor_v0_v2(v0, t.primary.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.primary.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.primary.pressed),
      selected: stateThemeColor_v0_v2(v0, t.primary.selected),
      disabled: stateThemeColor_v0_v2(v0, t.primary.disabled)
    },
    positive: {
      enabled: stateThemeColor_v0_v2(v0, t.positive.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.positive.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.positive.pressed),
      selected: stateThemeColor_v0_v2(v0, t.positive.selected),
      disabled: stateThemeColor_v0_v2(v0, t.positive.disabled)
    },
    caution: {
      enabled: stateThemeColor_v0_v2(v0, t.caution.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.caution.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.caution.pressed),
      selected: stateThemeColor_v0_v2(v0, t.caution.selected),
      disabled: stateThemeColor_v0_v2(v0, t.caution.disabled)
    },
    critical: {
      enabled: stateThemeColor_v0_v2(v0, t.critical.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.critical.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.critical.pressed),
      selected: stateThemeColor_v0_v2(v0, t.critical.selected),
      disabled: stateThemeColor_v0_v2(v0, t.critical.disabled)
    }
  };
}
function stateThemeColor_v0_v2(v0, state) {
  var _a, _b;
  return {
    ...state,
    avatar: {
      gray: {
        bg: v0.spot.gray,
        fg: v0.base.bg
      },
      blue: {
        bg: v0.spot.blue,
        fg: v0.base.bg
      },
      purple: {
        bg: v0.spot.purple,
        fg: v0.base.bg
      },
      magenta: {
        bg: v0.spot.magenta,
        fg: v0.base.bg
      },
      red: {
        bg: v0.spot.red,
        fg: v0.base.bg
      },
      orange: {
        bg: v0.spot.orange,
        fg: v0.base.bg
      },
      yellow: {
        bg: v0.spot.yellow,
        fg: v0.base.bg
      },
      green: {
        bg: v0.spot.green,
        fg: v0.base.bg
      },
      cyan: {
        bg: v0.spot.cyan,
        fg: v0.base.bg
      }
    },
    badge: {
      default: {
        bg: v0.muted.default.enabled.bg,
        fg: v0.muted.default.enabled.fg,
        dot: v0.muted.default.enabled.muted.fg,
        icon: v0.muted.default.enabled.muted.fg
      },
      primary: {
        bg: v0.muted.primary.enabled.bg,
        fg: v0.muted.primary.enabled.fg,
        dot: v0.muted.primary.enabled.muted.fg,
        icon: v0.muted.primary.enabled.muted.fg
      },
      positive: {
        bg: v0.muted.positive.enabled.bg,
        fg: v0.muted.positive.enabled.fg,
        dot: v0.muted.positive.enabled.muted.fg,
        icon: v0.muted.positive.enabled.muted.fg
      },
      caution: {
        bg: v0.muted.caution.enabled.bg,
        fg: v0.muted.caution.enabled.fg,
        dot: v0.muted.caution.enabled.muted.fg,
        icon: v0.muted.caution.enabled.muted.fg
      },
      critical: {
        bg: v0.muted.critical.enabled.bg,
        fg: v0.muted.critical.enabled.fg,
        dot: v0.muted.critical.enabled.muted.fg,
        icon: v0.muted.critical.enabled.muted.fg
      }
    },
    kbd: {
      bg: v0.muted.default.enabled.bg,
      fg: v0.muted.default.enabled.fg,
      border: v0.muted.default.enabled.border
    },
    muted: {
      ...v0.muted.default.enabled.muted,
      bg: state.bg2 || state.bg
    },
    skeleton: {
      from: ((_a = state.skeleton) == null ? void 0 : _a.from) || state.border,
      to: ((_b = state.skeleton) == null ? void 0 : _b.to) || state.border
    }
  };
}
function inputStatesThemeColor_v0_v2(states) {
  return {
    enabled: inputStateThemeColor_v0_v2(states.enabled),
    disabled: inputStateThemeColor_v0_v2(states.disabled),
    readOnly: inputStateThemeColor_v0_v2(states.readOnly),
    hovered: inputStateThemeColor_v0_v2(states.hovered)
  };
}
function inputStateThemeColor_v0_v2(state) {
  return {
    bg: state.bg,
    border: state.border,
    fg: state.fg,
    muted: {
      bg: state.bg2
    },
    placeholder: state.placeholder
  };
}
const cache$4 = /* @__PURE__ */ new WeakMap();
function getTheme_v2(theme) {
  var _a, _b;
  if ((_a = theme.sanity.v2) != null && _a._resolved) return theme.sanity.v2;
  const cached_v2 = cache$4.get(theme);
  if (cached_v2) return cached_v2;
  const v2 = {
    _version: 2,
    _resolved: !0,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...theme.sanity.avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...theme.sanity.button
    },
    card: defaultThemeConfig.card,
    color: themeColor_v0_v2(theme.sanity.color),
    container: theme.sanity.container,
    font: theme.sanity.fonts,
    input: {
      ...defaultThemeConfig.input,
      ...theme.sanity.input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...theme.sanity.input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...theme.sanity.input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...theme.sanity.input.switch
      }
    },
    layer: (_b = theme.sanity.layer) != null ? _b : defaultThemeConfig.layer,
    media: theme.sanity.media,
    radius: theme.sanity.radius,
    shadow: theme.sanity.shadows,
    space: theme.sanity.space,
    style: theme.sanity.styles
  };
  return cache$4.set(theme, v2), v2;
}
const COLOR_HUES = [
  "gray",
  "blue",
  "purple",
  "magenta",
  "red",
  "orange",
  "yellow",
  "green",
  "cyan"
], COLOR_TINTS = [
  "50",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900",
  "950"
], black = {
  title: "Black",
  hex: "#0d0e12"
}, white = {
  title: "White",
  hex: "#ffffff"
}, gray = {
  50: {
    title: "Gray 50",
    hex: "#f6f6f8"
  },
  100: {
    title: "Gray 100",
    hex: "#eeeef1"
  },
  200: {
    title: "Gray 200",
    hex: "#e3e4e8"
  },
  300: {
    title: "Gray 300",
    hex: "#bbbdc9"
  },
  400: {
    title: "Gray 400",
    hex: "#9499ad"
  },
  500: {
    title: "Gray 500",
    hex: "#727892"
  },
  600: {
    title: "Gray 600",
    hex: "#515870"
  },
  700: {
    title: "Gray 700",
    hex: "#383d51"
  },
  800: {
    title: "Gray 800",
    hex: "#252837"
  },
  900: {
    title: "Gray 900",
    hex: "#1b1d27"
  },
  950: {
    title: "Gray 950",
    hex: "#13141b"
  }
}, blue = {
  50: {
    title: "Blue 50",
    hex: "#f5f8ff"
  },
  100: {
    title: "Blue 100",
    hex: "#e5edff"
  },
  200: {
    title: "Blue 200",
    hex: "#dbe5ff"
  },
  300: {
    title: "Blue 300",
    hex: "#a8bfff"
  },
  400: {
    title: "Blue 400",
    hex: "#7595ff"
  },
  500: {
    title: "Blue 500",
    hex: "#556bfc"
  },
  600: {
    title: "Blue 600",
    hex: "#4043e7"
  },
  700: {
    title: "Blue 700",
    hex: "#2927aa"
  },
  800: {
    title: "Blue 800",
    hex: "#192457"
  },
  900: {
    title: "Blue 900",
    hex: "#161a41"
  },
  950: {
    title: "Blue 950",
    hex: "#101228"
  }
}, purple = {
  50: {
    title: "Purple 50",
    hex: "#f8f5ff"
  },
  100: {
    title: "Purple 100",
    hex: "#f1ebff"
  },
  200: {
    title: "Purple 200",
    hex: "#ece1fe"
  },
  300: {
    title: "Purple 300",
    hex: "#ccb1fc"
  },
  400: {
    title: "Purple 400",
    hex: "#b087f7"
  },
  500: {
    title: "Purple 500",
    hex: "#8f57ef"
  },
  600: {
    title: "Purple 600",
    hex: "#721fe5"
  },
  700: {
    title: "Purple 700",
    hex: "#4c1a9e"
  },
  800: {
    title: "Purple 800",
    hex: "#2f1862"
  },
  900: {
    title: "Purple 900",
    hex: "#23173f"
  },
  950: {
    title: "Purple 950",
    hex: "#181128"
  }
}, magenta = {
  50: {
    title: "Magenta 50",
    hex: "#fef6f9"
  },
  100: {
    title: "Magenta 100",
    hex: "#fde8ef"
  },
  200: {
    title: "Magenta 200",
    hex: "#fcdee9"
  },
  300: {
    title: "Magenta 300",
    hex: "#f7abc5"
  },
  400: {
    title: "Magenta 400",
    hex: "#f0709b"
  },
  500: {
    title: "Magenta 500",
    hex: "#e72767"
  },
  600: {
    title: "Magenta 600",
    hex: "#b11651"
  },
  700: {
    title: "Magenta 700",
    hex: "#7c1342"
  },
  800: {
    title: "Magenta 800",
    hex: "#4b1130"
  },
  900: {
    title: "Magenta 900",
    hex: "#341325"
  },
  950: {
    title: "Magenta 950",
    hex: "#1f0f14"
  }
}, red = {
  50: {
    title: "Red 50",
    hex: "#fff6f5"
  },
  100: {
    title: "Red 100",
    hex: "#ffe7e5"
  },
  200: {
    title: "Red 200",
    hex: "#ffdedc"
  },
  300: {
    title: "Red 300",
    hex: "#fdada5"
  },
  400: {
    title: "Red 400",
    hex: "#f77769"
  },
  500: {
    title: "Red 500",
    hex: "#ef4434"
  },
  600: {
    title: "Red 600",
    hex: "#cc2819"
  },
  700: {
    title: "Red 700",
    hex: "#8b2018"
  },
  800: {
    title: "Red 800",
    hex: "#4d1714"
  },
  900: {
    title: "Red 900",
    hex: "#321615"
  },
  950: {
    title: "Red 950",
    hex: "#1e1011"
  }
}, orange = {
  50: {
    title: "Orange 50",
    hex: "#fff7f0"
  },
  100: {
    title: "Orange 100",
    hex: "#ffeadb"
  },
  200: {
    title: "Orange 200",
    hex: "#ffddc7"
  },
  300: {
    title: "Orange 300",
    hex: "#ffb685"
  },
  400: {
    title: "Orange 400",
    hex: "#ff8e42"
  },
  500: {
    title: "Orange 500",
    hex: "#fa6400"
  },
  600: {
    title: "Orange 600",
    hex: "#b14802"
  },
  700: {
    title: "Orange 700",
    hex: "#7c3404"
  },
  800: {
    title: "Orange 800",
    hex: "#461e07"
  },
  900: {
    title: "Orange 900",
    hex: "#32160b"
  },
  950: {
    title: "Orange 950",
    hex: "#21120d"
  }
}, yellow = {
  50: {
    title: "Yellow 50",
    hex: "#fefae1"
  },
  100: {
    title: "Yellow 100",
    hex: "#fcf3bb"
  },
  200: {
    title: "Yellow 200",
    hex: "#f9e994"
  },
  300: {
    title: "Yellow 300",
    hex: "#f7d455"
  },
  400: {
    title: "Yellow 400",
    hex: "#f9bc15"
  },
  500: {
    title: "Yellow 500",
    hex: "#d28a04"
  },
  600: {
    title: "Yellow 600",
    hex: "#965908"
  },
  700: {
    title: "Yellow 700",
    hex: "#653a0b"
  },
  800: {
    title: "Yellow 800",
    hex: "#3b220c"
  },
  900: {
    title: "Yellow 900",
    hex: "#271a11"
  },
  950: {
    title: "Yellow 950",
    hex: "#181410"
  }
}, green = {
  50: {
    title: "Green 50",
    hex: "#e7fef5"
  },
  100: {
    title: "Green 100",
    hex: "#c5fce8"
  },
  200: {
    title: "Green 200",
    hex: "#a9f9dc"
  },
  300: {
    title: "Green 300",
    hex: "#59f3ba"
  },
  400: {
    title: "Green 400",
    hex: "#0ff0a1"
  },
  500: {
    title: "Green 500",
    hex: "#04b97a"
  },
  600: {
    title: "Green 600",
    hex: "#01794f"
  },
  700: {
    title: "Green 700",
    hex: "#015133"
  },
  800: {
    title: "Green 800",
    hex: "#023120"
  },
  900: {
    title: "Green 900",
    hex: "#06231a"
  },
  950: {
    title: "Green 950",
    hex: "#071715"
  }
}, cyan = {
  50: {
    title: "Cyan 50",
    hex: "#e7fefe"
  },
  100: {
    title: "Cyan 100",
    hex: "#c5fcfc"
  },
  200: {
    title: "Cyan 200",
    hex: "#96f8f8"
  },
  300: {
    title: "Cyan 300",
    hex: "#62efef"
  },
  400: {
    title: "Cyan 400",
    hex: "#18e2e2"
  },
  500: {
    title: "Cyan 500",
    hex: "#04b8be"
  },
  600: {
    title: "Cyan 600",
    hex: "#037782"
  },
  700: {
    title: "Cyan 700",
    hex: "#024950"
  },
  800: {
    title: "Cyan 800",
    hex: "#042f34"
  },
  900: {
    title: "Cyan 900",
    hex: "#072227"
  },
  950: {
    title: "Cyan 950",
    hex: "#0d181c"
  }
}, hues = { gray, blue, purple, magenta, red, orange, yellow, green, cyan }, color$3 = { black, white, ...hues }, defaultThemeFonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [
      {
        ascenderHeight: 4,
        descenderHeight: 4,
        fontSize: 10,
        iconSize: 17,
        lineHeight: 15,
        letterSpacing: 0
      },
      {
        ascenderHeight: 5,
        descenderHeight: 5,
        fontSize: 13,
        iconSize: 21,
        lineHeight: 19,
        letterSpacing: 0
      },
      {
        ascenderHeight: 6,
        descenderHeight: 6,
        fontSize: 16,
        iconSize: 25,
        lineHeight: 23,
        letterSpacing: 0
      },
      {
        ascenderHeight: 7,
        descenderHeight: 7,
        fontSize: 19,
        iconSize: 29,
        lineHeight: 27,
        letterSpacing: 0
      },
      {
        ascenderHeight: 8,
        descenderHeight: 8,
        fontSize: 22,
        iconSize: 33,
        lineHeight: 31,
        letterSpacing: 0
      }
    ]
  },
  heading: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [
      {
        ascenderHeight: 5,
        descenderHeight: 5,
        fontSize: 13,
        iconSize: 17,
        lineHeight: 19,
        letterSpacing: 0
      },
      {
        ascenderHeight: 6,
        descenderHeight: 6,
        fontSize: 16,
        iconSize: 25,
        lineHeight: 23,
        letterSpacing: 0
      },
      {
        ascenderHeight: 7,
        descenderHeight: 7,
        fontSize: 21,
        iconSize: 33,
        lineHeight: 29,
        letterSpacing: 0
      },
      {
        ascenderHeight: 8,
        descenderHeight: 8,
        fontSize: 27,
        iconSize: 41,
        lineHeight: 35,
        letterSpacing: 0
      },
      {
        ascenderHeight: 9.5,
        descenderHeight: 8.5,
        fontSize: 33,
        iconSize: 49,
        lineHeight: 41,
        letterSpacing: 0
      },
      {
        ascenderHeight: 10.5,
        descenderHeight: 9.5,
        fontSize: 38,
        iconSize: 53,
        lineHeight: 47,
        letterSpacing: 0
      }
    ]
  },
  label: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 8.1,
        iconSize: 13,
        lineHeight: 10,
        letterSpacing: 0.5
      },
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 9.5,
        iconSize: 15,
        lineHeight: 11,
        letterSpacing: 0.5
      },
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 10.8,
        iconSize: 17,
        lineHeight: 12,
        letterSpacing: 0.5
      },
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 12.25,
        iconSize: 19,
        lineHeight: 13,
        letterSpacing: 0.5
      },
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 13.6,
        iconSize: 21,
        lineHeight: 14,
        letterSpacing: 0.5
      },
      {
        ascenderHeight: 2,
        descenderHeight: 2,
        fontSize: 15,
        iconSize: 23,
        lineHeight: 15,
        letterSpacing: 0.5
      }
    ]
  },
  text: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [
      {
        ascenderHeight: 4,
        descenderHeight: 4,
        fontSize: 10,
        iconSize: 17,
        lineHeight: 15,
        letterSpacing: 0
      },
      {
        ascenderHeight: 5,
        descenderHeight: 5,
        fontSize: 13,
        iconSize: 21,
        lineHeight: 19,
        letterSpacing: 0
      },
      {
        ascenderHeight: 6,
        descenderHeight: 6,
        fontSize: 15,
        iconSize: 25,
        lineHeight: 23,
        letterSpacing: 0
      },
      {
        ascenderHeight: 7,
        descenderHeight: 7,
        fontSize: 18,
        iconSize: 29,
        lineHeight: 27,
        letterSpacing: 0
      },
      {
        ascenderHeight: 8,
        descenderHeight: 8,
        fontSize: 21,
        iconSize: 33,
        lineHeight: 31,
        letterSpacing: 0
      }
    ]
  }
};
function is_v2(themeProp) {
  return themeProp._version === 2;
}
const cache$2 = /* @__PURE__ */ new WeakMap();
function v0_v2(v0) {
  if (v0.v2) return v0.v2;
  const cached_v2 = cache$2.get(v0);
  if (cached_v2) return cached_v2;
  const {
    avatar,
    button,
    color: color2,
    container,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusRing: _unused_focusRing,
    fonts: font,
    input,
    layer,
    media,
    radius,
    shadows: shadow,
    space: space2,
    styles: style2
  } = v0, v2 = {
    _version: 2,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...button
    },
    card: defaultThemeConfig.card,
    color: {
      light: {
        transparent: themeColor_v0_v2(color2.light.transparent),
        default: themeColor_v0_v2(color2.light.default),
        primary: themeColor_v0_v2(color2.light.primary),
        positive: themeColor_v0_v2(color2.light.positive),
        caution: themeColor_v0_v2(color2.light.caution),
        critical: themeColor_v0_v2(color2.light.critical)
      },
      dark: {
        transparent: themeColor_v0_v2(color2.dark.transparent),
        default: themeColor_v0_v2(color2.dark.default),
        primary: themeColor_v0_v2(color2.dark.primary),
        positive: themeColor_v0_v2(color2.dark.positive),
        caution: themeColor_v0_v2(color2.dark.caution),
        critical: themeColor_v0_v2(color2.dark.critical)
      }
    },
    container,
    font,
    input: {
      ...defaultThemeConfig.input,
      ...input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...input.switch
      }
    },
    layer: layer ?? defaultThemeConfig.layer,
    media,
    radius,
    shadow,
    space: space2,
    style: style2
  };
  return cache$2.set(v0, v2), v2;
}
const cache$1 = /* @__PURE__ */ new WeakMap();
function v2_v0(v2) {
  const cachedTheme = cache$1.get(v2);
  if (cachedTheme) return cachedTheme;
  const {
    avatar,
    button,
    color: color2,
    container,
    font: fonts,
    input,
    media,
    radius,
    shadow: shadows,
    space: space2,
    style: styles
  } = v2;
  return {
    _version: 0,
    avatar,
    button,
    container,
    color: {
      light: {
        transparent: themeColor_v2_v0(color2.light.transparent),
        default: themeColor_v2_v0(color2.light.default),
        primary: themeColor_v2_v0(color2.light.primary),
        positive: themeColor_v2_v0(color2.light.positive),
        caution: themeColor_v2_v0(color2.light.caution),
        critical: themeColor_v2_v0(color2.light.critical)
      },
      dark: {
        transparent: themeColor_v2_v0(color2.dark.transparent),
        default: themeColor_v2_v0(color2.dark.default),
        primary: themeColor_v2_v0(color2.dark.primary),
        positive: themeColor_v2_v0(color2.dark.positive),
        caution: themeColor_v2_v0(color2.dark.caution),
        critical: themeColor_v2_v0(color2.dark.critical)
      }
    },
    focusRing: input.text.focusRing,
    fonts,
    input,
    media,
    radius,
    shadows,
    space: space2,
    styles,
    v2
  };
}
function themeColor_v2_v0(color_v2) {
  return {
    base: {
      bg: color_v2.bg,
      fg: color_v2.fg,
      border: color_v2.border,
      focusRing: color_v2.focusRing,
      shadow: color_v2.shadow
    },
    button: color_v2.button,
    card: color_v2.selectable.default,
    dark: color_v2._dark,
    input: {
      default: inputStatesThemeColor_v2_v0(color_v2.input.default),
      invalid: inputStatesThemeColor_v2_v0(color_v2.input.invalid)
    },
    muted: {
      ...color_v2.button.ghost,
      transparent: color_v2.button.ghost.default
    },
    solid: {
      ...color_v2.button.default,
      transparent: color_v2.button.default.default
    },
    selectable: color_v2.selectable,
    spot: {
      gray: color_v2.avatar.gray.bg,
      blue: color_v2.avatar.blue.bg,
      purple: color_v2.avatar.purple.bg,
      magenta: color_v2.avatar.magenta.bg,
      red: color_v2.avatar.red.bg,
      orange: color_v2.avatar.orange.bg,
      yellow: color_v2.avatar.yellow.bg,
      green: color_v2.avatar.green.bg,
      cyan: color_v2.avatar.cyan.bg
    },
    syntax: color_v2.syntax
  };
}
function inputStatesThemeColor_v2_v0(t) {
  return {
    enabled: inputStateThemeColor_v2_v0(t.enabled),
    disabled: inputStateThemeColor_v2_v0(t.disabled),
    readOnly: inputStateThemeColor_v2_v0(t.readOnly),
    hovered: inputStateThemeColor_v2_v0(t.hovered)
  };
}
function inputStateThemeColor_v2_v0(t) {
  return {
    bg: t.bg,
    bg2: t.muted.bg,
    border: t.border,
    fg: t.fg,
    placeholder: t.placeholder
  };
}
const THEME_COLOR_BLEND_MODES = ["multiply", "screen"], THEME_COLOR_CARD_TONES = [
  "transparent",
  "default",
  "primary",
  "positive",
  "caution",
  "critical"
], THEME_COLOR_STATE_TONES = [
  "default",
  "primary",
  "positive",
  "caution",
  "critical"
], THEME_COLOR_STATES = ["enabled", "hovered", "pressed", "selected", "disabled"], THEME_COLOR_BUTTON_MODES = ["default", "ghost", "bleed"], THEME_COLOR_INPUT_MODES = ["default", "invalid"], THEME_COLOR_INPUT_STATES = ["enabled", "hovered", "readOnly", "disabled"];
function isColorBlendModeValue(str) {
  return THEME_COLOR_BLEND_MODES.includes(str);
}
function isColorHueKey(str) {
  return COLOR_HUES.includes(str);
}
function isColorTintKey(str) {
  return COLOR_TINTS.includes(str);
}
function isColorMixPercentValue(str) {
  return /^\d+%$/.test(str);
}
function parseTokenValue(str) {
  const segments = str.split("/");
  let nextSegment = segments.shift() || "";
  const [segment0, segment0mix] = nextSegment.split(" ");
  if (isColorTintKey(segment0)) {
    const tint2 = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix2 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        tint: tint2,
        mix: mix2
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        tint: tint2,
        opacity
      };
    }
    return {
      type: "color",
      tint: tint2
    };
  }
  if (isColorValue(segment0)) {
    const key2 = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix2 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        key: key2,
        mix: mix2
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        key: key2,
        opacity
      };
    }
    return {
      type: "color",
      key: key2
    };
  }
  if (isColorHueKey(segment0)) {
    const hue = segment0;
    nextSegment = segments.shift() || "";
    const [segment1, segment1mix] = nextSegment.split(" ");
    if (isColorTintKey(segment1)) {
      const tint2 = segment1, segment2 = segments.shift() || "";
      if (isColorMixPercentValue(segment1mix)) {
        const mix2 = Number(segment1mix.slice(0, -1)) / 100;
        return {
          type: "color",
          hue,
          tint: tint2,
          mix: mix2
        };
      }
      if (isColorOpacityValue(segment2)) {
        const opacity = Number(segment2);
        return {
          type: "color",
          hue,
          tint: tint2,
          opacity
        };
      }
      return {
        type: "color",
        hue,
        tint: tint2
      };
    }
    return {
      type: "hue",
      value: hue
    };
  }
  if (isColorBlendModeValue(segment0))
    return {
      type: "blendMode",
      value: segment0
    };
}
function isColorValue(str) {
  return str === "black" || str === "white";
}
function isColorOpacityValue(str) {
  return str === "0" || /^0\.[0-9]+$/.test(str) || str === "1";
}
function compileColorTokenValue(node2) {
  let key2 = "";
  return node2.key === "black" || node2.key === "white" ? key2 = node2.key : key2 = `${node2.hue}/${node2.tint}`, node2.mix !== void 0 ? `${key2} ${node2.mix * 100}%` : (node2.opacity !== void 0 && (key2 += `/${node2.opacity}`), key2);
}
const DEFAULT_COLOR_TOKEN_VALUE = ["500", "500"];
function resolveColorTokenValue(context, value = DEFAULT_COLOR_TOKEN_VALUE) {
  const { hue, scheme } = context, node2 = parseTokenValue(value[scheme === "light" ? 0 : 1]);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token: ${value[0]}`);
  return compileColorTokenValue({ ...node2, hue: node2.hue || hue });
}
const defaultColorTokens = {
  base: {
    "*": {
      _blend: ["multiply", "screen"],
      accent: {
        fg: ["purple/600", "purple/400"]
      },
      avatar: {
        "*": {
          _blend: ["screen", "multiply"],
          bg: ["500", "400"],
          fg: ["white", "black"]
        }
      },
      backdrop: ["gray/200/0.5", "black/0.5"],
      badge: {
        "*": {
          bg: ["100", "900"],
          fg: ["600", "400"],
          icon: ["500", "500"],
          dot: ["500", "500"]
        },
        positive: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        },
        caution: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        }
      },
      bg: ["50", "950"],
      border: ["200", "800"],
      code: {
        bg: ["50", "950"],
        fg: ["600", "400"]
      },
      fg: ["800", "200"],
      focusRing: ["blue/500", "blue/500"],
      icon: ["600", "400"],
      kbd: {
        bg: ["white", "black"],
        fg: ["600", "400"],
        border: ["200", "800"]
      },
      link: {
        fg: ["blue/600", "blue/300"]
      },
      muted: {
        bg: ["50", "950"],
        fg: ["700 75%", "300 75%"]
      },
      shadow: {
        outline: ["500/0.3", "500/0.4"],
        umbra: ["gray/500/0.1", "black/0.2"],
        penumbra: ["gray/500/0.07", "black/0.14"],
        ambient: ["gray/500/0.06", "black/0.12"]
      },
      skeleton: {
        from: ["100", "900"],
        to: ["100 50%", "900 50%"]
      }
    },
    transparent: {
      bg: ["50", "black"]
    },
    default: {
      bg: ["white", "950"],
      fg: ["800", "200"],
      muted: {
        fg: ["600", "400"]
      }
    },
    primary: { _hue: "blue" },
    positive: {
      _hue: "green",
      shadow: { outline: ["500/0.4", "500/0.4"] }
    },
    caution: {
      _hue: "yellow",
      shadow: { outline: ["600/0.3", "500/0.4"] }
    },
    critical: { _hue: "red" }
  },
  button: {
    default: {
      "*": {
        "*": {
          _blend: ["screen", "multiply"],
          accent: {
            fg: ["purple/300", "purple/700"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["900", "100"],
              fg: ["400", "600"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["500", "400"],
          border: ["500/0", "400/0"],
          code: {
            bg: ["500 20%", "400 20%"],
            fg: ["200", "600"]
          },
          fg: ["white", "black"],
          icon: ["100 70%", "900 70%"],
          kbd: {
            bg: ["black", "white"],
            fg: ["200", "600"],
            border: ["800", "200"]
          },
          link: {
            fg: ["blue/200", "blue/600"]
          },
          muted: {
            bg: ["950", "50"],
            fg: ["100 70%", "900 70%"]
          },
          skeleton: {
            from: ["900", "100"],
            to: ["900 50%", "100 50%"]
          }
        },
        hovered: {
          bg: ["700", "300"],
          border: ["700/0", "300/0"]
        },
        pressed: {
          bg: ["700", "300"]
        },
        selected: {
          bg: ["700", "300"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["100 70%", "900 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/500", "gray/400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["gray/700", "gray/300"],
              fg: ["white", "black"],
              dot: ["white", "black"],
              icon: ["white", "black"]
            }
          },
          bg: ["300", "600"],
          code: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          fg: ["300", "600"],
          muted: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          kbd: {
            bg: ["black", "white"],
            fg: ["white", "black"],
            border: ["700", "300"]
          },
          link: {
            fg: ["100 70%", "900 70%"]
          }
        }
      },
      default: {
        "*": {
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          bg: ["800", "200"],
          muted: {
            bg: ["950", "50"],
            fg: ["400", "600"]
          }
        },
        hovered: {
          bg: ["900", "100"]
        },
        pressed: {
          bg: ["black", "white"]
        },
        selected: {
          bg: ["black", "white"]
        }
      }
    },
    ghost: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 60%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["50", "950"],
          border: ["100", "900"],
          code: {
            bg: ["500 10%", "400 10%"],
            fg: ["700 60%", "400 60%"]
          },
          fg: ["600", "400"],
          icon: ["700 60%", "300 60%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["600", "400"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 60%", "blue/300 60%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 60%", "300 60%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["100", "900"],
          fg: ["700", "300"]
        },
        pressed: {
          bg: ["100", "900"],
          fg: ["800", "200"]
        },
        selected: {
          bg: ["100", "900"],
          fg: ["800", "200"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          border: ["100", "900"],
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["300", "700"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      },
      positive: {
        "*": {
          border: ["600 20%", "800"]
        }
      },
      caution: {
        "*": {
          border: ["600 20%", "800"]
        }
      }
    },
    bleed: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 70%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["white", "black"],
          border: ["white/0", "black/0"],
          code: {
            bg: ["50", "950"],
            fg: ["700 75%", "300 75%"]
          },
          fg: ["700", "300"],
          icon: ["700 75%", "300 75%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["700", "300"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 70%", "blue/300 70%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 75%", "300 75%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["50", "950"],
          icon: ["700 70%", "400 70%"]
        },
        pressed: {
          bg: ["100", "900"],
          fg: ["800", "200"],
          icon: ["800 70%", "200 70%"]
        },
        selected: {
          bg: ["100", "900"],
          fg: ["800", "200"],
          icon: ["800 60%", "200 60%"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["400", "600"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      }
    }
  },
  input: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        bg: ["white", "black"],
        border: ["200", "800"],
        fg: ["black", "200"],
        muted: {
          bg: ["50", "950"]
        },
        placeholder: ["400", "600"]
      },
      hovered: {
        border: ["300", "700"]
      },
      readOnly: {
        bg: ["50", "950"],
        border: ["200", "800"],
        fg: ["800", "200"]
      },
      disabled: {
        fg: ["400", "600"],
        border: ["100", "900"],
        placeholder: ["200", "800 50%"]
      }
    },
    invalid: {
      "*": {
        _hue: "red",
        bg: ["100", "950"]
      }
    }
  },
  selectable: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        accent: {
          fg: ["purple/700 70%", "purple/300 70%"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["500", "400"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            bg: ["100", "900"],
            fg: ["600", "400"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["white", "black"],
        border: ["200", "800"],
        code: {
          bg: ["50", "950"],
          fg: ["600", "400"]
        },
        fg: ["700", "300"],
        icon: ["700 75%", "300 75%"],
        kbd: {
          bg: ["white", "black"],
          fg: ["600", "400"],
          border: ["200", "800"]
        },
        link: {
          fg: ["blue/700 70%", "blue/300 70%"]
        },
        muted: {
          bg: ["50", "950"],
          fg: ["700 75%", "300 75%"]
        },
        skeleton: {
          from: ["100", "900"],
          to: ["100 50%", "900 50%"]
        }
      },
      hovered: {
        bg: ["50", "950"]
      },
      pressed: {
        bg: ["100", "900"]
      },
      selected: {
        _blend: ["screen", "multiply"],
        accent: {
          fg: ["purple/300", "purple/700"]
        },
        avatar: {
          "*": {
            _blend: ["multiply", "screen"],
            bg: ["white", "black"],
            fg: ["black", "white"]
          }
        },
        badge: {
          "*": {
            bg: ["900", "100"],
            fg: ["400", "600"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["500", "400"],
        border: ["500 20%", "400 20%"],
        code: {
          bg: ["500 20%", "400 20%"],
          fg: ["200", "600"]
        },
        fg: ["white", "black"],
        icon: ["100 70%", "900 70%"],
        kbd: {
          bg: ["black", "white"],
          fg: ["200", "600"],
          border: ["800", "200"]
        },
        link: {
          fg: ["blue/200", "blue/600"]
        },
        muted: {
          bg: ["500 10%", "400 10%"],
          fg: ["100 70%", "900 70%"]
        },
        skeleton: {
          from: ["900", "100"],
          to: ["900 50%", "100 50%"]
        }
      },
      disabled: {
        _hue: "gray",
        accent: {
          fg: ["200", "800"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["gray/100", "gray/900"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            _hue: "gray",
            bg: ["50", "950"],
            fg: ["gray/200", "gray/800"],
            dot: ["gray/200", "gray/800"],
            icon: ["gray/200", "gray/800"]
          }
        },
        border: ["100", "900"],
        code: {
          bg: ["50", "950"],
          fg: ["200", "800"]
        },
        fg: ["200", "800"],
        icon: ["200", "800"],
        kbd: {
          bg: ["white", "black"],
          fg: ["200", "800"],
          border: ["100", "900"]
        },
        link: {
          fg: ["200", "800"]
        },
        muted: {
          bg: ["50 50%", "950 50%"],
          fg: ["200", "800"]
        }
      }
    },
    default: {
      selected: {
        _hue: "blue"
      }
    },
    critical: {
      disabled: {
        bg: ["50 50%", "950 50%"]
      }
    }
  },
  syntax: {
    atrule: ["purple/600", "purple/400"],
    attrName: ["green/600", "green/400"],
    attrValue: ["yellow/600", "yellow/400"],
    attribute: ["yellow/600", "yellow/400"],
    boolean: ["purple/600", "purple/400"],
    builtin: ["purple/600", "purple/400"],
    cdata: ["yellow/600", "yellow/400"],
    char: ["yellow/600", "yellow/400"],
    class: ["orange/600", "orange/400"],
    className: ["cyan/600", "cyan/400"],
    comment: ["gray/400", "gray/600"],
    constant: ["purple/600", "purple/400"],
    deleted: ["red/600", "red/400"],
    entity: ["red/600", "red/400"],
    function: ["green/600", "green/400"],
    hexcode: ["blue/600", "blue/400"],
    id: ["purple/600", "purple/400"],
    important: ["purple/600", "purple/400"],
    inserted: ["yellow/600", "yellow/400"],
    keyword: ["magenta/600", "magenta/400"],
    number: ["purple/600", "purple/400"],
    operator: ["magenta/600", "magenta/400"],
    property: ["blue/600", "blue/400"],
    pseudoClass: ["yellow/600", "yellow/400"],
    pseudoElement: ["yellow/600", "yellow/400"],
    punctuation: ["gray/600", "gray/400"],
    regex: ["blue/600", "blue/400"],
    selector: ["red/600", "red/400"],
    string: ["yellow/600", "yellow/400"],
    symbol: ["purple/600", "purple/400"],
    tag: ["red/600", "red/400"],
    unit: ["orange/600", "orange/400"],
    url: ["red/600", "red/400"],
    variable: ["red/600", "red/400"]
  }
};
function isRecord$1(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
function merge$2(...records) {
  const _records = records.filter(Boolean);
  return _records.length === 0 ? {} : _records.reduce(_merge, {});
}
function _merge(acc, source) {
  for (const key2 of Object.keys(source)) {
    const prevValue = acc[key2], nextValue = source[key2];
    isRecord$1(prevValue) && isRecord$1(nextValue) ? acc[key2] = merge$2(prevValue, nextValue) : acc[key2] = nextValue;
  }
  return acc;
}
function resolveColorTokens(inputTokens) {
  const tokens = merge$2(defaultColorTokens, inputTokens);
  return {
    base: resolveBaseColorTokens(tokens),
    button: resolveButtonColorTokens(tokens),
    input: resolveInputColorTokens(tokens),
    selectable: resolveSelectableColorTokens(tokens),
    syntax: tokens.syntax
  };
}
function resolveBaseColorTokens(sparseTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_CARD_TONES)
    tokens[tone] = resolveBaseColorTones(sparseTokens, tone);
  return tokens;
}
function resolveBaseColorTones(inputTokens, tone) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P;
  const spec = merge$2((_a = inputTokens?.base) == null ? void 0 : _a["*"], (_b = inputTokens?.base) == null ? void 0 : _b[tone]), hue = spec._hue || ((_d = (_c = inputTokens?.base) == null ? void 0 : _c[tone]) == null ? void 0 : _d._hue) || "gray";
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge$2({ _hue: "gray" }, (_e2 = spec.avatar) == null ? void 0 : _e2["*"], (_f = spec.avatar) == null ? void 0 : _f.gray),
      blue: merge$2({ _hue: "blue" }, (_g = spec.avatar) == null ? void 0 : _g["*"], (_h = spec.avatar) == null ? void 0 : _h.blue),
      purple: merge$2({ _hue: "purple" }, (_i = spec.avatar) == null ? void 0 : _i["*"], (_j = spec.avatar) == null ? void 0 : _j.purple),
      magenta: merge$2({ _hue: "magenta" }, (_k = spec.avatar) == null ? void 0 : _k["*"], (_l = spec.avatar) == null ? void 0 : _l.magenta),
      red: merge$2({ _hue: "red" }, (_m = spec.avatar) == null ? void 0 : _m["*"], (_n = spec.avatar) == null ? void 0 : _n.red),
      orange: merge$2({ _hue: "orange" }, (_o = spec.avatar) == null ? void 0 : _o["*"], (_p = spec.avatar) == null ? void 0 : _p.orange),
      yellow: merge$2({ _hue: "yellow" }, (_q = spec.avatar) == null ? void 0 : _q["*"], (_r = spec.avatar) == null ? void 0 : _r.yellow),
      green: merge$2({ _hue: "green" }, (_s = spec.avatar) == null ? void 0 : _s["*"], (_t = spec.avatar) == null ? void 0 : _t.green),
      cyan: merge$2({ _hue: "cyan" }, (_u = spec.avatar) == null ? void 0 : _u["*"], (_v = spec.avatar) == null ? void 0 : _v.cyan)
    },
    badge: {
      default: {
        _hue: ((_x = (_w = inputTokens?.base) == null ? void 0 : _w.default) == null ? void 0 : _x._hue) || hue,
        ...(_y = spec.badge) == null ? void 0 : _y["*"],
        ...(_z = spec.badge) == null ? void 0 : _z.default
      },
      primary: {
        _hue: ((_B = (_A = inputTokens?.base) == null ? void 0 : _A.primary) == null ? void 0 : _B._hue) || hue,
        ...(_C = spec.badge) == null ? void 0 : _C["*"],
        ...(_D = spec.badge) == null ? void 0 : _D.primary
      },
      positive: {
        _hue: ((_F = (_E = inputTokens?.base) == null ? void 0 : _E.positive) == null ? void 0 : _F._hue) || hue,
        ...(_G = spec.badge) == null ? void 0 : _G["*"],
        ...(_H = spec.badge) == null ? void 0 : _H.positive
      },
      caution: {
        _hue: ((_J = (_I = inputTokens?.base) == null ? void 0 : _I.caution) == null ? void 0 : _J._hue) || hue,
        ...(_K = spec.badge) == null ? void 0 : _K["*"],
        ...(_L = spec.badge) == null ? void 0 : _L.caution
      },
      critical: {
        _hue: ((_N = (_M = inputTokens?.base) == null ? void 0 : _M.critical) == null ? void 0 : _N._hue) || hue,
        ...(_O = spec.badge) == null ? void 0 : _O["*"],
        ...(_P = spec.badge) == null ? void 0 : _P.critical
      }
    }
  };
}
function resolveButtonColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    tokens[mode] = resolveButtonToneColorTokens(inputTokens, mode);
  return tokens;
}
function resolveButtonToneColorTokens(inputTokens, mode) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveButtonModeColorTokens(inputTokens, mode, tone);
  return tokens;
}
function resolveButtonModeColorTokens(inputTokens, mode, tone) {
  const tokens = {};
  for (const state of THEME_COLOR_STATES)
    tokens[state] = resolveButtonStateColorTokens(inputTokens, tone, mode, state);
  return tokens;
}
function resolveButtonStateColorTokens(inputTokens, tone, mode, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z;
  const spec = merge$2(
    (_c = (_b = (_a = inputTokens?.button) == null ? void 0 : _a[mode]) == null ? void 0 : _b["*"]) == null ? void 0 : _c["*"],
    (_f = (_e2 = (_d = inputTokens?.button) == null ? void 0 : _d[mode]) == null ? void 0 : _e2[tone]) == null ? void 0 : _f["*"],
    (_i = (_h = (_g = inputTokens?.button) == null ? void 0 : _g[mode]) == null ? void 0 : _h["*"]) == null ? void 0 : _i[state],
    (_l = (_k = (_j = inputTokens?.button) == null ? void 0 : _j[mode]) == null ? void 0 : _k[tone]) == null ? void 0 : _l[state]
  ), hue = spec._hue || ((_n = (_m = inputTokens?.base) == null ? void 0 : _m[tone]) == null ? void 0 : _n._hue);
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge$2({ _hue: "gray" }, (_o = spec.avatar) == null ? void 0 : _o["*"], (_p = spec.avatar) == null ? void 0 : _p.gray),
      blue: merge$2({ _hue: "blue" }, (_q = spec.avatar) == null ? void 0 : _q["*"], (_r = spec.avatar) == null ? void 0 : _r.blue),
      purple: merge$2({ _hue: "purple" }, (_s = spec.avatar) == null ? void 0 : _s["*"], (_t = spec.avatar) == null ? void 0 : _t.purple),
      magenta: merge$2({ _hue: "magenta" }, (_u = spec.avatar) == null ? void 0 : _u["*"], (_v = spec.avatar) == null ? void 0 : _v.magenta),
      red: merge$2({ _hue: "red" }, (_w = spec.avatar) == null ? void 0 : _w["*"], (_x = spec.avatar) == null ? void 0 : _x.red),
      orange: merge$2({ _hue: "orange" }, (_y = spec.avatar) == null ? void 0 : _y["*"], (_z = spec.avatar) == null ? void 0 : _z.orange),
      yellow: merge$2({ _hue: "yellow" }, (_A = spec.avatar) == null ? void 0 : _A["*"], (_B = spec.avatar) == null ? void 0 : _B.yellow),
      green: merge$2({ _hue: "green" }, (_C = spec.avatar) == null ? void 0 : _C["*"], (_D = spec.avatar) == null ? void 0 : _D.green),
      cyan: merge$2({ _hue: "cyan" }, (_E = spec.avatar) == null ? void 0 : _E["*"], (_F = spec.avatar) == null ? void 0 : _F.cyan)
    },
    badge: {
      default: {
        _hue: (_H = (_G = inputTokens?.base) == null ? void 0 : _G.default) == null ? void 0 : _H._hue,
        ...(_I = spec.badge) == null ? void 0 : _I["*"],
        ...(_J = spec.badge) == null ? void 0 : _J.default
      },
      primary: {
        _hue: (_L = (_K = inputTokens?.base) == null ? void 0 : _K.primary) == null ? void 0 : _L._hue,
        ...(_M = spec.badge) == null ? void 0 : _M["*"],
        ...(_N = spec.badge) == null ? void 0 : _N.primary
      },
      positive: {
        _hue: (_P = (_O = inputTokens?.base) == null ? void 0 : _O.positive) == null ? void 0 : _P._hue,
        ...(_Q = spec.badge) == null ? void 0 : _Q["*"],
        ...(_R = spec.badge) == null ? void 0 : _R.positive
      },
      caution: {
        _hue: (_T = (_S = inputTokens?.base) == null ? void 0 : _S.caution) == null ? void 0 : _T._hue,
        ...(_U = spec.badge) == null ? void 0 : _U["*"],
        ...(_V = spec.badge) == null ? void 0 : _V.caution
      },
      critical: {
        _hue: (_X = (_W = inputTokens?.base) == null ? void 0 : _W.critical) == null ? void 0 : _X._hue,
        ...(_Y = spec.badge) == null ? void 0 : _Y["*"],
        ...(_Z = spec.badge) == null ? void 0 : _Z.critical
      }
    }
  };
}
function resolveInputColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_INPUT_MODES)
    tokens[mode] = resolveInputModeColorTokens(inputTokens, mode);
  return tokens;
}
function resolveInputModeColorTokens(inputTokens, mode) {
  const states = {};
  for (const state of THEME_COLOR_INPUT_STATES)
    states[state] = resolveInputStateColorTokens(inputTokens, mode, state);
  return states;
}
function resolveInputStateColorTokens(inputTokens, mode, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
  const spec = merge$2(
    (_b = (_a = inputTokens?.input) == null ? void 0 : _a["*"]) == null ? void 0 : _b["*"],
    (_d = (_c = inputTokens?.input) == null ? void 0 : _c[mode]) == null ? void 0 : _d["*"],
    (_f = (_e2 = inputTokens?.input) == null ? void 0 : _e2["*"]) == null ? void 0 : _f[state],
    (_h = (_g = inputTokens?.input) == null ? void 0 : _g[mode]) == null ? void 0 : _h[state]
  ), hue = spec._hue || ((_j = (_i = inputTokens?.input) == null ? void 0 : _i[mode]) == null ? void 0 : _j._hue);
  return { ...spec, _hue: hue };
}
function resolveSelectableColorTokens(inputTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveSelectableToneColorTokens(inputTokens, tone);
  return tokens;
}
function resolveSelectableToneColorTokens(inputTokens, tone) {
  var _a, _b, _c, _d;
  const states = {
    _hue: ((_b = (_a = inputTokens?.selectable) == null ? void 0 : _a[tone]) == null ? void 0 : _b._hue) || ((_d = (_c = inputTokens?.base) == null ? void 0 : _c[tone]) == null ? void 0 : _d._hue)
  };
  for (const state of THEME_COLOR_STATES)
    states[state] = resolveSelectableStateColorTokens(inputTokens, tone, state);
  return states;
}
function resolveSelectableStateColorTokens(inputTokens, tone, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V;
  const spec = merge$2(
    (_b = (_a = inputTokens?.selectable) == null ? void 0 : _a["*"]) == null ? void 0 : _b["*"],
    (_d = (_c = inputTokens?.selectable) == null ? void 0 : _c[tone]) == null ? void 0 : _d["*"],
    (_f = (_e2 = inputTokens?.selectable) == null ? void 0 : _e2["*"]) == null ? void 0 : _f[state],
    (_h = (_g = inputTokens?.selectable) == null ? void 0 : _g[tone]) == null ? void 0 : _h[state]
  ), hue = spec._hue || ((_j = (_i = inputTokens?.base) == null ? void 0 : _i[tone]) == null ? void 0 : _j._hue);
  return {
    ...spec,
    _hue: hue,
    avatar: {
      gray: merge$2({ _hue: "gray" }, (_k = spec.avatar) == null ? void 0 : _k["*"], (_l = spec.avatar) == null ? void 0 : _l.gray),
      blue: merge$2({ _hue: "blue" }, (_m = spec.avatar) == null ? void 0 : _m["*"], (_n = spec.avatar) == null ? void 0 : _n.blue),
      purple: merge$2({ _hue: "purple" }, (_o = spec.avatar) == null ? void 0 : _o["*"], (_p = spec.avatar) == null ? void 0 : _p.purple),
      magenta: merge$2({ _hue: "magenta" }, (_q = spec.avatar) == null ? void 0 : _q["*"], (_r = spec.avatar) == null ? void 0 : _r.magenta),
      red: merge$2({ _hue: "red" }, (_s = spec.avatar) == null ? void 0 : _s["*"], (_t = spec.avatar) == null ? void 0 : _t.red),
      orange: merge$2({ _hue: "orange" }, (_u = spec.avatar) == null ? void 0 : _u["*"], (_v = spec.avatar) == null ? void 0 : _v.orange),
      yellow: merge$2({ _hue: "yellow" }, (_w = spec.avatar) == null ? void 0 : _w["*"], (_x = spec.avatar) == null ? void 0 : _x.yellow),
      green: merge$2({ _hue: "green" }, (_y = spec.avatar) == null ? void 0 : _y["*"], (_z = spec.avatar) == null ? void 0 : _z.green),
      cyan: merge$2({ _hue: "cyan" }, (_A = spec.avatar) == null ? void 0 : _A["*"], (_B = spec.avatar) == null ? void 0 : _B.cyan)
    },
    badge: {
      default: {
        _hue: (_D = (_C = inputTokens?.base) == null ? void 0 : _C.default) == null ? void 0 : _D._hue,
        ...(_E = spec.badge) == null ? void 0 : _E["*"],
        ...(_F = spec.badge) == null ? void 0 : _F.default
      },
      primary: {
        _hue: (_H = (_G = inputTokens?.base) == null ? void 0 : _G.primary) == null ? void 0 : _H._hue,
        ...(_I = spec.badge) == null ? void 0 : _I["*"],
        ...(_J = spec.badge) == null ? void 0 : _J.primary
      },
      positive: {
        _hue: (_L = (_K = inputTokens?.base) == null ? void 0 : _K.positive) == null ? void 0 : _L._hue,
        ...(_M = spec.badge) == null ? void 0 : _M["*"],
        ...(_N = spec.badge) == null ? void 0 : _N.positive
      },
      caution: {
        _hue: (_P = (_O = inputTokens?.base) == null ? void 0 : _O.caution) == null ? void 0 : _P._hue,
        ...(_Q = spec.badge) == null ? void 0 : _Q["*"],
        ...(_R = spec.badge) == null ? void 0 : _R.caution
      },
      critical: {
        _hue: (_T = (_S = inputTokens?.base) == null ? void 0 : _S.critical) == null ? void 0 : _T._hue,
        ...(_U = spec.badge) == null ? void 0 : _U["*"],
        ...(_V = spec.badge) == null ? void 0 : _V.critical
      }
    }
  };
}
function buildColorTheme(config) {
  const resolvedConfig = {
    ...config,
    color: resolveColorTokens(void 0)
  };
  return {
    light: buildColorScheme({ scheme: "light" }, resolvedConfig),
    dark: buildColorScheme({ scheme: "dark" }, resolvedConfig)
  };
}
function buildColorScheme(options, config) {
  const { scheme } = options;
  return {
    transparent: buildCardColorTheme({ scheme, tone: "transparent" }, config),
    default: buildCardColorTheme({ scheme, tone: "default" }, config),
    primary: buildCardColorTheme({ scheme, tone: "primary" }, config),
    positive: buildCardColorTheme({ scheme, tone: "positive" }, config),
    caution: buildCardColorTheme({ scheme, tone: "caution" }, config),
    critical: buildCardColorTheme({ scheme, tone: "critical" }, config)
  };
}
function buildCardColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m;
  const { scheme, tone } = options, tokens = (_b = (_a = config?.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone], context = { hue: tokens?._hue || "gray", scheme };
  return {
    _blend: (tokens?._blend || ["multiply", "screen"])[scheme === "light" ? 0 : 1],
    _dark: scheme === "dark",
    accent: {
      fg: resolveColorTokenValue(context, (_c = tokens?.accent) == null ? void 0 : _c.fg)
    },
    avatar: buildAvatarColorTheme({ scheme }, tokens),
    backdrop: resolveColorTokenValue(context, tokens?.backdrop),
    badge: buildBadgeColorTheme(tokens?.badge, { scheme }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    button: buildButtonColorTheme({ scheme }, config),
    code: {
      bg: resolveColorTokenValue(context, (_d = tokens?.code) == null ? void 0 : _d.bg),
      fg: resolveColorTokenValue(context, (_e2 = tokens?.code) == null ? void 0 : _e2.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    focusRing: resolveColorTokenValue(context, tokens?.focusRing),
    icon: resolveColorTokenValue(context, tokens?.icon),
    input: buildInputColorTheme({ scheme, tone }, config),
    kbd: {
      bg: resolveColorTokenValue(context, (_f = tokens?.kbd) == null ? void 0 : _f.bg),
      fg: resolveColorTokenValue(context, (_g = tokens?.kbd) == null ? void 0 : _g.fg),
      border: resolveColorTokenValue(context, (_h = tokens?.kbd) == null ? void 0 : _h.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_i = tokens?.link) == null ? void 0 : _i.fg)
    },
    muted: {
      bg: resolveColorTokenValue(context, (_j = tokens?.muted) == null ? void 0 : _j.bg),
      fg: resolveColorTokenValue(context, (_k = tokens?.muted) == null ? void 0 : _k.fg)
    },
    selectable: buildSelectableColorTheme({ scheme }, config),
    shadow: buildShadowColorTheme({ scheme, tone }, config),
    skeleton: {
      from: resolveColorTokenValue(context, (_l = tokens?.skeleton) == null ? void 0 : _l.from),
      to: resolveColorTokenValue(context, (_m = tokens?.skeleton) == null ? void 0 : _m.to)
    },
    syntax: buildSyntaxColorTheme({ scheme }, config)
  };
}
function buildShadowColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f;
  const { scheme, tone } = options, tokens = (_b = (_a = config?.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone], context = { hue: tokens?._hue || "gray", scheme };
  return {
    outline: resolveColorTokenValue(context, (_c = tokens?.shadow) == null ? void 0 : _c.outline),
    umbra: resolveColorTokenValue(context, (_d = tokens?.shadow) == null ? void 0 : _d.umbra),
    penumbra: resolveColorTokenValue(context, (_e2 = tokens?.shadow) == null ? void 0 : _e2.penumbra),
    ambient: resolveColorTokenValue(context, (_f = tokens?.shadow) == null ? void 0 : _f.ambient)
  };
}
function buildAvatarColorTheme(options, stateTokens) {
  const { scheme } = options;
  return {
    gray: _buildAvatarColorTheme({ color: "gray", scheme }, stateTokens),
    blue: _buildAvatarColorTheme({ color: "blue", scheme }, stateTokens),
    purple: _buildAvatarColorTheme({ color: "purple", scheme }, stateTokens),
    magenta: _buildAvatarColorTheme({ color: "magenta", scheme }, stateTokens),
    red: _buildAvatarColorTheme({ color: "red", scheme }, stateTokens),
    orange: _buildAvatarColorTheme({ color: "orange", scheme }, stateTokens),
    yellow: _buildAvatarColorTheme({ color: "yellow", scheme }, stateTokens),
    green: _buildAvatarColorTheme({ color: "green", scheme }, stateTokens),
    cyan: _buildAvatarColorTheme({ color: "cyan", scheme }, stateTokens)
  };
}
function _buildAvatarColorTheme(options, stateTokens) {
  var _a;
  const { color: color2, scheme } = options, tokens = (_a = stateTokens?.avatar) == null ? void 0 : _a[color2], context = { hue: tokens?._hue || "gray", scheme };
  return {
    _blend: (tokens?._blend || ["screen", "multiply"])[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens?.bg),
    fg: resolveColorTokenValue(context, tokens?.fg)
  };
}
function buildBadgeColorTheme(tokens, options, config) {
  const { scheme } = options;
  return {
    default: _buildBadgeColorTheme(tokens, { scheme, tone: "default" }, config),
    primary: _buildBadgeColorTheme(tokens, { scheme, tone: "primary" }, config),
    positive: _buildBadgeColorTheme(tokens, { scheme, tone: "positive" }, config),
    caution: _buildBadgeColorTheme(tokens, { scheme, tone: "caution" }, config),
    critical: _buildBadgeColorTheme(tokens, { scheme, tone: "critical" }, config)
  };
}
function _buildBadgeColorTheme(parentTokens, options, config) {
  var _a, _b, _c;
  const { scheme, tone } = options, tokens = parentTokens?.[tone], context = { hue: tokens?._hue || ((_c = (_b = (_a = config?.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone]) == null ? void 0 : _c._hue) || "gray", scheme };
  return {
    bg: resolveColorTokenValue(context, tokens?.bg),
    fg: resolveColorTokenValue(context, tokens?.fg),
    dot: resolveColorTokenValue(context, tokens?.dot),
    icon: resolveColorTokenValue(context, tokens?.icon)
  };
}
function buildButtonColorTheme(options, config) {
  const { scheme } = options, modes = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    modes[mode] = buildButtonTonesColorTheme({ scheme, mode }, config);
  return modes;
}
function buildButtonTonesColorTheme(options, config) {
  const { mode, scheme } = options, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildButtonStatesColorTheme({ mode, scheme, tone }, config);
  return tones2;
}
function buildButtonStatesColorTheme(options, config) {
  const { mode, scheme, tone } = options, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildButtonStateColorTheme({ mode, tone, scheme, state }, config);
  return states;
}
function buildButtonStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o;
  const { mode, tone, scheme, state } = options, tokens = (_d = (_c = (_b = (_a = config?.color) == null ? void 0 : _a.button) == null ? void 0 : _b[mode]) == null ? void 0 : _c[tone]) == null ? void 0 : _d[state], hue = tokens?._hue || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = { hue, scheme };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, (_e2 = tokens?.accent) == null ? void 0 : _e2.fg)
    },
    avatar: buildAvatarColorTheme({ scheme }, tokens),
    badge: buildBadgeColorTheme(tokens?.badge, { scheme }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    code: {
      bg: resolveColorTokenValue(context, (_f = tokens?.code) == null ? void 0 : _f.bg),
      fg: resolveColorTokenValue(context, (_g = tokens?.code) == null ? void 0 : _g.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    icon: resolveColorTokenValue(context, tokens?.icon),
    muted: {
      bg: resolveColorTokenValue(context, (_h = tokens?.muted) == null ? void 0 : _h.bg),
      fg: resolveColorTokenValue(context, (_i = tokens?.muted) == null ? void 0 : _i.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, (_j = tokens?.kbd) == null ? void 0 : _j.bg),
      fg: resolveColorTokenValue(context, (_k = tokens?.kbd) == null ? void 0 : _k.fg),
      border: resolveColorTokenValue(context, (_l = tokens?.kbd) == null ? void 0 : _l.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_m = tokens?.link) == null ? void 0 : _m.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, (_n = tokens?.skeleton) == null ? void 0 : _n.from),
      to: resolveColorTokenValue(context, (_o = tokens?.skeleton) == null ? void 0 : _o.to)
    }
  };
}
function buildInputColorTheme(options, config) {
  const { scheme, tone } = options;
  return {
    default: buildInputStatesColorTheme({ mode: "default", scheme, tone }, config),
    invalid: buildInputStatesColorTheme({ mode: "invalid", scheme, tone }, config)
  };
}
function buildInputStatesColorTheme(options, config) {
  const { mode, scheme, tone } = options;
  return {
    enabled: buildInputStateColorTheme({ mode, scheme, state: "enabled", tone }, config),
    hovered: buildInputStateColorTheme({ mode, scheme, state: "hovered", tone }, config),
    readOnly: buildInputStateColorTheme({ mode, scheme, state: "readOnly", tone }, config),
    disabled: buildInputStateColorTheme({ mode, scheme, state: "disabled", tone }, config)
  };
}
function buildInputStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g;
  const { mode, tone, scheme, state } = options, tokens = (_c = (_b = (_a = config?.color) == null ? void 0 : _a.input) == null ? void 0 : _b[mode]) == null ? void 0 : _c[state], hue = tokens?._hue || ((_f = (_e2 = (_d = config?.color) == null ? void 0 : _d.base) == null ? void 0 : _e2[tone]) == null ? void 0 : _f._hue) || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = { hue, scheme };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    fg: resolveColorTokenValue(context, tokens?.fg),
    muted: {
      bg: resolveColorTokenValue(context, (_g = tokens?.muted) == null ? void 0 : _g.bg)
    },
    placeholder: resolveColorTokenValue(context, tokens?.placeholder)
  };
}
function buildSelectableColorTheme(options, config) {
  const { scheme } = options, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildSelectableStatesColorTheme({ scheme, tone }, config);
  return tones2;
}
function buildSelectableStatesColorTheme(options, config) {
  const { scheme, tone } = options, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildSelectableStateColorTheme({ tone, scheme, state }, config);
  return states;
}
function buildSelectableStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const { scheme, state, tone } = options, tokens = (_c = (_b = (_a = config?.color) == null ? void 0 : _a.selectable) == null ? void 0 : _b[tone]) == null ? void 0 : _c[state], hue = tokens?._hue || "gray", blendMode = tokens?._blend || ["screen", "multiply"], context = { hue, scheme };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, (_d = tokens?.accent) == null ? void 0 : _d.fg)
    },
    avatar: buildAvatarColorTheme({ scheme }, tokens),
    badge: buildBadgeColorTheme(tokens?.badge, { scheme }, config),
    bg: resolveColorTokenValue(context, tokens?.bg),
    border: resolveColorTokenValue(context, tokens?.border),
    code: {
      bg: resolveColorTokenValue(context, (_e2 = tokens?.code) == null ? void 0 : _e2.bg),
      fg: resolveColorTokenValue(context, (_f = tokens?.code) == null ? void 0 : _f.fg)
    },
    fg: resolveColorTokenValue(context, tokens?.fg),
    icon: resolveColorTokenValue(context, tokens?.icon),
    muted: {
      bg: resolveColorTokenValue(context, (_g = tokens?.muted) == null ? void 0 : _g.bg),
      fg: resolveColorTokenValue(context, (_h = tokens?.muted) == null ? void 0 : _h.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, (_i = tokens?.kbd) == null ? void 0 : _i.bg),
      fg: resolveColorTokenValue(context, (_j = tokens?.kbd) == null ? void 0 : _j.fg),
      border: resolveColorTokenValue(context, (_k = tokens?.kbd) == null ? void 0 : _k.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_l = tokens?.link) == null ? void 0 : _l.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, (_m = tokens?.skeleton) == null ? void 0 : _m.from),
      to: resolveColorTokenValue(context, (_n = tokens?.skeleton) == null ? void 0 : _n.to)
    }
  };
}
function buildSyntaxColorTheme(options, config) {
  var _a;
  const { scheme } = options, tokens = (_a = config?.color) == null ? void 0 : _a.syntax, context = { hue: "gray", scheme };
  return {
    atrule: resolveColorTokenValue(context, tokens?.atrule),
    attrName: resolveColorTokenValue(context, tokens?.attrName),
    attrValue: resolveColorTokenValue(context, tokens?.attrValue),
    attribute: resolveColorTokenValue(context, tokens?.attribute),
    boolean: resolveColorTokenValue(context, tokens?.boolean),
    builtin: resolveColorTokenValue(context, tokens?.builtin),
    cdata: resolveColorTokenValue(context, tokens?.cdata),
    char: resolveColorTokenValue(context, tokens?.char),
    class: resolveColorTokenValue(context, tokens?.class),
    className: resolveColorTokenValue(context, tokens?.className),
    comment: resolveColorTokenValue(context, tokens?.comment),
    constant: resolveColorTokenValue(context, tokens?.constant),
    deleted: resolveColorTokenValue(context, tokens?.deleted),
    doctype: resolveColorTokenValue(context, tokens?.doctype),
    entity: resolveColorTokenValue(context, tokens?.entity),
    function: resolveColorTokenValue(context, tokens?.function),
    hexcode: resolveColorTokenValue(context, tokens?.hexcode),
    id: resolveColorTokenValue(context, tokens?.id),
    important: resolveColorTokenValue(context, tokens?.important),
    inserted: resolveColorTokenValue(context, tokens?.inserted),
    keyword: resolveColorTokenValue(context, tokens?.keyword),
    number: resolveColorTokenValue(context, tokens?.number),
    operator: resolveColorTokenValue(context, tokens?.operator),
    prolog: resolveColorTokenValue(context, tokens?.prolog),
    property: resolveColorTokenValue(context, tokens?.property),
    pseudoClass: resolveColorTokenValue(context, tokens?.pseudoClass),
    pseudoElement: resolveColorTokenValue(context, tokens?.pseudoElement),
    punctuation: resolveColorTokenValue(context, tokens?.punctuation),
    regex: resolveColorTokenValue(context, tokens?.regex),
    selector: resolveColorTokenValue(context, tokens?.selector),
    string: resolveColorTokenValue(context, tokens?.string),
    symbol: resolveColorTokenValue(context, tokens?.symbol),
    tag: resolveColorTokenValue(context, tokens?.tag),
    unit: resolveColorTokenValue(context, tokens?.unit),
    url: resolveColorTokenValue(context, tokens?.url),
    variable: resolveColorTokenValue(context, tokens?.variable)
  };
}
const defaultColorPalette = color$3;
function mixChannel(b, s, weight) {
  const delta2 = (s - b) * weight;
  return b + delta2;
}
function mix$1(b, s, weight) {
  return {
    r: mixChannel(b.r, s.r, weight),
    g: mixChannel(b.g, s.g, weight),
    b: mixChannel(b.b, s.b, weight)
  };
}
function multiplyChannel(b, s) {
  return b * s;
}
function multiply(b, s) {
  return {
    r: multiplyChannel(b.r / 255, s.r / 255) * 255,
    g: multiplyChannel(b.g / 255, s.g / 255) * 255,
    b: multiplyChannel(b.b / 255, s.b / 255) * 255
  };
}
function screenChannel(b, s) {
  return b + s - b * s;
}
function screen(b, s) {
  return {
    r: screenChannel(b.r / 255, s.r / 255) * 255,
    g: screenChannel(b.g / 255, s.g / 255) * 255,
    b: screenChannel(b.b / 255, s.b / 255) * 255
  };
}
function lerp(x2, y2, a) {
  return x2 * (1 - a) + y2 * a;
}
function invlerp(x2, y2, a) {
  return clamp$3((a - x2) / (y2 - x2));
}
function clamp$3(a, min2 = 0, max2 = 1) {
  return Math.min(max2, Math.max(min2, a));
}
function range$1(x1, y1, x2, y2, a) {
  return lerp(x2, y2, invlerp(x1, y1, a));
}
function round$1(value) {
  return Math.round(value);
}
function hexToRgb(hex2) {
  if (hex2.length === 4) {
    const hexR = hex2.slice(1, 2), hexG = hex2.slice(2, 3), hexB = hex2.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex2.slice(1, 3), 16),
    g: parseInt(hex2.slice(3, 5), 16),
    b: parseInt(hex2.slice(5, 7), 16)
  };
}
function rgbaToRGBA(rgba2) {
  const values = rgba2.replace(/rgba\(|\)/g, "").split(",");
  return {
    r: parseInt(values[0]),
    g: parseInt(values[1]),
    b: parseInt(values[2]),
    a: parseFloat(values[3])
  };
}
function rgbToHex(color2) {
  const r = round$1(clamp$3(Math.round(color2.r), 0, 255)), g2 = round$1(clamp$3(Math.round(color2.g), 0, 255)), b = round$1(clamp$3(Math.round(color2.b), 0, 255));
  return "a" in color2 ? `rgba(${r},${g2},${b},${color2.a})` : "#" + ((1 << 24) + (r << 16) + (g2 << 8) + b).toString(16).slice(1);
}
function hslToRgb(hsl) {
  const s = hsl.s / 100, l2 = hsl.l / 100, c = (1 - Math.abs(2 * l2 - 1)) * s, x2 = c * (1 - Math.abs(hsl.h / 60 % 2 - 1)), m2 = l2 - c / 2;
  let r = 0, g2 = 0, b = 0;
  return 0 <= hsl.h && hsl.h < 60 ? (r = c, g2 = x2, b = 0) : 60 <= hsl.h && hsl.h < 120 ? (r = x2, g2 = c, b = 0) : 120 <= hsl.h && hsl.h < 180 ? (r = 0, g2 = c, b = x2) : 180 <= hsl.h && hsl.h < 240 ? (r = 0, g2 = x2, b = c) : 240 <= hsl.h && hsl.h < 300 ? (r = x2, g2 = 0, b = c) : 300 <= hsl.h && hsl.h < 360 && (r = c, g2 = 0, b = x2), {
    r: Math.round((r + m2) * 255),
    g: Math.round((g2 + m2) * 255),
    b: Math.round((b + m2) * 255)
  };
}
const HEX_CHARS = "0123456789ABCDEFabcdef", HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c of str)
    if (HEX_CHARS.indexOf(c) === -1)
      return !1;
  return !0;
}
function isHex(str) {
  return str[0] !== "#" || !(str.length === 4 || str.length === 7) ? !1 : isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res)
    throw new Error(`parseHsl: string is not a HSL color: "${str}"`);
  return { h: parseInt(res[1]), s: parseFloat(res[3]), l: parseFloat(res[5]) };
}
function parseColor(color2) {
  if (!color2) return { r: 0, g: 0, b: 0 };
  if (typeof color2 != "string")
    throw new Error("parseColor: expected a string");
  if (isHex(color2))
    return hexToRgb(color2);
  if (color2.startsWith("hsl("))
    return hslToRgb(parseHsl(color2));
  if (color2.startsWith("rgba("))
    return rgbaToRGBA(color2);
  throw new Error(`parseColor: unexpected color format: "${color2}"`);
}
function rgba$1(color2, a) {
  const rgb = parseColor(color2);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${a})`;
}
const RGB_RANGE = [0, 255];
function mixThemeColor(value, options) {
  const { blendMode } = options, color2 = parseColor(value), black2 = parseColor(options.black), white2 = parseColor(options.white), bg = options.bg ? parseColor(options.bg) : blendMode === "multiply" ? white2 : black2, paletteRange = {
    r: [black2.r, white2.r],
    g: [black2.g, white2.g],
    b: [black2.b, white2.b]
  }, convertedBgColor = {
    r: clamp$3(range$1(...paletteRange.r, ...RGB_RANGE, bg.r), ...RGB_RANGE),
    g: clamp$3(range$1(...paletteRange.g, ...RGB_RANGE, bg.g), ...RGB_RANGE),
    b: clamp$3(range$1(...paletteRange.b, ...RGB_RANGE, bg.b), ...RGB_RANGE)
  }, convertedColor = {
    r: clamp$3(range$1(...paletteRange.r, ...RGB_RANGE, color2.r), ...RGB_RANGE),
    g: clamp$3(range$1(...paletteRange.g, ...RGB_RANGE, color2.g), ...RGB_RANGE),
    b: clamp$3(range$1(...paletteRange.b, ...RGB_RANGE, color2.b), ...RGB_RANGE)
  }, resultColor = blendMode === "multiply" ? multiply(convertedBgColor, convertedColor) : screen(convertedBgColor, convertedColor), v2 = {
    r: clamp$3(range$1(...RGB_RANGE, ...paletteRange.r, resultColor.r), ...paletteRange.r),
    g: clamp$3(range$1(...RGB_RANGE, ...paletteRange.g, resultColor.g), ...paletteRange.g),
    b: clamp$3(range$1(...RGB_RANGE, ...paletteRange.b, resultColor.b), ...paletteRange.b)
  };
  return rgbToHex(v2);
}
function renderColorValue(str, options) {
  const { bg, blendMode, colorPalette } = options;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  const node2 = parseTokenValue(str);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token value: ${str}`);
  let hex2 = "";
  if (node2.key === "black" && (hex2 = renderColorHex(colorPalette.black)), node2.key === "white" && (hex2 = renderColorHex(colorPalette.white)), node2.hue && node2.tint && (hex2 = renderColorHex(colorPalette[node2.hue][node2.tint])), !hex2)
    throw new Error(`Invalid color token value: ${str}`);
  const hexBeforeMix = hex2, mixOptions = {
    blendMode,
    bg,
    black: renderColorHex(colorPalette.black),
    // opacity: node.opacity,
    white: renderColorHex(colorPalette.white)
  };
  try {
    if (hex2 = mixThemeColor(hex2, mixOptions), bg && node2.mix !== void 0) {
      const from2 = hexToRgb(bg), to = hexToRgb(hex2);
      hex2 = rgbToHex(mix$1(from2, to, node2.mix));
    }
  } catch (err) {
    throw console.warn("could not blend", hex2, mixOptions), err;
  }
  return hex2 === "#aN" && (console.warn(`invalid color token value: ${str}`), hex2 = hexBeforeMix), node2.opacity !== void 0 && (hex2 = rgba$1(hex2, node2.opacity)), hex2;
}
function renderColorHex(color2) {
  return typeof color2 == "string" ? color2 : color2.hex;
}
function renderThemeColorSchemes(value, config) {
  var _a;
  const colorPalette = (_a = void 0) != null ? _a : defaultColorPalette;
  return {
    light: renderThemeColorScheme(colorPalette, value.light),
    dark: renderThemeColorScheme(colorPalette, value.dark)
  };
}
function renderThemeColorScheme(colorPalette, value) {
  const toneEntries = Object.entries(value), [, transparentTone] = toneEntries.find(([k2]) => k2 === "transparent"), [, defaultTone] = toneEntries.find(([k2]) => k2 === "default"), renderedTransparentTone = renderThemeColor(transparentTone, { colorPalette }), renderedDefaultTone = renderThemeColor(defaultTone, { colorPalette }), bg = renderedDefaultTone.bg;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  return Object.fromEntries([
    ["transparent", renderedTransparentTone],
    ["default", renderedDefaultTone],
    ...toneEntries.filter(([k2]) => k2 !== "default" && k2 !== "transparent").map(([k2, v2]) => [k2, renderThemeColor(v2, { bg, colorPalette })])
  ]);
}
function renderThemeColor(value, options) {
  const { colorPalette, bg } = options, blendMode = value._blend || "multiply", baseBg = renderColorValue(value.bg, { colorPalette, bg, blendMode }), colorOptions = { colorPalette, bg: baseBg, blendMode }, button = renderThemeColorButton(value.button, {
    baseBg,
    blendMode,
    colorPalette
  }), selectable = renderThemeColorSelectable(value.selectable, {
    colorPalette,
    baseBg,
    blendMode
  }), shadow = {
    outline: renderColorValue(value.shadow.outline, colorOptions),
    umbra: renderColorValue(value.shadow.umbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: { ...colorPalette, black: "#000000" }
    }),
    penumbra: renderColorValue(value.shadow.penumbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: { ...colorPalette, black: "#000000" }
    }),
    ambient: renderColorValue(value.shadow.ambient, {
      ...colorOptions,
      bg: void 0,
      colorPalette: { ...colorPalette, black: "#000000" }
    })
  };
  return {
    _blend: blendMode,
    _dark: value._dark,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, { baseBg, colorPalette, blendMode }),
    backdrop: renderColorValue(value.backdrop, colorOptions),
    badge: renderThemeColorBadge(value.badge, { baseBg, colorPalette, blendMode }),
    bg: baseBg,
    border: renderColorValue(value.border, colorOptions),
    button,
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    focusRing: renderColorValue(value.focusRing, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    input: renderThemeColorInput(value.input, { baseBg, colorPalette, blendMode }),
    kbd: renderThemeColorKBD(value.kbd, { baseBg, colorPalette, blendMode }),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    shadow,
    skeleton: {
      from: renderColorValue(value.skeleton.from, colorOptions),
      to: renderColorValue(value.skeleton.to, colorOptions)
    },
    syntax: renderSyntaxColorTheme(value.syntax, { baseBg, colorPalette, blendMode }),
    selectable
  };
}
function renderThemeColorKBD(value, options) {
  const { baseBg, blendMode, colorPalette } = options, rootOptions = {
    bg: baseBg,
    blendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    fg: renderColorValue(value.fg, colorOptions),
    border: renderColorValue(value.border, colorOptions)
  };
}
function renderThemeColorAvatar(value, options) {
  return {
    gray: renderThemeColorAvatarColor(value.gray, options),
    blue: renderThemeColorAvatarColor(value.blue, options),
    purple: renderThemeColorAvatarColor(value.purple, options),
    magenta: renderThemeColorAvatarColor(value.magenta, options),
    red: renderThemeColorAvatarColor(value.red, options),
    orange: renderThemeColorAvatarColor(value.orange, options),
    yellow: renderThemeColorAvatarColor(value.yellow, options),
    green: renderThemeColorAvatarColor(value.green, options),
    cyan: renderThemeColorAvatarColor(value.cyan, options)
  };
}
function renderThemeColorAvatarColor(value, options) {
  const { baseBg, blendMode: rootBlendMode, colorPalette } = options, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    bg,
    fg: renderColorValue(value.fg, colorOptions)
  };
}
function renderThemeColorBadge(value, options) {
  return {
    default: renderThemeColorBadgeColor(value.default, options),
    primary: renderThemeColorBadgeColor(value.primary, options),
    positive: renderThemeColorBadgeColor(value.positive, options),
    caution: renderThemeColorBadgeColor(value.caution, options),
    critical: renderThemeColorBadgeColor(value.critical, options)
  };
}
function renderThemeColorBadgeColor(value, options) {
  const { baseBg, blendMode: rootBlendMode, colorPalette } = options, blendMode = rootBlendMode, rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    dot: renderColorValue(value.dot, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions)
  };
}
function renderThemeColorButton(value, options) {
  return {
    default: renderThemeColorButtonTones(value.default, options),
    ghost: renderThemeColorButtonTones(value.ghost, options),
    bleed: renderThemeColorButtonTones(value.bleed, options)
  };
}
function renderThemeColorButtonTones(value, options) {
  return {
    default: renderThemeColorButtonStates(value.default, options),
    primary: renderThemeColorButtonStates(value.primary, options),
    positive: renderThemeColorButtonStates(value.positive, options),
    caution: renderThemeColorButtonStates(value.caution, options),
    critical: renderThemeColorButtonStates(value.critical, options)
  };
}
function renderThemeColorButtonStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options)
  };
}
function renderThemeColorState(value, options) {
  var _a, _b;
  const { baseBg, blendMode: rootBlendMode, colorPalette } = options, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, { baseBg: bg, colorPalette, blendMode }),
    badge: renderThemeColorBadge(value.badge, { baseBg: bg, colorPalette, blendMode }),
    bg,
    border: renderColorValue(value.border, colorOptions),
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    kbd: {
      bg: renderColorValue(value.kbd.bg, colorOptions),
      fg: renderColorValue(value.kbd.fg, colorOptions),
      border: renderColorValue(value.kbd.border, colorOptions)
    },
    skeleton: {
      from: renderColorValue((_a = value.skeleton) == null ? void 0 : _a.from, colorOptions),
      to: renderColorValue((_b = value.skeleton) == null ? void 0 : _b.to, colorOptions)
    }
  };
}
function renderThemeColorInput(value, options) {
  return {
    default: renderInputStatesColorTheme(value.default, options),
    invalid: renderInputStatesColorTheme(value.invalid, options)
  };
}
function renderInputStatesColorTheme(value, options) {
  return {
    enabled: renderInputStateColorTheme(value.enabled, options),
    hovered: renderInputStateColorTheme(value.hovered, options),
    readOnly: renderInputStateColorTheme(value.readOnly, options),
    disabled: renderInputStateColorTheme(value.disabled, options)
  };
}
function renderInputStateColorTheme(value, options) {
  const { baseBg, blendMode: rootBlendMode, colorPalette } = options, blendMode = value._blend || "multiply", rootOptions = { colorPalette, bg: baseBg, blendMode: rootBlendMode }, bg = renderColorValue(value.bg, rootOptions), colorOptions = { colorPalette, bg, blendMode };
  return {
    _blend: blendMode,
    bg,
    border: renderColorValue(value.border, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions)
    },
    placeholder: renderColorValue(value.placeholder, colorOptions)
  };
}
function renderThemeColorSelectable(value, options) {
  return {
    default: renderThemeColorSelectableStates(value.default, options),
    primary: renderThemeColorSelectableStates(value.primary, options),
    positive: renderThemeColorSelectableStates(value.positive, options),
    caution: renderThemeColorSelectableStates(value.caution, options),
    critical: renderThemeColorSelectableStates(value.critical, options)
  };
}
function renderThemeColorSelectableStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options)
  };
}
function renderSyntaxColorTheme(value, options) {
  const { colorPalette, baseBg, blendMode } = options, colorOptions = { colorPalette, bg: baseBg, blendMode };
  return {
    atrule: renderColorValue(value.atrule, colorOptions),
    attrName: renderColorValue(value.attrName, colorOptions),
    attrValue: renderColorValue(value.attrValue, colorOptions),
    attribute: renderColorValue(value.attribute, colorOptions),
    boolean: renderColorValue(value.boolean, colorOptions),
    builtin: renderColorValue(value.builtin, colorOptions),
    cdata: renderColorValue(value.cdata, colorOptions),
    char: renderColorValue(value.char, colorOptions),
    class: renderColorValue(value.class, colorOptions),
    className: renderColorValue(value.className, colorOptions),
    comment: renderColorValue(value.comment, colorOptions),
    constant: renderColorValue(value.constant, colorOptions),
    deleted: renderColorValue(value.deleted, colorOptions),
    doctype: renderColorValue(value.doctype, colorOptions),
    entity: renderColorValue(value.entity, colorOptions),
    function: renderColorValue(value.function, colorOptions),
    hexcode: renderColorValue(value.hexcode, colorOptions),
    id: renderColorValue(value.id, colorOptions),
    important: renderColorValue(value.important, colorOptions),
    inserted: renderColorValue(value.inserted, colorOptions),
    keyword: renderColorValue(value.keyword, colorOptions),
    number: renderColorValue(value.number, colorOptions),
    operator: renderColorValue(value.operator, colorOptions),
    prolog: renderColorValue(value.prolog, colorOptions),
    property: renderColorValue(value.property, colorOptions),
    pseudoClass: renderColorValue(value.pseudoClass, colorOptions),
    pseudoElement: renderColorValue(value.pseudoElement, colorOptions),
    punctuation: renderColorValue(value.punctuation, colorOptions),
    regex: renderColorValue(value.regex, colorOptions),
    selector: renderColorValue(value.selector, colorOptions),
    string: renderColorValue(value.string, colorOptions),
    symbol: renderColorValue(value.symbol, colorOptions),
    tag: renderColorValue(value.tag, colorOptions),
    unit: renderColorValue(value.unit, colorOptions),
    url: renderColorValue(value.url, colorOptions),
    variable: renderColorValue(value.variable, colorOptions)
  };
}
function buildTheme(config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l;
  const colorTheme = buildColorTheme(config), v2 = {
    _version: 2,
    avatar: (_a = void 0) != null ? _a : defaultThemeConfig.avatar,
    button: (_b = void 0) != null ? _b : defaultThemeConfig.button,
    card: (_c = void 0) != null ? _c : defaultThemeConfig.card,
    // How colors are generated:
    // 1. Merge custom tokens with default tokens
    // 2. Generate tree of color keys (gray/500, black, white, etc.)
    // 3. Apply mixing and render to hex values
    // render(build(mergeWithDefaults()))
    color: renderThemeColorSchemes(colorTheme),
    container: (_d = void 0) != null ? _d : defaultThemeConfig.container,
    font: (_e2 = void 0) != null ? _e2 : defaultThemeFonts,
    input: (_f = void 0) != null ? _f : defaultThemeConfig.input,
    layer: (_g = void 0) != null ? _g : defaultThemeConfig.layer,
    media: (_h = void 0) != null ? _h : defaultThemeConfig.media,
    radius: (_i = void 0) != null ? _i : defaultThemeConfig.radius,
    shadow: (_j = void 0) != null ? _j : defaultThemeConfig.shadow,
    space: (_k = void 0) != null ? _k : defaultThemeConfig.space,
    style: (_l = void 0) != null ? _l : defaultThemeConfig.style
  };
  return v2_v0(v2);
}
const cache$3 = /* @__PURE__ */ new Map();
function getScopedTheme(themeProp, scheme, tone) {
  const cachedTheme = _getCachedTheme(themeProp, scheme, tone);
  if (cachedTheme) return cachedTheme;
  const v0 = is_v2(themeProp) ? v2_v0(themeProp) : themeProp, v2 = is_v2(themeProp) ? themeProp : v0_v2(themeProp), colorScheme_v0 = v0.color[scheme] || v0.color.light, color_v0 = colorScheme_v0[tone] || colorScheme_v0.default, layer_v0 = v0.layer || defaultThemeConfig.layer, colorScheme_v2 = v2.color[scheme] || v2.color.light, color_v2 = colorScheme_v2[tone] || colorScheme_v2.default, layer_v2 = v2.layer || defaultThemeConfig.layer, theme = {
    sanity: {
      ...v0,
      color: color_v0,
      layer: layer_v0,
      v2: {
        ...v2,
        _resolved: !0,
        color: color_v2,
        layer: layer_v2
      }
    }
  };
  return _setCachedTheme(themeProp, scheme, tone, theme), theme;
}
function _getCachedTheme(rootTheme, scheme, tone) {
  const schemeCache = cache$3.get(scheme);
  if (!schemeCache) return;
  const toneCache = schemeCache.get(tone);
  if (toneCache)
    return toneCache.get(rootTheme);
}
function _setCachedTheme(rootTheme, scheme, tone, theme) {
  cache$3.has(scheme) || cache$3.set(scheme, /* @__PURE__ */ new Map());
  const schemeCache = cache$3.get(scheme);
  schemeCache.has(tone) || schemeCache.set(tone, /* @__PURE__ */ new WeakMap()), schemeCache.get(tone).set(rootTheme, theme);
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2.default : x2;
}
var reactIs = { exports: {} }, reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_production_min;
function requireReactIs_production_min() {
  if (hasRequiredReactIs_production_min) return reactIs_production_min;
  hasRequiredReactIs_production_min = 1;
  var b = typeof Symbol == "function" && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f2 = b ? Symbol.for("react.strict_mode") : 60108, g2 = b ? Symbol.for("react.profiler") : 60114, h2 = b ? Symbol.for("react.provider") : 60109, k2 = b ? Symbol.for("react.context") : 60110, l2 = b ? Symbol.for("react.async_mode") : 60111, m2 = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q2 = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v2 = b ? Symbol.for("react.block") : 60121, w2 = b ? Symbol.for("react.fundamental") : 60117, x2 = b ? Symbol.for("react.responder") : 60118, y2 = b ? Symbol.for("react.scope") : 60119;
  function z2(a) {
    if (typeof a == "object" && a !== null) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l2:
            case m2:
            case e:
            case g2:
            case f2:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k2:
                case n:
                case t:
                case r:
                case h2:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A2(a) {
    return z2(a) === m2;
  }
  return reactIs_production_min.AsyncMode = l2, reactIs_production_min.ConcurrentMode = m2, reactIs_production_min.ContextConsumer = k2, reactIs_production_min.ContextProvider = h2, reactIs_production_min.Element = c, reactIs_production_min.ForwardRef = n, reactIs_production_min.Fragment = e, reactIs_production_min.Lazy = t, reactIs_production_min.Memo = r, reactIs_production_min.Portal = d, reactIs_production_min.Profiler = g2, reactIs_production_min.StrictMode = f2, reactIs_production_min.Suspense = p, reactIs_production_min.isAsyncMode = function(a) {
    return A2(a) || z2(a) === l2;
  }, reactIs_production_min.isConcurrentMode = A2, reactIs_production_min.isContextConsumer = function(a) {
    return z2(a) === k2;
  }, reactIs_production_min.isContextProvider = function(a) {
    return z2(a) === h2;
  }, reactIs_production_min.isElement = function(a) {
    return typeof a == "object" && a !== null && a.$$typeof === c;
  }, reactIs_production_min.isForwardRef = function(a) {
    return z2(a) === n;
  }, reactIs_production_min.isFragment = function(a) {
    return z2(a) === e;
  }, reactIs_production_min.isLazy = function(a) {
    return z2(a) === t;
  }, reactIs_production_min.isMemo = function(a) {
    return z2(a) === r;
  }, reactIs_production_min.isPortal = function(a) {
    return z2(a) === d;
  }, reactIs_production_min.isProfiler = function(a) {
    return z2(a) === g2;
  }, reactIs_production_min.isStrictMode = function(a) {
    return z2(a) === f2;
  }, reactIs_production_min.isSuspense = function(a) {
    return z2(a) === p;
  }, reactIs_production_min.isValidElementType = function(a) {
    return typeof a == "string" || typeof a == "function" || a === e || a === m2 || a === g2 || a === f2 || a === p || a === q2 || typeof a == "object" && a !== null && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h2 || a.$$typeof === k2 || a.$$typeof === n || a.$$typeof === w2 || a.$$typeof === x2 || a.$$typeof === y2 || a.$$typeof === v2);
  }, reactIs_production_min.typeOf = z2, reactIs_production_min;
}
var reactIs_development = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactIs_development;
function requireReactIs_development() {
  return hasRequiredReactIs_development || (hasRequiredReactIs_development = 1, process.env.NODE_ENV !== "production" && function() {
    var hasSymbol = typeof Symbol == "function" && Symbol.for, REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103, REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106, REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107, REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108, REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114, REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109, REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110, REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111, REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111, REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112, REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113, REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120, REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115, REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116, REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121, REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117, REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118, REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
    function isValidElementType(type) {
      return typeof type == "string" || typeof type == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type == "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
    }
    function typeOf(object) {
      if (typeof object == "object" && object !== null) {
        var $$typeof = object.$$typeof;
        switch ($$typeof) {
          case REACT_ELEMENT_TYPE:
            var type = object.type;
            switch (type) {
              case REACT_ASYNC_MODE_TYPE:
              case REACT_CONCURRENT_MODE_TYPE:
              case REACT_FRAGMENT_TYPE:
              case REACT_PROFILER_TYPE:
              case REACT_STRICT_MODE_TYPE:
              case REACT_SUSPENSE_TYPE:
                return type;
              default:
                var $$typeofType = type && type.$$typeof;
                switch ($$typeofType) {
                  case REACT_CONTEXT_TYPE:
                  case REACT_FORWARD_REF_TYPE:
                  case REACT_LAZY_TYPE:
                  case REACT_MEMO_TYPE:
                  case REACT_PROVIDER_TYPE:
                    return $$typeofType;
                  default:
                    return $$typeof;
                }
            }
          case REACT_PORTAL_TYPE:
            return $$typeof;
        }
      }
    }
    var AsyncMode = REACT_ASYNC_MODE_TYPE, ConcurrentMode = REACT_CONCURRENT_MODE_TYPE, ContextConsumer = REACT_CONTEXT_TYPE, ContextProvider = REACT_PROVIDER_TYPE, Element2 = REACT_ELEMENT_TYPE, ForwardRef = REACT_FORWARD_REF_TYPE, Fragment2 = REACT_FRAGMENT_TYPE, Lazy = REACT_LAZY_TYPE, Memo = REACT_MEMO_TYPE, Portal2 = REACT_PORTAL_TYPE, Profiler = REACT_PROFILER_TYPE, StrictMode = REACT_STRICT_MODE_TYPE, Suspense = REACT_SUSPENSE_TYPE, hasWarnedAboutDeprecatedIsAsyncMode = !1;
    function isAsyncMode(object) {
      return hasWarnedAboutDeprecatedIsAsyncMode || (hasWarnedAboutDeprecatedIsAsyncMode = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
    }
    function isConcurrentMode(object) {
      return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
    }
    function isContextConsumer(object) {
      return typeOf(object) === REACT_CONTEXT_TYPE;
    }
    function isContextProvider(object) {
      return typeOf(object) === REACT_PROVIDER_TYPE;
    }
    function isElement2(object) {
      return typeof object == "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
    }
    function isForwardRef(object) {
      return typeOf(object) === REACT_FORWARD_REF_TYPE;
    }
    function isFragment(object) {
      return typeOf(object) === REACT_FRAGMENT_TYPE;
    }
    function isLazy(object) {
      return typeOf(object) === REACT_LAZY_TYPE;
    }
    function isMemo(object) {
      return typeOf(object) === REACT_MEMO_TYPE;
    }
    function isPortal(object) {
      return typeOf(object) === REACT_PORTAL_TYPE;
    }
    function isProfiler(object) {
      return typeOf(object) === REACT_PROFILER_TYPE;
    }
    function isStrictMode(object) {
      return typeOf(object) === REACT_STRICT_MODE_TYPE;
    }
    function isSuspense(object) {
      return typeOf(object) === REACT_SUSPENSE_TYPE;
    }
    reactIs_development.AsyncMode = AsyncMode, reactIs_development.ConcurrentMode = ConcurrentMode, reactIs_development.ContextConsumer = ContextConsumer, reactIs_development.ContextProvider = ContextProvider, reactIs_development.Element = Element2, reactIs_development.ForwardRef = ForwardRef, reactIs_development.Fragment = Fragment2, reactIs_development.Lazy = Lazy, reactIs_development.Memo = Memo, reactIs_development.Portal = Portal2, reactIs_development.Profiler = Profiler, reactIs_development.StrictMode = StrictMode, reactIs_development.Suspense = Suspense, reactIs_development.isAsyncMode = isAsyncMode, reactIs_development.isConcurrentMode = isConcurrentMode, reactIs_development.isContextConsumer = isContextConsumer, reactIs_development.isContextProvider = isContextProvider, reactIs_development.isElement = isElement2, reactIs_development.isForwardRef = isForwardRef, reactIs_development.isFragment = isFragment, reactIs_development.isLazy = isLazy, reactIs_development.isMemo = isMemo, reactIs_development.isPortal = isPortal, reactIs_development.isProfiler = isProfiler, reactIs_development.isStrictMode = isStrictMode, reactIs_development.isSuspense = isSuspense, reactIs_development.isValidElementType = isValidElementType, reactIs_development.typeOf = typeOf;
  }()), reactIs_development;
}
process.env.NODE_ENV === "production" ? reactIs.exports = requireReactIs_production_min() : reactIs.exports = requireReactIs_development();
var reactIsExports = reactIs.exports, ReactIs = /* @__PURE__ */ getDefaultExportFromCjs(reactIsExports), __assign = function() {
  return __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
    }
    return t;
  }, __assign.apply(this, arguments);
};
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l2 = from2.length, ar; i < l2; i++)
    (ar || !(i in from2)) && (ar || (ar = Array.prototype.slice.call(from2, 0, i)), ar[i] = from2[i]);
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function memoize(fn) {
  var cache2 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    return cache2[arg] === void 0 && (cache2[arg] = fn(arg)), cache2[arg];
  };
}
var reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/, isPropValid = /* @__PURE__ */ memoize(
  function(prop2) {
    return reactPropsRegex.test(prop2) || prop2.charCodeAt(0) === 111 && prop2.charCodeAt(1) === 110 && prop2.charCodeAt(2) < 91;
  }
  /* Z+1 */
), MS = "-ms-", MOZ = "-moz-", WEBKIT = "-webkit-", COMMENT = "comm", RULESET = "rule", DECLARATION = "decl", IMPORT = "@import", KEYFRAMES = "@keyframes", LAYER = "@layer", abs = Math.abs, from = String.fromCharCode, assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search2, position2) {
  return value.indexOf(search2, position2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter$3(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}
var line = 1, column = 1, length = 0, position = 0, character = 0, characters = "";
function node(value, root, parent, type, props, children, length2, siblings) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy$2(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  for (; root.root; )
    root = copy$2(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  return character = position > 0 ? charat(characters, --position) : 0, column--, character === 10 && (column = 1, line--), character;
}
function next() {
  return character = position < length ? charat(characters, position++) : 0, column++, character === 10 && (column = 1, line++), character;
}
function peek() {
  return charat(characters, position);
}
function caret$1() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  for (; (character = peek()) && character < 33; )
    next();
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  for (; --count && next() && !(character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97); )
    ;
  return slice(index2, caret$1() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  for (; next(); )
    switch (character) {
      case type:
        return position;
      case 34:
      case 39:
        type !== 34 && type !== 39 && delimiter(character);
        break;
      case 40:
        type === 41 && delimiter(type);
        break;
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  for (; next() && type + character !== 57; )
    if (type + character === 84 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  for (; !token(peek()); )
    next();
  return slice(index2, position);
}
function compile(value) {
  return dealloc(parse$4("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse$4(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  for (var index2 = 0, offset2 = 0, length2 = pseudo, atrule = 0, property = 0, previous = 0, variable = 1, scanning = 1, ampersand2 = 1, character2 = 0, type = "", props = rules, children = rulesets, reference = rule, characters2 = type; scanning; )
    switch (previous = character2, character2 = next()) {
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1 && (ampersand2 = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      case 92:
        characters2 += escaping(caret$1() - 1, 7);
        continue;
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret$1()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand2;
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          case 0:
          case 125:
            scanning = 0;
          case 59 + offset2:
            ampersand2 == -1 && (characters2 = replace(characters2, /\f/g, "")), property > 0 && strlen(characters2) - length2 && append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          case 59:
            characters2 += ";";
          default:
            if (append(reference = ruleset(characters2, root, parent, index2, offset2, rules, points, type, props = [], children = [], length2, rulesets), rulesets), character2 === 123)
              if (offset2 === 0)
                parse$4(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse$4(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse$4(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset2 = property = 0, variable = ampersand2 = 1, type = characters2 = "", length2 = pseudo;
        break;
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          case 38:
            ampersand2 = offset2 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand2, ampersand2 = 1;
            break;
          case 64:
            peek() === 45 && (characters2 += delimit(next())), atrule = peek(), offset2 = length2 = strlen(type = characters2 += identifier(caret$1())), character2++;
            break;
          case 45:
            previous === 45 && strlen(characters2) == 2 && (variable = 0);
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset2, rules, points, type, props, children, length2, siblings) {
  for (var post = offset2 - 1, rule = offset2 === 0 ? rules : [""], size2 = sizeof(rule), i = 0, j2 = 0, k2 = 0; i < index2; ++i)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i])), z2 = value; x2 < size2; ++x2)
      (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2]))) && (props[k2++] = z2);
  return node(value, root, parent, offset2 === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    case 5103:
      return WEBKIT + "print-" + value + value;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    case 4789:
      return MOZ + value + value;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    case 5936:
      switch (charat(value, length2 + 11)) {
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (match(value, /flex-|baseline/) ? "" : MS + "grid-row-" + replace(value, /flex-|-self/g, "")) + value;
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    case 4384:
    case 3616:
      return children && children.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      }) ? ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";" : MS + replace(value, "-start", "") + value;
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a, b, c, d, e, f2) {
        return MS + a + ":" + b + f2 + (c ? MS + a + "-span:" + (d ? e : +e - +b) + f2 : "") + value;
      });
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}
function serialize(children, callback) {
  for (var output = "", i = 0; i < children.length; i++)
    output += callback(children[i], i, children, callback) || "";
  return output;
}
function stringify$3(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    for (var output = "", i = 0; i < length2; i++)
      output += collection[i](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    element.root || (element = element.return) && callback(element);
  };
}
function prefixer(element, index2, children, callback) {
  if (element.length > -1 && !element.return)
    switch (element.type) {
      case DECLARATION:
        element.return = prefix(element.value, element.length, children);
        return;
      case KEYFRAMES:
        return serialize([copy$2(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
      case RULESET:
        if (element.length)
          return combine(children = element.props, function(value) {
            switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                lift(copy$2(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] })), lift(copy$2(element, { props: [value] })), assign(element, { props: filter$3(children, callback) });
                break;
              case "::placeholder":
                lift(copy$2(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] })), lift(copy$2(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] })), lift(copy$2(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] })), lift(copy$2(element, { props: [value] })), assign(element, { props: filter$3(children, callback) });
                break;
            }
            return "";
          });
    }
}
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, f = typeof process < "u" && process.env !== void 0 && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled", m = "active", y = "data-styled-version", v = "6.1.12", g$1 = `/*!sc*/
`, S = typeof window < "u" && "HTMLElement" in window, w = !!(typeof SC_DISABLE_SPEEDY == "boolean" ? SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== void 0 && process.env.REACT_APP_SC_DISABLE_SPEEDY !== "" ? process.env.REACT_APP_SC_DISABLE_SPEEDY !== "false" && process.env.REACT_APP_SC_DISABLE_SPEEDY : typeof process < "u" && process.env !== void 0 && process.env.SC_DISABLE_SPEEDY !== void 0 && process.env.SC_DISABLE_SPEEDY !== "" ? process.env.SC_DISABLE_SPEEDY !== "false" && process.env.SC_DISABLE_SPEEDY : process.env.NODE_ENV !== "production"), E = /invalid hook call/i, N = /* @__PURE__ */ new Set(), P = function(t, n) {
  if (process.env.NODE_ENV !== "production") {
    var r = n ? ' with the id of "'.concat(n, '"') : "", s = "The component ".concat(t).concat(r, ` has been created dynamically.
`) + `You may see this warning because you've called styled inside another component.
To resolve this only create new StyledComponents outside of any render method and function component.`, i = console.error;
    try {
      var a = !0;
      console.error = function(t2) {
        for (var n2 = [], r2 = 1; r2 < arguments.length; r2++) n2[r2 - 1] = arguments[r2];
        E.test(t2) ? (a = !1, N.delete(s)) : i.apply(void 0, __spreadArray([t2], n2, !1));
      }, useRef(), a && !N.has(s) && (console.warn(s), N.add(s));
    } catch (e) {
      E.test(e.message) && N.delete(s);
    } finally {
      console.error = i;
    }
  }
}, _ = Object.freeze([]), C = Object.freeze({});
function I(e, t, n) {
  return n === void 0 && (n = C), e.theme !== n.theme && e.theme || t || n.theme;
}
var A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]), O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g, D = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi, k = 52, j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x(e) {
  var t, n = "";
  for (t = Math.abs(e); t > k; t = t / k | 0) n = j(t % k) + n;
  return (j(t % k) + n).replace(T, "$1-$2");
}
var V, F = 5381, M = function(e, t) {
  for (var n = t.length; n; ) e = 33 * e ^ t.charCodeAt(--n);
  return e;
}, z = function(e) {
  return M(F, e);
};
function $(e) {
  return x(z(e) >>> 0);
}
function B(e) {
  return process.env.NODE_ENV !== "production" && typeof e == "string" && e || e.displayName || e.name || "Component";
}
function L$1(e) {
  return typeof e == "string" && (process.env.NODE_ENV === "production" || e.charAt(0) === e.charAt(0).toLowerCase());
}
var G$1 = typeof Symbol == "function" && Symbol.for, Y = G$1 ? Symbol.for("react.memo") : 60115, q = G$1 ? Symbol.for("react.forward_ref") : 60112, W = { childContextTypes: !0, contextType: !0, contextTypes: !0, defaultProps: !0, displayName: !0, getDefaultProps: !0, getDerivedStateFromError: !0, getDerivedStateFromProps: !0, mixins: !0, propTypes: !0, type: !0 }, H = { name: !0, length: !0, prototype: !0, caller: !0, callee: !0, arguments: !0, arity: !0 }, U = { $$typeof: !0, compare: !0, defaultProps: !0, displayName: !0, propTypes: !0, type: !0 }, J = ((V = {})[q] = { $$typeof: !0, render: !0, defaultProps: !0, displayName: !0, propTypes: !0 }, V[Y] = U, V);
function X(e) {
  return ("type" in (t = e) && t.type.$$typeof) === Y ? U : "$$typeof" in e ? J[e.$$typeof] : W;
  var t;
}
var Z = Object.defineProperty, K = Object.getOwnPropertyNames, Q = Object.getOwnPropertySymbols, ee$1 = Object.getOwnPropertyDescriptor, te = Object.getPrototypeOf, ne$1 = Object.prototype;
function re$1(e, t, n) {
  if (typeof t != "string") {
    if (ne$1) {
      var r = te(t);
      r && r !== ne$1 && re$1(e, r, n);
    }
    var o = K(t);
    Q && (o = o.concat(Q(t)));
    for (var s = X(e), i = X(t), a = 0; a < o.length; ++a) {
      var c = o[a];
      if (!(c in H || n && n[c] || i && c in i || s && c in s)) {
        var l2 = ee$1(t, c);
        try {
          Z(e, c, l2);
        } catch {
        }
      }
    }
  }
  return e;
}
function oe(e) {
  return typeof e == "function";
}
function se(e) {
  return typeof e == "object" && "styledComponentId" in e;
}
function ie(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function ae(e, t) {
  if (e.length === 0) return "";
  for (var n = e[0], r = 1; r < e.length; r++) n += e[r];
  return n;
}
function ce(e) {
  return e !== null && typeof e == "object" && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function le$1(e, t, n) {
  if (n === void 0 && (n = !1), !n && !ce(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var r = 0; r < t.length; r++) e[r] = le$1(e[r], t[r]);
  else if (ce(t)) for (var r in t) e[r] = le$1(e[r], t[r]);
  return e;
}
function ue(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
var pe = process.env.NODE_ENV !== "production" ? { 1: `Cannot create styled-component for component: %s.

`, 2: `Can't collect styles once you've consumed a \`ServerStyleSheet\`'s styles! \`ServerStyleSheet\` is a one off instance for each server-side render cycle.

- Are you trying to reuse it across renders?
- Are you accidentally calling collectStyles twice?

`, 3: `Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.

`, 4: `The \`StyleSheetManager\` expects a valid target or sheet prop!

- Does this error occur on the client and is your target falsy?
- Does this error occur on the server and is the sheet falsy?

`, 5: `The clone method cannot be used on the client!

- Are you running in a client-like environment on the server?
- Are you trying to run SSR on the client?

`, 6: `Trying to insert a new style tag, but the given Node is unmounted!

- Are you using a custom target that isn't mounted?
- Does your document not have a valid head element?
- Have you accidentally removed a style tag manually?

`, 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: `ThemeProvider: Please make your "theme" prop an object.

`, 9: "Missing document `<head>`\n\n", 10: `Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021

`, 11: `_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.

`, 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: `%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.

`, 14: `ThemeProvider: "theme" prop is required.

`, 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: `Reached the limit of how many styled components may be created at group %s.
You may only create up to 1,073,741,824 components. If you're creating components dynamically,
as for instance in your render method then you may be running into this limitation.

`, 17: `CSSStyleSheet could not be found on HTMLStyleElement.
Has styled-components' style tag been unmounted or altered by another script?
`, 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function de$1() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  for (var n = e[0], r = [], o = 1, s = e.length; o < s; o += 1) r.push(e[o]);
  return r.forEach(function(e2) {
    n = n.replace(/%[a-z]/, e2);
  }), n;
}
function he(t) {
  for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
  return process.env.NODE_ENV === "production" ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de$1.apply(void 0, __spreadArray([pe[t]], n, !1)).trim());
}
var fe = function() {
  function e(e2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e2;
  }
  return e.prototype.indexOfGroup = function(e2) {
    for (var t = 0, n = 0; n < e2; n++) t += this.groupSizes[n];
    return t;
  }, e.prototype.insertRules = function(e2, t) {
    if (e2 >= this.groupSizes.length) {
      for (var n = this.groupSizes, r = n.length, o = r; e2 >= o; ) if ((o <<= 1) < 0) throw he(16, "".concat(e2));
      this.groupSizes = new Uint32Array(o), this.groupSizes.set(n), this.length = o;
      for (var s = r; s < o; s++) this.groupSizes[s] = 0;
    }
    for (var i = this.indexOfGroup(e2 + 1), a = (s = 0, t.length); s < a; s++) this.tag.insertRule(i, t[s]) && (this.groupSizes[e2]++, i++);
  }, e.prototype.clearGroup = function(e2) {
    if (e2 < this.length) {
      var t = this.groupSizes[e2], n = this.indexOfGroup(e2), r = n + t;
      this.groupSizes[e2] = 0;
      for (var o = n; o < r; o++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e2) {
    var t = "";
    if (e2 >= this.length || this.groupSizes[e2] === 0) return t;
    for (var n = this.groupSizes[e2], r = this.indexOfGroup(e2), o = r + n, s = r; s < o; s++) t += "".concat(this.tag.getRule(s)).concat(g$1);
    return t;
  }, e;
}(), me = 1 << 30, ye$1 = /* @__PURE__ */ new Map(), ve = /* @__PURE__ */ new Map(), ge$1 = 1, Se = function(e) {
  if (ye$1.has(e)) return ye$1.get(e);
  for (; ve.has(ge$1); ) ge$1++;
  var t = ge$1++;
  if (process.env.NODE_ENV !== "production" && ((0 | t) < 0 || t > me)) throw he(16, "".concat(t));
  return ye$1.set(e, t), ve.set(t, e), t;
}, we = function(e, t) {
  ge$1 = t + 1, ye$1.set(e, t), ve.set(t, e);
}, be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]'), Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)')), Ne = function(e, t, n) {
  for (var r, o = n.split(","), s = 0, i = o.length; s < i; s++) (r = o[s]) && e.registerName(t, r);
}, Pe = function(e, t) {
  for (var n, r = ((n = t.textContent) !== null && n !== void 0 ? n : "").split(g$1), o = [], s = 0, i = r.length; s < i; s++) {
    var a = r[s].trim();
    if (a) {
      var c = a.match(Ee);
      if (c) {
        var l2 = 0 | parseInt(c[1], 10), u = c[2];
        l2 !== 0 && (we(u, l2), Ne(e, u, c[3]), e.getTag().insertRules(l2, o)), o.length = 0;
      } else o.push(a);
    }
  }
}, _e = function(e) {
  for (var t = document.querySelectorAll(be), n = 0, r = t.length; n < r; n++) {
    var o = t[n];
    o && o.getAttribute(f) !== m && (Pe(e, o), o.parentNode && o.parentNode.removeChild(o));
  }
};
function Ce() {
  return typeof __webpack_nonce__ < "u" ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t = document.head, n = e || t, r = document.createElement("style"), o = function(e2) {
    var t2 = Array.from(e2.querySelectorAll("style[".concat(f, "]")));
    return t2[t2.length - 1];
  }(n), s = o !== void 0 ? o.nextSibling : null;
  r.setAttribute(f, m), r.setAttribute(y, v);
  var i = Ce();
  return i && r.setAttribute("nonce", i), n.insertBefore(r, s), r;
}, Ae = function() {
  function e(e2) {
    this.element = Ie(e2), this.element.appendChild(document.createTextNode("")), this.sheet = function(e3) {
      if (e3.sheet) return e3.sheet;
      for (var t = document.styleSheets, n = 0, r = t.length; n < r; n++) {
        var o = t[n];
        if (o.ownerNode === e3) return o;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    try {
      return this.sheet.insertRule(t, e2), this.length++, !0;
    } catch {
      return !1;
    }
  }, e.prototype.deleteRule = function(e2) {
    this.sheet.deleteRule(e2), this.length--;
  }, e.prototype.getRule = function(e2) {
    var t = this.sheet.cssRules[e2];
    return t && t.cssText ? t.cssText : "";
  }, e;
}(), Oe = function() {
  function e(e2) {
    this.element = Ie(e2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    if (e2 <= this.length && e2 >= 0) {
      var n = document.createTextNode(t);
      return this.element.insertBefore(n, this.nodes[e2] || null), this.length++, !0;
    }
    return !1;
  }, e.prototype.deleteRule = function(e2) {
    this.element.removeChild(this.nodes[e2]), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.nodes[e2].textContent : "";
  }, e;
}(), De = function() {
  function e(e2) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    return e2 <= this.length && (this.rules.splice(e2, 0, t), this.length++, !0);
  }, e.prototype.deleteRule = function(e2) {
    this.rules.splice(e2, 1), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.rules[e2] : "";
  }, e;
}(), Re$1 = S, Te = { isServer: !S, useCSSOMInjection: !w }, ke = function() {
  function e(e2, n, r) {
    e2 === void 0 && (e2 = C), n === void 0 && (n = {});
    var o = this;
    this.options = __assign(__assign({}, Te), e2), this.gs = n, this.names = new Map(r), this.server = !!e2.isServer, !this.server && S && Re$1 && (Re$1 = !1, _e(this)), ue(this, function() {
      return function(e3) {
        for (var t = e3.getTag(), n2 = t.length, r2 = "", o2 = function(n3) {
          var o3 = function(e4) {
            return ve.get(e4);
          }(n3);
          if (o3 === void 0) return "continue";
          var s2 = e3.names.get(o3), i = t.getGroup(n3);
          if (s2 === void 0 || !s2.size || i.length === 0) return "continue";
          var a = "".concat(f, ".g").concat(n3, '[id="').concat(o3, '"]'), c = "";
          s2 !== void 0 && s2.forEach(function(e4) {
            e4.length > 0 && (c += "".concat(e4, ","));
          }), r2 += "".concat(i).concat(a, '{content:"').concat(c, '"}').concat(g$1);
        }, s = 0; s < n2; s++) o2(s);
        return r2;
      }(o);
    });
  }
  return e.registerId = function(e2) {
    return Se(e2);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, r) {
    return r === void 0 && (r = !0), new e(__assign(__assign({}, this.options), n), this.gs, r && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(e2) {
    return this.gs[e2] = (this.gs[e2] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e2 = function(e3) {
      var t = e3.useCSSOMInjection, n = e3.target;
      return e3.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e2)));
    var e2;
  }, e.prototype.hasNameForId = function(e2, t) {
    return this.names.has(e2) && this.names.get(e2).has(t);
  }, e.prototype.registerName = function(e2, t) {
    if (Se(e2), this.names.has(e2)) this.names.get(e2).add(t);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(t), this.names.set(e2, n);
    }
  }, e.prototype.insertRules = function(e2, t, n) {
    this.registerName(e2, t), this.getTag().insertRules(Se(e2), n);
  }, e.prototype.clearNames = function(e2) {
    this.names.has(e2) && this.names.get(e2).clear();
  }, e.prototype.clearRules = function(e2) {
    this.getTag().clearGroup(Se(e2)), this.clearNames(e2);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}(), je = /&/g, xe = /^\s*\/\/.*$/gm;
function Ve(e, t) {
  return e.map(function(e2) {
    return e2.type === "rule" && (e2.value = "".concat(t, " ").concat(e2.value), e2.value = e2.value.replaceAll(",", ",".concat(t, " ")), e2.props = e2.props.map(function(e3) {
      return "".concat(t, " ").concat(e3);
    })), Array.isArray(e2.children) && e2.type !== "@keyframes" && (e2.children = Ve(e2.children, t)), e2;
  });
}
function Fe(e) {
  var t, n, r, o = C, s = o.options, i = s === void 0 ? C : s, a = o.plugins, c = a === void 0 ? _ : a, l2 = function(e2, r2, o2) {
    return o2.startsWith(n) && o2.endsWith(n) && o2.replaceAll(n, "").length > 0 ? ".".concat(t) : e2;
  }, u = c.slice();
  u.push(function(e2) {
    e2.type === RULESET && e2.value.includes("&") && (e2.props[0] = e2.props[0].replace(je, n).replace(r, l2));
  }), i.prefix && u.push(prefixer), u.push(stringify$3);
  var p = function(e2, o2, s2, a2) {
    o2 === void 0 && (o2 = ""), s2 === void 0 && (s2 = ""), a2 === void 0 && (a2 = "&"), t = a2, n = o2, r = new RegExp("\\".concat(n, "\\b"), "g");
    var c2 = e2.replace(xe, ""), l3 = compile(s2 || o2 ? "".concat(s2, " ").concat(o2, " { ").concat(c2, " }") : c2);
    i.namespace && (l3 = Ve(l3, i.namespace));
    var p2 = [];
    return serialize(l3, middleware(u.concat(rulesheet(function(e3) {
      return p2.push(e3);
    })))), p2;
  };
  return p.hash = c.length ? c.reduce(function(e2, t2) {
    return t2.name || he(15), M(e2, t2.name);
  }, F).toString() : "", p;
}
var Me = new ke(), ze = Fe(), $e = React__default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
React__default.createContext(void 0);
function Ge() {
  return useContext($e);
}
var qe = function() {
  function e(e2, t) {
    var n = this;
    this.inject = function(e3, t2) {
      t2 === void 0 && (t2 = ze);
      var r = n.name + t2.hash;
      e3.hasNameForId(n.id, r) || e3.insertRules(n.id, r, t2(n.rules, r, "@keyframes"));
    }, this.name = e2, this.id = "sc-keyframes-".concat(e2), this.rules = t, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e2) {
    return e2 === void 0 && (e2 = ze), this.name + e2.hash;
  }, e;
}(), We = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var r = e[n];
    if (n === 1 && r === "-" && e[0] === "-") return e;
    We(r) ? t += "-" + r.toLowerCase() : t += r;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var Ue = function(e) {
  return e == null || e === !1 || e === "";
}, Je = function(t) {
  var n, r, o = [];
  for (var s in t) {
    var i = t[s];
    t.hasOwnProperty(s) && !Ue(i) && (Array.isArray(i) && i.isCss || oe(i) ? o.push("".concat(He(s), ":"), i, ";") : ce(i) ? o.push.apply(o, __spreadArray(__spreadArray(["".concat(s, " {")], Je(i), !1), ["}"], !1)) : o.push("".concat(He(s), ": ").concat((n = s, (r = i) == null || typeof r == "boolean" || r === "" ? "" : typeof r != "number" || r === 0 || n in unitlessKeys || n.startsWith("--") ? String(r).trim() : "".concat(r, "px")), ";")));
  }
  return o;
};
function Xe(e, t, n, r) {
  if (Ue(e)) return [];
  if (se(e)) return [".".concat(e.styledComponentId)];
  if (oe(e)) {
    if (!oe(s = e) || s.prototype && s.prototype.isReactComponent || !t) return [e];
    var o = e(t);
    return process.env.NODE_ENV === "production" || typeof o != "object" || Array.isArray(o) || o instanceof qe || ce(o) || o === null || console.error("".concat(B(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(o, t, n, r);
  }
  var s;
  return e instanceof qe ? n ? (e.inject(n, r), [e.getName(r)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e2) {
    return Xe(e2, t, n, r);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (oe(n) && !se(n)) return !1;
  }
  return !0;
}
var Ke = z(v), Qe = function() {
  function e(e2, t, n) {
    this.rules = e2, this.staticRulesId = "", this.isStatic = process.env.NODE_ENV === "production" && (n === void 0 || n.isStatic) && Ze(e2), this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(e2, t, n) {
    var r = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e2, t, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) r = ie(r, this.staticRulesId);
    else {
      var o = ae(Xe(this.rules, e2, t, n)), s = x(M(this.baseHash, o) >>> 0);
      if (!t.hasNameForId(this.componentId, s)) {
        var i = n(o, ".".concat(s), void 0, this.componentId);
        t.insertRules(this.componentId, s, i);
      }
      r = ie(r, s), this.staticRulesId = s;
    }
    else {
      for (var a = M(this.baseHash, n.hash), c = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u = this.rules[l2];
        if (typeof u == "string") c += u, process.env.NODE_ENV !== "production" && (a = M(a, u));
        else if (u) {
          var p = ae(Xe(u, e2, t, n));
          a = M(a, p + l2), c += p;
        }
      }
      if (c) {
        var d = x(a >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c, ".".concat(d), void 0, this.componentId)), r = ie(r, d);
      }
    }
    return r;
  }, e;
}(), et$1 = React__default.createContext(void 0);
function nt() {
  var e = useContext(et$1);
  if (!e) throw he(18);
  return e;
}
function rt(e) {
  var n = React__default.useContext(et$1), o = useMemo(function() {
    return function(e2, n2) {
      if (!e2) throw he(14);
      if (oe(e2)) {
        var r = e2(n2);
        if (process.env.NODE_ENV !== "production" && (r === null || Array.isArray(r) || typeof r != "object")) throw he(7);
        return r;
      }
      if (Array.isArray(e2) || typeof e2 != "object") throw he(8);
      return n2 ? __assign(__assign({}, n2), e2) : e2;
    }(e.theme, n);
  }, [e.theme, n]);
  return e.children ? React__default.createElement(et$1.Provider, { value: o }, e.children) : null;
}
var ot = {}, st = /* @__PURE__ */ new Set();
function it$1(e, o, s) {
  var i = se(e), a = e, c = !L$1(e), p = o.attrs, d = p === void 0 ? _ : p, h2 = o.componentId, f2 = h2 === void 0 ? function(e2, t) {
    var n = typeof e2 != "string" ? "sc" : R(e2);
    ot[n] = (ot[n] || 0) + 1;
    var r = "".concat(n, "-").concat($(v + n + ot[n]));
    return t ? "".concat(t, "-").concat(r) : r;
  }(o.displayName, o.parentComponentId) : h2, m2 = o.displayName, y2 = m2 === void 0 ? function(e2) {
    return L$1(e2) ? "styled.".concat(e2) : "Styled(".concat(B(e2), ")");
  }(e) : m2, g2 = o.displayName && o.componentId ? "".concat(R(o.displayName), "-").concat(o.componentId) : o.componentId || f2, S2 = i && a.attrs ? a.attrs.concat(d).filter(Boolean) : d, w2 = o.shouldForwardProp;
  if (i && a.shouldForwardProp) {
    var b = a.shouldForwardProp;
    if (o.shouldForwardProp) {
      var E2 = o.shouldForwardProp;
      w2 = function(e2, t) {
        return b(e2, t) && E2(e2, t);
      };
    } else w2 = b;
  }
  var N2 = new Qe(s, g2, i ? a.componentStyle : void 0);
  function O2(e2, o2) {
    return function(e3, o3, s2) {
      var i2 = e3.attrs, a2 = e3.componentStyle, c2 = e3.defaultProps, p2 = e3.foldedComponentIds, d2 = e3.styledComponentId, h3 = e3.target, f3 = React__default.useContext(et$1), m3 = Ge(), y3 = e3.shouldForwardProp || m3.shouldForwardProp;
      process.env.NODE_ENV !== "production" && useDebugValue(d2);
      var v2 = I(o3, f3, c2) || C, g3 = function(e4, n, r) {
        for (var o4, s3 = __assign(__assign({}, n), { className: void 0, theme: r }), i3 = 0; i3 < e4.length; i3 += 1) {
          var a3 = oe(o4 = e4[i3]) ? o4(s3) : o4;
          for (var c3 in a3) s3[c3] = c3 === "className" ? ie(s3[c3], a3[c3]) : c3 === "style" ? __assign(__assign({}, s3[c3]), a3[c3]) : a3[c3];
        }
        return n.className && (s3.className = ie(s3.className, n.className)), s3;
      }(i2, o3, v2), S3 = g3.as || h3, w3 = {};
      for (var b2 in g3) g3[b2] === void 0 || b2[0] === "$" || b2 === "as" || b2 === "theme" && g3.theme === v2 || (b2 === "forwardedAs" ? w3.as = g3.forwardedAs : y3 && !y3(b2, S3) || (w3[b2] = g3[b2], y3 || process.env.NODE_ENV !== "development" || isPropValid(b2) || st.has(b2) || !A.has(S3) || (st.add(b2), console.warn('styled-components: it looks like an unknown prop "'.concat(b2, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E3 = function(e4, t) {
        var n = Ge(), r = e4.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return process.env.NODE_ENV !== "production" && useDebugValue(r), r;
      }(a2, g3);
      process.env.NODE_ENV !== "production" && e3.warnTooManyClasses && e3.warnTooManyClasses(E3);
      var N3 = ie(p2, d2);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L$1(S3) && !A.has(S3) ? "class" : "className"] = N3, w3.ref = s2, createElement(S3, w3);
    }(D2, e2, o2);
  }
  O2.displayName = y2;
  var D2 = React__default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i ? ie(a.foldedComponentIds, a.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i ? a.target : e, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e2) {
    this._foldedDefaultProps = i ? function(e3) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      for (var r = 0, o2 = t; r < o2.length; r++) le$1(e3, o2[r], !0);
      return e3;
    }({}, a.defaultProps, e2) : e2;
  } }), process.env.NODE_ENV !== "production" && (P(y2, g2), D2.warnTooManyClasses = /* @__PURE__ */ function(e2, t) {
    var n = {}, r = !1;
    return function(o2) {
      if (!r && (n[o2] = !0, Object.keys(n).length >= 200)) {
        var s2 = t ? ' with the id of "'.concat(t, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e2).concat(s2, `.
`) + `Consider using the attrs method, together with a style object for frequently changed styles.
Example:
  const Component = styled.div.attrs(props => ({
    style: {
      background: props.background,
    },
  }))\`width: 100%;\`

  <Component />`), r = !0, n = {};
      }
    };
  }(y2, g2)), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c && re$1(D2, e, { attrs: !0, componentStyle: !0, displayName: !0, foldedComponentIds: !0, shouldForwardProp: !0, styledComponentId: !0, target: !0 }), D2;
}
function at(e, t) {
  for (var n = [e[0]], r = 0, o = t.length; r < o; r += 1) n.push(t[r], e[r + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: !0 });
};
function lt$2(t) {
  for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
  if (oe(t) || ce(t)) return ct(Xe(at(_, __spreadArray([t], n, !0))));
  var o = t;
  return n.length === 0 && o.length === 1 && typeof o[0] == "string" ? Xe(o) : ct(Xe(at(o, n)));
}
function ut(n, r, o) {
  if (o === void 0 && (o = C), !r) throw he(1, r);
  var s = function(t) {
    for (var s2 = [], i = 1; i < arguments.length; i++) s2[i - 1] = arguments[i];
    return n(r, o, lt$2.apply(void 0, __spreadArray([t], s2, !1)));
  };
  return s.attrs = function(e) {
    return ut(n, r, __assign(__assign({}, o), { attrs: Array.prototype.concat(o.attrs, e).filter(Boolean) }));
  }, s.withConfig = function(e) {
    return ut(n, r, __assign(__assign({}, o), e));
  }, s;
}
var pt = function(e) {
  return ut(it$1, e);
}, dt = pt;
A.forEach(function(e) {
  dt[e] = pt(e);
});
function mt(t) {
  for (var n = [], r = 1; r < arguments.length; r++) n[r - 1] = arguments[r];
  process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var o = ae(lt$2.apply(void 0, __spreadArray([t], n, !1))), s = $(o);
  return new qe(s, o);
}
process.env.NODE_ENV !== "production" && typeof navigator < "u" && navigator.product === "ReactNative" && console.warn(`It looks like you've imported 'styled-components' on React Native.
Perhaps you're looking to import 'styled-components/native'?
Read more about this at https://www.styled-components.com/docs/basics#react-native`);
var wt = "__sc-".concat(f, "__");
process.env.NODE_ENV !== "production" && process.env.NODE_ENV !== "test" && typeof window < "u" && (window[wt] || (window[wt] = 0), window[wt] === 1 && console.warn(`It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.

See https://s-c.sh/2BAXzed for more info.`), window[wt] += 1);
const AccessDeniedIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "access-denied",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.1568 6.84315C21.281 9.96734 21.281 15.0327 18.1568 18.1569C15.0326 21.281 9.96733 21.281 6.84313 18.1569C3.71894 15.0327 3.71894 9.96734 6.84313 6.84315C9.96733 3.71895 15.0326 3.71895 18.1568 6.84315ZM18.1568 6.84315L6.844 18.156",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
AccessDeniedIcon.displayName = "ForwardRef(AccessDeniedIcon)";
const ActivityIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "activity",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M21 15H19L15.5 7L11 18L8 12L6 15H4",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ActivityIcon.displayName = "ForwardRef(ActivityIcon)";
const AddCircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "add-circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 12.4H17M12.5 8V17M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
AddCircleIcon.displayName = "ForwardRef(AddCircleIcon)";
const AddCommentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "add-comment",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M13 6.5H7.5C6.39543 6.5 5.5 7.39543 5.5 8.5V14.5C5.5 15.6046 6.39543 16.5 7.5 16.5H9.5V20.5L13.5 16.5H16.5C17.6046 16.5 18.5 15.6046 18.5 14.5V12M15 6.5H22M18.5 10V3",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
AddCommentIcon.displayName = "ForwardRef(AddCommentIcon)";
const AddDocumentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "add-document",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 4.5H18.5V12M11.5 4.5L6.5 9.5M11.5 4.5V9.5H6.5M6.5 9.5V19.5H11M20 17.5H16.5M16.5 17.5H13M16.5 17.5V14M16.5 17.5V21",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
AddDocumentIcon.displayName = "ForwardRef(AddDocumentIcon)";
const AddIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "add",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 5V20M5 12.5H20",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
AddIcon.displayName = "ForwardRef(AddIcon)";
const ApiIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "api",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.93047 13.2107L6.66782 10.3728H6.73089L7.45854 13.2107H5.93047ZM8.17164 16H9.66089L7.56041 9H5.93047L3.82999 16H5.20767L5.65396 14.2876H7.73505L8.17164 16Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10.5389 9V16H11.9166V13.7782H13.0323C14.541 13.7782 15.5015 12.8517 15.5015 11.3964C15.5015 9.92654 14.5701 9 13.1003 9H10.5389ZM11.9166 10.1303H12.751C13.6533 10.1303 14.1044 10.5475 14.1044 11.3867C14.1044 12.2308 13.6533 12.6431 12.751 12.6431H11.9166V10.1303Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M21.1675 16V14.8164H19.717V10.1836H21.1675V9H16.8889V10.1836H18.3393V14.8164H16.8889V16H21.1675Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
ApiIcon.displayName = "ForwardRef(ApiIcon)";
const ArchiveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "archive",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 10V17M20.5 7.5V20.5H4.5V7.5L7.5 4.5H17.5L20.5 7.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.5 7.5H20.5M16 14L12.5 17.5L9 14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ArchiveIcon.displayName = "ForwardRef(ArchiveIcon)";
const ArrowDownIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "arrow-down",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M12.5 19.5V5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M18 14L12.5 19.5L7 14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ArrowDownIcon.displayName = "ForwardRef(ArrowDownIcon)";
const ArrowLeftIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "arrow-left",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M5.5 12.5H20", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11 18L5.5 12.5L11 7",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ArrowLeftIcon.displayName = "ForwardRef(ArrowLeftIcon)";
const ArrowRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "arrow-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M19.5 12.5H5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 7L19.5 12.5L14 18",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ArrowRightIcon.displayName = "ForwardRef(ArrowRightIcon)";
const ArrowTopRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "arrow-top-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M16.5 8.5L7 18", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx("path", { d: "M9 8.5H16.5V16", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
ArrowTopRightIcon.displayName = "ForwardRef(ArrowTopRightIcon)";
const ArrowUpIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "arrow-up",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7 11L12.5 5.5L18 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M12.5 5.5V20", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
ArrowUpIcon.displayName = "ForwardRef(ArrowUpIcon)";
const AsteriskIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "asterisk",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 4V21M16.75 5.13879L8.25 19.8612M19.8612 8.25L5.13878 16.75M4.00002 12.5H21M5.13881 8.25L19.8612 16.75M8.25002 5.13879L16.75 19.8612",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
AsteriskIcon.displayName = "ForwardRef(AsteriskIcon)";
const BarChartIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bar-chart",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 5V19.5H20M8.5 18V13M11.5 18V9M14.5 18V11M17.5 18V7",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BarChartIcon.displayName = "ForwardRef(BarChartIcon)";
const BasketIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "basket",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8.5 10.5H5L6.5 19.5H18.5L20 10.5H16.5M8.5 10.5L10.2721 5.18377C10.4082 4.77543 10.7903 4.5 11.2208 4.5H13.7792C14.2097 4.5 14.5918 4.77543 14.7279 5.18377L16.5 10.5M8.5 10.5H16.5M8.5 10.5L9.5 19.5M16.5 10.5L15.5 19.5M12.5 10.5V19.5M19.5 13.5H5.5M19 16.5H6",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BasketIcon.displayName = "ForwardRef(BasketIcon)";
const BellIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bell",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 17.5V18.5C10.5 20 11.5 20.5 12.5 20.5C13.5 20.5 14.5 20 14.5 18.5V17.5M5.5 17.5C6.5 16 6.5 15 6.5 12C6.5 8 8.5 5.5 12.5 5.5C16.5 5.5 18.5 8 18.5 12C18.5 15 18.5 16 19.5 17.5H5.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BellIcon.displayName = "ForwardRef(BellIcon)";
const BillIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bill",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M6.50001 5.5C8.50003 5.5 8.50003 8 8.50003 8V9.5M6.50001 5.5C4.5 5.5 4.5 8 4.5 8L4.50001 9.5H8.50003M6.50001 5.5C6.50001 5.5 15.8333 5.5 17.6667 5.5C19.5 5.5 19.5 8.5 19.5 8.5V20L17.6667 19L15.8333 20L14 19L12.1667 20L10.3334 19L8.50003 20V9.5M11 12.5H15M11 9.5H16M11 15.5H16",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BillIcon.displayName = "ForwardRef(BillIcon)";
const BinaryDocumentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "binary-document",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.5 12.5V17.5M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5ZM12.5 12.5V17.5H15.5V12.5H12.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinecap: "square",
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
BinaryDocumentIcon.displayName = "ForwardRef(BinaryDocumentIcon)";
const BlockContentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "block-content",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M21 7.60002L11 7.60003V6.40003L21 6.40002V7.60002Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M21 11.2667L12.4833 11.2667V10.0667L21 10.0667V11.2667Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M21 14.9334H13.9254V13.7334L21 13.7334V14.9334Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M21 18.6002H4V17.4002H21V18.6002Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.86438 15.6H11.2L8.27623 7.60003H6.92377L4 15.6H5.29072L6.0371 13.4767H9.12362L9.86438 15.6ZM7.53546 9.05255H7.63086L8.80374 12.4344H6.35698L7.53546 9.05255Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
BlockContentIcon.displayName = "ForwardRef(BlockContentIcon)";
const BlockElementIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "block-element",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5 19.5H20M5 5.5H20M6.5 8.5H18.5V16.5H6.5V8.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BlockElementIcon.displayName = "ForwardRef(BlockElementIcon)";
const BlockquoteIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "blockquote",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10 17.5H19M6 7.5H19M10 12.5H17M6.5 12V18",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BlockquoteIcon.displayName = "ForwardRef(BlockquoteIcon)";
const BoldIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bold",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M13.2087 18C15.5322 18 16.9731 16.793 16.9731 14.8844C16.9731 13.4812 15.9245 12.3949 14.4836 12.2892V12.1534C15.6001 11.9875 16.4526 10.9841 16.4526 9.82991C16.4526 8.14761 15.1927 7.11409 13.0804 7.11409H8.32019V18H13.2087ZM10.5985 8.85674H12.4995C13.5859 8.85674 14.212 9.37727 14.212 10.2448C14.212 11.1199 13.5406 11.6254 12.3109 11.6254H10.5985V8.85674ZM10.5985 16.2574V13.1643H12.575C13.9178 13.1643 14.6496 13.6924 14.6496 14.6882C14.6496 15.7066 13.9404 16.2574 12.6278 16.2574H10.5985Z",
          fill: "currentColor"
        }
      )
    }
  );
});
BoldIcon.displayName = "ForwardRef(BoldIcon)";
const BoltIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bolt",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18 11.5L9 21L11 13.5H7L16 4L14 11.5H18Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BoltIcon.displayName = "ForwardRef(BoltIcon)";
const BookIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "book",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M20.5 17.5V5.5L12.5 6.5M20.5 17.5L12.5 18.5M20.5 17.5V18.5M4.5 17.5V5.5L12.5 6.5M4.5 17.5L12.5 18.5M4.5 17.5V18.5M12.5 18.5L4.5 19.5V18.5M12.5 18.5L20.5 19.5V18.5M12.5 18.5V6.5M12.5 18.5H4.5M12.5 18.5H20.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BookIcon.displayName = "ForwardRef(BookIcon)";
const BottleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bottle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.5 17.5L17.5 17.5M17.5 13C17.5 12.087 17.5 11.3518 17.5 11C17.5 8.5 14.5 9 14.5 7.37494L14.5 5.5M17.5 13C17.5 15.1229 17.5 18.7543 17.5 20.5022C17.5 21.0545 17.0523 21.5 16.5 21.5L8.5 21.5C7.94772 21.5 7.5 21.0547 7.5 20.5024C7.5 18.8157 7.5 15.3546 7.5 13M17.5 13L7.5 13M7.5 13C7.5 12.2538 7.5 11.5648 7.5 11C7.5 8.5 10.5 9 10.5 7.37494L10.5 5.5M10.5 5.5L10.5 3.99999C10.5 3.72385 10.7239 3.49999 11 3.49999L14 3.49999C14.2761 3.49999 14.5 3.72385 14.5 3.99999L14.5 5.5M10.5 5.5L14.5 5.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
BottleIcon.displayName = "ForwardRef(BottleIcon)";
const BulbFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "bulb-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M16.4272 14.3368C15.8273 15.1773 15.5 16.1794 15.5 17.212V18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H14V20.5C14 21.0523 13.5523 21.5 13 21.5H12C11.4477 21.5 11 21.0523 11 20.5V19.5H10.5C9.94772 19.5 9.5 19.0523 9.5 18.5V17.212C9.5 16.1794 9.17266 15.1773 8.57284 14.3368C7.60216 12.9767 7 11.94 7 10C7 7 9.5 4.5 12.5 4.5C15.5 4.5 18 7 18 10C18 11.94 17.3978 12.9767 16.4272 14.3368Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.4272 14.3368L15.9388 13.9883L15.9388 13.9883L16.4272 14.3368ZM14 19.5V18.9H13.4V19.5H14ZM11 19.5H11.6V18.9H11V19.5ZM8.57284 14.3368L9.06122 13.9883L9.06122 13.9883L8.57284 14.3368ZM16.1 17.212C16.1 16.3069 16.3868 15.4261 16.9155 14.6853L15.9388 13.9883C15.2678 14.9284 14.9 16.0519 14.9 17.212H16.1ZM16.1 18.5V17.212H14.9V18.5H16.1ZM14.5 20.1C15.3837 20.1 16.1 19.3837 16.1 18.5H14.9C14.9 18.7209 14.7209 18.9 14.5 18.9V20.1ZM14 20.1H14.5V18.9H14V20.1ZM13.4 19.5V20.5H14.6V19.5H13.4ZM13.4 20.5C13.4 20.7209 13.2209 20.9 13 20.9V22.1C13.8837 22.1 14.6 21.3837 14.6 20.5H13.4ZM13 20.9H12V22.1H13V20.9ZM12 20.9C11.7791 20.9 11.6 20.7209 11.6 20.5H10.4C10.4 21.3837 11.1163 22.1 12 22.1V20.9ZM11.6 20.5V19.5H10.4V20.5H11.6ZM10.5 20.1H11V18.9H10.5V20.1ZM8.9 18.5C8.9 19.3837 9.61634 20.1 10.5 20.1V18.9C10.2791 18.9 10.1 18.7209 10.1 18.5H8.9ZM8.9 17.212V18.5H10.1V17.212H8.9ZM8.08446 14.6853C8.61315 15.4261 8.9 16.3069 8.9 17.212H10.1C10.1 16.0519 9.73217 14.9284 9.06122 13.9883L8.08446 14.6853ZM6.4 10C6.4 11.0377 6.56208 11.8595 6.86624 12.611C7.16624 13.3521 7.59495 13.9995 8.08446 14.6853L9.06122 13.9883C8.58004 13.314 8.22233 12.7629 7.97858 12.1607C7.739 11.5688 7.6 10.9023 7.6 10H6.4ZM12.5 3.9C9.16863 3.9 6.4 6.66863 6.4 10H7.6C7.6 7.33137 9.83137 5.1 12.5 5.1V3.9ZM18.6 10C18.6 6.66863 15.8314 3.9 12.5 3.9V5.1C15.1686 5.1 17.4 7.33137 17.4 10H18.6ZM16.9155 14.6853C17.4051 13.9995 17.8338 13.3521 18.1338 12.611C18.4379 11.8595 18.6 11.0377 18.6 10H17.4C17.4 10.9023 17.261 11.5688 17.0214 12.1607C16.7777 12.7629 16.42 13.314 15.9388 13.9883L16.9155 14.6853Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
BulbFilledIcon.displayName = "ForwardRef(BulbFilledIcon)";
const BulbOutlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "bulb-outline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 16.5H15.5M11 20V20.5C11 21.0523 11.4477 21.5 12 21.5H13C13.5523 21.5 14 21.0523 14 20.5V20M18 10C18 11.94 17.3978 12.9767 16.4272 14.3368C15.8273 15.1773 15.5 16.1794 15.5 17.212V18.5C15.5 19.0523 15.0523 19.5 14.5 19.5H10.5C9.94772 19.5 9.5 19.0523 9.5 18.5V17.212C9.5 16.1794 9.17266 15.1773 8.57284 14.3368C7.60216 12.9767 7 11.94 7 10C7 7 9.5 4.5 12.5 4.5C15.5 4.5 18 7 18 10Z",
          stroke: "currentColor",
          strokeWidth: 1.2
        }
      )
    }
  );
});
BulbOutlineIcon.displayName = "ForwardRef(BulbOutlineIcon)";
const CalendarIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "calendar",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.5 10.5V19.5H20.5V10.5M4.5 10.5V5.5H20.5V10.5M4.5 10.5H12.5H20.5M20.5 13.5H16.5M16.5 13.5H12.5M16.5 13.5V10.5M16.5 13.5V16.5M12.5 13.5H8.5M12.5 13.5V16.5M12.5 13.5V10.5M8.5 13.5H4.5M8.5 13.5V10.5M8.5 13.5V16.5M20.5 16.5H16.5M16.5 16.5H12.5M16.5 16.5V19.5M12.5 16.5H8.5M12.5 16.5V19.5M8.5 16.5H4.5M8.5 16.5V19.5M17.5 8V3M7.5 8V3",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CalendarIcon.displayName = "ForwardRef(CalendarIcon)";
const CaseIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "case",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9 8.5122V6C9 5.44772 9.44772 5 10 5H15C15.5523 5 16 5.44772 16 6V8.5122M4.5 12V18.5C4.5 19.0523 4.94772 19.5 5.5 19.5H19.5C20.0523 19.5 20.5 19.0523 20.5 18.5V12M4.5 12V9.5122C4.5 8.95991 4.94772 8.5122 5.5 8.5122H19.5C20.0523 8.5122 20.5 8.95991 20.5 9.5122V12M4.5 12L11.7978 14.7367C12.2505 14.9064 12.7495 14.9064 13.2022 14.7367L20.5 12",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CaseIcon.displayName = "ForwardRef(CaseIcon)";
const ChartUpwardIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "chart-upward",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 5V19.5H20M7.5 16L11.5 11.5L15.5 14L19.5 8.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ChartUpwardIcon.displayName = "ForwardRef(ChartUpwardIcon)";
const CheckmarkCircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "checkmark-circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 12.1316L11.7414 14.5L16 10M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CheckmarkCircleIcon.displayName = "ForwardRef(CheckmarkCircleIcon)";
const CheckmarkIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "checkmark",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 11.5L10.5 16.5L19.5 7.60001",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CheckmarkIcon.displayName = "ForwardRef(CheckmarkIcon)";
const ChevronDownIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "chevron-down",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17 10.5L12.5 15L8 10.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ChevronDownIcon.displayName = "ForwardRef(ChevronDownIcon)";
const ChevronLeftIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "chevron-left",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M14.5 17L10 12.5L14.5 8",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ChevronLeftIcon.displayName = "ForwardRef(ChevronLeftIcon)";
const ChevronRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "chevron-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 8L15 12.5L10.5 17",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ChevronRightIcon.displayName = "ForwardRef(ChevronRightIcon)";
const ChevronUpIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "chevron-up",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 14.5L12.5 10L17 14.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ChevronUpIcon.displayName = "ForwardRef(ChevronUpIcon)";
const CircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "circle",
        {
          cx: 12.5,
          cy: 12.5,
          r: 8,
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CircleIcon.displayName = "ForwardRef(CircleIcon)";
const ClipboardIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "clipboard",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 5.5H6.5V19.5H18.5V5.5H17M12.5 3C11.5 3 11.5 4.5 11 4.5C10 4.5 9.5 5 9.5 6.5H15.6C15.6 5 15 4.5 14 4.5C13.5 4.5 13.5 3 12.5 3Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ClipboardIcon.displayName = "ForwardRef(ClipboardIcon)";
const ClipboardImageIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "clipboard-image",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 5.5H6.5V19.5H10.5M17 5.5H18.5V11.5M10.5 18.5L12.73 15.8983C13.1327 15.4285 13.8613 15.4335 14.2575 15.909L15.299 17.1588C15.6754 17.6105 16.3585 17.6415 16.7743 17.2257L16.9903 17.0097C17.2947 16.7053 17.7597 16.6298 18.1447 16.8223L20.5 18M10.5 11.5H20.5V21.5H10.5V11.5ZM12.5 3C11.5 3 11.5 4.5 11 4.5C10 4.5 9.5 5 9.5 6.5H15.6C15.6 5 15 4.5 14 4.5C13.5 4.5 13.5 3 12.5 3Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ClipboardImageIcon.displayName = "ForwardRef(ClipboardImageIcon)";
const ClockIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "clock",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 8V12.5L15.5 15.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ClockIcon.displayName = "ForwardRef(ClockIcon)";
const CloseCircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "close-circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 15.5L12.5 12.5M12.5 12.5L15.5 9.5M12.5 12.5L9.5 9.5M12.5 12.5L15.5 15.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CloseCircleIcon.displayName = "ForwardRef(CloseCircleIcon)";
const CloseIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "close",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18 7L7 18M7 7L18 18",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CloseIcon.displayName = "ForwardRef(CloseIcon)";
const CodeBlockIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "code-block",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 15L8.5 12.5L11 10M14 10L16.5 12.5L14 15M5.5 6.5H19.5V18.5H5.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CodeBlockIcon.displayName = "ForwardRef(CodeBlockIcon)";
const CodeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "code",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 16L7.5 12.5L11 9M14 9L17.5 12.5L14 16",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CodeIcon.displayName = "ForwardRef(CodeIcon)";
const CogIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "cog",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14.2624 5.40607L13.8714 4.42848C13.6471 3.86771 13.104 3.5 12.5 3.5C11.896 3.5 11.3529 3.86771 11.1286 4.42848L10.7376 5.40607C10.5857 5.78585 10.2869 6.08826 9.90901 6.2448C9.53111 6.40133 9.10603 6.39874 8.73006 6.23761L7.76229 5.82285C7.20716 5.58494 6.56311 5.70897 6.13604 6.13604C5.70897 6.56311 5.58494 7.20716 5.82285 7.76229L6.23761 8.73006C6.39874 9.10602 6.40133 9.53111 6.2448 9.90901C6.08826 10.2869 5.78585 10.5857 5.40607 10.7376L4.42848 11.1286C3.86771 11.3529 3.5 11.896 3.5 12.5C3.5 13.104 3.86771 13.6471 4.42848 13.8714L5.40607 14.2624C5.78585 14.4143 6.08826 14.7131 6.2448 15.091C6.40133 15.4689 6.39874 15.894 6.23761 16.2699L5.82285 17.2377C5.58494 17.7928 5.70897 18.4369 6.13604 18.864C6.56311 19.291 7.20716 19.4151 7.76229 19.1772L8.73006 18.7624C9.10603 18.6013 9.53111 18.5987 9.90901 18.7552C10.2869 18.9117 10.5857 19.2141 10.7376 19.5939L11.1286 20.5715C11.3529 21.1323 11.896 21.5 12.5 21.5C13.104 21.5 13.6471 21.1323 13.8714 20.5715L14.2624 19.5939C14.4143 19.2141 14.7131 18.9117 15.091 18.7552C15.4689 18.5987 15.894 18.6013 16.2699 18.7624L17.2377 19.1771C17.7928 19.4151 18.4369 19.291 18.864 18.864C19.291 18.4369 19.4151 17.7928 19.1771 17.2377L18.7624 16.2699C18.6013 15.894 18.5987 15.4689 18.7552 15.091C18.9117 14.7131 19.2141 14.4143 19.5939 14.2624L20.5715 13.8714C21.1323 13.6471 21.5 13.104 21.5 12.5C21.5 11.896 21.1323 11.3529 20.5715 11.1286L19.5939 10.7376C19.2141 10.5857 18.9117 10.2869 18.7552 9.90901C18.5987 9.53111 18.6013 9.10602 18.7624 8.73006L19.1772 7.76229C19.4151 7.20716 19.291 6.56311 18.864 6.13604C18.4369 5.70897 17.7928 5.58494 17.2377 5.82285L16.2699 6.23761C15.894 6.39874 15.4689 6.40133 15.091 6.2448C14.7131 6.08826 14.4143 5.78585 14.2624 5.40607Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.5 12.5C16.5 14.7091 14.7091 16.5 12.5 16.5C10.2909 16.5 8.5 14.7091 8.5 12.5C8.5 10.2909 10.2909 8.5 12.5 8.5C14.7091 8.5 16.5 10.2909 16.5 12.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
CogIcon.displayName = "ForwardRef(CogIcon)";
const CollapseIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "collapse",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6 14.5L10.5 14.5V19M19 10.5H14.5L14.5 6",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10.5 14.5L6 19M14.5 10.5L19 6",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
CollapseIcon.displayName = "ForwardRef(CollapseIcon)";
const ColorWheelIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "color-wheel",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.43853 5.10896L11.1606 9.26642M13.8394 15.7336L15.5615 19.891M15.7336 11.1606L19.891 9.43853M9.26642 13.8394L5.10896 15.5615M5.3139 9.52342L9.23359 11.147M15.7664 13.853L19.6861 15.4766M13.853 9.23359L15.4766 5.3139M9.52342 19.6861L11.147 15.7664M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5ZM16 12.5C16 14.433 14.433 16 12.5 16C10.567 16 9 14.433 9 12.5C9 10.567 10.567 9 12.5 9C14.433 9 16 10.567 16 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ColorWheelIcon.displayName = "ForwardRef(ColorWheelIcon)";
const CommentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "comment",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.5 16.5H9.5V20.5L13.5 16.5H17.5C18.6046 16.5 19.5 15.6046 19.5 14.5V8.5C19.5 7.39543 18.6046 6.5 17.5 6.5H7.5C6.39543 6.5 5.5 7.39543 5.5 8.5V14.5C5.5 15.6046 6.39543 16.5 7.5 16.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CommentIcon.displayName = "ForwardRef(CommentIcon)";
const ComponentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "component",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8.5 8.5L12.5 12.5M12.5 12.5L16.5 16.5M12.5 12.5L16.5 8.5M12.5 12.5L8.5 16.5M12.5 4L21 12.5L12.5 21L4 12.5L12.5 4Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ComponentIcon.displayName = "ForwardRef(ComponentIcon)";
const ComposeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "compose",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17 6L19 8M14 5.5H5.5V19.5H19.5V11M9 16L9.5 13.5L19 4L21 6L11.5 15.5L9 16Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ComposeIcon.displayName = "ForwardRef(ComposeIcon)";
const ConfettiIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "confetti",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.5 6.25C16.9142 6.25 17.25 5.91421 17.25 5.5C17.25 5.08579 16.9142 4.75 16.5 4.75C16.0858 4.75 15.75 5.08579 15.75 5.5C15.75 5.91421 16.0858 6.25 16.5 6.25Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19.5 16.25C19.9142 16.25 20.25 15.9142 20.25 15.5C20.25 15.0858 19.9142 14.75 19.5 14.75C19.0858 14.75 18.75 15.0858 18.75 15.5C18.75 15.9142 19.0858 16.25 19.5 16.25Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M13 4C11 6 14.5 5.5 12.5 7.5M21 12C19 14 19.5 10.5 17.5 12.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.066 16.4904C15.3965 17.1598 13.1126 15.9613 10.9647 13.8135C8.81684 11.6656 7.61835 9.38165 8.28782 8.71218M16.066 16.4904C16.7355 15.8209 15.537 13.537 13.3891 11.3891C11.2412 9.2412 8.95729 8.04271 8.28782 8.71218M16.066 16.4904C15.8661 16.6902 15.6277 16.8474 15.3657 16.952L6.99288 20.296C6.26931 20.5849 5.44878 20.4193 4.9038 19.8744C4.35883 19.3294 4.19324 18.5089 4.48221 17.7853L7.82614 9.41242C7.93077 9.15042 8.08793 8.91208 8.28782 8.71218M20 5C20 14 11.5 5.32688 11.5 14.3269",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ConfettiIcon.displayName = "ForwardRef(ConfettiIcon)";
const ControlsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "controls",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M6.5 5V7.5M6.5 7.5C5.39543 7.5 4.5 8.39543 4.5 9.5C4.5 10.6046 5.39543 11.5 6.5 11.5M6.5 7.5C7.60457 7.5 8.5 8.39543 8.5 9.5C8.5 10.6046 7.60457 11.5 6.5 11.5M6.5 11.5V20M12.5 5V13.5M12.5 13.5C11.3954 13.5 10.5 14.3954 10.5 15.5C10.5 16.6046 11.3954 17.5 12.5 17.5M12.5 13.5C13.6046 13.5 14.5 14.3954 14.5 15.5C14.5 16.6046 13.6046 17.5 12.5 17.5M12.5 17.5V20M18.5 5V7.5M18.5 7.5C17.3954 7.5 16.5 8.39543 16.5 9.5C16.5 10.6046 17.3954 11.5 18.5 11.5M18.5 7.5C19.6046 7.5 20.5 8.39543 20.5 9.5C20.5 10.6046 19.6046 11.5 18.5 11.5M18.5 11.5V20",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ControlsIcon.displayName = "ForwardRef(ControlsIcon)";
const CopyIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "copy",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8.5 8.5H5.5V20.5H16.5V16.5M19.5 4.5H8.5V16.5H19.5V4.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CopyIcon.displayName = "ForwardRef(CopyIcon)";
const CreditCardIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "credit-card",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M20.5 9.5H4.5V11.5H20.5V9.5Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7 15.5H14M5.5 18.5H19.5C20.0523 18.5 20.5 18.0523 20.5 17.5V7.5C20.5 6.94772 20.0523 6.5 19.5 6.5H5.5C4.94772 6.5 4.5 6.94772 4.5 7.5V17.5C4.5 18.0523 4.94772 18.5 5.5 18.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
CreditCardIcon.displayName = "ForwardRef(CreditCardIcon)";
const CropIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "crop",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 5V15.5H20M5 9.5H15.5V20",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
CropIcon.displayName = "ForwardRef(CropIcon)";
const CubeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "cube",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.5 8L12.5 3L20.5 8V17L12.5 22L4.5 17V8Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 22V13M12.5 13L4.5 8M12.5 13L20.5 8",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
CubeIcon.displayName = "ForwardRef(CubeIcon)";
const DashboardIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "dashboard",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M14.5 19.5V12.5M10.5 12.5V5.5M5.5 12.5H19.5M5.5 19.5H19.5V5.5H5.5V19.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DashboardIcon.displayName = "ForwardRef(DashboardIcon)";
const DatabaseIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "database",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.5 7V17.5C18.5 19.0594 16.0504 20.5 12.5 20.5C8.9496 20.5 6.5 19.0594 6.5 17.5V7M18.5 7C18.5 8.45543 15.8137 9.5 12.5 9.5C9.18629 9.5 6.5 8.45543 6.5 7C6.5 5.54457 9.18629 4.5 12.5 4.5C15.8137 4.5 18.5 5.54457 18.5 7Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DatabaseIcon.displayName = "ForwardRef(DatabaseIcon)";
const DesktopIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "desktop",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.5 13.5V15.5C4.5 16.0523 4.94772 16.5 5.5 16.5H12.5M4.5 13.5V6.5C4.5 5.94772 4.94772 5.5 5.5 5.5H19.5C20.0523 5.5 20.5 5.94772 20.5 6.5V13.5M4.5 13.5H20.5M20.5 13.5V15.5C20.5 16.0523 20.0523 16.5 19.5 16.5H12.5M12.5 16.5V19.5M12.5 19.5H8M12.5 19.5H17",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DesktopIcon.displayName = "ForwardRef(DesktopIcon)";
const DiamondIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "diamond",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M21 10.5L12.5 21M21 10.5L18 5.5H11M21 10.5H16M12.5 21L4 10.5M12.5 21L9 10.5M12.5 21L16 10.5M4 10.5L7 5.5H11M4 10.5H9M9 10.5H12.5H16M9 10.5L11 5.5M16 10.5L14.5 5.5H11",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DiamondIcon.displayName = "ForwardRef(DiamondIcon)";
const DocumentIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 4.5H18.5V20.5H6.5L6.5 9.5M11.5 4.5L6.5 9.5M11.5 4.5V9.5H6.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentIcon.displayName = "ForwardRef(DocumentIcon)";
const DocumentPdfIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-pdf",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.7127 13.8012L12.7193 13.77C12.8488 13.2366 13.0117 12.5716 12.8845 11.969C12.7997 11.4937 12.4493 11.3084 12.1503 11.295C11.7977 11.2794 11.483 11.4803 11.4049 11.7726C11.2576 12.3082 11.3893 13.0402 11.6303 13.973C11.3268 14.6961 10.8425 15.7472 10.4877 16.3721C9.8271 16.7135 8.94113 17.2402 8.80946 17.9053C8.78268 18.028 8.81392 18.1842 8.88757 18.3248C8.97014 18.481 9.10181 18.6015 9.25579 18.6596C9.32274 18.6841 9.40308 18.7042 9.49681 18.7042C9.88959 18.7042 10.5256 18.3873 11.3736 16.9322C11.5031 16.8898 11.637 16.8452 11.7664 16.8006C12.3734 16.5953 13.0028 16.381 13.5718 16.2851C14.2012 16.622 14.9175 16.8385 15.404 16.8385C15.8861 16.8385 16.0758 16.5529 16.1472 16.381C16.2722 16.0797 16.2119 15.7004 16.0088 15.4973C15.7143 15.2072 14.9979 15.1313 13.882 15.2696C13.3331 14.9349 12.9738 14.4796 12.7127 13.8012ZM10.2645 17.1911C9.95431 17.6419 9.71998 17.8673 9.59278 17.9655C9.7423 17.691 10.0346 17.4009 10.2645 17.1911ZM12.2195 11.9355C12.3355 12.1341 12.3199 12.7345 12.2306 13.038C12.1213 12.5939 12.1056 11.9645 12.1704 11.8909L12.2195 11.9355ZM12.1837 14.6247C12.4225 15.0376 12.7238 15.3924 13.0563 15.6557C12.5743 15.7651 12.1346 15.9458 11.7419 16.1065C11.6481 16.1445 11.5566 16.1824 11.4674 16.2181C11.7642 15.6803 12.0119 15.071 12.1837 14.6247ZM15.6562 16.0864L15.6428 16.1065C15.6428 16.1065 15.4375 16.2315 14.6497 15.9213C15.5558 15.8789 15.6562 16.0864 15.6562 16.0864Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentPdfIcon.displayName = "ForwardRef(DocumentPdfIcon)";
const DocumentRemoveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-remove",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6.5 14V20.5H18.5V14M6.5 11V9.5L11.5 4.5H18.5V11M3 12.5H22",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentRemoveIcon.displayName = "ForwardRef(DocumentRemoveIcon)";
const DocumentSheetIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-sheet",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10.4 19V16.4M10.4 16.4L10.4 13.4M10.4 16.4H8M10.4 16.4H14.4M10.4 13.4V11M10.4 13.4H8M10.4 13.4H14.4M14.4 19V16.4M14.4 16.4V13.4M14.4 16.4H17M14.4 13.4V11M14.4 13.4H17M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentSheetIcon.displayName = "ForwardRef(DocumentSheetIcon)";
const DocumentTextIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-text",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16 13H9M14 16H9M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentTextIcon.displayName = "ForwardRef(DocumentTextIcon)";
const DocumentVideoIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-video",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 16.5V13.5L14 15L11.5 16.5Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: 1.2
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentVideoIcon.displayName = "ForwardRef(DocumentVideoIcon)";
const DocumentWordIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-word",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.4699 13.4588H12.5263L13.6328 17H14.5435L16 12H14.9952L14.0656 15.7214H14.0129L12.929 12H12.0672L10.9984 15.7214H10.9419L10.0124 12H9L10.4565 17H11.371L12.4699 13.4588Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentWordIcon.displayName = "ForwardRef(DocumentWordIcon)";
const DocumentZipIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "document-zip",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M11.5 4.5V9.5H6.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15 4.5L13.5 5L15.5 6L13.5 7L15.5 8L13.5 9L15.5 10L13.5 11L14.5 11.5V13M11.5 4.5H18.5V20.5H6.5V9.5L11.5 4.5ZM13.5 13H15.5L16 17H13L13.5 13Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentZipIcon.displayName = "ForwardRef(DocumentZipIcon)";
const DocumentsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "documents",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M10.5 4.5V9.5H5.5", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.5 7.5H19.5V21.5H8.5V18.5M10.5 4.5H16.5V18.5H5.5V9.5L10.5 4.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DocumentsIcon.displayName = "ForwardRef(DocumentsIcon)";
const DotIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "dot",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "circle",
        {
          cx: 12.5,
          cy: 12.5,
          r: 2.5,
          fill: "currentColor",
          stroke: "currentColor",
          strokeWidth: 1.2
        }
      )
    }
  );
});
DotIcon.displayName = "ForwardRef(DotIcon)";
const DoubleChevronDownIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "double-chevron-down",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17 8L12.5 12.5L8 8M17 13L12.5 17.5L8 13",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DoubleChevronDownIcon.displayName = "ForwardRef(DoubleChevronDownIcon)";
const DoubleChevronLeftIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "double-chevron-left",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12 17L7.5 12.5L12 8M17 17L12.5 12.5L17 8",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DoubleChevronLeftIcon.displayName = "ForwardRef(DoubleChevronLeftIcon)";
const DoubleChevronRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "double-chevron-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M13 8L17.5 12.5L13 17M8 8L12.5 12.5L8 17",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DoubleChevronRightIcon.displayName = "ForwardRef(DoubleChevronRightIcon)";
const DoubleChevronUpIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "double-chevron-up",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 12L12.5 7.5L17 12M8 17L12.5 12.5L17 17",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DoubleChevronUpIcon.displayName = "ForwardRef(DoubleChevronUpIcon)";
const DownloadIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "download",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19.5 17V19.5H5.5V17M12.5 16L12.5 5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M17.5 11L12.5 16L7.5 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
DownloadIcon.displayName = "ForwardRef(DownloadIcon)";
const DragHandleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "drag-handle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.5 8C10.3284 8 11 7.32843 11 6.5C11 5.67157 10.3284 5 9.5 5C8.67157 5 8 5.67157 8 6.5C8 7.32843 8.67157 8 9.5 8Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.5 14C10.3284 14 11 13.3284 11 12.5C11 11.6716 10.3284 11 9.5 11C8.67157 11 8 11.6716 8 12.5C8 13.3284 8.67157 14 9.5 14Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11 18.5C11 19.3284 10.3284 20 9.5 20C8.67157 20 8 19.3284 8 18.5C8 17.6716 8.67157 17 9.5 17C10.3284 17 11 17.6716 11 18.5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15.5 8C16.3284 8 17 7.32843 17 6.5C17 5.67157 16.3284 5 15.5 5C14.6716 5 14 5.67157 14 6.5C14 7.32843 14.6716 8 15.5 8Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M17 12.5C17 13.3284 16.3284 14 15.5 14C14.6716 14 14 13.3284 14 12.5C14 11.6716 14.6716 11 15.5 11C16.3284 11 17 11.6716 17 12.5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15.5 20C16.3284 20 17 19.3284 17 18.5C17 17.6716 16.3284 17 15.5 17C14.6716 17 14 17.6716 14 18.5C14 19.3284 14.6716 20 15.5 20Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
DragHandleIcon.displayName = "ForwardRef(DragHandleIcon)";
const DropIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "drop",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.5 14.5C18.5 18 16 20.5 12.5 20.5C9 20.5 6.5 18 6.5 14.5C6.5 11 9.5 7.50001 12.5 4.5C15.5 7.5 18.5 11 18.5 14.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
DropIcon.displayName = "ForwardRef(DropIcon)";
const EarthAmericasIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "earth-americas",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7 13L5.5 9L10 5H15V10L14 9H11L9.5 11L10.5 12H12V13L13 14.5H15.5L18.5 17L15.5 19.5L10.5 20V17L12.5 15L9 13L7 10.5V13Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "circle",
          {
            cx: 12.5,
            cy: 12.5,
            r: 8,
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
EarthAmericasIcon.displayName = "ForwardRef(EarthAmericasIcon)";
const EarthGlobeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "earth-globe",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 16.5H19.5M5.5 8.5H19.5M4.5 12.5H20.5M12.5 20.5C12.5 20.5 8 18.5 8 12.5C8 6.5 12.5 4.5 12.5 4.5M12.5 4.5C12.5 4.5 17 6.5 17 12.5C17 18.5 12.5 20.5 12.5 20.5M12.5 4.5V20.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
EarthGlobeIcon.displayName = "ForwardRef(EarthGlobeIcon)";
const EditIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "edit",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15 7L18 10M6 19L7 15L17 5L20 8L10 18L6 19Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
EditIcon.displayName = "ForwardRef(EditIcon)";
const EllipsisHorizontalIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "ellipsis-horizontal",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6.5 11C7.32843 11 8 11.6716 8 12.5C8 13.3284 7.32843 14 6.5 14C5.67157 14 5 13.3284 5 12.5C5 11.6716 5.67157 11 6.5 11Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 11C13.3284 11 14 11.6716 14 12.5C14 13.3284 13.3284 14 12.5 14C11.6716 14 11 13.3284 11 12.5C11 11.6716 11.6716 11 12.5 11Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M18.5 11C19.3284 11 20 11.6716 20 12.5C20 13.3284 19.3284 14 18.5 14C17.6716 14 17 13.3284 17 12.5C17 11.6716 17.6716 11 18.5 11Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
EllipsisHorizontalIcon.displayName = "ForwardRef(EllipsisHorizontalIcon)";
const EllipsisVerticalIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "ellipsis-vertical",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 6.5C14 7.32843 13.3284 8 12.5 8C11.6716 8 11 7.32843 11 6.5C11 5.67157 11.6716 5 12.5 5C13.3284 5 14 5.67157 14 6.5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 12.5C14 13.3284 13.3284 14 12.5 14C11.6716 14 11 13.3284 11 12.5C11 11.6716 11.6716 11 12.5 11C13.3284 11 14 11.6716 14 12.5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 18.5C14 19.3284 13.3284 20 12.5 20C11.6716 20 11 19.3284 11 18.5C11 17.6716 11.6716 17 12.5 17C13.3284 17 14 17.6716 14 18.5Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
EllipsisVerticalIcon.displayName = "ForwardRef(EllipsisVerticalIcon)";
const EmptyIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "empty",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 21V19.1111M8.25 19.8614L9.19445 18.2255M5.13878 16.7501L6.77461 15.8057M4 12.5H5.8889M5.13872 8.2499L6.77455 9.19436M8.25004 5.13876L9.19449 6.7746M12.5 5.88891V4M15.8055 6.77465L16.75 5.1388M18.2254 9.19449L19.8612 8.25004M19.1111 12.5001H21M18.2254 15.8056L19.8612 16.7501M15.8056 18.2255L16.75 19.8614",
          stroke: "currentColor",
          strokeWidth: 1.2
        }
      )
    }
  );
});
EmptyIcon.displayName = "ForwardRef(EmptyIcon)";
const EnterIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "enter",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M6 14.5H19.5V7", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10 18.5L6 14.5L10 10.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
EnterIcon.displayName = "ForwardRef(EnterIcon)";
const EnterRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "enter-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M19 14.5H5.5V7", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15 18.5L19 14.5L15 10.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
EnterRightIcon.displayName = "ForwardRef(EnterRightIcon)";
const EnvelopeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "envelope",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M20.5 18.5H4.5V6.5H20.5V18.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M20.5 18.5L17.75 15.5L15 12.5M4.5 18.5L10 12.5M20.5 6.5L12.5 15L4.5 6.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
EnvelopeIcon.displayName = "ForwardRef(EnvelopeIcon)";
const EqualIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "equal",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M7.5 4.5H3.5V20.5H7.5", stroke: "currentColor", strokeWidth: 1.2 }),
        /* @__PURE__ */ jsx("path", { d: "M17.5 20.5L21.5 20.5L21.5 4.5L17.5 4.5", stroke: "currentColor", strokeWidth: 1.2 }),
        /* @__PURE__ */ jsx("path", { d: "M9 10.5H16", stroke: "currentColor", strokeWidth: 1.2 }),
        /* @__PURE__ */ jsx("path", { d: "M9 14.5H16", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
});
EqualIcon.displayName = "ForwardRef(EqualIcon)";
const ErrorFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "error-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M4 12.5C4 7.80558 7.80558 4 12.5 4C17.1944 4 21 7.80558 21 12.5C21 17.1944 17.1944 21 12.5 21C7.80558 21 4 17.1944 4 12.5ZM13 14.5V16H12V14.5H13ZM12 9V13H13V9H12Z",
          fill: "currentColor"
        }
      )
    }
  );
});
ErrorFilledIcon.displayName = "ForwardRef(ErrorFilledIcon)";
const ErrorOutlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "error-outline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 16V14.5M12.5 9V13M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ErrorOutlineIcon.displayName = "ForwardRef(ErrorOutlineIcon)";
const ExpandIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "expand",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 6.5H18.5V11M11 18.5H6.5V14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M18.5 6.5L14 11M6.5 18.5L11 14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
ExpandIcon.displayName = "ForwardRef(ExpandIcon)";
const EyeClosedIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "eye-closed",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7 15.5L5.5 17.5M20.5 12.5C19.8612 13.5647 19.041 14.6294 18.0008 15.501M18.0008 15.501C16.5985 16.676 14.7965 17.5 12.5 17.5M18.0008 15.501L18 15.5M18.0008 15.501L19.5 17.5M12.5 17.5C8.5 17.5 6 15 4.5 12.5M12.5 17.5V20M15.5 17L16.5 19.5M9.5 17L8.5 19.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
EyeClosedIcon.displayName = "ForwardRef(EyeClosedIcon)";
const EyeOpenIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "eye-open",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M9.39999 12.5C9.39999 10.7879 10.7879 9.39999 12.5 9.39999C14.2121 9.39999 15.6 10.7879 15.6 12.5C15.6 14.2121 14.2121 15.6 12.5 15.6C10.7879 15.6 9.39999 14.2121 9.39999 12.5Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 7.5C8.5 7.5 6 10 4.5 12.5C6 15 8.5 17.5 12.5 17.5C16.5 17.5 19 15 20.5 12.5C19 10 16.5 7.5 12.5 7.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
EyeOpenIcon.displayName = "ForwardRef(EyeOpenIcon)";
const FilterIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "filter",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 12L6 7V6L19 6L19 7L14 12V17L11 19V12Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinecap: "square",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
FilterIcon.displayName = "ForwardRef(FilterIcon)";
const FolderIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "folder",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11.5 8.5H19.5V18.5H5.5V5.5H10.5L11.5 8.5ZM11.5 8.5H5.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
FolderIcon.displayName = "ForwardRef(FolderIcon)";
const GenerateIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "generate",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9 5.30423C6.33576 6.60253 4.5 9.33688 4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5V14.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16 11L12.5 14.5L9 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
GenerateIcon.displayName = "ForwardRef(GenerateIcon)";
const GroqIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "groq",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M13 13H21L13 21L13 13Z", fill: "currentColor" }),
        /* @__PURE__ */ jsx("path", { d: "M12 12V4L4 12H12Z", fill: "currentColor" }),
        /* @__PURE__ */ jsx("path", { d: "M12 13H4L12 21V13Z", fill: "currentColor" })
      ]
    }
  );
});
GroqIcon.displayName = "ForwardRef(GroqIcon)";
const HashIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "hash",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M8.33894 16.1002H5.44615L5.63077 14.9002H8.52356L9.26202 10.1002H6.36923L6.55384 8.90018H9.44663L9.89281 6H11.1069L10.6608 8.90018H15.4466L15.8928 6H17.1069L16.6608 8.90018H19.5539L19.3693 10.1002H16.4761L15.7377 14.9002H18.6308L18.4462 16.1002H15.5531L15.1069 19H13.8928L14.3389 16.1002H9.55306L9.10693 19H7.89281L8.33894 16.1002ZM10.4761 10.1002L9.73767 14.9002H14.5236L15.262 10.1002H10.4761Z",
          fill: "currentColor"
        }
      )
    }
  );
});
HashIcon.displayName = "ForwardRef(HashIcon)";
const HeartFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "heart-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17 16C15.8 17.3235 12.5 20.5 12.5 20.5C12.5 20.5 9.2 17.3235 8 16C5.2 12.9118 4.5 11.7059 4.5 9.5C4.5 7.29412 6.1 5.5 8.5 5.5C10.5 5.5 11.7 6.82353 12.5 8.14706C13.3 6.82353 14.5 5.5 16.5 5.5C18.9 5.5 20.5 7.29412 20.5 9.5C20.5 11.7059 19.8 12.9118 17 16Z",
          fill: "currentColor",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
HeartFilledIcon.displayName = "ForwardRef(HeartFilledIcon)";
const HeartIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "heart",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17 16C15.8 17.3235 12.5 20.5 12.5 20.5C12.5 20.5 9.2 17.3235 8 16C5.2 12.9118 4.5 11.7059 4.5 9.5C4.5 7.29412 6.1 5.5 8.5 5.5C10.5 5.5 11.7 6.82353 12.5 8.14706C13.3 6.82353 14.5 5.5 16.5 5.5C18.9 5.5 20.5 7.29412 20.5 9.5C20.5 11.7059 19.8 12.9118 17 16Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
HeartIcon.displayName = "ForwardRef(HeartIcon)";
const HelpCircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "help-circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 13C12.5 11 14 11.5 14 10C14 9.34375 13.5 8.5 12.5 8.5C11.5 8.5 11 9 10.5 9.5M12.5 16V14.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
HelpCircleIcon.displayName = "ForwardRef(HelpCircleIcon)";
const HighlightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "highlight",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17.5311 13.7141L8.0245 8.22547M17.5311 13.7141L20.25 9.00478M17.5311 13.7141L16.5 15.5L13.232 16.134L12 18L11.4142 17.6485M8.0245 8.22547L10.75 3.50479M8.0245 8.22547L6.99999 9.99998L7.99998 13L6.99998 15L7.58576 15.3514M7.58576 15.3514L4.90192 20L10.0566 20L11.4142 17.6485M7.58576 15.3514L11.4142 17.6485M13 20H20",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
HighlightIcon.displayName = "ForwardRef(HighlightIcon)";
const HomeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "home",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M6.5 8.75V18.5H18.5V8.75M4.5 10L12.5 5L20.5 10M14.5 18.5V11.5H10.5V18.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
HomeIcon.displayName = "ForwardRef(HomeIcon)";
const IceCreamIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "ice-cream",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 13.5L12.5 20.5L15.5 13.5M12.5 8.26389C11.9692 7.78885 11.2684 7.5 10.5 7.5C8.84315 7.5 7.5 8.84315 7.5 10.5C7.5 12.1569 8.84315 13.5 10.5 13.5C11.2684 13.5 11.9692 13.2111 12.5 12.7361M9.5 7.5C9.5 5.84315 10.8431 4.5 12.5 4.5C14.1569 4.5 15.5 5.84315 15.5 7.5M17.5 10.5C17.5 12.1569 16.1569 13.5 14.5 13.5C12.8431 13.5 11.5 12.1569 11.5 10.5C11.5 8.84315 12.8431 7.5 14.5 7.5C16.1569 7.5 17.5 8.84315 17.5 10.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
IceCreamIcon.displayName = "ForwardRef(IceCreamIcon)";
const ImageIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "image",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 15.5L8.79289 12.2071C9.18342 11.8166 9.81658 11.8166 10.2071 12.2071L12.8867 14.8867C13.2386 15.2386 13.7957 15.2782 14.1938 14.9796L15.1192 14.2856C15.3601 14.1049 15.6696 14.0424 15.9618 14.1154L19.5 15M5.5 6.5H19.5V18.5H5.5V6.5ZM15.5 10.5C15.5 11.0523 15.0523 11.5 14.5 11.5C13.9477 11.5 13.5 11.0523 13.5 10.5C13.5 9.94772 13.9477 9.5 14.5 9.5C15.0523 9.5 15.5 9.94772 15.5 10.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ImageIcon.displayName = "ForwardRef(ImageIcon)";
const ImageRemoveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "image-remove",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 11V6.5H19.5V11M5.5 14V18.5H19.5V14M3 12.5H22",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ImageRemoveIcon.displayName = "ForwardRef(ImageRemoveIcon)";
const ImagesIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "images",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.5 7.5H20.5V19.5H6.5V17.5M4.5 14.5L7.79289 11.2071C8.18342 10.8166 8.81658 10.8166 9.20711 11.2071L11.8867 13.8867C12.2386 14.2386 12.7957 14.2782 13.1938 13.9796L14.1192 13.2856C14.3601 13.1049 14.6696 13.0424 14.9618 13.1154L18.5 14M4.5 5.5H18.5V17.5H4.5V5.5ZM14.5 9.5C14.5 10.0523 14.0523 10.5 13.5 10.5C12.9477 10.5 12.5 10.0523 12.5 9.5C12.5 8.94772 12.9477 8.5 13.5 8.5C14.0523 8.5 14.5 8.94772 14.5 9.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ImagesIcon.displayName = "ForwardRef(ImagesIcon)";
const InfoFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "info-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M21 12.5C21 17.1944 17.1944 21 12.5 21C7.80558 21 4 17.1944 4 12.5C4 7.80558 7.80558 4 12.5 4C17.1944 4 21 7.80558 21 12.5ZM12 10.5V9H13V10.5H12ZM13 16V12H12V16H13Z",
          fill: "currentColor"
        }
      )
    }
  );
});
InfoFilledIcon.displayName = "ForwardRef(InfoFilledIcon)";
const InfoOutlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "info-outline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 10.5V9M12.5 12V16M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
InfoOutlineIcon.displayName = "ForwardRef(InfoOutlineIcon)";
const InlineElementIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "inline-element",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 5V20M19.5 5V20M8.5 6.5H16.5V18.5H8.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
InlineElementIcon.displayName = "ForwardRef(InlineElementIcon)";
const InlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "inline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 6.5H19.5V18.5H12.5M12.5 6.5H5.5V18.5H12.5M12.5 6.5V18.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
InlineIcon.displayName = "ForwardRef(InlineIcon)";
const InsertAboveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "insert-above",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M14.5 10.5556L10.5 10.5556M12.5 12.5L12.5 8.5M18.5 5.5L6.5 5.5M18.5 19.5L6.5 19.5L6.5 15.5L18.5 15.5L18.5 19.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinecap: "square",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
InsertAboveIcon.displayName = "ForwardRef(InsertAboveIcon)";
const InsertBelowIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "insert-below",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 14.5H14.5M12.5 12.5V16.5M6.5 19.5H18.5M6.5 5.5H18.5V9.5H6.5V5.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinecap: "square",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
InsertBelowIcon.displayName = "ForwardRef(InsertBelowIcon)";
const ItalicIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "italic",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.43 18H11.7276L13.4551 9.86763H12.1576L10.43 18ZM13.3043 8.29849C13.8022 8.29849 14.2095 7.89112 14.2095 7.39322C14.2095 6.89532 13.8022 6.48795 13.3043 6.48795C12.8064 6.48795 12.399 6.89532 12.399 7.39322C12.399 7.89112 12.8064 8.29849 13.3043 8.29849Z",
          fill: "currentColor"
        }
      )
    }
  );
});
ItalicIcon.displayName = "ForwardRef(ItalicIcon)";
const JoystickIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "joystick",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 16V14.5H15.5V16M13.5 10.5V14.5M11.5 10.5V14.5M15.5 7.5C15.5 9.15685 14.1569 10.5 12.5 10.5C10.8431 10.5 9.5 9.15685 9.5 7.5C9.5 5.84315 10.8431 4.5 12.5 4.5C14.1569 4.5 15.5 5.84315 15.5 7.5ZM18.5 19.5H6.5C5.94772 19.5 5.5 19.0523 5.5 18.5V17.5C5.5 16.9477 5.94772 16.5 6.5 16.5H18.5C19.0523 16.5 19.5 16.9477 19.5 17.5V18.5C19.5 19.0523 19.0523 19.5 18.5 19.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
JoystickIcon.displayName = "ForwardRef(JoystickIcon)";
const JsonIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "json",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 5.5H9.5C8.39543 5.5 7.5 6.39543 7.5 7.5V12.5M7.5 12.5H4M7.5 12.5V17.5C7.5 18.6046 8.39543 19.5 9.5 19.5H11M14 5.5H15.5C16.6046 5.5 17.5 6.39543 17.5 7.5V12.5M17.5 12.5H21M17.5 12.5V17.5C17.5 18.6046 16.6046 19.5 15.5 19.5H14",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
JsonIcon.displayName = "ForwardRef(JsonIcon)";
const LaunchIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "launch",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12 7.5H6.5V18.5H17.5V13M19.5 5.5L10.5 14.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M14 5.5H19.5V11", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
LaunchIcon.displayName = "ForwardRef(LaunchIcon)";
const LeaveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "leave",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14.5 15V18.5H5.5V6.5H14.5V10M9 12.5H21.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M18 9L21.5 12.5L18 16",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
LeaveIcon.displayName = "ForwardRef(LeaveIcon)";
const LemonIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "lemon",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.6569 10.3431L6.41422 14.5858C7.58579 15.7574 9.12132 16.3431 10.6569 16.3431M10.6569 10.3431L14.8995 6.1005C16.0711 7.27208 16.6569 8.80761 16.6569 10.3431M10.6569 10.3431L10.6569 16.3431M10.6569 10.3431L16.6569 10.3431M10.6569 10.3431L14.8995 14.5858M14.8995 14.5858C13.7279 15.7574 12.1924 16.3431 10.6569 16.3431M14.8995 14.5858C16.0711 13.4142 16.6569 11.8787 16.6569 10.3431M16.3137 4.68629C19.4379 7.81049 19.4379 12.8758 16.3137 16C13.1895 19.1242 8.12419 19.1242 5 16L16.3137 4.68629Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
LemonIcon.displayName = "ForwardRef(LemonIcon)";
const LinkIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "link",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 12.5L12.5 14C13.281 14.781 14.719 14.781 15.5 14L18.5 11C19.281 10.219 19.281 8.78105 18.5 8L18 7.5C17.2189 6.71895 15.781 6.71895 15 7.5L13 9.5M12 15.5L10 17.5C9.21895 18.281 7.78105 18.281 7 17.5L6.5 17C5.71895 16.219 5.71896 14.781 6.5 14L9.50001 11C10.2811 10.219 11.719 10.2189 12.5 11L14 12.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
LinkIcon.displayName = "ForwardRef(LinkIcon)";
const LinkRemovedIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "link-removed",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.5 11C19.281 10.219 19.281 8.78108 18.5 8.00003L18 7.50003C17.2189 6.71898 15.781 6.71898 15 7.50003L13 9.50003M15.5 14C14.7189 14.7811 13.281 14.7811 12.5 14M6.5 14C5.71895 14.7811 5.71894 16.219 6.49999 17L6.99999 17.5C7.78104 18.2811 9.21894 18.2811 9.99999 17.5L12 15.5M12.5 11C11.719 10.219 10.281 10.219 9.5 11M3 12.5H22",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
LinkRemovedIcon.displayName = "ForwardRef(LinkRemovedIcon)";
const LockIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "lock",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15.5 11.5V8.5C15.5 6.5 14 5.5 12.5 5.5C11 5.5 9.5 6.5 9.5 8.5V11.5M7.5 11.5H17.5V19.5H7.5V11.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
LockIcon.displayName = "ForwardRef(LockIcon)";
const LogoJsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "logo-js",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M20 5H5V20H20V5ZM12.5254 16.1572C12.5254 17.4189 11.7742 18.1536 10.4792 18.1536C9.24243 18.1536 8.49121 17.4189 8.45801 16.2942V16.261H9.67407V16.2859C9.69897 16.7466 9.9729 17.0703 10.4626 17.0703C10.9939 17.0703 11.272 16.7507 11.272 16.1489V12.011H12.5254V16.1572ZM18.2893 16.2153C18.2893 17.4023 17.3679 18.1536 15.8738 18.1536C14.4419 18.1536 13.5371 17.4688 13.4666 16.4062L13.4624 16.3398H14.6702L14.6743 16.3813C14.72 16.8296 15.2056 17.1326 15.907 17.1326C16.5752 17.1326 17.0359 16.813 17.0359 16.3523V16.3481C17.0359 15.9539 16.7412 15.7339 15.9983 15.5803L15.3674 15.4517C14.1223 15.1985 13.5869 14.6174 13.5869 13.7085V13.7043C13.5869 12.592 14.5415 11.8574 15.8696 11.8574C17.2683 11.8574 18.0901 12.5962 18.1689 13.5964L18.1731 13.6504H16.9944L16.9861 13.6006C16.9155 13.1731 16.5005 12.8743 15.8696 12.8743C15.2512 12.8784 14.8403 13.1606 14.8403 13.6089V13.613C14.8403 14.0032 15.1309 14.2356 15.8364 14.3809L16.4714 14.5095C17.7373 14.771 18.2893 15.2773 18.2893 16.2112V16.2153Z",
          fill: "currentColor"
        }
      )
    }
  );
});
LogoJsIcon.displayName = "ForwardRef(LogoJsIcon)";
const LogoTsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "logo-ts",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M20 5H5V20H20V5ZM11.0769 18H9.82349V13.0444H8.02637V12.011H12.874V13.0444H11.0769V18ZM18.2893 16.2153C18.2893 17.4023 17.3679 18.1536 15.8738 18.1536C14.4419 18.1536 13.5371 17.4688 13.4666 16.4062L13.4624 16.3398H14.6702L14.6743 16.3813C14.72 16.8296 15.2056 17.1326 15.907 17.1326C16.5752 17.1326 17.0359 16.813 17.0359 16.3523V16.3481C17.0359 15.9539 16.7412 15.7339 15.9983 15.5803L15.3674 15.4517C14.1223 15.1985 13.5869 14.6174 13.5869 13.7085V13.7043C13.5869 12.592 14.5415 11.8574 15.8696 11.8574C17.2683 11.8574 18.0901 12.5962 18.1689 13.5964L18.1731 13.6504H16.9944L16.9861 13.6006C16.9155 13.1731 16.5005 12.8743 15.8696 12.8743C15.2512 12.8784 14.8403 13.1606 14.8403 13.6089V13.613C14.8403 14.0032 15.1309 14.2356 15.8364 14.3809L16.4714 14.5095C17.7373 14.771 18.2893 15.2773 18.2893 16.2112V16.2153Z",
          fill: "currentColor"
        }
      )
    }
  );
});
LogoTsIcon.displayName = "ForwardRef(LogoTsIcon)";
const MasterDetailIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "master-detail",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7 9.5H10M11.5 6.5V18.5M7 12.5H10M13 9.5H18M7 15.5H10M5.5 6.5H19.5V18.5H5.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
MasterDetailIcon.displayName = "ForwardRef(MasterDetailIcon)";
const MenuIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "menu",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M6 7.5H19M6 17.5H19M6 12.5H19",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
MenuIcon.displayName = "ForwardRef(MenuIcon)";
const MobileDeviceIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "mobile-device",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.5 6.5C7.5 5.39543 8.39543 4.5 9.5 4.5H15.5C16.6046 4.5 17.5 5.39543 17.5 6.5V18.5C17.5 19.6046 16.6046 20.5 15.5 20.5H9.5C8.39543 20.5 7.5 19.6046 7.5 18.5V6.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M13.5 17.5C13.5 18.0523 13.0523 18.5 12.5 18.5C11.9477 18.5 11.5 18.0523 11.5 17.5C11.5 16.9477 11.9477 16.5 12.5 16.5C13.0523 16.5 13.5 16.9477 13.5 17.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
MobileDeviceIcon.displayName = "ForwardRef(MobileDeviceIcon)";
const MoonIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "moon",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M19.6065 16.1775C18.9417 16.387 18.234 16.5 17.5 16.5C13.634 16.5 10.5 13.366 10.5 9.5C10.5 7.54163 11.3042 5.77109 12.6004 4.50062C12.567 4.50021 12.5335 4.5 12.5 4.5C8.08172 4.5 4.5 8.08172 4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C15.5924 20.5 18.275 18.7454 19.6065 16.1775Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
MoonIcon.displayName = "ForwardRef(MoonIcon)";
const NumberIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "number",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M21.0165 17.6336H3.83636V16.4336H21.0165V17.6336Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.09808 13.3967V7.508H5.74066L3.83636 8.78241V10.091L5.65277 8.88495H5.74066V13.3967H3.84125V14.5539H8.89984V13.3967H7.09808Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.81781 9.63202V9.66132H11.1069V9.62714C11.1069 8.95331 11.5756 8.49432 12.2739 8.49432C12.9575 8.49432 13.4018 8.89471 13.4018 9.50507C13.4018 9.9787 13.1528 10.3498 12.1909 11.3117L9.89594 13.5822V14.5539H14.8618V13.3869H11.7807V13.299L13.1577 11.9855C14.3491 10.843 14.7543 10.1838 14.7543 9.41229C14.7543 8.19159 13.7729 7.36639 12.3178 7.36639C10.8383 7.36639 9.81781 8.28436 9.81781 9.63202Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M17.6694 11.4631H18.5092C19.3198 11.4631 19.8422 11.8683 19.8422 12.4982C19.8422 13.1183 19.3295 13.5139 18.5239 13.5139C17.767 13.5139 17.2592 13.133 17.2104 12.5324H15.9262C15.9897 13.8508 17.0248 14.6955 18.5629 14.6955C20.1401 14.6955 21.2192 13.841 21.2192 12.591C21.2192 11.6584 20.6528 11.0334 19.7006 10.9211V10.8332C20.4721 10.6769 20.9457 10.0666 20.9457 9.23651C20.9457 8.12323 19.9741 7.36639 18.5434 7.36639C17.0541 7.36639 16.1118 8.17694 16.0629 9.50018H17.2983C17.3422 8.88007 17.8061 8.48456 18.4995 8.48456C19.2075 8.48456 19.6567 8.85565 19.6567 9.44159C19.6567 10.0324 19.1977 10.4182 18.4946 10.4182H17.6694V11.4631Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
NumberIcon.displayName = "ForwardRef(NumberIcon)";
const OkHandIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "ok-hand",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15.9957 11.5C14.8197 10.912 11.9957 9 10.4957 9C8.9957 9 5.17825 11.7674 6 13C7 14.5 9.15134 11.7256 10.4957 12C11.8401 12.2744 13 13.5 13 14.5C13 15.5 11.8401 16.939 10.4957 16.5C9.15134 16.061 8.58665 14.3415 7.4957 14C6.21272 13.5984 5.05843 14.6168 5.5 15.5C5.94157 16.3832 7.10688 17.6006 8.4957 19C9.74229 20.2561 11.9957 21.5 14.9957 20C17.9957 18.5 18.5 16.2498 18.5 13C18.5 11.5 13.7332 5.36875 11.9957 4.5C10.9957 4 10 5 10.9957 6.5C11.614 7.43149 13.5 9.27705 14 10.3751M15.5 8C15.5 8 15.3707 7.5 14.9957 6C14.4957 4 15.9957 3.5 16.4957 4.5C17.1281 5.76491 18.2872 10.9147 18.4957 13",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
OkHandIcon.displayName = "ForwardRef(OkHandIcon)";
const OlistIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "olist",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10 7.5H19M10 12.5H19M10 17.5H19M5 18.5H7.5L7 17.5L7.5 16.5H5M5 6.5H6.5V8.5M5 8.5H6.5M6.5 8.5H8M8 13.5H6L7 11.5H5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
OlistIcon.displayName = "ForwardRef(OlistIcon)";
const OverageIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "overage",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M18.5 11V6.5H14", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" }),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6.5 18.5L9 16L12 13L18.5 6.5M3 13.5H22",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
OverageIcon.displayName = "ForwardRef(OverageIcon)";
const PackageIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "package",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 13V22M12.5 13L4.5 8M12.5 13L20.5 8M8.5 5.5L16.5 10.5M4.5 8L12.5 3L20.5 8V17L12.5 22L4.5 17V8Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PackageIcon.displayName = "ForwardRef(PackageIcon)";
const PanelLeftIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "panel-left",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 6.5H19.5V18.5H10.5M10.5 6.5H5.5V18.5H10.5M10.5 6.5V18.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PanelLeftIcon.displayName = "ForwardRef(PanelLeftIcon)";
const PanelRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "panel-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M14.5 6.5H19.5V18.5H14.5M14.5 6.5H5.5V18.5H14.5M14.5 6.5V18.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PanelRightIcon.displayName = "ForwardRef(PanelRightIcon)";
const PauseIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "pause",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx("path", { d: "M10.5 7.5H8.5V17.5H10.5V7.5Z", fill: "currentColor" }),
        /* @__PURE__ */ jsx("path", { d: "M16.5 7.5H14.5V17.5H16.5V7.5Z", fill: "currentColor" }),
        /* @__PURE__ */ jsx("path", { d: "M10.5 7.5H8.5V17.5H10.5V7.5Z", stroke: "currentColor", strokeWidth: 1.2 }),
        /* @__PURE__ */ jsx("path", { d: "M16.5 7.5H14.5V17.5H16.5V7.5Z", stroke: "currentColor", strokeWidth: 1.2 })
      ]
    }
  );
});
PauseIcon.displayName = "ForwardRef(PauseIcon)";
const PinIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "pin",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6.5 10.5C6.5 7 9 4.5 12.5 4.5C16 4.5 18.5 7 18.5 10.5C18.5 14 15.5 17.5 12.5 20.5C9.5 17.5 6.5 14 6.5 10.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 10.5C14 11.3284 13.3284 12 12.5 12C11.6716 12 11 11.3284 11 10.5C11 9.67157 11.6716 9 12.5 9C13.3284 9 14 9.67157 14 10.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
PinIcon.displayName = "ForwardRef(PinIcon)";
const PinRemovedIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "pin-removed",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.39787 14C8.51075 16.2897 10.5054 18.5054 12.5 20.5C14.4946 18.5054 16.4892 16.2897 17.6021 14M6.52009 11C6.50681 10.8334 6.5 10.6667 6.5 10.5C6.5 7 9 4.5 12.5 4.5C16 4.5 18.5 7 18.5 10.5C18.5 10.6667 18.4932 10.8334 18.4799 11M3 12.5H22",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PinRemovedIcon.displayName = "ForwardRef(PinRemovedIcon)";
const PlayIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "play",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.5 18.5V6.5L17.5 12.5L7.5 18.5Z",
          fill: "currentColor",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PlayIcon.displayName = "ForwardRef(PlayIcon)";
const PlugIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "plug",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M13.25 8.5L16.75 5M16.25 11.5L19.75 8M9.25 15.5L5.25 19.5M7.75 14L9.75 12C8.25 10 8.75 9 9.75 8C10.15 7.6 11.25 6.5 11.25 6.5L18.25 13.5C18.25 13.5 17.3825 14.3675 16.75 15C15.75 16 14.75 16.5 12.75 15L10.75 17L7.75 14Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PlugIcon.displayName = "ForwardRef(PlugIcon)";
const PresentationIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "presentation",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 18H5.5V8.5H19.5V18H14.5M10.5 18L9 22M10.5 18H14.5M14.5 18L16 22M4.5 8.5H20.5V6.5H4.5V8.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
PresentationIcon.displayName = "ForwardRef(PresentationIcon)";
const Progress50Icon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "progress-50",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M17 12.5C17 14.9853 14.9853 17 12.5 17V8C14.9853 8 17 10.0147 17 12.5Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5C8.08172 4.5 4.5 8.08172 4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
Progress50Icon.displayName = "ForwardRef(Progress50Icon)";
const Progress75Icon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "progress-75",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 17C14.9853 17 17 14.9853 17 12.5C17 10.0147 14.9853 8 12.5 8V12.5H8C8 14.9853 10.0147 17 12.5 17Z",
            fill: "currentColor",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
Progress75Icon.displayName = "ForwardRef(Progress75Icon)";
const ProjectsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "projects",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M21 17.5H14M17.5 14V21M5.5 14.5H10.5V19.5H5.5V14.5ZM14.5 5.5H19.5V10.5H14.5V5.5ZM5.5 5.5H10.5V10.5H5.5V5.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ProjectsIcon.displayName = "ForwardRef(ProjectsIcon)";
const PublishIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "publish",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.99997 5.50006H20M12.5 9.00005V20",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.5 14L12.5 9.00006L17.5 14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
PublishIcon.displayName = "ForwardRef(PublishIcon)";
const ReadOnlyIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "read-only",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15 7L18 10M10 12L7 15L6 19L10 18L13 15M12 10L17 5L20 8L15 13M19 19L5 5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ReadOnlyIcon.displayName = "ForwardRef(ReadOnlyIcon)";
const RedoIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "redo",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19 9.5L10 9.5C7.51472 9.5 5.5 11.5147 5.5 14C5.5 16.4853 7.51472 18.5 10 18.5H19",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15 13.5L19 9.5L15 5.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RedoIcon.displayName = "ForwardRef(RedoIcon)";
const RefreshIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "refresh",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19.5 13.5C19.5 17.366 16.366 20.5 12.5 20.5C8.63401 20.5 5.5 17.366 5.5 13.5C5.5 9.63401 8.63401 6.5 12.5 6.5H15.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.5 10.5L15.5 6.5L11.5 2.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RefreshIcon.displayName = "ForwardRef(RefreshIcon)";
const RemoveCircleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "remove-circle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 12.4H17M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
RemoveCircleIcon.displayName = "ForwardRef(RemoveCircleIcon)";
const RemoveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "remove",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx("path", { d: "M5 12.5H20", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
    }
  );
});
RemoveIcon.displayName = "ForwardRef(RemoveIcon)";
const ResetIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "reset",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.56189 13.5L4.14285 13.9294C4.25676 14.0406 4.41017 14.1019 4.56932 14.1C4.72847 14.098 4.88032 14.0329 4.99144 13.9189L4.56189 13.5ZM9.92427 15.9243L15.9243 9.92427L15.0757 9.07574L9.07574 15.0757L9.92427 15.9243ZM9.07574 9.92426L15.0757 15.9243L15.9243 15.0757L9.92426 9.07574L9.07574 9.92426ZM19.9 12.5C19.9 16.5869 16.5869 19.9 12.5 19.9V21.1C17.2496 21.1 21.1 17.2496 21.1 12.5H19.9ZM5.1 12.5C5.1 8.41309 8.41309 5.1 12.5 5.1V3.9C7.75035 3.9 3.9 7.75035 3.9 12.5H5.1ZM12.5 5.1C16.5869 5.1 19.9 8.41309 19.9 12.5H21.1C21.1 7.75035 17.2496 3.9 12.5 3.9V5.1ZM5.15728 13.4258C5.1195 13.1227 5.1 12.8138 5.1 12.5H3.9C3.9 12.8635 3.92259 13.2221 3.9665 13.5742L5.15728 13.4258ZM12.5 19.9C9.9571 19.9 7.71347 18.6179 6.38048 16.6621L5.38888 17.3379C6.93584 19.6076 9.54355 21.1 12.5 21.1V19.9ZM4.99144 13.9189L7.42955 11.4189L6.57045 10.5811L4.13235 13.0811L4.99144 13.9189ZM4.98094 13.0706L2.41905 10.5706L1.58095 11.4294L4.14285 13.9294L4.98094 13.0706Z",
          fill: "currentColor"
        }
      )
    }
  );
});
ResetIcon.displayName = "ForwardRef(ResetIcon)";
const RestoreIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "restore",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.88468 17C7.32466 19.1128 9.75033 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5C8.08172 4.5 4.5 8.08172 4.5 12.5V13.5M12.5 8V12.5L15.5 15.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7 11L4.5 13.5L2 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RestoreIcon.displayName = "ForwardRef(RestoreIcon)";
const RetrieveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "retrieve",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16 14L12.5 10.5L9 14M5.5 7.5H19.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 10.5L12.5 17.5M19.5 7.5V19.5H5.5V7.5L7.5 5.5H17.5L19.5 7.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RetrieveIcon.displayName = "ForwardRef(RetrieveIcon)";
const RetryIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "retry",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19 9.5L10 9.5C7.51472 9.5 5.5 11.5147 5.5 14C5.5 16.4853 7.51472 18.5 10 18.5H19",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15 13.5L19 9.5L15 5.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RetryIcon.displayName = "ForwardRef(RetryIcon)";
const RevertIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "revert",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6 9.5L15 9.5C17.4853 9.5 19.5 11.5147 19.5 14C19.5 16.4853 17.4853 18.5 15 18.5H6",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10 13.5L6 9.5L10 5.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
RevertIcon.displayName = "ForwardRef(RevertIcon)";
const RobotIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "robot",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 15.5V17.5M12.5 8.5V6.5M12.5 6.5C13.3284 6.5 14 5.82843 14 5C14 4.17157 13.3284 3.5 12.5 3.5C11.6716 3.5 11 4.17157 11 5C11 5.82843 11.6716 6.5 12.5 6.5ZM20.5 20.5V19.5C20.5 18.3954 19.6046 17.5 18.5 17.5H6.5C5.39543 17.5 4.5 18.3954 4.5 19.5V20.5H20.5ZM11.5 12C11.5 12.5523 11.0523 13 10.5 13C9.94772 13 9.5 12.5523 9.5 12C9.5 11.4477 9.94772 11 10.5 11C11.0523 11 11.5 11.4477 11.5 12ZM15.5 12C15.5 12.5523 15.0523 13 14.5 13C13.9477 13 13.5 12.5523 13.5 12C13.5 11.4477 13.9477 11 14.5 11C15.0523 11 15.5 11.4477 15.5 12ZM8.5 15.5H16.5C17.6046 15.5 18.5 14.6046 18.5 13.5V10.5C18.5 9.39543 17.6046 8.5 16.5 8.5H8.5C7.39543 8.5 6.5 9.39543 6.5 10.5V13.5C6.5 14.6046 7.39543 15.5 8.5 15.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
RobotIcon.displayName = "ForwardRef(RobotIcon)";
const RocketIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "rocket",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 20.5L15.5 14M11 9.49999L4.5 12.5M9 14C9 14 7.54688 14.9531 6.5 16C5.5 17 4.5 20.5 4.5 20.5C4.5 20.5 8 19.5 9 18.5C10 17.5 11 16 11 16M9 14C9 14 10.1 9.9 12.5 7.5C15.5 4.5 20.5 4.5 20.5 4.5C20.5 4.5 20.5 9.5 17.5 12.5C15.7492 14.2508 11 16 11 16L9 14ZM16.5 9.99999C16.5 10.8284 15.8284 11.5 15 11.5C14.1716 11.5 13.5 10.8284 13.5 9.99999C13.5 9.17157 14.1716 8.49999 15 8.49999C15.8284 8.49999 16.5 9.17157 16.5 9.99999Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
RocketIcon.displayName = "ForwardRef(RocketIcon)";
const SchemaIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "schema",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 9.5V12.5M12.5 12.5H8.5V15.5M12.5 12.5H16.5V15.5M10.5 5.5H14.5V9.5H10.5V5.5ZM6.5 15.5H10.5V19.5H6.5V15.5ZM14.5 15.5H18.5V19.5H14.5V15.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SchemaIcon.displayName = "ForwardRef(SchemaIcon)";
const SearchIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "search",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15.0355 15.0355L20 20M16.5 11.5C16.5 14.2614 14.2614 16.5 11.5 16.5C8.73858 16.5 6.5 14.2614 6.5 11.5C6.5 8.73858 8.73858 6.5 11.5 6.5C14.2614 6.5 16.5 8.73858 16.5 11.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SearchIcon.displayName = "ForwardRef(SearchIcon)";
const SelectIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "select",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M16 15L12.5 18.5L9 15M9 10L12.5 6.5L16 10",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SelectIcon.displayName = "ForwardRef(SelectIcon)";
const ShareIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "share",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M15 10.5H18.5V19.5H6.5L6.5 10.5H10M12.5 16V3.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M9 7L12.5 3.5L16 7", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
ShareIcon.displayName = "ForwardRef(ShareIcon)";
const SortIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "sort",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8.5 18.5V6M16.5 19V6.5M12 15L8.5 18.5L5 15M13 10L16.5 6.5L20 10",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SortIcon.displayName = "ForwardRef(SortIcon)";
const SparkleIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "sparkle",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 10.5C8.5 12.5 5 12.5 5 12.5C5 12.5 8.5 12.5 10.5 14.5C12.5 16.5 12.5 20 12.5 20C12.5 20 12.5 16.5 14.5 14.5C16.5 12.5 20 12.5 20 12.5C20 12.5 16.5 12.5 14.5 10.5C12.5 8.5 12.5 5 12.5 5C12.5 5 12.5 8.5 10.5 10.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SparkleIcon.displayName = "ForwardRef(SparkleIcon)";
const SparklesIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "sparkles",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M11 3.5V5M11 5V6.5M11 5H12.5M11 5H9.5M9.5 15C9.5 15 12.2308 14.7692 13.5 13.5C14.7692 12.2308 15 9.5 15 9.5C15 9.5 15.2308 12.2308 16.5 13.5C17.7692 14.7692 20.5 15 20.5 15C20.5 15 17.7692 15.2308 16.5 16.5C15.2308 17.7692 15 20.5 15 20.5C15 20.5 14.7692 17.7692 13.5 16.5C12.2308 15.2308 9.5 15 9.5 15ZM4.5 10C4.5 10 5.72308 9.87692 6.3 9.3C6.87692 8.72308 7 7.5 7 7.5C7 7.5 7.12308 8.72308 7.7 9.3C8.27692 9.87692 9.5 10 9.5 10C9.5 10 8.27692 10.1231 7.7 10.7C7.12308 11.2769 7 12.5 7 12.5C7 12.5 6.87692 11.2769 6.3 10.7C5.72308 10.1231 4.5 10 4.5 10Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinecap: "round",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SparklesIcon.displayName = "ForwardRef(SparklesIcon)";
const SpinnerIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "spinner",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M4.5 12.5C4.5 16.9183 8.08172 20.5 12.5 20.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 8.08172 16.9183 4.5 12.5 4.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SpinnerIcon.displayName = "ForwardRef(SpinnerIcon)";
const SplitHorizontalIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "split-horizontal",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M19.5 10.5V20.5H5.5V10.5M19.5 10.5H5.5M19.5 10.5V4.5H5.5V10.5M12.5 13V15.5M12.5 18V15.5M12.5 15.5H15M12.5 15.5H10",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SplitHorizontalIcon.displayName = "ForwardRef(SplitHorizontalIcon)";
const SplitVerticalIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "split-vertical",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10.5 5.5V19.5M13 12.5H15.5M18 12.5H15.5M15.5 12.5V15M15.5 12.5V10M4.5 5.5H20.5V19.5H4.5V5.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SplitVerticalIcon.displayName = "ForwardRef(SplitVerticalIcon)";
const SquareIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "square",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "rect",
        {
          x: 5.5,
          y: 5.5,
          width: 14,
          height: 14,
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SquareIcon.displayName = "ForwardRef(SquareIcon)";
const StackCompactIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "stack-compact",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 15.5V18.5H19.5V15.5M5.5 15.5H19.5M5.5 15.5V9.5M19.5 15.5V9.5M5.5 9.5V6.5H19.5V9.5M5.5 9.5H19.5M5.5 12.5H19.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
StackCompactIcon.displayName = "ForwardRef(StackCompactIcon)";
const StackIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "stack",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5.5 12.5H19.5M5.5 18.5H19.5V6.5H5.5V18.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
StackIcon.displayName = "ForwardRef(StackIcon)";
const StarFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "star-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 5L14.522 10.217L20.1085 10.5279L15.7716 14.063L17.2023 19.4721L12.5 16.44L7.79772 19.4721L9.22837 14.063L4.89155 10.5279L10.478 10.217L12.5 5Z",
          fill: "currentColor",
          stroke: "currentColor",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
StarFilledIcon.displayName = "ForwardRef(StarFilledIcon)";
const StarIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "star",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 5L14.522 10.217L20.1085 10.5279L15.7716 14.063L17.2023 19.4721L12.5 16.44L7.79772 19.4721L9.22837 14.063L4.89155 10.5279L10.478 10.217L12.5 5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
StarIcon.displayName = "ForwardRef(StarIcon)";
const StopIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "stop",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "rect",
        {
          x: 7.5,
          y: 7.5,
          width: 10,
          height: 10,
          fill: "currentColor",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
StopIcon.displayName = "ForwardRef(StopIcon)";
const StrikethroughIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "strikethrough",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5656 7.73438C11.0656 7.73438 10.0734 8.48438 10.0734 9.625C10.0734 10.2317 10.3649 10.6613 11.0519 11H8.90358C8.71703 10.6199 8.62813 10.1801 8.62813 9.67188C8.62813 7.75781 10.2297 6.46094 12.6125 6.46094C14.7922 6.46094 16.4172 7.75781 16.5344 9.57812H15.1203C14.925 8.42188 13.9719 7.73438 12.5656 7.73438Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.4875 18.2656C10.0969 18.2656 8.44844 17 8.3 15.0547H9.72188C9.89375 16.2344 11.0188 16.9844 12.6203 16.9844C14.1359 16.9844 15.2531 16.1641 15.2531 15.0469C15.2531 14.6375 15.1255 14.292 14.8589 14H16.5912C16.6638 14.266 16.6984 14.5566 16.6984 14.875C16.6984 16.9453 15.0656 18.2656 12.4875 18.2656Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M7 13.1H18V11.9H7V13.1Z", fill: "currentColor" })
      ]
    }
  );
});
StrikethroughIcon.displayName = "ForwardRef(StrikethroughIcon)";
const StringIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "string",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11.6748 15.5227H13.1855L9.87842 6.36304H8.34863L5.0415 15.5227H6.50146L7.3457 13.0916H10.8369L11.6748 15.5227ZM9.04053 8.02612H9.14844L10.4751 11.8982H7.70752L9.04053 8.02612Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16.8101 14.488C16.0674 14.488 15.5278 14.1262 15.5278 13.5042C15.5278 12.8948 15.9595 12.571 16.9116 12.5076L18.6001 12.3997V12.9773C18.6001 13.8342 17.8384 14.488 16.8101 14.488ZM16.4609 15.637C17.3687 15.637 18.124 15.2434 18.5366 14.5515H18.6445V15.5227H19.9585V10.8C19.9585 9.34009 18.981 8.47681 17.248 8.47681C15.6802 8.47681 14.563 9.23853 14.4233 10.4255H15.7437C15.896 9.93677 16.4229 9.65747 17.1846 9.65747C18.1177 9.65747 18.6001 10.0701 18.6001 10.8V11.3967L16.7275 11.5046C15.0835 11.6062 14.1567 12.3235 14.1567 13.5676C14.1567 14.8308 15.1279 15.637 16.4609 15.637Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            fillRule: "evenodd",
            clipRule: "evenodd",
            d: "M19.9585 18.637L5.0415 18.637V17.437L19.9585 17.437V18.637Z",
            fill: "currentColor"
          }
        )
      ]
    }
  );
});
StringIcon.displayName = "ForwardRef(StringIcon)";
const SunIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "sun",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M19 12.5H22M3 12.5H6M12.5 6V3M12.5 22V19M17.3891 7.61091L19.5104 5.48959M5.48959 19.5104L7.61091 17.3891M7.61091 7.61091L5.48959 5.48959M19.5104 19.5104L17.3891 17.3891M16 12.5C16 14.433 14.433 16 12.5 16C10.567 16 9 14.433 9 12.5C9 10.567 10.567 9 12.5 9C14.433 9 16 10.567 16 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
SunIcon.displayName = "ForwardRef(SunIcon)";
const SyncIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "sync",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M13.5 4.5H12.5C8.08172 4.5 4.5 8.08172 4.5 12.5C4.5 15.6631 6.33576 18.3975 9 19.6958M11.5 20.5H12.5C16.9183 20.5 20.5 16.9183 20.5 12.5C20.5 9.33688 18.6642 6.60253 16 5.30423",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M14 17.5619L11.5 20.5L14.5 23.0619M11 7.43811L13.5 4.50001L10.5 1.93811",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
SyncIcon.displayName = "ForwardRef(SyncIcon)";
const TabletDeviceIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "tablet-device",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5.5 5.5C5.5 4.94772 5.94772 4.5 6.5 4.5H18.5C19.0523 4.5 19.5 4.94772 19.5 5.5V19.5C19.5 20.0523 19.0523 20.5 18.5 20.5H6.5C5.94772 20.5 5.5 20.0523 5.5 19.5V5.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M13 18C13 18.2761 12.7761 18.5 12.5 18.5C12.2239 18.5 12 18.2761 12 18C12 17.7239 12.2239 17.5 12.5 17.5C12.7761 17.5 13 17.7239 13 18Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
TabletDeviceIcon.displayName = "ForwardRef(TabletDeviceIcon)";
const TagIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "tag",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 20L5 20L5 12.5L12.5 5L20 12.5L12.5 20Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M11 15.5C11 16.3284 10.3284 17 9.5 17C8.67157 17 8 16.3284 8 15.5C8 14.6716 8.67157 14 9.5 14C10.3284 14 11 14.6716 11 15.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
TagIcon.displayName = "ForwardRef(TagIcon)";
const TagsIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "tags",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.1562 7.93179L13.9717 6.11633L20.3553 12.5L13.9717 18.8836L10.6855 18.8836M11.0283 18.8836L17.4119 12.5L11.0283 6.11633L4.64462 12.5L4.64462 18.8836L11.0283 18.8836ZM9.75153 15.0534C9.75153 15.7585 9.17992 16.3302 8.47481 16.3302C7.76969 16.3302 7.19808 15.7585 7.19808 15.0534C7.19808 14.3483 7.76969 13.7767 8.47481 13.7767C9.17992 13.7767 9.75153 14.3483 9.75153 15.0534Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TagsIcon.displayName = "ForwardRef(TagsIcon)";
const TaskIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "task",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.88281 10.75V19.75H20.8828V10.75M4.88281 10.75V5.75H20.8828V10.75M4.88281 10.75H12.8828H20.8828M17.8828 8.25V3.25M7.88281 8.25V3.25",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10.083 14.7358L12.083 16.7358L15.683 13.1758",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
TaskIcon.displayName = "ForwardRef(TaskIcon)";
const TerminalIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "terminal",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8.5 9.5L11.5 12.5L8.5 15.5M13 15.5H17M5.5 6.5H19.5V18.5H5.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TerminalIcon.displayName = "ForwardRef(TerminalIcon)";
const TextIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "text",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M7.5 9V6.5H17.5V9M12.5 18.5V6.5M10 18.5H15",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TextIcon.displayName = "ForwardRef(TextIcon)";
const ThLargeIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "th-large",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 6.5V12.5M12.5 12.5V18.5M12.5 12.5H20.5M12.5 12.5H4.5M4.5 6.5H20.5V18.5H4.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ThLargeIcon.displayName = "ForwardRef(ThLargeIcon)";
const ThListIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "th-list",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 6.5V10.5M9.5 10.5V14.5M9.5 10.5H20.5M9.5 10.5H4.5M9.5 14.5V18.5M9.5 14.5H20.5M9.5 14.5H4.5M4.5 6.5H20.5V18.5H4.5V6.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ThListIcon.displayName = "ForwardRef(ThListIcon)";
const TiersIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "tiers",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M16.5 14.5L20.5 16.5L12.5 20.5L4.5 16.5L8.5 14.5M16.5 10.5L20.5 12.5L12.5 16.5L4.5 12.5L8.5 10.5M12.5 12.5L20.5 8.5L12.5 4.5L4.5 8.5L12.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TiersIcon.displayName = "ForwardRef(TiersIcon)";
const ToggleArrowRightIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "toggle-arrow-right",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M10 16.5V8.5L16 12.5L10 16.5Z",
          fill: "currentColor",
          stroke: "currentColor",
          strokeLinejoin: "round"
        }
      )
    }
  );
});
ToggleArrowRightIcon.displayName = "ForwardRef(ToggleArrowRightIcon)";
const TokenIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "token",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17.5711 12.5C17.5711 15.2614 15.3325 17.5 12.5711 17.5M7.57107 12.5C7.57107 9.73858 9.80964 7.5 12.5711 7.5M20.5 12.5C20.5 16.9183 16.9183 20.5 12.5 20.5C8.08172 20.5 4.5 16.9183 4.5 12.5C4.5 8.08172 8.08172 4.5 12.5 4.5C16.9183 4.5 20.5 8.08172 20.5 12.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TokenIcon.displayName = "ForwardRef(TokenIcon)";
const TransferIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "transfer",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M19.5 16.5H6M5.5 8.5L19 8.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M16 13L19.5 16.5L16 20M9 12L5.5 8.5L9 5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
TransferIcon.displayName = "ForwardRef(TransferIcon)";
const TranslateIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "translate",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M9.4 5.4H4V6.6H13.2189C13.1612 6.78478 13.0895 6.99578 13.0025 7.22211C12.7032 8.00031 12.2402 8.91125 11.5757 9.57574L10 11.1515L9.42426 10.5757C8.72102 9.8725 8.25297 9.16987 7.96199 8.64611C7.81668 8.38455 7.71617 8.16874 7.65305 8.02146C7.62151 7.94787 7.59937 7.89154 7.5857 7.85534C7.57886 7.83725 7.57415 7.8242 7.57144 7.81657L7.56886 7.80922C7.56886 7.80922 7.56921 7.81026 7 8C6.43079 8.18974 6.43091 8.19009 6.43091 8.19009L6.43133 8.19135L6.43206 8.19351L6.4341 8.19948L6.44052 8.21786C6.44587 8.23292 6.45336 8.25357 6.46313 8.27942C6.48266 8.33112 6.5113 8.40369 6.55008 8.49416C6.62758 8.67501 6.74582 8.92795 6.91301 9.22889C7.24703 9.83013 7.77898 10.6275 8.57574 11.4243L9.15147 12L4.57964 16.5718L4.57655 16.5749L4.57577 16.5757L5.4243 17.4242L5.42688 17.4216L10.0368 12.8117L12.6159 14.9609L13.3841 14.0391L10.8888 11.9597L12.4243 10.4243C13.2598 9.58875 13.7968 8.49969 14.1225 7.65289C14.2818 7.23863 14.395 6.87072 14.4696 6.6H16V5.4H10.6V4H9.4V5.4ZM17.4405 10L21.553 19.7672H20.2509L19.1279 17.1H14.8721L13.7491 19.7672H12.447L16.5595 10H17.4405ZM15.3773 15.9H18.6227L17 12.0462L15.3773 15.9Z",
          fill: "currentColor"
        }
      )
    }
  );
});
TranslateIcon.displayName = "ForwardRef(TranslateIcon)";
const TrashIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "trash",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5 6.5H20M10 6.5V4.5C10 3.94772 10.4477 3.5 11 3.5H14C14.5523 3.5 15 3.94772 15 4.5V6.5M12.5 9V17M15.5 9L15 17M9.5 9L10 17M18.5 6.5L17.571 18.5767C17.5309 19.0977 17.0965 19.5 16.574 19.5H8.42603C7.90349 19.5 7.46905 19.0977 7.42898 18.5767L6.5 6.5H18.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TrashIcon.displayName = "ForwardRef(TrashIcon)";
const TrendUpwardIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "trend-upward",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.5 18.5L11.5 10.5L13.5 14.5L20.5 6.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M20.5 11V6.5H16", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
TrendUpwardIcon.displayName = "ForwardRef(TrendUpwardIcon)";
const TriangleOutlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "triangle-outline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M20.5 18.5H4.5L12.5 5.5L20.5 18.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TriangleOutlineIcon.displayName = "ForwardRef(TriangleOutlineIcon)";
const TrolleyIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "trolley",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 17.5L5.81763 6.26772C5.71013 5.81757 5.30779 5.5 4.84498 5.5H3M8 17.5H17M8 17.5C8.82843 17.5 9.5 18.1716 9.5 19C9.5 19.8284 8.82843 20.5 8 20.5C7.17157 20.5 6.5 19.8284 6.5 19C6.5 18.1716 7.17157 17.5 8 17.5ZM17 17.5C17.8284 17.5 18.5 18.1716 18.5 19C18.5 19.8284 17.8284 20.5 17 20.5C16.1716 20.5 15.5 19.8284 15.5 19C15.5 18.1716 16.1716 17.5 17 17.5ZM7.78357 14.5H17.5L19 7.5H6",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TrolleyIcon.displayName = "ForwardRef(TrolleyIcon)";
const TruncateIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "truncate",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M5 12.5H20M8.5 19.5L12.5 15.5L16.5 19.5M16.5 5.5L12.5 9.5L8.5 5.5",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
TruncateIcon.displayName = "ForwardRef(TruncateIcon)";
const TwitterIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "twitter",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M18.8738 6.65751C18.1994 5.9447 17.2445 5.5 16.1857 5.5C14.1423 5.5 12.4857 7.15655 12.4857 9.2C12.4857 9.55263 12.535 9.89374 12.6272 10.2168C7.0826 9.56422 4.55703 6.02857 4.55703 6.02857C4.55703 6.02857 4.02846 9.2 6.14274 11.3143C5.08571 11.3143 4.55703 10.7857 4.55703 10.7857C4.55703 10.7857 4.55703 13.4286 7.19989 14.4857C6.67143 15.0143 5.61417 14.4857 5.61417 14.4857C5.97533 15.9303 7.45606 16.8562 8.82133 17.1358C6.67298 19.1676 3.5 18.7143 3.5 18.7143C5.14562 19.771 7.21334 20.3 9.31429 20.3C16.1214 20.3 19.8162 15.6315 19.8848 9.37762C20.8722 8.58943 22 7.08571 22 7.08571C22 7.08571 21.277 7.45458 19.6913 7.98315C21.277 6.92601 21.4714 5.5 21.4714 5.5C21.4714 5.5 20.4135 6.55789 18.8738 6.65751Z",
          fill: "currentColor"
        }
      )
    }
  );
});
TwitterIcon.displayName = "ForwardRef(TwitterIcon)";
const UlistIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "ulist",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.10153 17.5001C7.10153 17.8323 6.83221 18.1016 6.5 18.1016C6.16778 18.1016 5.89847 17.8323 5.89847 17.5001C5.89847 17.1678 6.16778 16.8985 6.5 16.8985C6.83221 16.8985 7.10153 17.1678 7.10153 17.5001Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.10153 7.5C7.10153 7.83221 6.83221 8.10153 6.5 8.10153C6.16778 8.10153 5.89847 7.83221 5.89847 7.5C5.89847 7.16778 6.16778 6.89847 6.5 6.89847C6.83221 6.89847 7.10153 7.16778 7.10153 7.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.10153 12.5C7.10153 12.8322 6.83221 13.1015 6.5 13.1015C6.16778 13.1015 5.89847 12.8322 5.89847 12.5C5.89847 12.1678 6.16778 11.8985 6.5 11.8985C6.83221 11.8985 7.10153 12.1678 7.10153 12.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10 7.5H19M10 17.5H19M10 12.5H19",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
UlistIcon.displayName = "ForwardRef(UlistIcon)";
const UnarchiveIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "unarchive",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 10.5V18M20.5 7.5V20.5H4.5V7.5L7.5 4.5H17.5L20.5 7.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M4.5 7.5H20.5M16 14L12.5 10.5L9 14",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
UnarchiveIcon.displayName = "ForwardRef(UnarchiveIcon)";
const UnderlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "underline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M9.52791 7.11407H8.17V14.2582C8.17 16.5817 9.79195 18.2565 12.4927 18.2565C15.1934 18.2565 16.8154 16.5817 16.8154 14.2582V7.11407H15.4574V14.1677C15.4574 15.8122 14.3787 17.0042 12.4927 17.0042C10.6067 17.0042 9.52791 15.8122 9.52791 14.1677V7.11407Z",
            fill: "currentColor"
          }
        ),
        /* @__PURE__ */ jsx("path", { d: "M7 20.5H18", stroke: "currentColor", strokeWidth: 1.2, strokeLinejoin: "round" })
      ]
    }
  );
});
UnderlineIcon.displayName = "ForwardRef(UnderlineIcon)";
const UndoIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "undo",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6 9.5L15 9.5C17.4853 9.5 19.5 11.5147 19.5 14C19.5 16.4853 17.4853 18.5 15 18.5H6",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M10 13.5L6 9.5L10 5.5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
UndoIcon.displayName = "ForwardRef(UndoIcon)";
const UnknownIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "unknown",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 13C12.5 11 14 11.5 14 10C14 9.34375 13.5 8.5 12.5 8.5C11.5 8.5 11 9 10.5 9.5M12.5 16V14.5M5.5 5.5H19.5V19.5H5.5V5.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
UnknownIcon.displayName = "ForwardRef(UnknownIcon)";
const UnlinkIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "unlink",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M15 13.5L17.5 11C18.281 10.219 18.281 8.78105 17.5 8L17 7.5C16.2189 6.71895 14.781 6.71895 14 7.5L11.5 10M10 11.5L7.5 14C6.71896 14.781 6.71895 16.219 7.5 17L8 17.5C8.78105 18.281 10.2189 18.281 11 17.5L13.5 15M9.5 8V5M8 9.5H5M17 15.5H20M15.5 17V20",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
UnlinkIcon.displayName = "ForwardRef(UnlinkIcon)";
const UnlockIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "unlock",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M9.5 11.5V8.5C9.5 6.5 8 5.5 6.5 5.5C5 5.5 3.5 6.5 3.5 8.5V11.5M7.5 11.5H17.5V19.5H7.5V11.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
UnlockIcon.displayName = "ForwardRef(UnlockIcon)";
const UnpublishIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "unpublish",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M5 19.5H20M12.5 16V5",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M17.5 11L12.5 16L7.5 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
UnpublishIcon.displayName = "ForwardRef(UnpublishIcon)";
const UploadIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsxs(
    "svg",
    {
      "data-sanity-icon": "upload",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: [
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M12.5 6.00003V15.5M5.5 15.5H19.5V19.5H5.5V15.5Z",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        ),
        /* @__PURE__ */ jsx(
          "path",
          {
            d: "M7.5 11L12.5 6.00003L17.5 11",
            stroke: "currentColor",
            strokeWidth: 1.2,
            strokeLinejoin: "round"
          }
        )
      ]
    }
  );
});
UploadIcon.displayName = "ForwardRef(UploadIcon)";
const UserIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "user",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M8 14.5C7 15 5.5 16 5.5 19.5H19.5C19.5 16 18.3416 15.1708 17 14.5C16 14 14 14 14 12.5C14 11 15 10.25 15 8.25C15 6.25 14 5.25 12.5 5.25C11 5.25 10 6.25 10 8.25C10 10.25 11 11 11 12.5C11 14 9 14 8 14.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
UserIcon.displayName = "ForwardRef(UserIcon)";
const UsersIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "users",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17.5 18.5H21.5C21.5 15 20.8416 14.1708 19.5 13.5C18.5 13 16.5 12.5 16.5 11C16.5 9.5 17.5 9 17.5 7C17.5 5 16.5 4 15 4C13.6628 4 12.723 4.79472 12.5347 6.38415M4.5 20.5C4.5 17 5.5 16 6.5 15.5C7.5 15 9.5 14.5 9.5 13C9.5 11.5 8.5 11 8.5 9C8.5 7 9.5 6 11 6C12.5 6 13.5 7 13.5 9C13.5 11 12.5 11.5 12.5 13C12.5 14.5 14.5 15 15.5 15.5C16.8416 16.1708 17.5 17 17.5 20.5H4.5Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
UsersIcon.displayName = "ForwardRef(UsersIcon)";
const WarningFilledIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "warning-filled",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          fillRule: "evenodd",
          clipRule: "evenodd",
          d: "M14.741 5.12637C13.7357 3.41737 11.2643 3.41737 10.259 5.12637L3.7558 16.1818C2.73624 17.915 3.98595 20.1 5.99683 20.1H19.0032C21.014 20.1 22.2637 17.915 21.2442 16.1818L14.741 5.12637ZM11.9 9V13H13.1V9H11.9ZM13.1 16V14.5H11.9V16H13.1Z",
          fill: "currentColor"
        }
      )
    }
  );
});
WarningFilledIcon.displayName = "ForwardRef(WarningFilledIcon)";
const WarningOutlineIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "warning-outline",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M12.5 9V13M12.5 16V14.5M14.2239 5.43058L20.727 16.486C21.5113 17.8192 20.55 19.5 19.0032 19.5H5.99683C4.45 19.5 3.48869 17.8192 4.27297 16.486L10.7761 5.43058C11.5494 4.11596 13.4506 4.11596 14.2239 5.43058Z",
          stroke: "currentColor",
          strokeWidth: 1.2,
          strokeLinejoin: "round"
        }
      )
    }
  );
});
WarningOutlineIcon.displayName = "ForwardRef(WarningOutlineIcon)";
const WrenchIcon = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(
    "svg",
    {
      "data-sanity-icon": "wrench",
      width: "1em",
      height: "1em",
      viewBox: "0 0 25 25",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      ref,
      ...props,
      children: /* @__PURE__ */ jsx(
        "path",
        {
          d: "M17.0407 5.14624L17.4649 5.57051C17.6166 5.41887 17.6758 5.19783 17.6202 4.99071C17.5646 4.78359 17.4027 4.62189 17.1955 4.56656L17.0407 5.14624ZM14.4013 7.7856L13.9771 7.36134C13.8288 7.50959 13.7687 7.72447 13.8185 7.92813L14.4013 7.7856ZM12.8778 6.26211L12.4535 5.83784L12.4535 5.83784L12.8778 6.26211ZM11.8309 10.6568L12.2552 11.0811C12.4152 10.9211 12.4716 10.6847 12.401 10.4697L11.8309 10.6568ZM5.63925 16.8485L5.21498 16.4242L5.21498 16.4242L5.63925 16.8485ZM5.63925 19.935L6.06351 19.5108L6.06351 19.5108L5.63925 19.935ZM8.72581 19.935L9.15007 20.3593L9.15007 20.3593L8.72581 19.935ZM15.1184 13.5425L15.2301 12.953C15.0351 12.916 14.8344 12.9779 14.6941 13.1182L15.1184 13.5425ZM18.9718 12.3561L18.5475 11.9318L18.5475 11.9318L18.9718 12.3561ZM20.0877 8.19324L20.6674 8.03843C20.612 7.83124 20.4503 7.66934 20.2432 7.61375C20.0361 7.55816 19.815 7.61734 19.6634 7.76897L20.0877 8.19324ZM17.4483 10.8326L17.3058 11.4154C17.5094 11.4652 17.7243 11.4051 17.8726 11.2569L17.4483 10.8326ZM15 10.2339L14.4172 10.3764C14.4704 10.5938 14.6401 10.7635 14.8575 10.8167L15 10.2339ZM16.6164 4.72198L13.9771 7.36134L14.8256 8.20986L17.4649 5.57051L16.6164 4.72198ZM13.3021 6.68637C14.2723 5.71612 15.6467 5.39501 16.8859 5.72593L17.1955 4.56656C15.5595 4.12966 13.7389 4.55245 12.4535 5.83784L13.3021 6.68637ZM12.401 10.4697C11.9779 9.18109 12.2794 7.70907 13.3021 6.68637L12.4535 5.83784C11.0986 7.19284 10.7021 9.14217 11.2608 10.844L12.401 10.4697ZM11.4066 10.2326L5.21498 16.4242L6.06351 17.2727L12.2552 11.0811L11.4066 10.2326ZM5.21498 16.4242C4.12834 17.5109 4.12834 19.2727 5.21498 20.3593L6.06351 19.5108C5.4455 18.8928 5.4455 17.8908 6.06351 17.2727L5.21498 16.4242ZM5.21498 20.3593C6.30163 21.446 8.06343 21.446 9.15007 20.3593L8.30155 19.5108C7.68353 20.1288 6.68153 20.1288 6.06351 19.5108L5.21498 20.3593ZM9.15007 20.3593L15.5426 13.9668L14.6941 13.1182L8.30155 19.5108L9.15007 20.3593ZM18.5475 11.9318C17.6463 12.8331 16.3968 13.1742 15.2301 12.953L15.0066 14.132C16.5466 14.4239 18.2023 13.9741 19.3961 12.7804L18.5475 11.9318ZM19.508 8.34804C19.8389 9.58721 19.5178 10.9616 18.5475 11.9318L19.3961 12.7804C20.6815 11.495 21.1043 9.67445 20.6674 8.03843L19.508 8.34804ZM17.8726 11.2569L20.5119 8.6175L19.6634 7.76897L17.024 10.4083L17.8726 11.2569ZM14.8575 10.8167L17.3058 11.4154L17.5908 10.2498L15.1426 9.65106L14.8575 10.8167ZM13.8185 7.92813L14.4172 10.3764L15.5829 10.0914L14.9841 7.64307L13.8185 7.92813Z",
          fill: "currentColor"
        }
      )
    }
  );
});
WrenchIcon.displayName = "ForwardRef(WrenchIcon)";
const icons = {
  "access-denied": AccessDeniedIcon,
  activity: ActivityIcon,
  "add-circle": AddCircleIcon,
  "add-comment": AddCommentIcon,
  "add-document": AddDocumentIcon,
  add: AddIcon,
  api: ApiIcon,
  archive: ArchiveIcon,
  "arrow-down": ArrowDownIcon,
  "arrow-left": ArrowLeftIcon,
  "arrow-right": ArrowRightIcon,
  "arrow-top-right": ArrowTopRightIcon,
  "arrow-up": ArrowUpIcon,
  asterisk: AsteriskIcon,
  "bar-chart": BarChartIcon,
  basket: BasketIcon,
  bell: BellIcon,
  bill: BillIcon,
  "binary-document": BinaryDocumentIcon,
  "block-content": BlockContentIcon,
  "block-element": BlockElementIcon,
  blockquote: BlockquoteIcon,
  bold: BoldIcon,
  bolt: BoltIcon,
  book: BookIcon,
  bottle: BottleIcon,
  "bulb-filled": BulbFilledIcon,
  "bulb-outline": BulbOutlineIcon,
  calendar: CalendarIcon,
  case: CaseIcon,
  "chart-upward": ChartUpwardIcon,
  "checkmark-circle": CheckmarkCircleIcon,
  checkmark: CheckmarkIcon,
  "chevron-down": ChevronDownIcon,
  "chevron-left": ChevronLeftIcon,
  "chevron-right": ChevronRightIcon,
  "chevron-up": ChevronUpIcon,
  circle: CircleIcon,
  clipboard: ClipboardIcon,
  "clipboard-image": ClipboardImageIcon,
  clock: ClockIcon,
  "close-circle": CloseCircleIcon,
  close: CloseIcon,
  "code-block": CodeBlockIcon,
  code: CodeIcon,
  cog: CogIcon,
  collapse: CollapseIcon,
  "color-wheel": ColorWheelIcon,
  comment: CommentIcon,
  component: ComponentIcon,
  compose: ComposeIcon,
  confetti: ConfettiIcon,
  controls: ControlsIcon,
  copy: CopyIcon,
  "credit-card": CreditCardIcon,
  crop: CropIcon,
  cube: CubeIcon,
  dashboard: DashboardIcon,
  database: DatabaseIcon,
  desktop: DesktopIcon,
  diamond: DiamondIcon,
  document: DocumentIcon,
  "document-pdf": DocumentPdfIcon,
  "document-remove": DocumentRemoveIcon,
  "document-sheet": DocumentSheetIcon,
  "document-text": DocumentTextIcon,
  "document-video": DocumentVideoIcon,
  "document-word": DocumentWordIcon,
  "document-zip": DocumentZipIcon,
  documents: DocumentsIcon,
  dot: DotIcon,
  "double-chevron-down": DoubleChevronDownIcon,
  "double-chevron-left": DoubleChevronLeftIcon,
  "double-chevron-right": DoubleChevronRightIcon,
  "double-chevron-up": DoubleChevronUpIcon,
  download: DownloadIcon,
  "drag-handle": DragHandleIcon,
  drop: DropIcon,
  "earth-americas": EarthAmericasIcon,
  "earth-globe": EarthGlobeIcon,
  edit: EditIcon,
  "ellipsis-horizontal": EllipsisHorizontalIcon,
  "ellipsis-vertical": EllipsisVerticalIcon,
  empty: EmptyIcon,
  enter: EnterIcon,
  "enter-right": EnterRightIcon,
  envelope: EnvelopeIcon,
  equal: EqualIcon,
  "error-filled": ErrorFilledIcon,
  "error-outline": ErrorOutlineIcon,
  expand: ExpandIcon,
  "eye-closed": EyeClosedIcon,
  "eye-open": EyeOpenIcon,
  filter: FilterIcon,
  folder: FolderIcon,
  generate: GenerateIcon,
  groq: GroqIcon,
  hash: HashIcon,
  "heart-filled": HeartFilledIcon,
  heart: HeartIcon,
  "help-circle": HelpCircleIcon,
  highlight: HighlightIcon,
  home: HomeIcon,
  "ice-cream": IceCreamIcon,
  image: ImageIcon,
  "image-remove": ImageRemoveIcon,
  images: ImagesIcon,
  "info-filled": InfoFilledIcon,
  "info-outline": InfoOutlineIcon,
  "inline-element": InlineElementIcon,
  inline: InlineIcon,
  "insert-above": InsertAboveIcon,
  "insert-below": InsertBelowIcon,
  italic: ItalicIcon,
  joystick: JoystickIcon,
  json: JsonIcon,
  launch: LaunchIcon,
  leave: LeaveIcon,
  lemon: LemonIcon,
  link: LinkIcon,
  "link-removed": LinkRemovedIcon,
  lock: LockIcon,
  "logo-js": LogoJsIcon,
  "logo-ts": LogoTsIcon,
  "master-detail": MasterDetailIcon,
  menu: MenuIcon,
  "mobile-device": MobileDeviceIcon,
  moon: MoonIcon,
  number: NumberIcon,
  "ok-hand": OkHandIcon,
  olist: OlistIcon,
  overage: OverageIcon,
  package: PackageIcon,
  "panel-left": PanelLeftIcon,
  "panel-right": PanelRightIcon,
  pause: PauseIcon,
  pin: PinIcon,
  "pin-removed": PinRemovedIcon,
  play: PlayIcon,
  plug: PlugIcon,
  presentation: PresentationIcon,
  "progress-50": Progress50Icon,
  "progress-75": Progress75Icon,
  projects: ProjectsIcon,
  publish: PublishIcon,
  "read-only": ReadOnlyIcon,
  redo: RedoIcon,
  refresh: RefreshIcon,
  "remove-circle": RemoveCircleIcon,
  remove: RemoveIcon,
  reset: ResetIcon,
  restore: RestoreIcon,
  retrieve: RetrieveIcon,
  retry: RetryIcon,
  revert: RevertIcon,
  robot: RobotIcon,
  rocket: RocketIcon,
  schema: SchemaIcon,
  search: SearchIcon,
  select: SelectIcon,
  share: ShareIcon,
  sort: SortIcon,
  sparkle: SparkleIcon,
  sparkles: SparklesIcon,
  spinner: SpinnerIcon,
  "split-horizontal": SplitHorizontalIcon,
  "split-vertical": SplitVerticalIcon,
  square: SquareIcon,
  "stack-compact": StackCompactIcon,
  stack: StackIcon,
  "star-filled": StarFilledIcon,
  star: StarIcon,
  stop: StopIcon,
  strikethrough: StrikethroughIcon,
  string: StringIcon,
  sun: SunIcon,
  sync: SyncIcon,
  "tablet-device": TabletDeviceIcon,
  tag: TagIcon,
  tags: TagsIcon,
  task: TaskIcon,
  terminal: TerminalIcon,
  text: TextIcon,
  "th-large": ThLargeIcon,
  "th-list": ThListIcon,
  tiers: TiersIcon,
  "toggle-arrow-right": ToggleArrowRightIcon,
  token: TokenIcon,
  transfer: TransferIcon,
  translate: TranslateIcon,
  trash: TrashIcon,
  "trend-upward": TrendUpwardIcon,
  "triangle-outline": TriangleOutlineIcon,
  trolley: TrolleyIcon,
  truncate: TruncateIcon,
  twitter: TwitterIcon,
  ulist: UlistIcon,
  unarchive: UnarchiveIcon,
  underline: UnderlineIcon,
  undo: UndoIcon,
  unknown: UnknownIcon,
  unlink: UnlinkIcon,
  unlock: UnlockIcon,
  unpublish: UnpublishIcon,
  upload: UploadIcon,
  user: UserIcon,
  users: UsersIcon,
  "warning-filled": WarningFilledIcon,
  "warning-outline": WarningOutlineIcon,
  wrench: WrenchIcon
}, Icon = forwardRef(function(props, ref) {
  const { symbol, ...restProps } = props, IconComponent = icons[symbol];
  return IconComponent ? /* @__PURE__ */ jsx(IconComponent, { ...restProps, ref }) : null;
});
Icon.displayName = "ForwardRef(Icon)";
var immutable = extend, hasOwnProperty = Object.prototype.hasOwnProperty;
function extend() {
  for (var target2 = {}, i = 0; i < arguments.length; i++) {
    var source = arguments[i];
    for (var key2 in source)
      hasOwnProperty.call(source, key2) && (target2[key2] = source[key2]);
  }
  return target2;
}
var schema$1 = Schema$2, proto$1 = Schema$2.prototype;
proto$1.space = null;
proto$1.normal = {};
proto$1.property = {};
function Schema$2(property, normal, space2) {
  this.property = property, this.normal = normal, space2 && (this.space = space2);
}
var xtend = immutable, Schema$1 = schema$1, merge_1 = merge$1;
function merge$1(definitions) {
  for (var length2 = definitions.length, property = [], normal = [], index2 = -1, info2, space2; ++index2 < length2; )
    info2 = definitions[index2], property.push(info2.property), normal.push(info2.normal), space2 = info2.space;
  return new Schema$1(
    xtend.apply(null, property),
    xtend.apply(null, normal),
    space2
  );
}
var normalize_1 = normalize$3;
function normalize$3(value) {
  return value.toLowerCase();
}
var info = Info$2, proto = Info$2.prototype;
proto.space = null;
proto.attribute = null;
proto.property = null;
proto.boolean = !1;
proto.booleanish = !1;
proto.overloadedBoolean = !1;
proto.number = !1;
proto.commaSeparated = !1;
proto.spaceSeparated = !1;
proto.commaOrSpaceSeparated = !1;
proto.mustUseProperty = !1;
proto.defined = !1;
function Info$2(property, attribute) {
  this.property = property, this.attribute = attribute;
}
var types$4 = {}, powers = 0;
types$4.boolean = increment();
types$4.booleanish = increment();
types$4.overloadedBoolean = increment();
types$4.number = increment();
types$4.spaceSeparated = increment();
types$4.commaSeparated = increment();
types$4.commaOrSpaceSeparated = increment();
function increment() {
  return Math.pow(2, ++powers);
}
var Info$1 = info, types$3 = types$4, definedInfo = DefinedInfo$2;
DefinedInfo$2.prototype = new Info$1();
DefinedInfo$2.prototype.defined = !0;
var checks = [
  "boolean",
  "booleanish",
  "overloadedBoolean",
  "number",
  "commaSeparated",
  "spaceSeparated",
  "commaOrSpaceSeparated"
], checksLength = checks.length;
function DefinedInfo$2(property, attribute, mask, space2) {
  var index2 = -1, check2;
  for (mark(this, "space", space2), Info$1.call(this, property, attribute); ++index2 < checksLength; )
    check2 = checks[index2], mark(this, check2, (mask & types$3[check2]) === types$3[check2]);
}
function mark(values, key2, value) {
  value && (values[key2] = value);
}
var normalize$2 = normalize_1, Schema = schema$1, DefinedInfo$1 = definedInfo, create_1 = create$5;
function create$5(definition) {
  var space2 = definition.space, mustUseProperty = definition.mustUseProperty || [], attributes2 = definition.attributes || {}, props = definition.properties, transform = definition.transform, property = {}, normal = {}, prop2, info2;
  for (prop2 in props)
    info2 = new DefinedInfo$1(
      prop2,
      transform(attributes2, prop2),
      props[prop2],
      space2
    ), mustUseProperty.indexOf(prop2) !== -1 && (info2.mustUseProperty = !0), property[prop2] = info2, normal[normalize$2(prop2)] = prop2, normal[normalize$2(info2.attribute)] = prop2;
  return new Schema(property, normal, space2);
}
var create$4 = create_1, xlink$1 = create$4({
  space: "xlink",
  transform: xlinkTransform,
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
});
function xlinkTransform(_2, prop2) {
  return "xlink:" + prop2.slice(5).toLowerCase();
}
var create$3 = create_1, xml$1 = create$3({
  space: "xml",
  transform: xmlTransform,
  properties: {
    xmlLang: null,
    xmlBase: null,
    xmlSpace: null
  }
});
function xmlTransform(_2, prop2) {
  return "xml:" + prop2.slice(3).toLowerCase();
}
var caseSensitiveTransform_1 = caseSensitiveTransform$1;
function caseSensitiveTransform$1(attributes2, attribute) {
  return attribute in attributes2 ? attributes2[attribute] : attribute;
}
var caseSensitiveTransform = caseSensitiveTransform_1, caseInsensitiveTransform_1 = caseInsensitiveTransform$2;
function caseInsensitiveTransform$2(attributes2, property) {
  return caseSensitiveTransform(attributes2, property.toLowerCase());
}
var create$2 = create_1, caseInsensitiveTransform$1 = caseInsensitiveTransform_1, xmlns$1 = create$2({
  space: "xmlns",
  attributes: {
    xmlnsxlink: "xmlns:xlink"
  },
  transform: caseInsensitiveTransform$1,
  properties: {
    xmlns: null,
    xmlnsXLink: null
  }
}), types$2 = types$4, create$1 = create_1, booleanish$1 = types$2.booleanish, number$2 = types$2.number, spaceSeparated$1 = types$2.spaceSeparated, aria$1 = create$1({
  transform: ariaTransform,
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish$1,
    ariaAutoComplete: null,
    ariaBusy: booleanish$1,
    ariaChecked: booleanish$1,
    ariaColCount: number$2,
    ariaColIndex: number$2,
    ariaColSpan: number$2,
    ariaControls: spaceSeparated$1,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated$1,
    ariaDetails: null,
    ariaDisabled: booleanish$1,
    ariaDropEffect: spaceSeparated$1,
    ariaErrorMessage: null,
    ariaExpanded: booleanish$1,
    ariaFlowTo: spaceSeparated$1,
    ariaGrabbed: booleanish$1,
    ariaHasPopup: null,
    ariaHidden: booleanish$1,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated$1,
    ariaLevel: number$2,
    ariaLive: null,
    ariaModal: booleanish$1,
    ariaMultiLine: booleanish$1,
    ariaMultiSelectable: booleanish$1,
    ariaOrientation: null,
    ariaOwns: spaceSeparated$1,
    ariaPlaceholder: null,
    ariaPosInSet: number$2,
    ariaPressed: booleanish$1,
    ariaReadOnly: booleanish$1,
    ariaRelevant: null,
    ariaRequired: booleanish$1,
    ariaRoleDescription: spaceSeparated$1,
    ariaRowCount: number$2,
    ariaRowIndex: number$2,
    ariaRowSpan: number$2,
    ariaSelected: booleanish$1,
    ariaSetSize: number$2,
    ariaSort: null,
    ariaValueMax: number$2,
    ariaValueMin: number$2,
    ariaValueNow: number$2,
    ariaValueText: null,
    role: null
  }
});
function ariaTransform(_2, prop2) {
  return prop2 === "role" ? prop2 : "aria-" + prop2.slice(4).toLowerCase();
}
var types$1 = types$4, create = create_1, caseInsensitiveTransform = caseInsensitiveTransform_1, boolean = types$1.boolean, overloadedBoolean = types$1.overloadedBoolean, booleanish = types$1.booleanish, number$1 = types$1.number, spaceSeparated = types$1.spaceSeparated, commaSeparated = types$1.commaSeparated, html$2 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    capture: boolean,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number$1,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number$1 | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number$1,
    hidden: boolean,
    high: number$1,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: commaSeparated,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number$1,
    manifest: null,
    max: null,
    maxLength: number$1,
    media: null,
    method: null,
    min: null,
    minLength: number$1,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforePrint: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextMenu: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number$1,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number$1,
    rowSpan: number$1,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shape: null,
    size: number$1,
    sizes: null,
    slot: null,
    span: number$1,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: commaSeparated,
    start: number$1,
    step: null,
    style: null,
    tabIndex: number$1,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number$1,
    wrap: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number$1,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number$1,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number$1,
    // `<img>` and `<object>`
    leftMargin: number$1,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number$1,
    // `<body>`
    marginWidth: number$1,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number$1,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number$1,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number$1,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number$1,
    security: null,
    unselectable: null
  }
}), merge = merge_1, xlink = xlink$1, xml = xml$1, xmlns = xmlns$1, aria = aria$1, html$1 = html$2, html_1$1 = merge([xml, xlink, xmlns, aria, html$1]), normalize$1 = normalize_1, DefinedInfo = definedInfo, Info = info, data = "data", find_1 = find$1, valid = /^data[-\w.:]+$/i, dash$1 = /-[a-z]/g, cap$1 = /[A-Z]/g;
function find$1(schema2, value) {
  var normal = normalize$1(value), prop2 = value, Type = Info;
  return normal in schema2.normal ? schema2.property[schema2.normal[normal]] : (normal.length > 4 && normal.slice(0, 4) === data && valid.test(value) && (value.charAt(4) === "-" ? prop2 = datasetToProperty(value) : value = datasetToAttribute(value), Type = DefinedInfo), new Type(prop2, value));
}
function datasetToProperty(attribute) {
  var value = attribute.slice(5).replace(dash$1, camelcase);
  return data + value.charAt(0).toUpperCase() + value.slice(1);
}
function datasetToAttribute(property) {
  var value = property.slice(4);
  return dash$1.test(value) ? property : (value = value.replace(cap$1, kebab), value.charAt(0) !== "-" && (value = "-" + value), data + value);
}
function kebab($0) {
  return "-" + $0.toLowerCase();
}
function camelcase($0) {
  return $0.charAt(1).toUpperCase();
}
var hastUtilParseSelector = parse$3, search = /[#.]/g;
function parse$3(selector, defaultTagName) {
  for (var value = selector || "", name2 = defaultTagName || "div", props = {}, start = 0, subvalue, previous, match2; start < value.length; )
    search.lastIndex = start, match2 = search.exec(value), subvalue = value.slice(start, match2 ? match2.index : value.length), subvalue && (previous ? previous === "#" ? props.id = subvalue : props.className ? props.className.push(subvalue) : props.className = [subvalue] : name2 = subvalue, start += subvalue.length), match2 && (previous = match2[0], start++);
  return { type: "element", tagName: name2, properties: props, children: [] };
}
var spaceSeparatedTokens = {};
spaceSeparatedTokens.parse = parse$2;
spaceSeparatedTokens.stringify = stringify$2;
var empty$2 = "", space$2 = " ", whiteSpace = /[ \t\n\r\f]+/g;
function parse$2(value) {
  var input = String(value || empty$2).trim();
  return input === empty$2 ? [] : input.split(whiteSpace);
}
function stringify$2(values) {
  return values.join(space$2).trim();
}
var commaSeparatedTokens = {};
commaSeparatedTokens.parse = parse$1;
commaSeparatedTokens.stringify = stringify$1;
var comma$1 = ",", space$1 = " ", empty$1 = "";
function parse$1(value) {
  for (var values = [], input = String(value || empty$1), index2 = input.indexOf(comma$1), lastIndex = 0, end = !1, val; !end; )
    index2 === -1 && (index2 = input.length, end = !0), val = input.slice(lastIndex, index2).trim(), (val || !end) && values.push(val), lastIndex = index2 + 1, index2 = input.indexOf(comma$1, lastIndex);
  return values;
}
function stringify$1(values, options) {
  var settings = options || {}, left = settings.padLeft === !1 ? empty$1 : space$1, right = settings.padRight ? space$1 : empty$1;
  return values[values.length - 1] === empty$1 && (values = values.concat(empty$1)), values.join(right + comma$1 + left).trim();
}
var find = find_1, normalize = normalize_1, parseSelector = hastUtilParseSelector, spaces = spaceSeparatedTokens.parse, commas = commaSeparatedTokens.parse, factory_1 = factory$1, own$4 = {}.hasOwnProperty;
function factory$1(schema2, defaultTagName, caseSensitive) {
  var adjust = caseSensitive ? createAdjustMap(caseSensitive) : null;
  return h2;
  function h2(selector, properties) {
    var node2 = parseSelector(selector, defaultTagName), children = Array.prototype.slice.call(arguments, 2), name2 = node2.tagName.toLowerCase(), property;
    if (node2.tagName = adjust && own$4.call(adjust, name2) ? adjust[name2] : name2, properties && isChildren(properties, node2) && (children.unshift(properties), properties = null), properties)
      for (property in properties)
        addProperty(node2.properties, property, properties[property]);
    return addChild(node2.children, children), node2.tagName === "template" && (node2.content = { type: "root", children: node2.children }, node2.children = []), node2;
  }
  function addProperty(properties, key2, value) {
    var info2, property, result;
    value == null || value !== value || (info2 = find(schema2, key2), property = info2.property, result = value, typeof result == "string" && (info2.spaceSeparated ? result = spaces(result) : info2.commaSeparated ? result = commas(result) : info2.commaOrSpaceSeparated && (result = spaces(commas(result).join(" ")))), property === "style" && typeof value != "string" && (result = style(result)), property === "className" && properties.className && (result = properties.className.concat(result)), properties[property] = parsePrimitives(info2, property, result));
  }
}
function isChildren(value, node2) {
  return typeof value == "string" || "length" in value || isNode$1(node2.tagName, value);
}
function isNode$1(tagName, value) {
  var type = value.type;
  return tagName === "input" || !type || typeof type != "string" ? !1 : typeof value.children == "object" && "length" in value.children ? !0 : (type = type.toLowerCase(), tagName === "button" ? type !== "menu" && type !== "submit" && type !== "reset" && type !== "button" : "value" in value);
}
function addChild(nodes, value) {
  var index2, length2;
  if (typeof value == "string" || typeof value == "number") {
    nodes.push({ type: "text", value: String(value) });
    return;
  }
  if (typeof value == "object" && "length" in value) {
    for (index2 = -1, length2 = value.length; ++index2 < length2; )
      addChild(nodes, value[index2]);
    return;
  }
  if (typeof value != "object" || !("type" in value))
    throw new Error("Expected node, nodes, or string, got `" + value + "`");
  nodes.push(value);
}
function parsePrimitives(info2, name2, value) {
  var index2, length2, result;
  if (typeof value != "object" || !("length" in value))
    return parsePrimitive(info2, name2, value);
  for (length2 = value.length, index2 = -1, result = []; ++index2 < length2; )
    result[index2] = parsePrimitive(info2, name2, value[index2]);
  return result;
}
function parsePrimitive(info2, name2, value) {
  var result = value;
  return info2.number || info2.positiveNumber ? !isNaN(result) && result !== "" && (result = Number(result)) : (info2.boolean || info2.overloadedBoolean) && typeof result == "string" && (result === "" || normalize(value) === normalize(name2)) && (result = !0), result;
}
function style(value) {
  var result = [], key2;
  for (key2 in value)
    result.push([key2, value[key2]].join(": "));
  return result.join("; ");
}
function createAdjustMap(values) {
  for (var length2 = values.length, index2 = -1, result = {}, value; ++index2 < length2; )
    value = values[index2], result[value.toLowerCase()] = value;
  return result;
}
var schema = html_1$1, factory = factory_1, html = factory(schema, "div");
html.displayName = "html";
var html_1 = html, hastscript = html_1, AElig$1 = "\xC6", AMP$1 = "&", Aacute$1 = "\xC1", Acirc$1 = "\xC2", Agrave$1 = "\xC0", Aring$1 = "\xC5", Atilde$1 = "\xC3", Auml$1 = "\xC4", COPY$1 = "\xA9", Ccedil$1 = "\xC7", ETH$1 = "\xD0", Eacute$1 = "\xC9", Ecirc$1 = "\xCA", Egrave$1 = "\xC8", Euml$1 = "\xCB", GT$1 = ">", Iacute$1 = "\xCD", Icirc$1 = "\xCE", Igrave$1 = "\xCC", Iuml$1 = "\xCF", LT$1 = "<", Ntilde$1 = "\xD1", Oacute$1 = "\xD3", Ocirc$1 = "\xD4", Ograve$1 = "\xD2", Oslash$1 = "\xD8", Otilde$1 = "\xD5", Ouml$1 = "\xD6", QUOT$1 = '"', REG$1 = "\xAE", THORN$1 = "\xDE", Uacute$1 = "\xDA", Ucirc$1 = "\xDB", Ugrave$1 = "\xD9", Uuml$1 = "\xDC", Yacute$1 = "\xDD", aacute$1 = "\xE1", acirc$1 = "\xE2", acute$1 = "\xB4", aelig$1 = "\xE6", agrave$1 = "\xE0", amp$1 = "&", aring$1 = "\xE5", atilde$1 = "\xE3", auml$1 = "\xE4", brvbar$1 = "\xA6", ccedil$1 = "\xE7", cedil$1 = "\xB8", cent$1 = "\xA2", copy$1 = "\xA9", curren$1 = "\xA4", deg$1 = "\xB0", divide$1 = "\xF7", eacute$1 = "\xE9", ecirc$1 = "\xEA", egrave$1 = "\xE8", eth$1 = "\xF0", euml$1 = "\xEB", frac12$1 = "\xBD", frac14$1 = "\xBC", frac34$1 = "\xBE", gt$1 = ">", iacute$1 = "\xED", icirc$1 = "\xEE", iexcl$1 = "\xA1", igrave$1 = "\xEC", iquest$1 = "\xBF", iuml$1 = "\xEF", laquo$1 = "\xAB", lt$1 = "<", macr$1 = "\xAF", micro$1 = "\xB5", middot$1 = "\xB7", nbsp$1 = "\xA0", not$1 = "\xAC", ntilde$1 = "\xF1", oacute$1 = "\xF3", ocirc$1 = "\xF4", ograve$1 = "\xF2", ordf$1 = "\xAA", ordm$1 = "\xBA", oslash$1 = "\xF8", otilde$1 = "\xF5", ouml$1 = "\xF6", para$1 = "\xB6", plusmn$1 = "\xB1", pound$1 = "\xA3", quot$1 = '"', raquo$1 = "\xBB", reg$1 = "\xAE", sect$1 = "\xA7", shy$1 = "\xAD", sup1$1 = "\xB9", sup2$1 = "\xB2", sup3$1 = "\xB3", szlig$1 = "\xDF", thorn$1 = "\xFE", times$1 = "\xD7", uacute$1 = "\xFA", ucirc$1 = "\xFB", ugrave$1 = "\xF9", uml$1 = "\xA8", uuml$1 = "\xFC", yacute$1 = "\xFD", yen$1 = "\xA5", yuml$1 = "\xFF", require$$0$1 = {
  AElig: AElig$1,
  AMP: AMP$1,
  Aacute: Aacute$1,
  Acirc: Acirc$1,
  Agrave: Agrave$1,
  Aring: Aring$1,
  Atilde: Atilde$1,
  Auml: Auml$1,
  COPY: COPY$1,
  Ccedil: Ccedil$1,
  ETH: ETH$1,
  Eacute: Eacute$1,
  Ecirc: Ecirc$1,
  Egrave: Egrave$1,
  Euml: Euml$1,
  GT: GT$1,
  Iacute: Iacute$1,
  Icirc: Icirc$1,
  Igrave: Igrave$1,
  Iuml: Iuml$1,
  LT: LT$1,
  Ntilde: Ntilde$1,
  Oacute: Oacute$1,
  Ocirc: Ocirc$1,
  Ograve: Ograve$1,
  Oslash: Oslash$1,
  Otilde: Otilde$1,
  Ouml: Ouml$1,
  QUOT: QUOT$1,
  REG: REG$1,
  THORN: THORN$1,
  Uacute: Uacute$1,
  Ucirc: Ucirc$1,
  Ugrave: Ugrave$1,
  Uuml: Uuml$1,
  Yacute: Yacute$1,
  aacute: aacute$1,
  acirc: acirc$1,
  acute: acute$1,
  aelig: aelig$1,
  agrave: agrave$1,
  amp: amp$1,
  aring: aring$1,
  atilde: atilde$1,
  auml: auml$1,
  brvbar: brvbar$1,
  ccedil: ccedil$1,
  cedil: cedil$1,
  cent: cent$1,
  copy: copy$1,
  curren: curren$1,
  deg: deg$1,
  divide: divide$1,
  eacute: eacute$1,
  ecirc: ecirc$1,
  egrave: egrave$1,
  eth: eth$1,
  euml: euml$1,
  frac12: frac12$1,
  frac14: frac14$1,
  frac34: frac34$1,
  gt: gt$1,
  iacute: iacute$1,
  icirc: icirc$1,
  iexcl: iexcl$1,
  igrave: igrave$1,
  iquest: iquest$1,
  iuml: iuml$1,
  laquo: laquo$1,
  lt: lt$1,
  macr: macr$1,
  micro: micro$1,
  middot: middot$1,
  nbsp: nbsp$1,
  not: not$1,
  ntilde: ntilde$1,
  oacute: oacute$1,
  ocirc: ocirc$1,
  ograve: ograve$1,
  ordf: ordf$1,
  ordm: ordm$1,
  oslash: oslash$1,
  otilde: otilde$1,
  ouml: ouml$1,
  para: para$1,
  plusmn: plusmn$1,
  pound: pound$1,
  quot: quot$1,
  raquo: raquo$1,
  reg: reg$1,
  sect: sect$1,
  shy: shy$1,
  sup1: sup1$1,
  sup2: sup2$1,
  sup3: sup3$1,
  szlig: szlig$1,
  thorn: thorn$1,
  times: times$1,
  uacute: uacute$1,
  ucirc: ucirc$1,
  ugrave: ugrave$1,
  uml: uml$1,
  uuml: uuml$1,
  yacute: yacute$1,
  yen: yen$1,
  yuml: yuml$1
}, require$$1 = {
  0: "\uFFFD",
  128: "\u20AC",
  130: "\u201A",
  131: "\u0192",
  132: "\u201E",
  133: "\u2026",
  134: "\u2020",
  135: "\u2021",
  136: "\u02C6",
  137: "\u2030",
  138: "\u0160",
  139: "\u2039",
  140: "\u0152",
  142: "\u017D",
  145: "\u2018",
  146: "\u2019",
  147: "\u201C",
  148: "\u201D",
  149: "\u2022",
  150: "\u2013",
  151: "\u2014",
  152: "\u02DC",
  153: "\u2122",
  154: "\u0161",
  155: "\u203A",
  156: "\u0153",
  158: "\u017E",
  159: "\u0178"
}, isDecimal = decimal$2;
function decimal$2(character2) {
  var code = typeof character2 == "string" ? character2.charCodeAt(0) : character2;
  return code >= 48 && code <= 57;
}
var isHexadecimal = hexadecimal$1;
function hexadecimal$1(character2) {
  var code = typeof character2 == "string" ? character2.charCodeAt(0) : character2;
  return code >= 97 && code <= 102 || code >= 65 && code <= 70 || code >= 48 && code <= 57;
}
var isAlphabetical = alphabetical$1;
function alphabetical$1(character2) {
  var code = typeof character2 == "string" ? character2.charCodeAt(0) : character2;
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
var alphabetical = isAlphabetical, decimal$1 = isDecimal, isAlphanumerical = alphanumerical$1;
function alphanumerical$1(character2) {
  return alphabetical(character2) || decimal$1(character2);
}
var AEli = "\xC6", AElig = "\xC6", AM = "&", AMP = "&", Aacut = "\xC1", Aacute = "\xC1", Abreve = "\u0102", Acir = "\xC2", Acirc = "\xC2", Acy = "\u0410", Afr = "\u{1D504}", Agrav = "\xC0", Agrave = "\xC0", Alpha = "\u0391", Amacr = "\u0100", And = "\u2A53", Aogon = "\u0104", Aopf = "\u{1D538}", ApplyFunction = "\u2061", Arin = "\xC5", Aring = "\xC5", Ascr = "\u{1D49C}", Assign = "\u2254", Atild = "\xC3", Atilde = "\xC3", Aum = "\xC4", Auml = "\xC4", Backslash = "\u2216", Barv = "\u2AE7", Barwed = "\u2306", Bcy = "\u0411", Because = "\u2235", Bernoullis = "\u212C", Beta = "\u0392", Bfr = "\u{1D505}", Bopf = "\u{1D539}", Breve = "\u02D8", Bscr = "\u212C", Bumpeq = "\u224E", CHcy = "\u0427", COP = "\xA9", COPY = "\xA9", Cacute = "\u0106", Cap = "\u22D2", CapitalDifferentialD = "\u2145", Cayleys = "\u212D", Ccaron = "\u010C", Ccedi = "\xC7", Ccedil = "\xC7", Ccirc = "\u0108", Cconint = "\u2230", Cdot = "\u010A", Cedilla = "\xB8", CenterDot = "\xB7", Cfr = "\u212D", Chi = "\u03A7", CircleDot = "\u2299", CircleMinus = "\u2296", CirclePlus = "\u2295", CircleTimes = "\u2297", ClockwiseContourIntegral = "\u2232", CloseCurlyDoubleQuote = "\u201D", CloseCurlyQuote = "\u2019", Colon = "\u2237", Colone = "\u2A74", Congruent = "\u2261", Conint = "\u222F", ContourIntegral = "\u222E", Copf = "\u2102", Coproduct = "\u2210", CounterClockwiseContourIntegral = "\u2233", Cross = "\u2A2F", Cscr = "\u{1D49E}", Cup = "\u22D3", CupCap = "\u224D", DD = "\u2145", DDotrahd = "\u2911", DJcy = "\u0402", DScy = "\u0405", DZcy = "\u040F", Dagger = "\u2021", Darr = "\u21A1", Dashv = "\u2AE4", Dcaron = "\u010E", Dcy = "\u0414", Del = "\u2207", Delta = "\u0394", Dfr = "\u{1D507}", DiacriticalAcute = "\xB4", DiacriticalDot = "\u02D9", DiacriticalDoubleAcute = "\u02DD", DiacriticalGrave = "`", DiacriticalTilde = "\u02DC", Diamond = "\u22C4", DifferentialD = "\u2146", Dopf = "\u{1D53B}", Dot = "\xA8", DotDot = "\u20DC", DotEqual = "\u2250", DoubleContourIntegral = "\u222F", DoubleDot = "\xA8", DoubleDownArrow = "\u21D3", DoubleLeftArrow = "\u21D0", DoubleLeftRightArrow = "\u21D4", DoubleLeftTee = "\u2AE4", DoubleLongLeftArrow = "\u27F8", DoubleLongLeftRightArrow = "\u27FA", DoubleLongRightArrow = "\u27F9", DoubleRightArrow = "\u21D2", DoubleRightTee = "\u22A8", DoubleUpArrow = "\u21D1", DoubleUpDownArrow = "\u21D5", DoubleVerticalBar = "\u2225", DownArrow = "\u2193", DownArrowBar = "\u2913", DownArrowUpArrow = "\u21F5", DownBreve = "\u0311", DownLeftRightVector = "\u2950", DownLeftTeeVector = "\u295E", DownLeftVector = "\u21BD", DownLeftVectorBar = "\u2956", DownRightTeeVector = "\u295F", DownRightVector = "\u21C1", DownRightVectorBar = "\u2957", DownTee = "\u22A4", DownTeeArrow = "\u21A7", Downarrow = "\u21D3", Dscr = "\u{1D49F}", Dstrok = "\u0110", ENG = "\u014A", ET = "\xD0", ETH = "\xD0", Eacut = "\xC9", Eacute = "\xC9", Ecaron = "\u011A", Ecir = "\xCA", Ecirc = "\xCA", Ecy = "\u042D", Edot = "\u0116", Efr = "\u{1D508}", Egrav = "\xC8", Egrave = "\xC8", Element$1 = "\u2208", Emacr = "\u0112", EmptySmallSquare = "\u25FB", EmptyVerySmallSquare = "\u25AB", Eogon = "\u0118", Eopf = "\u{1D53C}", Epsilon = "\u0395", Equal = "\u2A75", EqualTilde = "\u2242", Equilibrium = "\u21CC", Escr = "\u2130", Esim = "\u2A73", Eta = "\u0397", Eum = "\xCB", Euml = "\xCB", Exists = "\u2203", ExponentialE = "\u2147", Fcy = "\u0424", Ffr = "\u{1D509}", FilledSmallSquare = "\u25FC", FilledVerySmallSquare = "\u25AA", Fopf = "\u{1D53D}", ForAll = "\u2200", Fouriertrf = "\u2131", Fscr = "\u2131", GJcy = "\u0403", G = ">", GT = ">", Gamma = "\u0393", Gammad = "\u03DC", Gbreve = "\u011E", Gcedil = "\u0122", Gcirc = "\u011C", Gcy = "\u0413", Gdot = "\u0120", Gfr = "\u{1D50A}", Gg = "\u22D9", Gopf = "\u{1D53E}", GreaterEqual = "\u2265", GreaterEqualLess = "\u22DB", GreaterFullEqual = "\u2267", GreaterGreater = "\u2AA2", GreaterLess = "\u2277", GreaterSlantEqual = "\u2A7E", GreaterTilde = "\u2273", Gscr = "\u{1D4A2}", Gt = "\u226B", HARDcy = "\u042A", Hacek = "\u02C7", Hat = "^", Hcirc = "\u0124", Hfr = "\u210C", HilbertSpace = "\u210B", Hopf = "\u210D", HorizontalLine = "\u2500", Hscr = "\u210B", Hstrok = "\u0126", HumpDownHump = "\u224E", HumpEqual = "\u224F", IEcy = "\u0415", IJlig = "\u0132", IOcy = "\u0401", Iacut = "\xCD", Iacute = "\xCD", Icir = "\xCE", Icirc = "\xCE", Icy = "\u0418", Idot = "\u0130", Ifr = "\u2111", Igrav = "\xCC", Igrave = "\xCC", Im = "\u2111", Imacr = "\u012A", ImaginaryI = "\u2148", Implies = "\u21D2", Int = "\u222C", Integral = "\u222B", Intersection = "\u22C2", InvisibleComma = "\u2063", InvisibleTimes = "\u2062", Iogon = "\u012E", Iopf = "\u{1D540}", Iota = "\u0399", Iscr = "\u2110", Itilde = "\u0128", Iukcy = "\u0406", Ium = "\xCF", Iuml = "\xCF", Jcirc = "\u0134", Jcy = "\u0419", Jfr = "\u{1D50D}", Jopf = "\u{1D541}", Jscr = "\u{1D4A5}", Jsercy = "\u0408", Jukcy = "\u0404", KHcy = "\u0425", KJcy = "\u040C", Kappa = "\u039A", Kcedil = "\u0136", Kcy = "\u041A", Kfr = "\u{1D50E}", Kopf = "\u{1D542}", Kscr = "\u{1D4A6}", LJcy = "\u0409", L = "<", LT = "<", Lacute = "\u0139", Lambda = "\u039B", Lang = "\u27EA", Laplacetrf = "\u2112", Larr = "\u219E", Lcaron = "\u013D", Lcedil = "\u013B", Lcy = "\u041B", LeftAngleBracket = "\u27E8", LeftArrow = "\u2190", LeftArrowBar = "\u21E4", LeftArrowRightArrow = "\u21C6", LeftCeiling = "\u2308", LeftDoubleBracket = "\u27E6", LeftDownTeeVector = "\u2961", LeftDownVector = "\u21C3", LeftDownVectorBar = "\u2959", LeftFloor = "\u230A", LeftRightArrow = "\u2194", LeftRightVector = "\u294E", LeftTee = "\u22A3", LeftTeeArrow = "\u21A4", LeftTeeVector = "\u295A", LeftTriangle = "\u22B2", LeftTriangleBar = "\u29CF", LeftTriangleEqual = "\u22B4", LeftUpDownVector = "\u2951", LeftUpTeeVector = "\u2960", LeftUpVector = "\u21BF", LeftUpVectorBar = "\u2958", LeftVector = "\u21BC", LeftVectorBar = "\u2952", Leftarrow = "\u21D0", Leftrightarrow = "\u21D4", LessEqualGreater = "\u22DA", LessFullEqual = "\u2266", LessGreater = "\u2276", LessLess = "\u2AA1", LessSlantEqual = "\u2A7D", LessTilde = "\u2272", Lfr = "\u{1D50F}", Ll = "\u22D8", Lleftarrow = "\u21DA", Lmidot = "\u013F", LongLeftArrow = "\u27F5", LongLeftRightArrow = "\u27F7", LongRightArrow = "\u27F6", Longleftarrow = "\u27F8", Longleftrightarrow = "\u27FA", Longrightarrow = "\u27F9", Lopf = "\u{1D543}", LowerLeftArrow = "\u2199", LowerRightArrow = "\u2198", Lscr = "\u2112", Lsh = "\u21B0", Lstrok = "\u0141", Lt = "\u226A", Mcy = "\u041C", MediumSpace = "\u205F", Mellintrf = "\u2133", Mfr = "\u{1D510}", MinusPlus = "\u2213", Mopf = "\u{1D544}", Mscr = "\u2133", Mu = "\u039C", NJcy = "\u040A", Nacute = "\u0143", Ncaron = "\u0147", Ncedil = "\u0145", Ncy = "\u041D", NegativeMediumSpace = "\u200B", NegativeThickSpace = "\u200B", NegativeThinSpace = "\u200B", NegativeVeryThinSpace = "\u200B", NestedGreaterGreater = "\u226B", NestedLessLess = "\u226A", NewLine = `
`, Nfr = "\u{1D511}", NoBreak = "\u2060", NonBreakingSpace = "\xA0", Nopf = "\u2115", Not = "\u2AEC", NotCongruent = "\u2262", NotCupCap = "\u226D", NotDoubleVerticalBar = "\u2226", NotElement = "\u2209", NotEqual = "\u2260", NotEqualTilde = "\u2242\u0338", NotExists = "\u2204", NotGreater = "\u226F", NotGreaterEqual = "\u2271", NotGreaterFullEqual = "\u2267\u0338", NotGreaterGreater = "\u226B\u0338", NotGreaterLess = "\u2279", NotGreaterSlantEqual = "\u2A7E\u0338", NotGreaterTilde = "\u2275", NotHumpDownHump = "\u224E\u0338", NotHumpEqual = "\u224F\u0338", NotLeftTriangle = "\u22EA", NotLeftTriangleBar = "\u29CF\u0338", NotLeftTriangleEqual = "\u22EC", NotLess = "\u226E", NotLessEqual = "\u2270", NotLessGreater = "\u2278", NotLessLess = "\u226A\u0338", NotLessSlantEqual = "\u2A7D\u0338", NotLessTilde = "\u2274", NotNestedGreaterGreater = "\u2AA2\u0338", NotNestedLessLess = "\u2AA1\u0338", NotPrecedes = "\u2280", NotPrecedesEqual = "\u2AAF\u0338", NotPrecedesSlantEqual = "\u22E0", NotReverseElement = "\u220C", NotRightTriangle = "\u22EB", NotRightTriangleBar = "\u29D0\u0338", NotRightTriangleEqual = "\u22ED", NotSquareSubset = "\u228F\u0338", NotSquareSubsetEqual = "\u22E2", NotSquareSuperset = "\u2290\u0338", NotSquareSupersetEqual = "\u22E3", NotSubset = "\u2282\u20D2", NotSubsetEqual = "\u2288", NotSucceeds = "\u2281", NotSucceedsEqual = "\u2AB0\u0338", NotSucceedsSlantEqual = "\u22E1", NotSucceedsTilde = "\u227F\u0338", NotSuperset = "\u2283\u20D2", NotSupersetEqual = "\u2289", NotTilde = "\u2241", NotTildeEqual = "\u2244", NotTildeFullEqual = "\u2247", NotTildeTilde = "\u2249", NotVerticalBar = "\u2224", Nscr = "\u{1D4A9}", Ntild = "\xD1", Ntilde = "\xD1", Nu = "\u039D", OElig = "\u0152", Oacut = "\xD3", Oacute = "\xD3", Ocir = "\xD4", Ocirc = "\xD4", Ocy = "\u041E", Odblac = "\u0150", Ofr = "\u{1D512}", Ograv = "\xD2", Ograve = "\xD2", Omacr = "\u014C", Omega = "\u03A9", Omicron = "\u039F", Oopf = "\u{1D546}", OpenCurlyDoubleQuote = "\u201C", OpenCurlyQuote = "\u2018", Or = "\u2A54", Oscr = "\u{1D4AA}", Oslas = "\xD8", Oslash = "\xD8", Otild = "\xD5", Otilde = "\xD5", Otimes = "\u2A37", Oum = "\xD6", Ouml = "\xD6", OverBar = "\u203E", OverBrace = "\u23DE", OverBracket = "\u23B4", OverParenthesis = "\u23DC", PartialD = "\u2202", Pcy = "\u041F", Pfr = "\u{1D513}", Phi = "\u03A6", Pi = "\u03A0", PlusMinus = "\xB1", Poincareplane = "\u210C", Popf = "\u2119", Pr = "\u2ABB", Precedes = "\u227A", PrecedesEqual = "\u2AAF", PrecedesSlantEqual = "\u227C", PrecedesTilde = "\u227E", Prime = "\u2033", Product = "\u220F", Proportion = "\u2237", Proportional = "\u221D", Pscr = "\u{1D4AB}", Psi = "\u03A8", QUO = '"', QUOT = '"', Qfr = "\u{1D514}", Qopf = "\u211A", Qscr = "\u{1D4AC}", RBarr = "\u2910", RE = "\xAE", REG = "\xAE", Racute = "\u0154", Rang = "\u27EB", Rarr = "\u21A0", Rarrtl = "\u2916", Rcaron = "\u0158", Rcedil = "\u0156", Rcy = "\u0420", Re = "\u211C", ReverseElement = "\u220B", ReverseEquilibrium = "\u21CB", ReverseUpEquilibrium = "\u296F", Rfr = "\u211C", Rho = "\u03A1", RightAngleBracket = "\u27E9", RightArrow = "\u2192", RightArrowBar = "\u21E5", RightArrowLeftArrow = "\u21C4", RightCeiling = "\u2309", RightDoubleBracket = "\u27E7", RightDownTeeVector = "\u295D", RightDownVector = "\u21C2", RightDownVectorBar = "\u2955", RightFloor = "\u230B", RightTee = "\u22A2", RightTeeArrow = "\u21A6", RightTeeVector = "\u295B", RightTriangle = "\u22B3", RightTriangleBar = "\u29D0", RightTriangleEqual = "\u22B5", RightUpDownVector = "\u294F", RightUpTeeVector = "\u295C", RightUpVector = "\u21BE", RightUpVectorBar = "\u2954", RightVector = "\u21C0", RightVectorBar = "\u2953", Rightarrow = "\u21D2", Ropf = "\u211D", RoundImplies = "\u2970", Rrightarrow = "\u21DB", Rscr = "\u211B", Rsh = "\u21B1", RuleDelayed = "\u29F4", SHCHcy = "\u0429", SHcy = "\u0428", SOFTcy = "\u042C", Sacute = "\u015A", Sc = "\u2ABC", Scaron = "\u0160", Scedil = "\u015E", Scirc = "\u015C", Scy = "\u0421", Sfr = "\u{1D516}", ShortDownArrow = "\u2193", ShortLeftArrow = "\u2190", ShortRightArrow = "\u2192", ShortUpArrow = "\u2191", Sigma = "\u03A3", SmallCircle = "\u2218", Sopf = "\u{1D54A}", Sqrt = "\u221A", Square = "\u25A1", SquareIntersection = "\u2293", SquareSubset = "\u228F", SquareSubsetEqual = "\u2291", SquareSuperset = "\u2290", SquareSupersetEqual = "\u2292", SquareUnion = "\u2294", Sscr = "\u{1D4AE}", Star = "\u22C6", Sub = "\u22D0", Subset = "\u22D0", SubsetEqual = "\u2286", Succeeds = "\u227B", SucceedsEqual = "\u2AB0", SucceedsSlantEqual = "\u227D", SucceedsTilde = "\u227F", SuchThat = "\u220B", Sum = "\u2211", Sup = "\u22D1", Superset = "\u2283", SupersetEqual = "\u2287", Supset = "\u22D1", THOR = "\xDE", THORN = "\xDE", TRADE = "\u2122", TSHcy = "\u040B", TScy = "\u0426", Tab$1 = "	", Tau = "\u03A4", Tcaron = "\u0164", Tcedil = "\u0162", Tcy = "\u0422", Tfr = "\u{1D517}", Therefore = "\u2234", Theta = "\u0398", ThickSpace = "\u205F\u200A", ThinSpace = "\u2009", Tilde = "\u223C", TildeEqual = "\u2243", TildeFullEqual = "\u2245", TildeTilde = "\u2248", Topf = "\u{1D54B}", TripleDot = "\u20DB", Tscr = "\u{1D4AF}", Tstrok = "\u0166", Uacut = "\xDA", Uacute = "\xDA", Uarr = "\u219F", Uarrocir = "\u2949", Ubrcy = "\u040E", Ubreve = "\u016C", Ucir = "\xDB", Ucirc = "\xDB", Ucy = "\u0423", Udblac = "\u0170", Ufr = "\u{1D518}", Ugrav = "\xD9", Ugrave = "\xD9", Umacr = "\u016A", UnderBar = "_", UnderBrace = "\u23DF", UnderBracket = "\u23B5", UnderParenthesis = "\u23DD", Union = "\u22C3", UnionPlus = "\u228E", Uogon = "\u0172", Uopf = "\u{1D54C}", UpArrow = "\u2191", UpArrowBar = "\u2912", UpArrowDownArrow = "\u21C5", UpDownArrow = "\u2195", UpEquilibrium = "\u296E", UpTee = "\u22A5", UpTeeArrow = "\u21A5", Uparrow = "\u21D1", Updownarrow = "\u21D5", UpperLeftArrow = "\u2196", UpperRightArrow = "\u2197", Upsi = "\u03D2", Upsilon = "\u03A5", Uring = "\u016E", Uscr = "\u{1D4B0}", Utilde = "\u0168", Uum = "\xDC", Uuml = "\xDC", VDash = "\u22AB", Vbar = "\u2AEB", Vcy = "\u0412", Vdash = "\u22A9", Vdashl = "\u2AE6", Vee = "\u22C1", Verbar = "\u2016", Vert = "\u2016", VerticalBar = "\u2223", VerticalLine = "|", VerticalSeparator = "\u2758", VerticalTilde = "\u2240", VeryThinSpace = "\u200A", Vfr = "\u{1D519}", Vopf = "\u{1D54D}", Vscr = "\u{1D4B1}", Vvdash = "\u22AA", Wcirc = "\u0174", Wedge = "\u22C0", Wfr = "\u{1D51A}", Wopf = "\u{1D54E}", Wscr = "\u{1D4B2}", Xfr = "\u{1D51B}", Xi = "\u039E", Xopf = "\u{1D54F}", Xscr = "\u{1D4B3}", YAcy = "\u042F", YIcy = "\u0407", YUcy = "\u042E", Yacut = "\xDD", Yacute = "\xDD", Ycirc = "\u0176", Ycy = "\u042B", Yfr = "\u{1D51C}", Yopf = "\u{1D550}", Yscr = "\u{1D4B4}", Yuml = "\u0178", ZHcy = "\u0416", Zacute = "\u0179", Zcaron = "\u017D", Zcy = "\u0417", Zdot = "\u017B", ZeroWidthSpace = "\u200B", Zeta = "\u0396", Zfr = "\u2128", Zopf = "\u2124", Zscr = "\u{1D4B5}", aacut = "\xE1", aacute = "\xE1", abreve = "\u0103", ac = "\u223E", acE = "\u223E\u0333", acd = "\u223F", acir = "\xE2", acirc = "\xE2", acut = "\xB4", acute = "\xB4", acy = "\u0430", aeli = "\xE6", aelig = "\xE6", af = "\u2061", afr = "\u{1D51E}", agrav = "\xE0", agrave = "\xE0", alefsym = "\u2135", aleph = "\u2135", alpha$1 = "\u03B1", amacr = "\u0101", amalg = "\u2A3F", am = "&", amp = "&", and = "\u2227", andand = "\u2A55", andd = "\u2A5C", andslope = "\u2A58", andv = "\u2A5A", ang = "\u2220", ange = "\u29A4", angle = "\u2220", angmsd = "\u2221", angmsdaa = "\u29A8", angmsdab = "\u29A9", angmsdac = "\u29AA", angmsdad = "\u29AB", angmsdae = "\u29AC", angmsdaf = "\u29AD", angmsdag = "\u29AE", angmsdah = "\u29AF", angrt = "\u221F", angrtvb = "\u22BE", angrtvbd = "\u299D", angsph = "\u2222", angst = "\xC5", angzarr = "\u237C", aogon = "\u0105", aopf = "\u{1D552}", ap = "\u2248", apE = "\u2A70", apacir = "\u2A6F", ape = "\u224A", apid = "\u224B", apos = "'", approx = "\u2248", approxeq = "\u224A", arin = "\xE5", aring = "\xE5", ascr = "\u{1D4B6}", ast = "*", asymp = "\u2248", asympeq = "\u224D", atild = "\xE3", atilde = "\xE3", aum = "\xE4", auml = "\xE4", awconint = "\u2233", awint = "\u2A11", bNot = "\u2AED", backcong = "\u224C", backepsilon = "\u03F6", backprime = "\u2035", backsim = "\u223D", backsimeq = "\u22CD", barvee = "\u22BD", barwed = "\u2305", barwedge = "\u2305", bbrk = "\u23B5", bbrktbrk = "\u23B6", bcong = "\u224C", bcy = "\u0431", bdquo = "\u201E", becaus = "\u2235", because = "\u2235", bemptyv = "\u29B0", bepsi = "\u03F6", bernou = "\u212C", beta = "\u03B2", beth = "\u2136", between = "\u226C", bfr = "\u{1D51F}", bigcap = "\u22C2", bigcirc = "\u25EF", bigcup = "\u22C3", bigodot = "\u2A00", bigoplus = "\u2A01", bigotimes = "\u2A02", bigsqcup = "\u2A06", bigstar = "\u2605", bigtriangledown = "\u25BD", bigtriangleup = "\u25B3", biguplus = "\u2A04", bigvee = "\u22C1", bigwedge = "\u22C0", bkarow = "\u290D", blacklozenge = "\u29EB", blacksquare = "\u25AA", blacktriangle = "\u25B4", blacktriangledown = "\u25BE", blacktriangleleft = "\u25C2", blacktriangleright = "\u25B8", blank = "\u2423", blk12 = "\u2592", blk14 = "\u2591", blk34 = "\u2593", block = "\u2588", bne = "=\u20E5", bnequiv = "\u2261\u20E5", bnot = "\u2310", bopf = "\u{1D553}", bot = "\u22A5", bottom = "\u22A5", bowtie = "\u22C8", boxDL = "\u2557", boxDR = "\u2554", boxDl = "\u2556", boxDr = "\u2553", boxH = "\u2550", boxHD = "\u2566", boxHU = "\u2569", boxHd = "\u2564", boxHu = "\u2567", boxUL = "\u255D", boxUR = "\u255A", boxUl = "\u255C", boxUr = "\u2559", boxV = "\u2551", boxVH = "\u256C", boxVL = "\u2563", boxVR = "\u2560", boxVh = "\u256B", boxVl = "\u2562", boxVr = "\u255F", boxbox = "\u29C9", boxdL = "\u2555", boxdR = "\u2552", boxdl = "\u2510", boxdr = "\u250C", boxh = "\u2500", boxhD = "\u2565", boxhU = "\u2568", boxhd = "\u252C", boxhu = "\u2534", boxminus = "\u229F", boxplus = "\u229E", boxtimes = "\u22A0", boxuL = "\u255B", boxuR = "\u2558", boxul = "\u2518", boxur = "\u2514", boxv = "\u2502", boxvH = "\u256A", boxvL = "\u2561", boxvR = "\u255E", boxvh = "\u253C", boxvl = "\u2524", boxvr = "\u251C", bprime = "\u2035", breve = "\u02D8", brvba = "\xA6", brvbar = "\xA6", bscr = "\u{1D4B7}", bsemi = "\u204F", bsim = "\u223D", bsime = "\u22CD", bsol = "\\", bsolb = "\u29C5", bsolhsub = "\u27C8", bull = "\u2022", bullet = "\u2022", bump = "\u224E", bumpE = "\u2AAE", bumpe = "\u224F", bumpeq = "\u224F", cacute = "\u0107", cap = "\u2229", capand = "\u2A44", capbrcup = "\u2A49", capcap = "\u2A4B", capcup = "\u2A47", capdot = "\u2A40", caps = "\u2229\uFE00", caret = "\u2041", caron = "\u02C7", ccaps = "\u2A4D", ccaron = "\u010D", ccedi = "\xE7", ccedil = "\xE7", ccirc = "\u0109", ccups = "\u2A4C", ccupssm = "\u2A50", cdot = "\u010B", cedi = "\xB8", cedil = "\xB8", cemptyv = "\u29B2", cen = "\xA2", cent = "\xA2", centerdot = "\xB7", cfr = "\u{1D520}", chcy = "\u0447", check = "\u2713", checkmark = "\u2713", chi = "\u03C7", cir = "\u25CB", cirE = "\u29C3", circ = "\u02C6", circeq = "\u2257", circlearrowleft = "\u21BA", circlearrowright = "\u21BB", circledR = "\xAE", circledS = "\u24C8", circledast = "\u229B", circledcirc = "\u229A", circleddash = "\u229D", cire = "\u2257", cirfnint = "\u2A10", cirmid = "\u2AEF", cirscir = "\u29C2", clubs = "\u2663", clubsuit = "\u2663", colon = ":", colone = "\u2254", coloneq = "\u2254", comma = ",", commat = "@", comp = "\u2201", compfn = "\u2218", complement = "\u2201", complexes = "\u2102", cong = "\u2245", congdot = "\u2A6D", conint = "\u222E", copf = "\u{1D554}", coprod = "\u2210", cop = "\xA9", copy = "\xA9", copysr = "\u2117", crarr = "\u21B5", cross = "\u2717", cscr = "\u{1D4B8}", csub = "\u2ACF", csube = "\u2AD1", csup = "\u2AD0", csupe = "\u2AD2", ctdot = "\u22EF", cudarrl = "\u2938", cudarrr = "\u2935", cuepr = "\u22DE", cuesc = "\u22DF", cularr = "\u21B6", cularrp = "\u293D", cup = "\u222A", cupbrcap = "\u2A48", cupcap = "\u2A46", cupcup = "\u2A4A", cupdot = "\u228D", cupor = "\u2A45", cups = "\u222A\uFE00", curarr = "\u21B7", curarrm = "\u293C", curlyeqprec = "\u22DE", curlyeqsucc = "\u22DF", curlyvee = "\u22CE", curlywedge = "\u22CF", curre = "\xA4", curren = "\xA4", curvearrowleft = "\u21B6", curvearrowright = "\u21B7", cuvee = "\u22CE", cuwed = "\u22CF", cwconint = "\u2232", cwint = "\u2231", cylcty = "\u232D", dArr = "\u21D3", dHar = "\u2965", dagger = "\u2020", daleth = "\u2138", darr = "\u2193", dash = "\u2010", dashv = "\u22A3", dbkarow = "\u290F", dblac = "\u02DD", dcaron = "\u010F", dcy = "\u0434", dd = "\u2146", ddagger = "\u2021", ddarr = "\u21CA", ddotseq = "\u2A77", de = "\xB0", deg = "\xB0", delta = "\u03B4", demptyv = "\u29B1", dfisht = "\u297F", dfr = "\u{1D521}", dharl = "\u21C3", dharr = "\u21C2", diam = "\u22C4", diamond = "\u22C4", diamondsuit = "\u2666", diams = "\u2666", die = "\xA8", digamma = "\u03DD", disin = "\u22F2", div = "\xF7", divid = "\xF7", divide = "\xF7", divideontimes = "\u22C7", divonx = "\u22C7", djcy = "\u0452", dlcorn = "\u231E", dlcrop = "\u230D", dollar = "$", dopf = "\u{1D555}", dot = "\u02D9", doteq = "\u2250", doteqdot = "\u2251", dotminus = "\u2238", dotplus = "\u2214", dotsquare = "\u22A1", doublebarwedge = "\u2306", downarrow = "\u2193", downdownarrows = "\u21CA", downharpoonleft = "\u21C3", downharpoonright = "\u21C2", drbkarow = "\u2910", drcorn = "\u231F", drcrop = "\u230C", dscr = "\u{1D4B9}", dscy = "\u0455", dsol = "\u29F6", dstrok = "\u0111", dtdot = "\u22F1", dtri = "\u25BF", dtrif = "\u25BE", duarr = "\u21F5", duhar = "\u296F", dwangle = "\u29A6", dzcy = "\u045F", dzigrarr = "\u27FF", eDDot = "\u2A77", eDot = "\u2251", eacut = "\xE9", eacute = "\xE9", easter = "\u2A6E", ecaron = "\u011B", ecir = "\xEA", ecirc = "\xEA", ecolon = "\u2255", ecy = "\u044D", edot = "\u0117", ee = "\u2147", efDot = "\u2252", efr = "\u{1D522}", eg = "\u2A9A", egrav = "\xE8", egrave = "\xE8", egs = "\u2A96", egsdot = "\u2A98", el = "\u2A99", elinters = "\u23E7", ell = "\u2113", els = "\u2A95", elsdot = "\u2A97", emacr = "\u0113", empty = "\u2205", emptyset = "\u2205", emptyv = "\u2205", emsp13 = "\u2004", emsp14 = "\u2005", emsp = "\u2003", eng = "\u014B", ensp = "\u2002", eogon = "\u0119", eopf = "\u{1D556}", epar = "\u22D5", eparsl = "\u29E3", eplus = "\u2A71", epsi = "\u03B5", epsilon = "\u03B5", epsiv = "\u03F5", eqcirc = "\u2256", eqcolon = "\u2255", eqsim = "\u2242", eqslantgtr = "\u2A96", eqslantless = "\u2A95", equals = "=", equest = "\u225F", equiv = "\u2261", equivDD = "\u2A78", eqvparsl = "\u29E5", erDot = "\u2253", erarr = "\u2971", escr = "\u212F", esdot = "\u2250", esim = "\u2242", eta = "\u03B7", et = "\xF0", eth = "\xF0", eum = "\xEB", euml = "\xEB", euro = "\u20AC", excl = "!", exist = "\u2203", expectation = "\u2130", exponentiale = "\u2147", fallingdotseq = "\u2252", fcy = "\u0444", female = "\u2640", ffilig = "\uFB03", fflig = "\uFB00", ffllig = "\uFB04", ffr = "\u{1D523}", filig = "\uFB01", fjlig = "fj", flat = "\u266D", fllig = "\uFB02", fltns = "\u25B1", fnof = "\u0192", fopf = "\u{1D557}", forall = "\u2200", fork = "\u22D4", forkv = "\u2AD9", fpartint = "\u2A0D", frac1 = "\xBC", frac12 = "\xBD", frac13 = "\u2153", frac14 = "\xBC", frac15 = "\u2155", frac16 = "\u2159", frac18 = "\u215B", frac23 = "\u2154", frac25 = "\u2156", frac3 = "\xBE", frac34 = "\xBE", frac35 = "\u2157", frac38 = "\u215C", frac45 = "\u2158", frac56 = "\u215A", frac58 = "\u215D", frac78 = "\u215E", frasl = "\u2044", frown = "\u2322", fscr = "\u{1D4BB}", gE = "\u2267", gEl = "\u2A8C", gacute = "\u01F5", gamma = "\u03B3", gammad = "\u03DD", gap = "\u2A86", gbreve = "\u011F", gcirc = "\u011D", gcy = "\u0433", gdot = "\u0121", ge = "\u2265", gel = "\u22DB", geq = "\u2265", geqq = "\u2267", geqslant = "\u2A7E", ges = "\u2A7E", gescc = "\u2AA9", gesdot = "\u2A80", gesdoto = "\u2A82", gesdotol = "\u2A84", gesl = "\u22DB\uFE00", gesles = "\u2A94", gfr = "\u{1D524}", gg = "\u226B", ggg = "\u22D9", gimel = "\u2137", gjcy = "\u0453", gl = "\u2277", glE = "\u2A92", gla = "\u2AA5", glj = "\u2AA4", gnE = "\u2269", gnap = "\u2A8A", gnapprox = "\u2A8A", gne = "\u2A88", gneq = "\u2A88", gneqq = "\u2269", gnsim = "\u22E7", gopf = "\u{1D558}", grave = "`", gscr = "\u210A", gsim = "\u2273", gsime = "\u2A8E", gsiml = "\u2A90", g = ">", gt = ">", gtcc = "\u2AA7", gtcir = "\u2A7A", gtdot = "\u22D7", gtlPar = "\u2995", gtquest = "\u2A7C", gtrapprox = "\u2A86", gtrarr = "\u2978", gtrdot = "\u22D7", gtreqless = "\u22DB", gtreqqless = "\u2A8C", gtrless = "\u2277", gtrsim = "\u2273", gvertneqq = "\u2269\uFE00", gvnE = "\u2269\uFE00", hArr = "\u21D4", hairsp = "\u200A", half = "\xBD", hamilt = "\u210B", hardcy = "\u044A", harr = "\u2194", harrcir = "\u2948", harrw = "\u21AD", hbar = "\u210F", hcirc = "\u0125", hearts = "\u2665", heartsuit = "\u2665", hellip = "\u2026", hercon = "\u22B9", hfr = "\u{1D525}", hksearow = "\u2925", hkswarow = "\u2926", hoarr = "\u21FF", homtht = "\u223B", hookleftarrow = "\u21A9", hookrightarrow = "\u21AA", hopf = "\u{1D559}", horbar = "\u2015", hscr = "\u{1D4BD}", hslash = "\u210F", hstrok = "\u0127", hybull = "\u2043", hyphen = "\u2010", iacut = "\xED", iacute = "\xED", ic = "\u2063", icir = "\xEE", icirc = "\xEE", icy = "\u0438", iecy = "\u0435", iexc = "\xA1", iexcl = "\xA1", iff = "\u21D4", ifr = "\u{1D526}", igrav = "\xEC", igrave = "\xEC", ii = "\u2148", iiiint = "\u2A0C", iiint = "\u222D", iinfin = "\u29DC", iiota = "\u2129", ijlig = "\u0133", imacr = "\u012B", image = "\u2111", imagline = "\u2110", imagpart = "\u2111", imath = "\u0131", imof = "\u22B7", imped = "\u01B5", incare = "\u2105", infin = "\u221E", infintie = "\u29DD", inodot = "\u0131", int$1 = "\u222B", intcal = "\u22BA", integers = "\u2124", intercal = "\u22BA", intlarhk = "\u2A17", intprod = "\u2A3C", iocy = "\u0451", iogon = "\u012F", iopf = "\u{1D55A}", iota = "\u03B9", iprod = "\u2A3C", iques = "\xBF", iquest = "\xBF", iscr = "\u{1D4BE}", isin = "\u2208", isinE = "\u22F9", isindot = "\u22F5", isins = "\u22F4", isinsv = "\u22F3", isinv = "\u2208", it = "\u2062", itilde = "\u0129", iukcy = "\u0456", ium = "\xEF", iuml = "\xEF", jcirc = "\u0135", jcy = "\u0439", jfr = "\u{1D527}", jmath = "\u0237", jopf = "\u{1D55B}", jscr = "\u{1D4BF}", jsercy = "\u0458", jukcy = "\u0454", kappa = "\u03BA", kappav = "\u03F0", kcedil = "\u0137", kcy = "\u043A", kfr = "\u{1D528}", kgreen = "\u0138", khcy = "\u0445", kjcy = "\u045C", kopf = "\u{1D55C}", kscr = "\u{1D4C0}", lAarr = "\u21DA", lArr = "\u21D0", lAtail = "\u291B", lBarr = "\u290E", lE = "\u2266", lEg = "\u2A8B", lHar = "\u2962", lacute = "\u013A", laemptyv = "\u29B4", lagran = "\u2112", lambda = "\u03BB", lang = "\u27E8", langd = "\u2991", langle = "\u27E8", lap = "\u2A85", laqu = "\xAB", laquo = "\xAB", larr = "\u2190", larrb = "\u21E4", larrbfs = "\u291F", larrfs = "\u291D", larrhk = "\u21A9", larrlp = "\u21AB", larrpl = "\u2939", larrsim = "\u2973", larrtl = "\u21A2", lat = "\u2AAB", latail = "\u2919", late = "\u2AAD", lates = "\u2AAD\uFE00", lbarr = "\u290C", lbbrk = "\u2772", lbrace = "{", lbrack = "[", lbrke = "\u298B", lbrksld = "\u298F", lbrkslu = "\u298D", lcaron = "\u013E", lcedil = "\u013C", lceil = "\u2308", lcub = "{", lcy = "\u043B", ldca = "\u2936", ldquo = "\u201C", ldquor = "\u201E", ldrdhar = "\u2967", ldrushar = "\u294B", ldsh = "\u21B2", le = "\u2264", leftarrow = "\u2190", leftarrowtail = "\u21A2", leftharpoondown = "\u21BD", leftharpoonup = "\u21BC", leftleftarrows = "\u21C7", leftrightarrow = "\u2194", leftrightarrows = "\u21C6", leftrightharpoons = "\u21CB", leftrightsquigarrow = "\u21AD", leftthreetimes = "\u22CB", leg = "\u22DA", leq = "\u2264", leqq = "\u2266", leqslant = "\u2A7D", les = "\u2A7D", lescc = "\u2AA8", lesdot = "\u2A7F", lesdoto = "\u2A81", lesdotor = "\u2A83", lesg = "\u22DA\uFE00", lesges = "\u2A93", lessapprox = "\u2A85", lessdot = "\u22D6", lesseqgtr = "\u22DA", lesseqqgtr = "\u2A8B", lessgtr = "\u2276", lesssim = "\u2272", lfisht = "\u297C", lfloor = "\u230A", lfr = "\u{1D529}", lg = "\u2276", lgE = "\u2A91", lhard = "\u21BD", lharu = "\u21BC", lharul = "\u296A", lhblk = "\u2584", ljcy = "\u0459", ll = "\u226A", llarr = "\u21C7", llcorner = "\u231E", llhard = "\u296B", lltri = "\u25FA", lmidot = "\u0140", lmoust = "\u23B0", lmoustache = "\u23B0", lnE = "\u2268", lnap = "\u2A89", lnapprox = "\u2A89", lne = "\u2A87", lneq = "\u2A87", lneqq = "\u2268", lnsim = "\u22E6", loang = "\u27EC", loarr = "\u21FD", lobrk = "\u27E6", longleftarrow = "\u27F5", longleftrightarrow = "\u27F7", longmapsto = "\u27FC", longrightarrow = "\u27F6", looparrowleft = "\u21AB", looparrowright = "\u21AC", lopar = "\u2985", lopf = "\u{1D55D}", loplus = "\u2A2D", lotimes = "\u2A34", lowast = "\u2217", lowbar = "_", loz = "\u25CA", lozenge = "\u25CA", lozf = "\u29EB", lpar = "(", lparlt = "\u2993", lrarr = "\u21C6", lrcorner = "\u231F", lrhar = "\u21CB", lrhard = "\u296D", lrm = "\u200E", lrtri = "\u22BF", lsaquo = "\u2039", lscr = "\u{1D4C1}", lsh = "\u21B0", lsim = "\u2272", lsime = "\u2A8D", lsimg = "\u2A8F", lsqb = "[", lsquo = "\u2018", lsquor = "\u201A", lstrok = "\u0142", l = "<", lt = "<", ltcc = "\u2AA6", ltcir = "\u2A79", ltdot = "\u22D6", lthree = "\u22CB", ltimes = "\u22C9", ltlarr = "\u2976", ltquest = "\u2A7B", ltrPar = "\u2996", ltri = "\u25C3", ltrie = "\u22B4", ltrif = "\u25C2", lurdshar = "\u294A", luruhar = "\u2966", lvertneqq = "\u2268\uFE00", lvnE = "\u2268\uFE00", mDDot = "\u223A", mac = "\xAF", macr = "\xAF", male = "\u2642", malt = "\u2720", maltese = "\u2720", map$1 = "\u21A6", mapsto = "\u21A6", mapstodown = "\u21A7", mapstoleft = "\u21A4", mapstoup = "\u21A5", marker = "\u25AE", mcomma = "\u2A29", mcy = "\u043C", mdash = "\u2014", measuredangle = "\u2221", mfr = "\u{1D52A}", mho = "\u2127", micr = "\xB5", micro = "\xB5", mid = "\u2223", midast = "*", midcir = "\u2AF0", middo = "\xB7", middot = "\xB7", minus = "\u2212", minusb = "\u229F", minusd = "\u2238", minusdu = "\u2A2A", mlcp = "\u2ADB", mldr = "\u2026", mnplus = "\u2213", models = "\u22A7", mopf = "\u{1D55E}", mp = "\u2213", mscr = "\u{1D4C2}", mstpos = "\u223E", mu = "\u03BC", multimap = "\u22B8", mumap = "\u22B8", nGg = "\u22D9\u0338", nGt = "\u226B\u20D2", nGtv = "\u226B\u0338", nLeftarrow = "\u21CD", nLeftrightarrow = "\u21CE", nLl = "\u22D8\u0338", nLt = "\u226A\u20D2", nLtv = "\u226A\u0338", nRightarrow = "\u21CF", nVDash = "\u22AF", nVdash = "\u22AE", nabla = "\u2207", nacute = "\u0144", nang = "\u2220\u20D2", nap = "\u2249", napE = "\u2A70\u0338", napid = "\u224B\u0338", napos = "\u0149", napprox = "\u2249", natur = "\u266E", natural = "\u266E", naturals = "\u2115", nbs = "\xA0", nbsp = "\xA0", nbump = "\u224E\u0338", nbumpe = "\u224F\u0338", ncap = "\u2A43", ncaron = "\u0148", ncedil = "\u0146", ncong = "\u2247", ncongdot = "\u2A6D\u0338", ncup = "\u2A42", ncy = "\u043D", ndash = "\u2013", ne = "\u2260", neArr = "\u21D7", nearhk = "\u2924", nearr = "\u2197", nearrow = "\u2197", nedot = "\u2250\u0338", nequiv = "\u2262", nesear = "\u2928", nesim = "\u2242\u0338", nexist = "\u2204", nexists = "\u2204", nfr = "\u{1D52B}", ngE = "\u2267\u0338", nge = "\u2271", ngeq = "\u2271", ngeqq = "\u2267\u0338", ngeqslant = "\u2A7E\u0338", nges = "\u2A7E\u0338", ngsim = "\u2275", ngt = "\u226F", ngtr = "\u226F", nhArr = "\u21CE", nharr = "\u21AE", nhpar = "\u2AF2", ni = "\u220B", nis = "\u22FC", nisd = "\u22FA", niv = "\u220B", njcy = "\u045A", nlArr = "\u21CD", nlE = "\u2266\u0338", nlarr = "\u219A", nldr = "\u2025", nle = "\u2270", nleftarrow = "\u219A", nleftrightarrow = "\u21AE", nleq = "\u2270", nleqq = "\u2266\u0338", nleqslant = "\u2A7D\u0338", nles = "\u2A7D\u0338", nless = "\u226E", nlsim = "\u2274", nlt = "\u226E", nltri = "\u22EA", nltrie = "\u22EC", nmid = "\u2224", nopf = "\u{1D55F}", no = "\xAC", not = "\xAC", notin = "\u2209", notinE = "\u22F9\u0338", notindot = "\u22F5\u0338", notinva = "\u2209", notinvb = "\u22F7", notinvc = "\u22F6", notni = "\u220C", notniva = "\u220C", notnivb = "\u22FE", notnivc = "\u22FD", npar = "\u2226", nparallel = "\u2226", nparsl = "\u2AFD\u20E5", npart = "\u2202\u0338", npolint = "\u2A14", npr = "\u2280", nprcue = "\u22E0", npre = "\u2AAF\u0338", nprec = "\u2280", npreceq = "\u2AAF\u0338", nrArr = "\u21CF", nrarr = "\u219B", nrarrc = "\u2933\u0338", nrarrw = "\u219D\u0338", nrightarrow = "\u219B", nrtri = "\u22EB", nrtrie = "\u22ED", nsc = "\u2281", nsccue = "\u22E1", nsce = "\u2AB0\u0338", nscr = "\u{1D4C3}", nshortmid = "\u2224", nshortparallel = "\u2226", nsim = "\u2241", nsime = "\u2244", nsimeq = "\u2244", nsmid = "\u2224", nspar = "\u2226", nsqsube = "\u22E2", nsqsupe = "\u22E3", nsub = "\u2284", nsubE = "\u2AC5\u0338", nsube = "\u2288", nsubset = "\u2282\u20D2", nsubseteq = "\u2288", nsubseteqq = "\u2AC5\u0338", nsucc = "\u2281", nsucceq = "\u2AB0\u0338", nsup = "\u2285", nsupE = "\u2AC6\u0338", nsupe = "\u2289", nsupset = "\u2283\u20D2", nsupseteq = "\u2289", nsupseteqq = "\u2AC6\u0338", ntgl = "\u2279", ntild = "\xF1", ntilde = "\xF1", ntlg = "\u2278", ntriangleleft = "\u22EA", ntrianglelefteq = "\u22EC", ntriangleright = "\u22EB", ntrianglerighteq = "\u22ED", nu = "\u03BD", num = "#", numero = "\u2116", numsp = "\u2007", nvDash = "\u22AD", nvHarr = "\u2904", nvap = "\u224D\u20D2", nvdash = "\u22AC", nvge = "\u2265\u20D2", nvgt = ">\u20D2", nvinfin = "\u29DE", nvlArr = "\u2902", nvle = "\u2264\u20D2", nvlt = "<\u20D2", nvltrie = "\u22B4\u20D2", nvrArr = "\u2903", nvrtrie = "\u22B5\u20D2", nvsim = "\u223C\u20D2", nwArr = "\u21D6", nwarhk = "\u2923", nwarr = "\u2196", nwarrow = "\u2196", nwnear = "\u2927", oS = "\u24C8", oacut = "\xF3", oacute = "\xF3", oast = "\u229B", ocir = "\xF4", ocirc = "\xF4", ocy = "\u043E", odash = "\u229D", odblac = "\u0151", odiv = "\u2A38", odot = "\u2299", odsold = "\u29BC", oelig = "\u0153", ofcir = "\u29BF", ofr = "\u{1D52C}", ogon = "\u02DB", ograv = "\xF2", ograve = "\xF2", ogt = "\u29C1", ohbar = "\u29B5", ohm = "\u03A9", oint = "\u222E", olarr = "\u21BA", olcir = "\u29BE", olcross = "\u29BB", oline = "\u203E", olt = "\u29C0", omacr = "\u014D", omega = "\u03C9", omicron = "\u03BF", omid = "\u29B6", ominus = "\u2296", oopf = "\u{1D560}", opar = "\u29B7", operp = "\u29B9", oplus = "\u2295", or = "\u2228", orarr = "\u21BB", ord = "\xBA", order = "\u2134", orderof = "\u2134", ordf = "\xAA", ordm = "\xBA", origof = "\u22B6", oror = "\u2A56", orslope = "\u2A57", orv = "\u2A5B", oscr = "\u2134", oslas = "\xF8", oslash = "\xF8", osol = "\u2298", otild = "\xF5", otilde = "\xF5", otimes = "\u2297", otimesas = "\u2A36", oum = "\xF6", ouml = "\xF6", ovbar = "\u233D", par = "\xB6", para = "\xB6", parallel = "\u2225", parsim = "\u2AF3", parsl = "\u2AFD", part = "\u2202", pcy = "\u043F", percnt = "%", period = ".", permil = "\u2030", perp = "\u22A5", pertenk = "\u2031", pfr = "\u{1D52D}", phi = "\u03C6", phiv = "\u03D5", phmmat = "\u2133", phone = "\u260E", pi = "\u03C0", pitchfork = "\u22D4", piv = "\u03D6", planck = "\u210F", planckh = "\u210E", plankv = "\u210F", plus = "+", plusacir = "\u2A23", plusb = "\u229E", pluscir = "\u2A22", plusdo = "\u2214", plusdu = "\u2A25", pluse = "\u2A72", plusm = "\xB1", plusmn = "\xB1", plussim = "\u2A26", plustwo = "\u2A27", pm = "\xB1", pointint = "\u2A15", popf = "\u{1D561}", poun = "\xA3", pound = "\xA3", pr = "\u227A", prE = "\u2AB3", prap = "\u2AB7", prcue = "\u227C", pre = "\u2AAF", prec = "\u227A", precapprox = "\u2AB7", preccurlyeq = "\u227C", preceq = "\u2AAF", precnapprox = "\u2AB9", precneqq = "\u2AB5", precnsim = "\u22E8", precsim = "\u227E", prime = "\u2032", primes = "\u2119", prnE = "\u2AB5", prnap = "\u2AB9", prnsim = "\u22E8", prod = "\u220F", profalar = "\u232E", profline = "\u2312", profsurf = "\u2313", prop = "\u221D", propto = "\u221D", prsim = "\u227E", prurel = "\u22B0", pscr = "\u{1D4C5}", psi = "\u03C8", puncsp = "\u2008", qfr = "\u{1D52E}", qint = "\u2A0C", qopf = "\u{1D562}", qprime = "\u2057", qscr = "\u{1D4C6}", quaternions = "\u210D", quatint = "\u2A16", quest = "?", questeq = "\u225F", quo = '"', quot = '"', rAarr = "\u21DB", rArr = "\u21D2", rAtail = "\u291C", rBarr = "\u290F", rHar = "\u2964", race = "\u223D\u0331", racute = "\u0155", radic = "\u221A", raemptyv = "\u29B3", rang = "\u27E9", rangd = "\u2992", range = "\u29A5", rangle = "\u27E9", raqu = "\xBB", raquo = "\xBB", rarr = "\u2192", rarrap = "\u2975", rarrb = "\u21E5", rarrbfs = "\u2920", rarrc = "\u2933", rarrfs = "\u291E", rarrhk = "\u21AA", rarrlp = "\u21AC", rarrpl = "\u2945", rarrsim = "\u2974", rarrtl = "\u21A3", rarrw = "\u219D", ratail = "\u291A", ratio = "\u2236", rationals = "\u211A", rbarr = "\u290D", rbbrk = "\u2773", rbrace = "}", rbrack = "]", rbrke = "\u298C", rbrksld = "\u298E", rbrkslu = "\u2990", rcaron = "\u0159", rcedil = "\u0157", rceil = "\u2309", rcub = "}", rcy = "\u0440", rdca = "\u2937", rdldhar = "\u2969", rdquo = "\u201D", rdquor = "\u201D", rdsh = "\u21B3", real = "\u211C", realine = "\u211B", realpart = "\u211C", reals = "\u211D", rect = "\u25AD", re = "\xAE", reg = "\xAE", rfisht = "\u297D", rfloor = "\u230B", rfr = "\u{1D52F}", rhard = "\u21C1", rharu = "\u21C0", rharul = "\u296C", rho = "\u03C1", rhov = "\u03F1", rightarrow = "\u2192", rightarrowtail = "\u21A3", rightharpoondown = "\u21C1", rightharpoonup = "\u21C0", rightleftarrows = "\u21C4", rightleftharpoons = "\u21CC", rightrightarrows = "\u21C9", rightsquigarrow = "\u219D", rightthreetimes = "\u22CC", ring = "\u02DA", risingdotseq = "\u2253", rlarr = "\u21C4", rlhar = "\u21CC", rlm = "\u200F", rmoust = "\u23B1", rmoustache = "\u23B1", rnmid = "\u2AEE", roang = "\u27ED", roarr = "\u21FE", robrk = "\u27E7", ropar = "\u2986", ropf = "\u{1D563}", roplus = "\u2A2E", rotimes = "\u2A35", rpar = ")", rpargt = "\u2994", rppolint = "\u2A12", rrarr = "\u21C9", rsaquo = "\u203A", rscr = "\u{1D4C7}", rsh = "\u21B1", rsqb = "]", rsquo = "\u2019", rsquor = "\u2019", rthree = "\u22CC", rtimes = "\u22CA", rtri = "\u25B9", rtrie = "\u22B5", rtrif = "\u25B8", rtriltri = "\u29CE", ruluhar = "\u2968", rx = "\u211E", sacute = "\u015B", sbquo = "\u201A", sc = "\u227B", scE = "\u2AB4", scap = "\u2AB8", scaron = "\u0161", sccue = "\u227D", sce = "\u2AB0", scedil = "\u015F", scirc = "\u015D", scnE = "\u2AB6", scnap = "\u2ABA", scnsim = "\u22E9", scpolint = "\u2A13", scsim = "\u227F", scy = "\u0441", sdot = "\u22C5", sdotb = "\u22A1", sdote = "\u2A66", seArr = "\u21D8", searhk = "\u2925", searr = "\u2198", searrow = "\u2198", sec = "\xA7", sect = "\xA7", semi = ";", seswar = "\u2929", setminus = "\u2216", setmn = "\u2216", sext = "\u2736", sfr = "\u{1D530}", sfrown = "\u2322", sharp = "\u266F", shchcy = "\u0449", shcy = "\u0448", shortmid = "\u2223", shortparallel = "\u2225", sh = "\xAD", shy = "\xAD", sigma = "\u03C3", sigmaf = "\u03C2", sigmav = "\u03C2", sim = "\u223C", simdot = "\u2A6A", sime = "\u2243", simeq = "\u2243", simg = "\u2A9E", simgE = "\u2AA0", siml = "\u2A9D", simlE = "\u2A9F", simne = "\u2246", simplus = "\u2A24", simrarr = "\u2972", slarr = "\u2190", smallsetminus = "\u2216", smashp = "\u2A33", smeparsl = "\u29E4", smid = "\u2223", smile = "\u2323", smt = "\u2AAA", smte = "\u2AAC", smtes = "\u2AAC\uFE00", softcy = "\u044C", sol = "/", solb = "\u29C4", solbar = "\u233F", sopf = "\u{1D564}", spades = "\u2660", spadesuit = "\u2660", spar = "\u2225", sqcap = "\u2293", sqcaps = "\u2293\uFE00", sqcup = "\u2294", sqcups = "\u2294\uFE00", sqsub = "\u228F", sqsube = "\u2291", sqsubset = "\u228F", sqsubseteq = "\u2291", sqsup = "\u2290", sqsupe = "\u2292", sqsupset = "\u2290", sqsupseteq = "\u2292", squ = "\u25A1", square = "\u25A1", squarf = "\u25AA", squf = "\u25AA", srarr = "\u2192", sscr = "\u{1D4C8}", ssetmn = "\u2216", ssmile = "\u2323", sstarf = "\u22C6", star = "\u2606", starf = "\u2605", straightepsilon = "\u03F5", straightphi = "\u03D5", strns = "\xAF", sub = "\u2282", subE = "\u2AC5", subdot = "\u2ABD", sube = "\u2286", subedot = "\u2AC3", submult = "\u2AC1", subnE = "\u2ACB", subne = "\u228A", subplus = "\u2ABF", subrarr = "\u2979", subset = "\u2282", subseteq = "\u2286", subseteqq = "\u2AC5", subsetneq = "\u228A", subsetneqq = "\u2ACB", subsim = "\u2AC7", subsub = "\u2AD5", subsup = "\u2AD3", succ = "\u227B", succapprox = "\u2AB8", succcurlyeq = "\u227D", succeq = "\u2AB0", succnapprox = "\u2ABA", succneqq = "\u2AB6", succnsim = "\u22E9", succsim = "\u227F", sum = "\u2211", sung = "\u266A", sup = "\u2283", sup1 = "\xB9", sup2 = "\xB2", sup3 = "\xB3", supE = "\u2AC6", supdot = "\u2ABE", supdsub = "\u2AD8", supe = "\u2287", supedot = "\u2AC4", suphsol = "\u27C9", suphsub = "\u2AD7", suplarr = "\u297B", supmult = "\u2AC2", supnE = "\u2ACC", supne = "\u228B", supplus = "\u2AC0", supset = "\u2283", supseteq = "\u2287", supseteqq = "\u2AC6", supsetneq = "\u228B", supsetneqq = "\u2ACC", supsim = "\u2AC8", supsub = "\u2AD4", supsup = "\u2AD6", swArr = "\u21D9", swarhk = "\u2926", swarr = "\u2199", swarrow = "\u2199", swnwar = "\u292A", szli = "\xDF", szlig = "\xDF", target = "\u2316", tau = "\u03C4", tbrk = "\u23B4", tcaron = "\u0165", tcedil = "\u0163", tcy = "\u0442", tdot = "\u20DB", telrec = "\u2315", tfr = "\u{1D531}", there4 = "\u2234", therefore = "\u2234", theta = "\u03B8", thetasym = "\u03D1", thetav = "\u03D1", thickapprox = "\u2248", thicksim = "\u223C", thinsp = "\u2009", thkap = "\u2248", thksim = "\u223C", thor = "\xFE", thorn = "\xFE", tilde = "\u02DC", time$2 = "\xD7", times = "\xD7", timesb = "\u22A0", timesbar = "\u2A31", timesd = "\u2A30", tint = "\u222D", toea = "\u2928", top = "\u22A4", topbot = "\u2336", topcir = "\u2AF1", topf = "\u{1D565}", topfork = "\u2ADA", tosa = "\u2929", tprime = "\u2034", trade = "\u2122", triangle = "\u25B5", triangledown = "\u25BF", triangleleft = "\u25C3", trianglelefteq = "\u22B4", triangleq = "\u225C", triangleright = "\u25B9", trianglerighteq = "\u22B5", tridot = "\u25EC", trie = "\u225C", triminus = "\u2A3A", triplus = "\u2A39", trisb = "\u29CD", tritime = "\u2A3B", trpezium = "\u23E2", tscr = "\u{1D4C9}", tscy = "\u0446", tshcy = "\u045B", tstrok = "\u0167", twixt = "\u226C", twoheadleftarrow = "\u219E", twoheadrightarrow = "\u21A0", uArr = "\u21D1", uHar = "\u2963", uacut = "\xFA", uacute = "\xFA", uarr = "\u2191", ubrcy = "\u045E", ubreve = "\u016D", ucir = "\xFB", ucirc = "\xFB", ucy = "\u0443", udarr = "\u21C5", udblac = "\u0171", udhar = "\u296E", ufisht = "\u297E", ufr = "\u{1D532}", ugrav = "\xF9", ugrave = "\xF9", uharl = "\u21BF", uharr = "\u21BE", uhblk = "\u2580", ulcorn = "\u231C", ulcorner = "\u231C", ulcrop = "\u230F", ultri = "\u25F8", umacr = "\u016B", um = "\xA8", uml = "\xA8", uogon = "\u0173", uopf = "\u{1D566}", uparrow = "\u2191", updownarrow = "\u2195", upharpoonleft = "\u21BF", upharpoonright = "\u21BE", uplus = "\u228E", upsi = "\u03C5", upsih = "\u03D2", upsilon = "\u03C5", upuparrows = "\u21C8", urcorn = "\u231D", urcorner = "\u231D", urcrop = "\u230E", uring = "\u016F", urtri = "\u25F9", uscr = "\u{1D4CA}", utdot = "\u22F0", utilde = "\u0169", utri = "\u25B5", utrif = "\u25B4", uuarr = "\u21C8", uum = "\xFC", uuml = "\xFC", uwangle = "\u29A7", vArr = "\u21D5", vBar = "\u2AE8", vBarv = "\u2AE9", vDash = "\u22A8", vangrt = "\u299C", varepsilon = "\u03F5", varkappa = "\u03F0", varnothing = "\u2205", varphi = "\u03D5", varpi = "\u03D6", varpropto = "\u221D", varr = "\u2195", varrho = "\u03F1", varsigma = "\u03C2", varsubsetneq = "\u228A\uFE00", varsubsetneqq = "\u2ACB\uFE00", varsupsetneq = "\u228B\uFE00", varsupsetneqq = "\u2ACC\uFE00", vartheta = "\u03D1", vartriangleleft = "\u22B2", vartriangleright = "\u22B3", vcy = "\u0432", vdash = "\u22A2", vee = "\u2228", veebar = "\u22BB", veeeq = "\u225A", vellip = "\u22EE", verbar = "|", vert = "|", vfr = "\u{1D533}", vltri = "\u22B2", vnsub = "\u2282\u20D2", vnsup = "\u2283\u20D2", vopf = "\u{1D567}", vprop = "\u221D", vrtri = "\u22B3", vscr = "\u{1D4CB}", vsubnE = "\u2ACB\uFE00", vsubne = "\u228A\uFE00", vsupnE = "\u2ACC\uFE00", vsupne = "\u228B\uFE00", vzigzag = "\u299A", wcirc = "\u0175", wedbar = "\u2A5F", wedge = "\u2227", wedgeq = "\u2259", weierp = "\u2118", wfr = "\u{1D534}", wopf = "\u{1D568}", wp = "\u2118", wr = "\u2240", wreath = "\u2240", wscr = "\u{1D4CC}", xcap = "\u22C2", xcirc = "\u25EF", xcup = "\u22C3", xdtri = "\u25BD", xfr = "\u{1D535}", xhArr = "\u27FA", xharr = "\u27F7", xi = "\u03BE", xlArr = "\u27F8", xlarr = "\u27F5", xmap = "\u27FC", xnis = "\u22FB", xodot = "\u2A00", xopf = "\u{1D569}", xoplus = "\u2A01", xotime = "\u2A02", xrArr = "\u27F9", xrarr = "\u27F6", xscr = "\u{1D4CD}", xsqcup = "\u2A06", xuplus = "\u2A04", xutri = "\u25B3", xvee = "\u22C1", xwedge = "\u22C0", yacut = "\xFD", yacute = "\xFD", yacy = "\u044F", ycirc = "\u0177", ycy = "\u044B", ye = "\xA5", yen = "\xA5", yfr = "\u{1D536}", yicy = "\u0457", yopf = "\u{1D56A}", yscr = "\u{1D4CE}", yucy = "\u044E", yum = "\xFF", yuml = "\xFF", zacute = "\u017A", zcaron = "\u017E", zcy = "\u0437", zdot = "\u017C", zeetrf = "\u2128", zeta = "\u03B6", zfr = "\u{1D537}", zhcy = "\u0436", zigrarr = "\u21DD", zopf = "\u{1D56B}", zscr = "\u{1D4CF}", zwj = "\u200D", zwnj = "\u200C", require$$0 = {
  AEli,
  AElig,
  AM,
  AMP,
  Aacut,
  Aacute,
  Abreve,
  Acir,
  Acirc,
  Acy,
  Afr,
  Agrav,
  Agrave,
  Alpha,
  Amacr,
  And,
  Aogon,
  Aopf,
  ApplyFunction,
  Arin,
  Aring,
  Ascr,
  Assign,
  Atild,
  Atilde,
  Aum,
  Auml,
  Backslash,
  Barv,
  Barwed,
  Bcy,
  Because,
  Bernoullis,
  Beta,
  Bfr,
  Bopf,
  Breve,
  Bscr,
  Bumpeq,
  CHcy,
  COP,
  COPY,
  Cacute,
  Cap,
  CapitalDifferentialD,
  Cayleys,
  Ccaron,
  Ccedi,
  Ccedil,
  Ccirc,
  Cconint,
  Cdot,
  Cedilla,
  CenterDot,
  Cfr,
  Chi,
  CircleDot,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  Colon,
  Colone,
  Congruent,
  Conint,
  ContourIntegral,
  Copf,
  Coproduct,
  CounterClockwiseContourIntegral,
  Cross,
  Cscr,
  Cup,
  CupCap,
  DD,
  DDotrahd,
  DJcy,
  DScy,
  DZcy,
  Dagger,
  Darr,
  Dashv,
  Dcaron,
  Dcy,
  Del,
  Delta,
  Dfr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  Diamond,
  DifferentialD,
  Dopf,
  Dot,
  DotDot,
  DotEqual,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrow,
  DownArrowBar,
  DownArrowUpArrow,
  DownBreve,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVector,
  DownLeftVectorBar,
  DownRightTeeVector,
  DownRightVector,
  DownRightVectorBar,
  DownTee,
  DownTeeArrow,
  Downarrow,
  Dscr,
  Dstrok,
  ENG,
  ET,
  ETH,
  Eacut,
  Eacute,
  Ecaron,
  Ecir,
  Ecirc,
  Ecy,
  Edot,
  Efr,
  Egrav,
  Egrave,
  Element: Element$1,
  Emacr,
  EmptySmallSquare,
  EmptyVerySmallSquare,
  Eogon,
  Eopf,
  Epsilon,
  Equal,
  EqualTilde,
  Equilibrium,
  Escr,
  Esim,
  Eta,
  Eum,
  Euml,
  Exists,
  ExponentialE,
  Fcy,
  Ffr,
  FilledSmallSquare,
  FilledVerySmallSquare,
  Fopf,
  ForAll,
  Fouriertrf,
  Fscr,
  GJcy,
  G,
  GT,
  Gamma,
  Gammad,
  Gbreve,
  Gcedil,
  Gcirc,
  Gcy,
  Gdot,
  Gfr,
  Gg,
  Gopf,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  Gt,
  HARDcy,
  Hacek,
  Hat,
  Hcirc,
  Hfr,
  HilbertSpace,
  Hopf,
  HorizontalLine,
  Hscr,
  Hstrok,
  HumpDownHump,
  HumpEqual,
  IEcy,
  IJlig,
  IOcy,
  Iacut,
  Iacute,
  Icir,
  Icirc,
  Icy,
  Idot,
  Ifr,
  Igrav,
  Igrave,
  Im,
  Imacr,
  ImaginaryI,
  Implies,
  Int,
  Integral,
  Intersection,
  InvisibleComma,
  InvisibleTimes,
  Iogon,
  Iopf,
  Iota,
  Iscr,
  Itilde,
  Iukcy,
  Ium,
  Iuml,
  Jcirc,
  Jcy,
  Jfr,
  Jopf,
  Jscr,
  Jsercy,
  Jukcy,
  KHcy,
  KJcy,
  Kappa,
  Kcedil,
  Kcy,
  Kfr,
  Kopf,
  Kscr,
  LJcy,
  L,
  LT,
  Lacute,
  Lambda,
  Lang,
  Laplacetrf,
  Larr,
  Lcaron,
  Lcedil,
  Lcy,
  LeftAngleBracket,
  LeftArrow,
  LeftArrowBar,
  LeftArrowRightArrow,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVector,
  LeftDownVectorBar,
  LeftFloor,
  LeftRightArrow,
  LeftRightVector,
  LeftTee,
  LeftTeeArrow,
  LeftTeeVector,
  LeftTriangle,
  LeftTriangleBar,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVector,
  LeftUpVectorBar,
  LeftVector,
  LeftVectorBar,
  Leftarrow,
  Leftrightarrow,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  LessLess,
  LessSlantEqual,
  LessTilde,
  Lfr,
  Ll,
  Lleftarrow,
  Lmidot,
  LongLeftArrow,
  LongLeftRightArrow,
  LongRightArrow,
  Longleftarrow,
  Longleftrightarrow,
  Longrightarrow,
  Lopf,
  LowerLeftArrow,
  LowerRightArrow,
  Lscr,
  Lsh,
  Lstrok,
  Lt,
  Map: "\u2905",
  Mcy,
  MediumSpace,
  Mellintrf,
  Mfr,
  MinusPlus,
  Mopf,
  Mscr,
  Mu,
  NJcy,
  Nacute,
  Ncaron,
  Ncedil,
  Ncy,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  Nfr,
  NoBreak,
  NonBreakingSpace,
  Nopf,
  Not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  NotLeftTriangle,
  NotLeftTriangleBar,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangle,
  NotRightTriangleBar,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  Nscr,
  Ntild,
  Ntilde,
  Nu,
  OElig,
  Oacut,
  Oacute,
  Ocir,
  Ocirc,
  Ocy,
  Odblac,
  Ofr,
  Ograv,
  Ograve,
  Omacr,
  Omega,
  Omicron,
  Oopf,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  Or,
  Oscr,
  Oslas,
  Oslash,
  Otild,
  Otilde,
  Otimes,
  Oum,
  Ouml,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  PartialD,
  Pcy,
  Pfr,
  Phi,
  Pi,
  PlusMinus,
  Poincareplane,
  Popf,
  Pr,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  Prime,
  Product,
  Proportion,
  Proportional,
  Pscr,
  Psi,
  QUO,
  QUOT,
  Qfr,
  Qopf,
  Qscr,
  RBarr,
  RE,
  REG,
  Racute,
  Rang,
  Rarr,
  Rarrtl,
  Rcaron,
  Rcedil,
  Rcy,
  Re,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  Rfr,
  Rho,
  RightAngleBracket,
  RightArrow,
  RightArrowBar,
  RightArrowLeftArrow,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVector,
  RightDownVectorBar,
  RightFloor,
  RightTee,
  RightTeeArrow,
  RightTeeVector,
  RightTriangle,
  RightTriangleBar,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVector,
  RightUpVectorBar,
  RightVector,
  RightVectorBar,
  Rightarrow,
  Ropf,
  RoundImplies,
  Rrightarrow,
  Rscr,
  Rsh,
  RuleDelayed,
  SHCHcy,
  SHcy,
  SOFTcy,
  Sacute,
  Sc,
  Scaron,
  Scedil,
  Scirc,
  Scy,
  Sfr,
  ShortDownArrow,
  ShortLeftArrow,
  ShortRightArrow,
  ShortUpArrow,
  Sigma,
  SmallCircle,
  Sopf,
  Sqrt,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  Sscr,
  Star,
  Sub,
  Subset,
  SubsetEqual,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  SuchThat,
  Sum,
  Sup,
  Superset,
  SupersetEqual,
  Supset,
  THOR,
  THORN,
  TRADE,
  TSHcy,
  TScy,
  Tab: Tab$1,
  Tau,
  Tcaron,
  Tcedil,
  Tcy,
  Tfr,
  Therefore,
  Theta,
  ThickSpace,
  ThinSpace,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  Topf,
  TripleDot,
  Tscr,
  Tstrok,
  Uacut,
  Uacute,
  Uarr,
  Uarrocir,
  Ubrcy,
  Ubreve,
  Ucir,
  Ucirc,
  Ucy,
  Udblac,
  Ufr,
  Ugrav,
  Ugrave,
  Umacr,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  Uopf,
  UpArrow,
  UpArrowBar,
  UpArrowDownArrow,
  UpDownArrow,
  UpEquilibrium,
  UpTee,
  UpTeeArrow,
  Uparrow,
  Updownarrow,
  UpperLeftArrow,
  UpperRightArrow,
  Upsi,
  Upsilon,
  Uring,
  Uscr,
  Utilde,
  Uum,
  Uuml,
  VDash,
  Vbar,
  Vcy,
  Vdash,
  Vdashl,
  Vee,
  Verbar,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  Vopf,
  Vscr,
  Vvdash,
  Wcirc,
  Wedge,
  Wfr,
  Wopf,
  Wscr,
  Xfr,
  Xi,
  Xopf,
  Xscr,
  YAcy,
  YIcy,
  YUcy,
  Yacut,
  Yacute,
  Ycirc,
  Ycy,
  Yfr,
  Yopf,
  Yscr,
  Yuml,
  ZHcy,
  Zacute,
  Zcaron,
  Zcy,
  Zdot,
  ZeroWidthSpace,
  Zeta,
  Zfr,
  Zopf,
  Zscr,
  aacut,
  aacute,
  abreve,
  ac,
  acE,
  acd,
  acir,
  acirc,
  acut,
  acute,
  acy,
  aeli,
  aelig,
  af,
  afr,
  agrav,
  agrave,
  alefsym,
  aleph,
  alpha: alpha$1,
  amacr,
  amalg,
  am,
  amp,
  and,
  andand,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsd,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  aogon,
  aopf,
  ap,
  apE,
  apacir,
  ape,
  apid,
  apos,
  approx,
  approxeq,
  arin,
  aring,
  ascr,
  ast,
  asymp,
  asympeq,
  atild,
  atilde,
  aum,
  auml,
  awconint,
  awint,
  bNot,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  barvee,
  barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  bcy,
  bdquo,
  becaus,
  because,
  bemptyv,
  bepsi,
  bernou,
  beta,
  beth,
  between,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block,
  bne,
  bnequiv,
  bnot,
  bopf,
  bot,
  bottom,
  bowtie,
  boxDL,
  boxDR,
  boxDl,
  boxDr,
  boxH,
  boxHD,
  boxHU,
  boxHd,
  boxHu,
  boxUL,
  boxUR,
  boxUl,
  boxUr,
  boxV,
  boxVH,
  boxVL,
  boxVR,
  boxVh,
  boxVl,
  boxVr,
  boxbox,
  boxdL,
  boxdR,
  boxdl,
  boxdr,
  boxh,
  boxhD,
  boxhU,
  boxhd,
  boxhu,
  boxminus,
  boxplus,
  boxtimes,
  boxuL,
  boxuR,
  boxul,
  boxur,
  boxv,
  boxvH,
  boxvL,
  boxvR,
  boxvh,
  boxvl,
  boxvr,
  bprime,
  breve,
  brvba,
  brvbar,
  bscr,
  bsemi,
  bsim,
  bsime,
  bsol,
  bsolb,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  bumpeq,
  cacute,
  cap,
  capand,
  capbrcup,
  capcap,
  capcup,
  capdot,
  caps,
  caret,
  caron,
  ccaps,
  ccaron,
  ccedi,
  ccedil,
  ccirc,
  ccups,
  ccupssm,
  cdot,
  cedi,
  cedil,
  cemptyv,
  cen,
  cent,
  centerdot,
  cfr,
  chcy,
  check,
  checkmark,
  chi,
  cir,
  cirE,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledR,
  circledS,
  circledast,
  circledcirc,
  circleddash,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  clubs,
  clubsuit,
  colon,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  conint,
  copf,
  coprod,
  cop,
  copy,
  copysr,
  crarr,
  cross,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cup,
  cupbrcap,
  cupcap,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curre,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dArr,
  dHar,
  dagger,
  daleth,
  darr,
  dash,
  dashv,
  dbkarow,
  dblac,
  dcaron,
  dcy,
  dd,
  ddagger,
  ddarr,
  ddotseq,
  de,
  deg,
  delta,
  demptyv,
  dfisht,
  dfr,
  dharl,
  dharr,
  diam,
  diamond,
  diamondsuit,
  diams,
  die,
  digamma,
  disin,
  div,
  divid,
  divide,
  divideontimes,
  divonx,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  dopf,
  dot,
  doteq,
  doteqdot,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  downarrow,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  drbkarow,
  drcorn,
  drcrop,
  dscr,
  dscy,
  dsol,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  dzcy,
  dzigrarr,
  eDDot,
  eDot,
  eacut,
  eacute,
  easter,
  ecaron,
  ecir,
  ecirc,
  ecolon,
  ecy,
  edot,
  ee,
  efDot,
  efr,
  eg,
  egrav,
  egrave,
  egs,
  egsdot,
  el,
  elinters,
  ell,
  els,
  elsdot,
  emacr,
  empty,
  emptyset,
  emptyv,
  emsp13,
  emsp14,
  emsp,
  eng,
  ensp,
  eogon,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  equals,
  equest,
  equiv,
  equivDD,
  eqvparsl,
  erDot,
  erarr,
  escr,
  esdot,
  esim,
  eta,
  et,
  eth,
  eum,
  euml,
  euro,
  excl,
  exist,
  expectation,
  exponentiale,
  fallingdotseq,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  ffr,
  filig,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  fopf,
  forall,
  fork,
  forkv,
  fpartint,
  frac1,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac3,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  gE,
  gEl,
  gacute,
  gamma,
  gammad,
  gap,
  gbreve,
  gcirc,
  gcy,
  gdot,
  ge,
  gel,
  geq,
  geqq,
  geqslant,
  ges,
  gescc,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  gfr,
  gg,
  ggg,
  gimel,
  gjcy,
  gl,
  glE,
  gla,
  glj,
  gnE,
  gnap,
  gnapprox,
  gne,
  gneq,
  gneqq,
  gnsim,
  gopf,
  grave,
  gscr,
  gsim,
  gsime,
  gsiml,
  g,
  gt,
  gtcc,
  gtcir,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  hArr,
  hairsp,
  half,
  hamilt,
  hardcy,
  harr,
  harrcir,
  harrw,
  hbar,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  horbar,
  hscr,
  hslash,
  hstrok,
  hybull,
  hyphen,
  iacut,
  iacute,
  ic,
  icir,
  icirc,
  icy,
  iecy,
  iexc,
  iexcl,
  iff,
  ifr,
  igrav,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  ijlig,
  imacr,
  image,
  imagline,
  imagpart,
  imath,
  imof,
  imped,
  in: "\u2208",
  incare,
  infin,
  infintie,
  inodot,
  int: int$1,
  intcal,
  integers,
  intercal,
  intlarhk,
  intprod,
  iocy,
  iogon,
  iopf,
  iota,
  iprod,
  iques,
  iquest,
  iscr,
  isin,
  isinE,
  isindot,
  isins,
  isinsv,
  isinv,
  it,
  itilde,
  iukcy,
  ium,
  iuml,
  jcirc,
  jcy,
  jfr,
  jmath,
  jopf,
  jscr,
  jsercy,
  jukcy,
  kappa,
  kappav,
  kcedil,
  kcy,
  kfr,
  kgreen,
  khcy,
  kjcy,
  kopf,
  kscr,
  lAarr,
  lArr,
  lAtail,
  lBarr,
  lE,
  lEg,
  lHar,
  lacute,
  laemptyv,
  lagran,
  lambda,
  lang,
  langd,
  langle,
  lap,
  laqu,
  laquo,
  larr,
  larrb,
  larrbfs,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  lat,
  latail,
  late,
  lates,
  lbarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  lcaron,
  lcedil,
  lceil,
  lcub,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  leftarrow,
  leftarrowtail,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  leftthreetimes,
  leg,
  leq,
  leqq,
  leqslant,
  les,
  lescc,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  lessgtr,
  lesssim,
  lfisht,
  lfloor,
  lfr,
  lg,
  lgE,
  lhard,
  lharu,
  lharul,
  lhblk,
  ljcy,
  ll,
  llarr,
  llcorner,
  llhard,
  lltri,
  lmidot,
  lmoust,
  lmoustache,
  lnE,
  lnap,
  lnapprox,
  lne,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  longleftrightarrow,
  longmapsto,
  longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  lstrok,
  l,
  lt,
  ltcc,
  ltcir,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltrPar,
  ltri,
  ltrie,
  ltrif,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  mDDot,
  mac,
  macr,
  male,
  malt,
  maltese,
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  mcy,
  mdash,
  measuredangle,
  mfr,
  mho,
  micr,
  micro,
  mid,
  midast,
  midcir,
  middo,
  middot,
  minus,
  minusb,
  minusd,
  minusdu,
  mlcp,
  mldr,
  mnplus,
  models,
  mopf,
  mp,
  mscr,
  mstpos,
  mu,
  multimap,
  mumap,
  nGg,
  nGt,
  nGtv,
  nLeftarrow,
  nLeftrightarrow,
  nLl,
  nLt,
  nLtv,
  nRightarrow,
  nVDash,
  nVdash,
  nabla,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natur,
  natural,
  naturals,
  nbs,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  ncaron,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  ncy,
  ndash,
  ne,
  neArr,
  nearhk,
  nearr,
  nearrow,
  nedot,
  nequiv,
  nesear,
  nesim,
  nexist,
  nexists,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  ngsim,
  ngt,
  ngtr,
  nhArr,
  nharr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  njcy,
  nlArr,
  nlE,
  nlarr,
  nldr,
  nle,
  nleftarrow,
  nleftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nlsim,
  nlt,
  nltri,
  nltrie,
  nmid,
  nopf,
  no,
  not,
  notin,
  notinE,
  notindot,
  notinva,
  notinvb,
  notinvc,
  notni,
  notniva,
  notnivb,
  notnivc,
  npar,
  nparallel,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  npre,
  nprec,
  npreceq,
  nrArr,
  nrarr,
  nrarrc,
  nrarrw,
  nrightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  ntild,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  nu,
  num,
  numero,
  numsp,
  nvDash,
  nvHarr,
  nvap,
  nvdash,
  nvge,
  nvgt,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwArr,
  nwarhk,
  nwarr,
  nwarrow,
  nwnear,
  oS,
  oacut,
  oacute,
  oast,
  ocir,
  ocirc,
  ocy,
  odash,
  odblac,
  odiv,
  odot,
  odsold,
  oelig,
  ofcir,
  ofr,
  ogon,
  ograv,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  omacr,
  omega,
  omicron,
  omid,
  ominus,
  oopf,
  opar,
  operp,
  oplus,
  or,
  orarr,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oscr,
  oslas,
  oslash,
  osol,
  otild,
  otilde,
  otimes,
  otimesas,
  oum,
  ouml,
  ovbar,
  par,
  para,
  parallel,
  parsim,
  parsl,
  part,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  pfr,
  phi,
  phiv,
  phmmat,
  phone,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plus,
  plusacir,
  plusb,
  pluscir,
  plusdo,
  plusdu,
  pluse,
  plusm,
  plusmn,
  plussim,
  plustwo,
  pm,
  pointint,
  popf,
  poun,
  pound,
  pr,
  prE,
  prap,
  prcue,
  pre,
  prec,
  precapprox,
  preccurlyeq,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  precsim,
  prime,
  primes,
  prnE,
  prnap,
  prnsim,
  prod,
  profalar,
  profline,
  profsurf,
  prop,
  propto,
  prsim,
  prurel,
  pscr,
  psi,
  puncsp,
  qfr,
  qint,
  qopf,
  qprime,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quo,
  quot,
  rAarr,
  rArr,
  rAtail,
  rBarr,
  rHar,
  race,
  racute,
  radic,
  raemptyv,
  rang,
  rangd,
  range,
  rangle,
  raqu,
  raquo,
  rarr,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  rarrtl,
  rarrw,
  ratail,
  ratio,
  rationals,
  rbarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  rcaron,
  rcedil,
  rceil,
  rcub,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  rect,
  re,
  reg,
  rfisht,
  rfloor,
  rfr,
  rhard,
  rharu,
  rharul,
  rho,
  rhov,
  rightarrow,
  rightarrowtail,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  rightthreetimes,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoust,
  rmoustache,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  roplus,
  rotimes,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  rsaquo,
  rscr,
  rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  ruluhar,
  rx,
  sacute,
  sbquo,
  sc,
  scE,
  scap,
  scaron,
  sccue,
  sce,
  scedil,
  scirc,
  scnE,
  scnap,
  scnsim,
  scpolint,
  scsim,
  scy,
  sdot,
  sdotb,
  sdote,
  seArr,
  searhk,
  searr,
  searrow,
  sec,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  sfr,
  sfrown,
  sharp,
  shchcy,
  shcy,
  shortmid,
  shortparallel,
  sh,
  shy,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  softcy,
  sol,
  solb,
  solbar,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  squ,
  square,
  squarf,
  squf,
  srarr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  subE,
  subdot,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  subseteq,
  subseteqq,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succ,
  succapprox,
  succcurlyeq,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  sum,
  sung,
  sup,
  sup1,
  sup2,
  sup3,
  supE,
  supdot,
  supdsub,
  supe,
  supedot,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swArr,
  swarhk,
  swarr,
  swarrow,
  swnwar,
  szli,
  szlig,
  target,
  tau,
  tbrk,
  tcaron,
  tcedil,
  tcy,
  tdot,
  telrec,
  tfr,
  there4,
  therefore,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  thinsp,
  thkap,
  thksim,
  thor,
  thorn,
  tilde,
  time: time$2,
  times,
  timesb,
  timesbar,
  timesd,
  tint,
  toea,
  top,
  topbot,
  topcir,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  triplus,
  trisb,
  tritime,
  trpezium,
  tscr,
  tscy,
  tshcy,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  uArr,
  uHar,
  uacut,
  uacute,
  uarr,
  ubrcy,
  ubreve,
  ucir,
  ucirc,
  ucy,
  udarr,
  udblac,
  udhar,
  ufisht,
  ufr,
  ugrav,
  ugrave,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  umacr,
  um,
  uml,
  uogon,
  uopf,
  uparrow,
  updownarrow,
  upharpoonleft,
  upharpoonright,
  uplus,
  upsi,
  upsih,
  upsilon,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  uring,
  urtri,
  uscr,
  utdot,
  utilde,
  utri,
  utrif,
  uuarr,
  uum,
  uuml,
  uwangle,
  vArr,
  vBar,
  vBarv,
  vDash,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vcy,
  vdash,
  vee,
  veebar,
  veeeq,
  vellip,
  verbar,
  vert,
  vfr,
  vltri,
  vnsub,
  vnsup,
  vopf,
  vprop,
  vrtri,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  vzigzag,
  wcirc,
  wedbar,
  wedge,
  wedgeq,
  weierp,
  wfr,
  wopf,
  wp,
  wr,
  wreath,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  xfr,
  xhArr,
  xharr,
  xi,
  xlArr,
  xlarr,
  xmap,
  xnis,
  xodot,
  xopf,
  xoplus,
  xotime,
  xrArr,
  xrarr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  yacut,
  yacute,
  yacy,
  ycirc,
  ycy,
  ye,
  yen,
  yfr,
  yicy,
  yopf,
  yscr,
  yucy,
  yum,
  yuml,
  zacute,
  zcaron,
  zcy,
  zdot,
  zeetrf,
  zeta,
  zfr,
  zhcy,
  zigrarr,
  zopf,
  zscr,
  zwj,
  zwnj
}, characterEntities = require$$0, decodeEntity_1 = decodeEntity$1, own$3 = {}.hasOwnProperty;
function decodeEntity$1(characters2) {
  return own$3.call(characterEntities, characters2) ? characterEntities[characters2] : !1;
}
var legacy = require$$0$1, invalid = require$$1, decimal = isDecimal, hexadecimal = isHexadecimal, alphanumerical = isAlphanumerical, decodeEntity = decodeEntity_1, parseEntities_1 = parseEntities, own$2 = {}.hasOwnProperty, fromCharCode = String.fromCharCode, noop$1 = Function.prototype, defaults = {
  warning: null,
  reference: null,
  text: null,
  warningContext: null,
  referenceContext: null,
  textContext: null,
  position: {},
  additional: null,
  attribute: !1,
  nonTerminated: !0
}, tab = 9, lineFeed = 10, formFeed = 12, space = 32, ampersand = 38, semicolon = 59, lessThan = 60, equalsTo = 61, numberSign = 35, uppercaseX = 88, lowercaseX = 120, replacementCharacter = 65533, name = "named", hexa = "hexadecimal", deci = "decimal", bases = {};
bases[hexa] = 16;
bases[deci] = 10;
var tests = {};
tests[name] = alphanumerical;
tests[deci] = decimal;
tests[hexa] = hexadecimal;
var namedNotTerminated = 1, numericNotTerminated = 2, namedEmpty = 3, numericEmpty = 4, namedUnknown = 5, numericDisallowed = 6, numericProhibited = 7, messages = {};
messages[namedNotTerminated] = "Named character references must be terminated by a semicolon";
messages[numericNotTerminated] = "Numeric character references must be terminated by a semicolon";
messages[namedEmpty] = "Named character references cannot be empty";
messages[numericEmpty] = "Numeric character references cannot be empty";
messages[namedUnknown] = "Named character references must be known";
messages[numericDisallowed] = "Numeric character references cannot be disallowed";
messages[numericProhibited] = "Numeric character references cannot be outside the permissible Unicode range";
function parseEntities(value, options) {
  var settings = {}, option, key2;
  options || (options = {});
  for (key2 in defaults)
    option = options[key2], settings[key2] = option ?? defaults[key2];
  return (settings.position.indent || settings.position.start) && (settings.indent = settings.position.indent || [], settings.position = settings.position.start), parse(value, settings);
}
function parse(value, settings) {
  var additional = settings.additional, nonTerminated = settings.nonTerminated, handleText = settings.text, handleReference = settings.reference, handleWarning = settings.warning, textContext = settings.textContext, referenceContext = settings.referenceContext, warningContext = settings.warningContext, pos = settings.position, indent = settings.indent || [], length2 = value.length, index2 = 0, lines = -1, column2 = pos.column || 1, line2 = pos.line || 1, queue = "", result = [], entityCharacters, namedEntity, terminated, characters2, character2, reference, following, warning2, reason, output, entity, begin, start, type, test2, prev2, next2, diff, end;
  for (typeof additional == "string" && (additional = additional.charCodeAt(0)), prev2 = now2(), warning2 = handleWarning ? parseError : noop$1, index2--, length2++; ++index2 < length2; )
    if (character2 === lineFeed && (column2 = indent[lines] || 1), character2 = value.charCodeAt(index2), character2 === ampersand) {
      if (following = value.charCodeAt(index2 + 1), following === tab || following === lineFeed || following === formFeed || following === space || following === ampersand || following === lessThan || following !== following || additional && following === additional) {
        queue += fromCharCode(character2), column2++;
        continue;
      }
      for (start = index2 + 1, begin = start, end = start, following === numberSign ? (end = ++begin, following = value.charCodeAt(end), following === uppercaseX || following === lowercaseX ? (type = hexa, end = ++begin) : type = deci) : type = name, entityCharacters = "", entity = "", characters2 = "", test2 = tests[type], end--; ++end < length2 && (following = value.charCodeAt(end), !!test2(following)); )
        characters2 += fromCharCode(following), type === name && own$2.call(legacy, characters2) && (entityCharacters = characters2, entity = legacy[characters2]);
      terminated = value.charCodeAt(end) === semicolon, terminated && (end++, namedEntity = type === name ? decodeEntity(characters2) : !1, namedEntity && (entityCharacters = characters2, entity = namedEntity)), diff = 1 + end - start, !terminated && !nonTerminated || (characters2 ? type === name ? (terminated && !entity ? warning2(namedUnknown, 1) : (entityCharacters !== characters2 && (end = begin + entityCharacters.length, diff = 1 + end - begin, terminated = !1), terminated || (reason = entityCharacters ? namedNotTerminated : namedEmpty, settings.attribute ? (following = value.charCodeAt(end), following === equalsTo ? (warning2(reason, diff), entity = null) : alphanumerical(following) ? entity = null : warning2(reason, diff)) : warning2(reason, diff))), reference = entity) : (terminated || warning2(numericNotTerminated, diff), reference = parseInt(characters2, bases[type]), prohibited(reference) ? (warning2(numericProhibited, diff), reference = fromCharCode(replacementCharacter)) : reference in invalid ? (warning2(numericDisallowed, diff), reference = invalid[reference]) : (output = "", disallowed(reference) && warning2(numericDisallowed, diff), reference > 65535 && (reference -= 65536, output += fromCharCode(reference >>> 10 | 55296), reference = 56320 | reference & 1023), reference = output + fromCharCode(reference))) : type !== name && warning2(numericEmpty, diff)), reference ? (flush(), prev2 = now2(), index2 = end - 1, column2 += end - start + 1, result.push(reference), next2 = now2(), next2.offset++, handleReference && handleReference.call(
        referenceContext,
        reference,
        { start: prev2, end: next2 },
        value.slice(start - 1, end)
      ), prev2 = next2) : (characters2 = value.slice(start - 1, end), queue += characters2, column2 += characters2.length, index2 = end - 1);
    } else
      character2 === 10 && (line2++, lines++, column2 = 0), character2 === character2 ? (queue += fromCharCode(character2), column2++) : flush();
  return result.join("");
  function now2() {
    return {
      line: line2,
      column: column2,
      offset: index2 + (pos.offset || 0)
    };
  }
  function parseError(code, offset2) {
    var position2 = now2();
    position2.column += offset2, position2.offset += offset2, handleWarning.call(warningContext, messages[code], position2, code);
  }
  function flush() {
    queue && (result.push(queue), handleText && handleText.call(textContext, queue, { start: prev2, end: now2() }), queue = "");
  }
}
function prohibited(code) {
  return code >= 55296 && code <= 57343 || code > 1114111;
}
function disallowed(code) {
  return code >= 1 && code <= 8 || code === 11 || code >= 13 && code <= 31 || code >= 127 && code <= 159 || code >= 64976 && code <= 65007 || (code & 65535) === 65535 || (code & 65535) === 65534;
}
var prismCore = { exports: {} };
(function(module) {
  var _self = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var Prism2 = function(_self2) {
    var lang2 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, uniqueId = 0, plainTextGrammar = {}, _2 = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: _self2.Prism && _self2.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function encode2(tokens) {
          return tokens instanceof Token ? new Token(tokens.type, encode2(tokens.content), tokens.alias) : Array.isArray(tokens) ? tokens.map(encode2) : tokens.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(o) {
          return Object.prototype.toString.call(o).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(obj) {
          return obj.__id || Object.defineProperty(obj, "__id", { value: ++uniqueId }), obj.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function deepClone(o, visited) {
          visited = visited || {};
          var clone, id2;
          switch (_2.util.type(o)) {
            case "Object":
              if (id2 = _2.util.objId(o), visited[id2])
                return visited[id2];
              clone = /** @type {Record<string, any>} */
              {}, visited[id2] = clone;
              for (var key2 in o)
                o.hasOwnProperty(key2) && (clone[key2] = deepClone(o[key2], visited));
              return (
                /** @type {any} */
                clone
              );
            case "Array":
              return id2 = _2.util.objId(o), visited[id2] ? visited[id2] : (clone = [], visited[id2] = clone, /** @type {Array} */
              /** @type {any} */
              o.forEach(function(v2, i) {
                clone[i] = deepClone(v2, visited);
              }), /** @type {any} */
              clone);
            default:
              return o;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(element) {
          for (; element; ) {
            var m2 = lang2.exec(element.className);
            if (m2)
              return m2[1].toLowerCase();
            element = element.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(element, language) {
          element.className = element.className.replace(RegExp(lang2, "gi"), ""), element.classList.add("language-" + language);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (err) {
            var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
            if (src) {
              var scripts = document.getElementsByTagName("script");
              for (var i in scripts)
                if (scripts[i].src == src)
                  return scripts[i];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(element, className, defaultActivation) {
          for (var no2 = "no-" + className; element; ) {
            var classList = element.classList;
            if (classList.contains(className))
              return !0;
            if (classList.contains(no2))
              return !1;
            element = element.parentElement;
          }
          return !!defaultActivation;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: plainTextGrammar,
        plaintext: plainTextGrammar,
        text: plainTextGrammar,
        txt: plainTextGrammar,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(id2, redef) {
          var lang3 = _2.util.clone(_2.languages[id2]);
          for (var key2 in redef)
            lang3[key2] = redef[key2];
          return lang3;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(inside, before, insert, root) {
          root = root || /** @type {any} */
          _2.languages;
          var grammar = root[inside], ret = {};
          for (var token2 in grammar)
            if (grammar.hasOwnProperty(token2)) {
              if (token2 == before)
                for (var newToken in insert)
                  insert.hasOwnProperty(newToken) && (ret[newToken] = insert[newToken]);
              insert.hasOwnProperty(token2) || (ret[token2] = grammar[token2]);
            }
          var old = root[inside];
          return root[inside] = ret, _2.languages.DFS(_2.languages, function(key2, value) {
            value === old && key2 != inside && (this[key2] = ret);
          }), ret;
        },
        // Traverse a language definition with Depth First Search
        DFS: function DFS(o, callback, type, visited) {
          visited = visited || {};
          var objId = _2.util.objId;
          for (var i in o)
            if (o.hasOwnProperty(i)) {
              callback.call(o, i, o[i], type || i);
              var property = o[i], propertyType = _2.util.type(property);
              propertyType === "Object" && !visited[objId(property)] ? (visited[objId(property)] = !0, DFS(property, callback, null, visited)) : propertyType === "Array" && !visited[objId(property)] && (visited[objId(property)] = !0, DFS(property, callback, i, visited));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(async, callback) {
        _2.highlightAllUnder(document, async, callback);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(container, async, callback) {
        var env = {
          callback,
          container,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        _2.hooks.run("before-highlightall", env), env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector)), _2.hooks.run("before-all-elements-highlight", env);
        for (var i = 0, element; element = env.elements[i++]; )
          _2.highlightElement(element, async === !0, env.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(element, async, callback) {
        var language = _2.util.getLanguage(element), grammar = _2.languages[language];
        _2.util.setLanguage(element, language);
        var parent = element.parentElement;
        parent && parent.nodeName.toLowerCase() === "pre" && _2.util.setLanguage(parent, language);
        var code = element.textContent, env = {
          element,
          language,
          grammar,
          code
        };
        function insertHighlightedCode(highlightedCode) {
          env.highlightedCode = highlightedCode, _2.hooks.run("before-insert", env), env.element.innerHTML = env.highlightedCode, _2.hooks.run("after-highlight", env), _2.hooks.run("complete", env), callback && callback.call(env.element);
        }
        if (_2.hooks.run("before-sanity-check", env), parent = env.element.parentElement, parent && parent.nodeName.toLowerCase() === "pre" && !parent.hasAttribute("tabindex") && parent.setAttribute("tabindex", "0"), !env.code) {
          _2.hooks.run("complete", env), callback && callback.call(env.element);
          return;
        }
        if (_2.hooks.run("before-highlight", env), !env.grammar) {
          insertHighlightedCode(_2.util.encode(env.code));
          return;
        }
        if (async && _self2.Worker) {
          var worker = new Worker(_2.filename);
          worker.onmessage = function(evt) {
            insertHighlightedCode(evt.data);
          }, worker.postMessage(JSON.stringify({
            language: env.language,
            code: env.code,
            immediateClose: !0
          }));
        } else
          insertHighlightedCode(_2.highlight(env.code, env.grammar, env.language));
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(text, grammar, language) {
        var env = {
          code: text,
          grammar,
          language
        };
        if (_2.hooks.run("before-tokenize", env), !env.grammar)
          throw new Error('The language "' + env.language + '" has no grammar.');
        return env.tokens = _2.tokenize(env.code, env.grammar), _2.hooks.run("after-tokenize", env), Token.stringify(_2.util.encode(env.tokens), env.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(text, grammar) {
        var rest = grammar.rest;
        if (rest) {
          for (var token2 in rest)
            grammar[token2] = rest[token2];
          delete grammar.rest;
        }
        var tokenList = new LinkedList();
        return addAfter(tokenList, tokenList.head, text), matchGrammar(text, tokenList, grammar, tokenList.head, 0), toArray(tokenList);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(name2, callback) {
          var hooks = _2.hooks.all;
          hooks[name2] = hooks[name2] || [], hooks[name2].push(callback);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(name2, env) {
          var callbacks2 = _2.hooks.all[name2];
          if (!(!callbacks2 || !callbacks2.length))
            for (var i = 0, callback; callback = callbacks2[i++]; )
              callback(env);
        }
      },
      Token
    };
    _self2.Prism = _2;
    function Token(type, content, alias2, matchedStr) {
      this.type = type, this.content = content, this.alias = alias2, this.length = (matchedStr || "").length | 0;
    }
    Token.stringify = function stringify2(o, language) {
      if (typeof o == "string")
        return o;
      if (Array.isArray(o)) {
        var s = "";
        return o.forEach(function(e) {
          s += stringify2(e, language);
        }), s;
      }
      var env = {
        type: o.type,
        content: stringify2(o.content, language),
        tag: "span",
        classes: ["token", o.type],
        attributes: {},
        language
      }, aliases = o.alias;
      aliases && (Array.isArray(aliases) ? Array.prototype.push.apply(env.classes, aliases) : env.classes.push(aliases)), _2.hooks.run("wrap", env);
      var attributes2 = "";
      for (var name2 in env.attributes)
        attributes2 += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
      return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes2 + ">" + env.content + "</" + env.tag + ">";
    };
    function matchPattern(pattern, pos, text, lookbehind) {
      pattern.lastIndex = pos;
      var match2 = pattern.exec(text);
      if (match2 && lookbehind && match2[1]) {
        var lookbehindLength = match2[1].length;
        match2.index += lookbehindLength, match2[0] = match2[0].slice(lookbehindLength);
      }
      return match2;
    }
    function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
      for (var token2 in grammar)
        if (!(!grammar.hasOwnProperty(token2) || !grammar[token2])) {
          var patterns = grammar[token2];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j2 = 0; j2 < patterns.length; ++j2) {
            if (rematch && rematch.cause == token2 + "," + j2)
              return;
            var patternObj = patterns[j2], inside = patternObj.inside, lookbehind = !!patternObj.lookbehind, greedy = !!patternObj.greedy, alias2 = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            for (var pattern = patternObj.pattern || patternObj, currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail && !(rematch && pos >= rematch.reach); pos += currentNode.value.length, currentNode = currentNode.next) {
              var str = currentNode.value;
              if (tokenList.length > text.length)
                return;
              if (!(str instanceof Token)) {
                var removeCount = 1, match2;
                if (greedy) {
                  if (match2 = matchPattern(pattern, pos, text, lookbehind), !match2 || match2.index >= text.length)
                    break;
                  var from2 = match2.index, to = match2.index + match2[0].length, p = pos;
                  for (p += currentNode.value.length; from2 >= p; )
                    currentNode = currentNode.next, p += currentNode.value.length;
                  if (p -= currentNode.value.length, pos = p, currentNode.value instanceof Token)
                    continue;
                  for (var k2 = currentNode; k2 !== tokenList.tail && (p < to || typeof k2.value == "string"); k2 = k2.next)
                    removeCount++, p += k2.value.length;
                  removeCount--, str = text.slice(pos, p), match2.index -= pos;
                } else if (match2 = matchPattern(pattern, 0, str, lookbehind), !match2)
                  continue;
                var from2 = match2.index, matchStr = match2[0], before = str.slice(0, from2), after = str.slice(from2 + matchStr.length), reach = pos + str.length;
                rematch && reach > rematch.reach && (rematch.reach = reach);
                var removeFrom = currentNode.prev;
                before && (removeFrom = addAfter(tokenList, removeFrom, before), pos += before.length), removeRange(tokenList, removeFrom, removeCount);
                var wrapped = new Token(token2, inside ? _2.tokenize(matchStr, inside) : matchStr, alias2, matchStr);
                if (currentNode = addAfter(tokenList, removeFrom, wrapped), after && addAfter(tokenList, currentNode, after), removeCount > 1) {
                  var nestedRematch = {
                    cause: token2 + "," + j2,
                    reach
                  };
                  matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch), rematch && nestedRematch.reach > rematch.reach && (rematch.reach = nestedRematch.reach);
                }
              }
            }
          }
        }
    }
    function LinkedList() {
      var head = { value: null, prev: null, next: null }, tail = { value: null, prev: head, next: null };
      head.next = tail, this.head = head, this.tail = tail, this.length = 0;
    }
    function addAfter(list, node2, value) {
      var next2 = node2.next, newNode = { value, prev: node2, next: next2 };
      return node2.next = newNode, next2.prev = newNode, list.length++, newNode;
    }
    function removeRange(list, node2, count) {
      for (var next2 = node2.next, i = 0; i < count && next2 !== list.tail; i++)
        next2 = next2.next;
      node2.next = next2, next2.prev = node2, list.length -= i;
    }
    function toArray(list) {
      for (var array = [], node2 = list.head.next; node2 !== list.tail; )
        array.push(node2.value), node2 = node2.next;
      return array;
    }
    if (!_self2.document)
      return _self2.addEventListener && (_2.disableWorkerMessageHandler || _self2.addEventListener("message", function(evt) {
        var message = JSON.parse(evt.data), lang3 = message.language, code = message.code, immediateClose = message.immediateClose;
        _self2.postMessage(_2.highlight(code, _2.languages[lang3], lang3)), immediateClose && _self2.close();
      }, !1)), _2;
    var script = _2.util.currentScript();
    script && (_2.filename = script.src, script.hasAttribute("data-manual") && (_2.manual = !0));
    function highlightAutomaticallyCallback() {
      _2.manual || _2.highlightAll();
    }
    if (!_2.manual) {
      var readyState = document.readyState;
      readyState === "loading" || readyState === "interactive" && script && script.defer ? document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback) : window.requestAnimationFrame ? window.requestAnimationFrame(highlightAutomaticallyCallback) : window.setTimeout(highlightAutomaticallyCallback, 16);
    }
    return _2;
  }(_self);
  module.exports && (module.exports = Prism2), typeof commonjsGlobal < "u" && (commonjsGlobal.Prism = Prism2);
})(prismCore);
var prismCoreExports = prismCore.exports, markup_1 = markup$1;
markup$1.displayName = "markup";
markup$1.aliases = ["html", "mathml", "svg", "xml", "ssml", "atom", "rss"];
function markup$1(Prism2) {
  Prism2.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              /"|'/
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, Prism2.languages.markup.tag.inside["attr-value"].inside.entity = Prism2.languages.markup.entity, Prism2.languages.markup.doctype.inside["internal-subset"].inside = Prism2.languages.markup, Prism2.hooks.add("wrap", function(env) {
    env.type === "entity" && (env.attributes.title = env.content.value.replace(/&amp;/, "&"));
  }), Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(tagName, lang2) {
      var includedCdataInside = {};
      includedCdataInside["language-" + lang2] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: Prism2.languages[lang2]
      }, includedCdataInside.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var inside = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: includedCdataInside
        }
      };
      inside["language-" + lang2] = {
        pattern: /[\s\S]+/,
        inside: Prism2.languages[lang2]
      };
      var def = {};
      def[tagName] = {
        pattern: RegExp(
          /(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
            /__/g,
            function() {
              return tagName;
            }
          ),
          "i"
        ),
        lookbehind: !0,
        greedy: !0,
        inside
      }, Prism2.languages.insertBefore("markup", "cdata", def);
    }
  }), Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(attrName, lang2) {
      Prism2.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [lang2, "language-" + lang2],
                inside: Prism2.languages[lang2]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), Prism2.languages.html = Prism2.languages.markup, Prism2.languages.mathml = Prism2.languages.markup, Prism2.languages.svg = Prism2.languages.markup, Prism2.languages.xml = Prism2.languages.extend("markup", {}), Prism2.languages.ssml = Prism2.languages.xml, Prism2.languages.atom = Prism2.languages.xml, Prism2.languages.rss = Prism2.languages.xml;
}
var css_1 = css$1;
css$1.displayName = "css";
css$1.aliases = [];
function css$1(Prism2) {
  (function(Prism3) {
    var string = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    Prism3.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp(
          "\\burl\\((?:" + string.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)",
          "i"
        ),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + string.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(
          `(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string.source + ")*(?=\\s*\\{)"
        ),
        lookbehind: !0
      },
      string: {
        pattern: string,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, Prism3.languages.css.atrule.inside.rest = Prism3.languages.css;
    var markup2 = Prism3.languages.markup;
    markup2 && (markup2.tag.addInlined("style", "css"), markup2.tag.addAttribute("style", "css"));
  })(Prism2);
}
var clike_1 = clike$1;
clike$1.displayName = "clike";
clike$1.aliases = [];
function clike$1(Prism2) {
  Prism2.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  };
}
var javascript_1 = javascript;
javascript.displayName = "javascript";
javascript.aliases = ["js"];
function javascript(Prism2) {
  Prism2.languages.javascript = Prism2.languages.extend("clike", {
    "class-name": [
      Prism2.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, Prism2.languages.insertBefore("javascript", "keyword", {
    regex: {
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: Prism2.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: Prism2.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), Prism2.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: Prism2.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), Prism2.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), Prism2.languages.markup && (Prism2.languages.markup.tag.addInlined("script", "javascript"), Prism2.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), Prism2.languages.js = Prism2.languages.javascript;
}
var ctx = typeof globalThis == "object" ? globalThis : typeof self == "object" ? self : typeof window == "object" ? window : typeof commonjsGlobal == "object" ? commonjsGlobal : {}, restore = capture();
ctx.Prism = { manual: !0, disableWorkerMessageHandler: !0 };
var h$1 = hastscript, decode = parseEntities_1, Prism = prismCoreExports, markup = markup_1, css = css_1, clike = clike_1, js = javascript_1;
restore();
var own$1 = {}.hasOwnProperty;
function Refractor$2() {
}
Refractor$2.prototype = Prism;
var refract = new Refractor$2(), core = refract;
refract.highlight = highlight;
refract.register = register;
refract.alias = alias;
refract.registered = registered;
refract.listLanguages = listLanguages;
register(markup);
register(css);
register(clike);
register(js);
refract.util.encode = encode;
refract.Token.stringify = stringify;
function register(grammar) {
  if (typeof grammar != "function" || !grammar.displayName)
    throw new Error("Expected `function` for `grammar`, got `" + grammar + "`");
  refract.languages[grammar.displayName] === void 0 && grammar(refract);
}
function alias(name2, alias2) {
  var languages = refract.languages, map2 = name2, key2, list, length2, index2;
  alias2 && (map2 = {}, map2[name2] = alias2);
  for (key2 in map2)
    for (list = map2[key2], list = typeof list == "string" ? [list] : list, length2 = list.length, index2 = -1; ++index2 < length2; )
      languages[list[index2]] = languages[key2];
}
function highlight(value, name2) {
  var sup4 = Prism.highlight, grammar;
  if (typeof value != "string")
    throw new Error("Expected `string` for `value`, got `" + value + "`");
  if (refract.util.type(name2) === "Object")
    grammar = name2, name2 = null;
  else {
    if (typeof name2 != "string")
      throw new Error("Expected `string` for `name`, got `" + name2 + "`");
    if (own$1.call(refract.languages, name2))
      grammar = refract.languages[name2];
    else
      throw new Error("Unknown language: `" + name2 + "` is not registered");
  }
  return sup4.call(this, value, grammar, name2);
}
function registered(language) {
  if (typeof language != "string")
    throw new Error("Expected `string` for `language`, got `" + language + "`");
  return own$1.call(refract.languages, language);
}
function listLanguages() {
  var languages = refract.languages, list = [], language;
  for (language in languages)
    own$1.call(languages, language) && typeof languages[language] == "object" && list.push(language);
  return list;
}
function stringify(value, language, parent) {
  var env;
  return typeof value == "string" ? { type: "text", value } : refract.util.type(value) === "Array" ? stringifyAll(value, language) : (env = {
    type: value.type,
    content: refract.Token.stringify(value.content, language, parent),
    tag: "span",
    classes: ["token", value.type],
    attributes: {},
    language,
    parent
  }, value.alias && (env.classes = env.classes.concat(value.alias)), refract.hooks.run("wrap", env), h$1(
    env.tag + "." + env.classes.join("."),
    attributes(env.attributes),
    env.content
  ));
}
function stringifyAll(values, language) {
  for (var result = [], length2 = values.length, index2 = -1, value; ++index2 < length2; )
    value = values[index2], value !== "" && value !== null && value !== void 0 && result.push(value);
  for (index2 = -1, length2 = result.length; ++index2 < length2; )
    value = result[index2], result[index2] = refract.Token.stringify(value, language, result);
  return result;
}
function encode(tokens) {
  return tokens;
}
function attributes(attrs) {
  var key2;
  for (key2 in attrs)
    attrs[key2] = decode(attrs[key2]);
  return attrs;
}
function capture() {
  var defined = "Prism" in ctx, current = defined ? ctx.Prism : void 0;
  return restore2;
  function restore2() {
    defined ? ctx.Prism = current : delete ctx.Prism, defined = void 0, current = void 0;
  }
}
var mapChildren$1 = {}, React$1 = React__default;
function mapChild(child, i, depth) {
  if (child.tagName) {
    var className = child.properties && Array.isArray(child.properties.className) ? child.properties.className.join(" ") : child.properties.className;
    return React$1.createElement(child.tagName, Object.assign({
      key: "fract-".concat(depth, "-").concat(i)
    }, child.properties, {
      className
    }), child.children && child.children.map(mapWithDepth(depth + 1)));
  }
  return child.value;
}
function mapWithDepth(depth) {
  return function(child, i) {
    return mapChild(child, i, depth);
  };
}
mapChildren$1.depth = mapWithDepth;
var convert_1 = convert$2;
function convert$2(test2) {
  if (test2 == null)
    return ok;
  if (typeof test2 == "string")
    return typeFactory(test2);
  if (typeof test2 == "object")
    return "length" in test2 ? anyFactory(test2) : allFactory(test2);
  if (typeof test2 == "function")
    return test2;
  throw new Error("Expected function, string, or object as test");
}
function allFactory(test2) {
  return all;
  function all(node2) {
    var key2;
    for (key2 in test2)
      if (node2[key2] !== test2[key2]) return !1;
    return !0;
  }
}
function anyFactory(tests2) {
  for (var checks2 = [], index2 = -1; ++index2 < tests2.length; )
    checks2[index2] = convert$2(tests2[index2]);
  return any;
  function any() {
    for (var index3 = -1; ++index3 < checks2.length; )
      if (checks2[index3].apply(this, arguments))
        return !0;
    return !1;
  }
}
function typeFactory(test2) {
  return type;
  function type(node2) {
    return !!(node2 && node2.type === test2);
  }
}
function ok() {
  return !0;
}
var convert$1 = convert_1, unistUtilFilter = filter$2, own = {}.hasOwnProperty;
function filter$2(tree, options, test2) {
  var is = convert$1(test2 || options), cascade = options.cascade == null ? !0 : options.cascade;
  return preorder(tree, null, null);
  function preorder(node2, index2, parent) {
    var children, childIndex, result, next2, key2;
    if (!is(node2, index2, parent)) return null;
    if (node2.children) {
      for (children = [], childIndex = -1; ++childIndex < node2.children.length; )
        result = preorder(node2.children[childIndex], childIndex, node2), result && children.push(result);
      if (cascade && node2.children.length && !children.length) return null;
    }
    next2 = {};
    for (key2 in node2)
      own.call(node2, key2) && (next2[key2] = key2 === "children" ? children : node2[key2]);
    return next2;
  }
}
var color_1 = color$2;
function color$2(d) {
  return "\x1B[33m" + d + "\x1B[39m";
}
var unistUtilVisitParents = visitParents, convert = convert_1, color$1 = color_1, CONTINUE = !0, SKIP = "skip", EXIT = !1;
visitParents.CONTINUE = CONTINUE;
visitParents.SKIP = SKIP;
visitParents.EXIT = EXIT;
function visitParents(tree, test2, visitor, reverse) {
  var step, is;
  typeof test2 == "function" && typeof visitor != "function" && (reverse = visitor, visitor = test2, test2 = null), is = convert(test2), step = reverse ? -1 : 1, factory2(tree, null, [])();
  function factory2(node2, index2, parents) {
    var value = typeof node2 == "object" && node2 !== null ? node2 : {}, name2;
    return typeof value.type == "string" && (name2 = typeof value.tagName == "string" ? value.tagName : typeof value.name == "string" ? value.name : void 0, visit2.displayName = "node (" + color$1(value.type + (name2 ? "<" + name2 + ">" : "")) + ")"), visit2;
    function visit2() {
      var grandparents = parents.concat(node2), result = [], subresult, offset2;
      if ((!test2 || is(node2, index2, parents[parents.length - 1] || null)) && (result = toResult(visitor(node2, parents)), result[0] === EXIT))
        return result;
      if (node2.children && result[0] !== SKIP)
        for (offset2 = (reverse ? node2.children.length : -1) + step; offset2 > -1 && offset2 < node2.children.length; ) {
          if (subresult = factory2(node2.children[offset2], offset2, grandparents)(), subresult[0] === EXIT)
            return subresult;
          offset2 = typeof subresult[1] == "number" ? subresult[1] : offset2 + step;
        }
      return result;
    }
  }
}
function toResult(value) {
  return value !== null && typeof value == "object" && "length" in value ? value : typeof value == "number" ? [CONTINUE, value] : [value];
}
var map = typeof WeakMap == "function" ? HappyMap : SadMap;
function HappyMap() {
  this.map = /* @__PURE__ */ new WeakMap();
}
HappyMap.prototype.has = function(key2) {
  return this.map.has(key2);
};
HappyMap.prototype.set = function(key2, value) {
  return this.map.set(key2, value), this;
};
HappyMap.prototype.get = function(key2) {
  return this.map.get(key2);
};
HappyMap.prototype.clear = function() {
};
function SadMap() {
  this.keys = [], this.values = [];
}
SadMap.prototype.has = function(key2) {
  return this.keys.indexOf(key2) !== -1;
};
SadMap.prototype.set = function(key2, value) {
  var index2 = this.keys.indexOf(key2);
  return index2 === -1 ? (this.keys.push(key2), this.values.push(value)) : this.values[index2] = value, this;
};
SadMap.prototype.get = function(key2) {
  var index2 = this.keys.indexOf(key2);
  return index2 === -1 ? void 0 : this.values[index2];
};
SadMap.prototype.clear = function() {
  this.keys = [], this.values = [];
};
var filter$1 = unistUtilFilter, visit = unistUtilVisitParents, NodeMap = map;
function lineNumberify(ast2) {
  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
    lineNumber: 1
  };
  return ast2.reduce(function(result, node2) {
    var lineStart = context.lineNumber;
    if (node2.type === "text") {
      if (node2.value.indexOf(`
`) === -1)
        return node2.lineStart = lineStart, node2.lineEnd = lineStart, result.nodes.push(node2), result;
      for (var lines = node2.value.split(`
`), i = 0; i < lines.length; i++) {
        var lineNum = i === 0 ? context.lineNumber : ++context.lineNumber;
        result.nodes.push({
          type: "text",
          value: i === lines.length - 1 ? lines[i] : "".concat(lines[i], `
`),
          lineStart: lineNum,
          lineEnd: lineNum
        });
      }
      return result.lineNumber = context.lineNumber, result;
    }
    if (node2.children) {
      var processed = lineNumberify(node2.children, context), firstChild = processed.nodes[0], lastChild = processed.nodes[processed.nodes.length - 1];
      return node2.lineStart = firstChild ? firstChild.lineStart : lineStart, node2.lineEnd = lastChild ? lastChild.lineEnd : lineStart, node2.children = processed.nodes, result.lineNumber = processed.lineNumber, result.nodes.push(node2), result;
    }
    return result.nodes.push(node2), result;
  }, {
    nodes: [],
    lineNumber: context.lineNumber
  });
}
function unwrapLine(markerLine, nodes) {
  var tree = {
    type: "root",
    children: nodes
  }, headMap = new NodeMap(), lineMap = new NodeMap(), tailMap = new NodeMap(), cloned = [];
  function addCopy(map2, node2, ancestors) {
    cloned.push(node2), ancestors.forEach(function(ancestor2) {
      map2.has(ancestor2) || (map2.set(ancestor2, Object.assign({}, ancestor2, {
        children: []
      })), ancestor2 !== tree && cloned.push(ancestor2));
    });
    for (var i = ancestors.length; i--; ) {
      var ancestor = map2.get(ancestors[i]), child = ancestors[i + 1], leaf = map2.get(child) || node2;
      ancestor.children.indexOf(leaf) === -1 && ancestor.children.push(leaf);
    }
  }
  visit(tree, function(node2, ancestors) {
    if (!node2.children) {
      if (node2.lineStart < markerLine) {
        addCopy(headMap, node2, ancestors);
        return;
      }
      if (node2.lineStart === markerLine) {
        addCopy(lineMap, node2, ancestors);
        return;
      }
      node2.lineEnd > markerLine && cloned.some(function(clone) {
        return ancestors.indexOf(clone) !== -1;
      }) && addCopy(tailMap, node2, ancestors);
    }
  });
  var filtered = filter$1(tree, function(node2) {
    return cloned.indexOf(node2) === -1;
  }), getChildren = function(map2) {
    var rootNode = map2.get(tree);
    return rootNode ? (visit(rootNode, function(leaf, ancestors) {
      if (leaf.children) {
        leaf.lineStart = 0, leaf.lineEnd = 0;
        return;
      }
      ancestors.forEach(function(ancestor) {
        ancestor.lineStart = Math.max(ancestor.lineStart, leaf.lineStart), ancestor.lineEnd = Math.max(ancestor.lineEnd, leaf.lineEnd);
      });
    }), rootNode.children) : [];
  }, merged = [].concat(getChildren(headMap), getChildren(lineMap), getChildren(tailMap), filtered ? filtered.children : []);
  return headMap.clear(), lineMap.clear(), tailMap.clear(), merged;
}
function wrapBatch(children, marker2, options) {
  var className = marker2.className || "refractor-marker";
  return {
    type: "element",
    tagName: marker2.component || "div",
    properties: marker2.component ? Object.assign({}, options, {
      className
    }) : {
      className
    },
    children,
    lineStart: marker2.line,
    lineEnd: children[children.length - 1].lineEnd,
    isMarker: !0
  };
}
function wrapLines(treeNodes, markers, options) {
  if (markers.length === 0 || treeNodes.length === 0)
    return treeNodes;
  for (var ast2 = markers.reduce(function(acc, marker3) {
    return unwrapLine(marker3.line, acc);
  }, treeNodes), wrapped = [], astIndex = 0, m2 = 0; m2 < markers.length; m2++) {
    for (var marker2 = markers[m2], node2 = ast2[astIndex]; node2 && node2.lineEnd < marker2.line; node2 = ast2[++astIndex])
      wrapped.push(node2);
    for (var batch = [], _node = ast2[astIndex]; _node && _node.lineEnd === marker2.line; _node = ast2[++astIndex])
      batch.push(_node);
    batch.length > 0 && wrapped.push(wrapBatch(batch, marker2, options));
  }
  for (; astIndex < ast2.length; )
    wrapped.push(ast2[astIndex++]);
  return wrapped;
}
function addMarkers$1(ast2, options) {
  var markers = options.markers.map(function(marker2) {
    return marker2.line ? marker2 : {
      line: marker2
    };
  }).sort(function(nodeA, nodeB) {
    return nodeA.line - nodeB.line;
  }), numbered = lineNumberify(ast2).nodes;
  return wrapLines(numbered, markers, options);
}
var addMarkers_1 = addMarkers$1, React = React__default, fract = core, mapChildren = mapChildren$1, addMarkers = addMarkers_1, h = React.createElement;
function Refractor(props) {
  process.env.NODE_ENV !== "production" && (fract.registered(props.language) || console.warn('No language definitions for "'.concat(props.language, '" seems to be registered, did you forget to call `Refractor.registerLanguage()`?')));
  var langClassName = "language-".concat(props.language), codeProps = {
    className: langClassName
  }, preProps = {
    className: [props.className || "refractor", langClassName].filter(Boolean).join(" ")
  };
  props.inline && (codeProps.style = {
    display: "inline"
  }, codeProps.className = props.className || "refractor");
  var ast2 = fract.highlight(props.value, props.language);
  props.markers && props.markers.length > 0 && (ast2 = addMarkers(ast2, {
    markers: props.markers
  }));
  var value = ast2.length === 0 ? props.value : ast2.map(mapChildren.depth(0)), code = h("code", codeProps, value);
  return props.inline ? code : h("pre", preProps, code);
}
Refractor.registerLanguage = function(lang2) {
  return fract.register(lang2);
};
Refractor.hasLanguage = function(lang2) {
  return fract.registered(lang2);
};
var Refractor_1 = Refractor, Refractor$1 = /* @__PURE__ */ getDefaultExportFromCjs(Refractor_1);
const sides = ["top", "right", "bottom", "left"], min = Math.min, max = Math.max, round = Math.round, floor = Math.floor, createCoords = (v2) => ({
  x: v2,
  y: v2
}), oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp$2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value == "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  rtl === void 0 && (rtl = !1);
  const alignment = getAlignment(placement), alignmentAxis = getAlignmentAxis(placement), length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  return rects.reference[length2] > rects.floating[length2] && (mainAlignmentSide = getOppositePlacement(mainAlignmentSide)), [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"], rl = ["right", "left"], tb = ["top", "bottom"], bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      return rtl ? isStart ? rl : lr : isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  return alignment && (list = list.map((side) => side + "-" + alignment), flipAlignment && (list = list.concat(list.map(getOppositeAlignmentPlacement)))), list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding != "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect2) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect2;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement), alignmentAxis = getAlignmentAxis(placement), alignLength = getAxisLength(alignmentAxis), side = getSide(placement), isVertical = sideAxis === "y", commonX = reference.x + reference.width / 2 - floating.width / 2, commonY = reference.y + reference.height / 2 - floating.height / 2, commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config, validMiddleware = middleware2.filter(Boolean), rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  }), {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl), statefulPlacement = placement, middlewareData = {}, resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name: name2,
      fn
    } = validMiddleware[i], {
      x: nextX,
      y: nextY,
      data: data2,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX ?? x2, y2 = nextY ?? y2, middlewareData = {
      ...middlewareData,
      [name2]: {
        ...middlewareData[name2],
        ...data2
      }
    }, reset && resetCount <= 50 && (resetCount++, typeof reset == "object" && (reset.placement && (statefulPlacement = reset.placement), reset.rects && (rects = reset.rects === !0 ? await platform2.getElementRects({
      reference,
      floating,
      strategy
    }) : reset.rects), {
      x: x2,
      y: y2
    } = computeCoordsFromPlacement(rects, statefulPlacement, rtl)), i = -1);
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow$1(state, options) {
  var _await$platform$isEle;
  options === void 0 && (options = {});
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state, {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = !1,
    padding = 0
  } = evaluate(options, state), paddingObject = getPaddingObject(padding), element = elements[altBoundary ? elementContext === "floating" ? "reference" : "floating" : elementContext], clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: (_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) == null || _await$platform$isEle ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  })), rect2 = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference, offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating)), offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect: rect2,
    offsetParent,
    strategy
  }) : rect2);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state, {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null)
      return {};
    const paddingObject = getPaddingObject(padding), coords = {
      x: x2,
      y: y2
    }, axis = getAlignmentAxis(placement), length2 = getAxisLength(axis), arrowDimensions = await platform2.getDimensions(element), isYAxis = axis === "y", minProp = isYAxis ? "top" : "left", maxProp = isYAxis ? "bottom" : "right", clientProp = isYAxis ? "clientHeight" : "clientWidth", endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2], startDiff = coords[axis] - rects.reference[axis], arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) && (clientSize = elements.floating[clientProp] || rects.floating[length2]);
    const centerToReference = endDiff / 2 - startDiff / 2, largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1, minPadding = min(paddingObject[minProp], largestPossiblePadding), maxPadding = min(paddingObject[maxProp], largestPossiblePadding), min$1 = minPadding, max2 = clientSize - arrowDimensions[length2] - maxPadding, center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference, offset2 = clamp$2(min$1, center, max2), shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0, alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
}), flip$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !0,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = !0,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset)
        return {};
      const side = getSide(placement), initialSideAxis = getSideAxis(initialPlacement), isBasePlacement = getSide(initialPlacement) === initialPlacement, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement)), hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      !specifiedFallbackPlacements && hasFallbackAxisSideDirection && fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      const placements = [initialPlacement, ...fallbackPlacements], overflow = await detectOverflow$1(state, detectOverflowOptions), overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis && overflows.push(overflow[side]), checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      if (overflowsData = [...overflowsData, {
        placement,
        overflows
      }], !overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1, nextPlacement = placements[nextIndex];
        if (nextPlacement)
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement)
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return !0;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              placement2 && (resetPlacement = placement2);
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        if (placement !== resetPlacement)
          return {
            reset: {
              placement: resetPlacement
            }
          };
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect2) {
  return {
    top: overflow.top - rect2.height,
    right: overflow.right - rect2.width,
    bottom: overflow.bottom - rect2.height,
    left: overflow.left - rect2.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state, {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          }), offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow$1(state, {
            ...detectOverflowOptions,
            altBoundary: !0
          }), offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state, rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)), side = getSide(placement), alignment = getAlignment(placement), isVertical = getSideAxis(placement) === "y", mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1, crossAxisMulti = rtl && isVertical ? -1 : 1, rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue == "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  return alignment && typeof alignmentAxis == "number" && (crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis), isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  return options === void 0 && (options = 0), {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state, diffCoords = await convertValueToCoords(state, options);
      return placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset ? {} : {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
}, shift$2 = function(options) {
  return options === void 0 && (options = {}), {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state, {
        mainAxis: checkMainAxis = !0,
        crossAxis: checkCrossAxis = !1,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state), coords = {
        x: x2,
        y: y2
      }, overflow = await detectOverflow$1(state, detectOverflowOptions), crossAxis = getSideAxis(getSide(placement)), mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis], crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left", maxSide = mainAxis === "y" ? "bottom" : "right", min2 = mainAxisCoord + overflow[minSide], max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp$2(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left", maxSide = crossAxis === "y" ? "bottom" : "right", min2 = crossAxisCoord + overflow[minSide], max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp$2(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2
        }
      };
    }
  };
};
function getNodeName(node2) {
  return isNode(node2) ? (node2.nodeName || "").toLowerCase() : "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement$1(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  return typeof ShadowRoot > "u" ? !1 : value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$2(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch {
      return !1;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit(), css2 = isElement$1(elementOrCss) ? getComputedStyle$2(elementOrCss) : elementOrCss;
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : !1) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : !1) || !webkit && (css2.filter ? css2.filter !== "none" : !1) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  for (; isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode); ) {
    if (isContainingBlock(currentNode))
      return currentNode;
    if (isTopLayer(currentNode))
      return null;
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle$2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  return isElement$1(element) ? {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  } : {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html")
    return node2;
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  return isLastTraversableNode(parentNode) ? node2.ownerDocument ? node2.ownerDocument.body : node2.body : isHTMLElement$1(parentNode) && isOverflowElement(parentNode) ? parentNode : getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  list === void 0 && (list = []), traverseIframes === void 0 && (traverseIframes = !0);
  const scrollableAncestor = getNearestOverflowAncestor(node2), isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body), win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css2 = getComputedStyle$2(element);
  let width = parseFloat(css2.width) || 0, height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement$1(element), offsetWidth = hasOffset ? element.offsetWidth : width, offsetHeight = hasOffset ? element.offsetHeight : height, shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  return shouldFallback && (width = offsetWidth, height = offsetHeight), {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return isElement$1(element) ? element : element.contextElement;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement))
    return createCoords(1);
  const rect2 = domElement.getBoundingClientRect(), {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round(rect2.width) : rect2.width) / width, y2 = ($2 ? round(rect2.height) : rect2.height) / height;
  return (!x2 || !Number.isFinite(x2)) && (x2 = 1), (!y2 || !Number.isFinite(y2)) && (y2 = 1), {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  return !isWebKit() || !win.visualViewport ? noOffsets : {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  return isFixed === void 0 && (isFixed = !1), !floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element) ? !1 : isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  includeScale === void 0 && (includeScale = !1), isFixedStrategy === void 0 && (isFixedStrategy = !1);
  const clientRect = element.getBoundingClientRect(), domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  includeScale && (offsetParent ? isElement$1(offsetParent) && (scale2 = getScale(offsetParent)) : scale2 = getScale(element));
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x, y2 = (clientRect.top + visualOffsets.y) / scale2.y, width = clientRect.width / scale2.x, height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement), offsetWin = offsetParent && isElement$1(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win, currentIFrame = getFrameElement(currentWin);
    for (; currentIFrame && offsetParent && offsetWin !== currentWin; ) {
      const iframeScale = getScale(currentIFrame), iframeRect = currentIFrame.getBoundingClientRect(), css2 = getComputedStyle$2(currentIFrame), left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x, top2 = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x, y2 *= iframeScale.y, width *= iframeScale.x, height *= iframeScale.y, x2 += left, y2 += top2, currentWin = getWindow(currentIFrame), currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect: rect2,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed", documentElement = getDocumentElement(offsetParent), topLayer = elements ? isTopLayer(elements.floating) : !1;
  if (offsetParent === documentElement || topLayer && isFixed)
    return rect2;
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  }, scale2 = createCoords(1);
  const offsets = createCoords(0), isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if ((isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) && ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isHTMLElement$1(offsetParent))) {
    const offsetRect = getBoundingClientRect(offsetParent);
    scale2 = getScale(offsetParent), offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
  }
  return {
    width: rect2.width * scale2.x,
    height: rect2.height * scale2.y,
    x: rect2.x * scale2.x - scroll.scrollLeft * scale2.x + offsets.x,
    y: rect2.y * scale2.y - scroll.scrollTop * scale2.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html2 = getDocumentElement(element), scroll = getNodeScroll(element), body = element.ownerDocument.body, width = max(html2.scrollWidth, html2.clientWidth, body.scrollWidth, body.clientWidth), height = max(html2.scrollHeight, html2.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  return getComputedStyle$2(body).direction === "rtl" && (x2 += max(html2.clientWidth, body.clientWidth) - width), {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element), html2 = getDocumentElement(element), visualViewport = win.visualViewport;
  let width = html2.clientWidth, height = html2.clientHeight, x2 = 0, y2 = 0;
  if (visualViewport) {
    width = visualViewport.width, height = visualViewport.height;
    const visualViewportBased = isWebKit();
    (!visualViewportBased || visualViewportBased && strategy === "fixed") && (x2 = visualViewport.offsetLeft, y2 = visualViewport.offsetTop);
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, !0, strategy === "fixed"), top2 = clientRect.top + element.clientTop, left = clientRect.left + element.clientLeft, scale2 = isHTMLElement$1(element) ? getScale(element) : createCoords(1), width = element.clientWidth * scale2.x, height = element.clientHeight * scale2.y, x2 = left * scale2.x, y2 = top2 * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect2;
  if (clippingAncestor === "viewport")
    rect2 = getViewportRect(element, strategy);
  else if (clippingAncestor === "document")
    rect2 = getDocumentRect(getDocumentElement(element));
  else if (isElement$1(clippingAncestor))
    rect2 = getInnerBoundingClientRect(clippingAncestor, strategy);
  else {
    const visualOffsets = getVisualOffsets(element);
    rect2 = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect2);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  return parentNode === stopNode || !isElement$1(parentNode) || isLastTraversableNode(parentNode) ? !1 : getComputedStyle$2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache2) {
  const cachedResult = cache2.get(element);
  if (cachedResult)
    return cachedResult;
  let result = getOverflowAncestors(element, [], !1).filter((el2) => isElement$1(el2) && getNodeName(el2) !== "body"), currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$2(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  for (; isElement$1(currentNode) && !isLastTraversableNode(currentNode); ) {
    const computedStyle = getComputedStyle$2(currentNode), currentNodeIsContaining = isContainingBlock(currentNode);
    !currentNodeIsContaining && computedStyle.position === "fixed" && (currentContainingBlockComputedStyle = null), (elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode)) ? result = result.filter((ancestor) => ancestor !== currentNode) : currentContainingBlockComputedStyle = computedStyle, currentNode = getParentNode(currentNode);
  }
  return cache2.set(element, result), result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const clippingAncestors = [...boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary), rootBoundary], firstClippingAncestor = clippingAncestors[0], clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect2 = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    return accRect.top = max(rect2.top, accRect.top), accRect.right = min(rect2.right, accRect.right), accRect.bottom = min(rect2.bottom, accRect.bottom), accRect.left = max(rect2.left, accRect.left), accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent), documentElement = getDocumentElement(offsetParent), isFixed = strategy === "fixed", rect2 = getBoundingClientRect(element, !0, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed)
    if ((getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) && (scroll = getNodeScroll(offsetParent)), isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, !0, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft, offsets.y = offsetRect.y + offsetParent.clientTop;
    } else documentElement && (offsets.x = getWindowScrollBarX(documentElement));
  const x2 = rect2.left + scroll.scrollLeft - offsets.x, y2 = rect2.top + scroll.scrollTop - offsets.y;
  return {
    x: x2,
    y: y2,
    width: rect2.width,
    height: rect2.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$2(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  return !isHTMLElement$1(element) || getComputedStyle$2(element).position === "fixed" ? null : polyfill ? polyfill(element) : element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element))
    return win;
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    for (; svgOffsetParent && !isLastTraversableNode(svgOffsetParent); ) {
      if (isElement$1(svgOffsetParent) && !isStaticPositioned(svgOffsetParent))
        return svgOffsetParent;
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  for (; offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent); )
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  return offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent) ? win : offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data2) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent, getDimensionsFn = this.getDimensions, floatingDimensions = await getDimensionsFn(data2.floating);
  return {
    reference: getRectRelativeToOffsetParent(data2.reference, await getOffsetParentFn(data2.floating), data2.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$2(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement$1,
  isRTL
};
function observeMove(element, onMove) {
  let io = null, timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId), (_io = io) == null || _io.disconnect(), io = null;
  }
  function refresh(skip, threshold) {
    skip === void 0 && (skip = !1), threshold === void 0 && (threshold = 1), cleanup();
    const {
      left,
      top: top2,
      width,
      height
    } = element.getBoundingClientRect();
    if (skip || onMove(), !width || !height)
      return;
    const insetTop = floor(top2), insetRight = floor(root.clientWidth - (left + width)), insetBottom = floor(root.clientHeight - (top2 + height)), insetLeft = floor(left), options = {
      rootMargin: -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px",
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = !0;
    function handleObserve(entries) {
      const ratio2 = entries[0].intersectionRatio;
      if (ratio2 !== threshold) {
        if (!isFirstUpdate)
          return refresh();
        ratio2 ? refresh(!1, ratio2) : timeoutId = setTimeout(() => {
          refresh(!1, 1e-7);
        }, 1e3);
      }
      isFirstUpdate = !1;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  return refresh(!0), cleanup;
}
function autoUpdate(reference, floating, update, options) {
  options === void 0 && (options = {});
  const {
    ancestorScroll = !0,
    ancestorResize = !0,
    elementResize = typeof ResizeObserver == "function",
    layoutShift = typeof IntersectionObserver == "function",
    animationFrame = !1
  } = options, referenceEl = unwrapElement(reference), ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: !0
    }), ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1, resizeObserver = null;
  elementResize && (resizeObserver = new ResizeObserver((_ref) => {
    let [firstEntry] = _ref;
    firstEntry && firstEntry.target === referenceEl && resizeObserver && (resizeObserver.unobserve(floating), cancelAnimationFrame(reobserveFrame), reobserveFrame = requestAnimationFrame(() => {
      var _resizeObserver;
      (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
    })), update();
  }), referenceEl && !animationFrame && resizeObserver.observe(referenceEl), resizeObserver.observe(floating));
  let frameId, prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  animationFrame && frameLoop();
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height) && update(), prevRefRect = nextRefRect, frameId = requestAnimationFrame(frameLoop);
  }
  return update(), () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update), ancestorResize && ancestor.removeEventListener("resize", update);
    }), cleanupIo?.(), (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect(), resizeObserver = null, animationFrame && cancelAnimationFrame(frameId);
  };
}
const detectOverflow = detectOverflow$1, offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, hide$1 = hide$2, arrow$2 = arrow$3, computePosition = (reference, floating, options) => {
  const cache2 = /* @__PURE__ */ new Map(), mergedOptions = {
    platform,
    ...options
  }, platformWithCache = {
    ...mergedOptions.platform,
    _c: cache2
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var reactDom = { exports: {} }, reactDom_production_min = {}, scheduler$1 = { exports: {} }, scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_production_min;
function requireScheduler_production_min() {
  return hasRequiredScheduler_production_min || (hasRequiredScheduler_production_min = 1, function(exports) {
    function f2(a, b) {
      var c = a.length;
      a.push(b);
      a: for (; 0 < c; ) {
        var d = c - 1 >>> 1, e = a[d];
        if (0 < g2(e, b)) a[d] = b, a[c] = e, c = d;
        else break a;
      }
    }
    function h2(a) {
      return a.length === 0 ? null : a[0];
    }
    function k2(a) {
      if (a.length === 0) return null;
      var b = a[0], c = a.pop();
      if (c !== b) {
        a[0] = c;
        a: for (var d = 0, e = a.length, w2 = e >>> 1; d < w2; ) {
          var m2 = 2 * (d + 1) - 1, C2 = a[m2], n = m2 + 1, x2 = a[n];
          if (0 > g2(C2, c)) n < e && 0 > g2(x2, C2) ? (a[d] = x2, a[n] = c, d = n) : (a[d] = C2, a[m2] = c, d = m2);
          else if (n < e && 0 > g2(x2, c)) a[d] = x2, a[n] = c, d = n;
          else break a;
        }
      }
      return b;
    }
    function g2(a, b) {
      var c = a.sortIndex - b.sortIndex;
      return c !== 0 ? c : a.id - b.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var l2 = performance;
      exports.unstable_now = function() {
        return l2.now();
      };
    } else {
      var p = Date, q2 = p.now();
      exports.unstable_now = function() {
        return p.now() - q2;
      };
    }
    var r = [], t = [], u = 1, v2 = null, y2 = 3, z2 = !1, A2 = !1, B2 = !1, D2 = typeof setTimeout == "function" ? setTimeout : null, E2 = typeof clearTimeout == "function" ? clearTimeout : null, F2 = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function G2(a) {
      for (var b = h2(t); b !== null; ) {
        if (b.callback === null) k2(t);
        else if (b.startTime <= a) k2(t), b.sortIndex = b.expirationTime, f2(r, b);
        else break;
        b = h2(t);
      }
    }
    function H2(a) {
      if (B2 = !1, G2(a), !A2) if (h2(r) !== null) A2 = !0, I2(J2);
      else {
        var b = h2(t);
        b !== null && K2(H2, b.startTime - a);
      }
    }
    function J2(a, b) {
      A2 = !1, B2 && (B2 = !1, E2(L2), L2 = -1), z2 = !0;
      var c = y2;
      try {
        for (G2(b), v2 = h2(r); v2 !== null && (!(v2.expirationTime > b) || a && !M2()); ) {
          var d = v2.callback;
          if (typeof d == "function") {
            v2.callback = null, y2 = v2.priorityLevel;
            var e = d(v2.expirationTime <= b);
            b = exports.unstable_now(), typeof e == "function" ? v2.callback = e : v2 === h2(r) && k2(r), G2(b);
          } else k2(r);
          v2 = h2(r);
        }
        if (v2 !== null) var w2 = !0;
        else {
          var m2 = h2(t);
          m2 !== null && K2(H2, m2.startTime - b), w2 = !1;
        }
        return w2;
      } finally {
        v2 = null, y2 = c, z2 = !1;
      }
    }
    var N2 = !1, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
    function M2() {
      return !(exports.unstable_now() - Q2 < P2);
    }
    function R2() {
      if (O2 !== null) {
        var a = exports.unstable_now();
        Q2 = a;
        var b = !0;
        try {
          b = O2(!0, a);
        } finally {
          b ? S2() : (N2 = !1, O2 = null);
        }
      } else N2 = !1;
    }
    var S2;
    if (typeof F2 == "function") S2 = function() {
      F2(R2);
    };
    else if (typeof MessageChannel < "u") {
      var T2 = new MessageChannel(), U2 = T2.port2;
      T2.port1.onmessage = R2, S2 = function() {
        U2.postMessage(null);
      };
    } else S2 = function() {
      D2(R2, 0);
    };
    function I2(a) {
      O2 = a, N2 || (N2 = !0, S2());
    }
    function K2(a, b) {
      L2 = D2(function() {
        a(exports.unstable_now());
      }, b);
    }
    exports.unstable_IdlePriority = 5, exports.unstable_ImmediatePriority = 1, exports.unstable_LowPriority = 4, exports.unstable_NormalPriority = 3, exports.unstable_Profiling = null, exports.unstable_UserBlockingPriority = 2, exports.unstable_cancelCallback = function(a) {
      a.callback = null;
    }, exports.unstable_continueExecution = function() {
      A2 || z2 || (A2 = !0, I2(J2));
    }, exports.unstable_forceFrameRate = function(a) {
      0 > a || 125 < a ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a ? Math.floor(1e3 / a) : 5;
    }, exports.unstable_getCurrentPriorityLevel = function() {
      return y2;
    }, exports.unstable_getFirstCallbackNode = function() {
      return h2(r);
    }, exports.unstable_next = function(a) {
      switch (y2) {
        case 1:
        case 2:
        case 3:
          var b = 3;
          break;
        default:
          b = y2;
      }
      var c = y2;
      y2 = b;
      try {
        return a();
      } finally {
        y2 = c;
      }
    }, exports.unstable_pauseExecution = function() {
    }, exports.unstable_requestPaint = function() {
    }, exports.unstable_runWithPriority = function(a, b) {
      switch (a) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          a = 3;
      }
      var c = y2;
      y2 = a;
      try {
        return b();
      } finally {
        y2 = c;
      }
    }, exports.unstable_scheduleCallback = function(a, b, c) {
      var d = exports.unstable_now();
      switch (typeof c == "object" && c !== null ? (c = c.delay, c = typeof c == "number" && 0 < c ? d + c : d) : c = d, a) {
        case 1:
          var e = -1;
          break;
        case 2:
          e = 250;
          break;
        case 5:
          e = 1073741823;
          break;
        case 4:
          e = 1e4;
          break;
        default:
          e = 5e3;
      }
      return e = c + e, a = { id: u++, callback: b, priorityLevel: a, startTime: c, expirationTime: e, sortIndex: -1 }, c > d ? (a.sortIndex = c, f2(t, a), h2(r) === null && a === h2(t) && (B2 ? (E2(L2), L2 = -1) : B2 = !0, K2(H2, c - d))) : (a.sortIndex = e, f2(r, a), A2 || z2 || (A2 = !0, I2(J2))), a;
    }, exports.unstable_shouldYield = M2, exports.unstable_wrapCallback = function(a) {
      var b = y2;
      return function() {
        var c = y2;
        y2 = b;
        try {
          return a.apply(this, arguments);
        } finally {
          y2 = c;
        }
      };
    };
  }(scheduler_production_min)), scheduler_production_min;
}
var scheduler_development = {};
/**
 * @license React
 * scheduler.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredScheduler_development;
function requireScheduler_development() {
  return hasRequiredScheduler_development || (hasRequiredScheduler_development = 1, function(exports) {
    process.env.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var enableSchedulerDebugging = !1, enableProfiling = !1, frameYieldMs = 5;
      function push(heap, node2) {
        var index2 = heap.length;
        heap.push(node2), siftUp(heap, node2, index2);
      }
      function peek2(heap) {
        return heap.length === 0 ? null : heap[0];
      }
      function pop(heap) {
        if (heap.length === 0)
          return null;
        var first = heap[0], last = heap.pop();
        return last !== first && (heap[0] = last, siftDown(heap, last, 0)), first;
      }
      function siftUp(heap, node2, i) {
        for (var index2 = i; index2 > 0; ) {
          var parentIndex = index2 - 1 >>> 1, parent = heap[parentIndex];
          if (compare(parent, node2) > 0)
            heap[parentIndex] = node2, heap[index2] = parent, index2 = parentIndex;
          else
            return;
        }
      }
      function siftDown(heap, node2, i) {
        for (var index2 = i, length2 = heap.length, halfLength = length2 >>> 1; index2 < halfLength; ) {
          var leftIndex = (index2 + 1) * 2 - 1, left = heap[leftIndex], rightIndex = leftIndex + 1, right = heap[rightIndex];
          if (compare(left, node2) < 0)
            rightIndex < length2 && compare(right, left) < 0 ? (heap[index2] = right, heap[rightIndex] = node2, index2 = rightIndex) : (heap[index2] = left, heap[leftIndex] = node2, index2 = leftIndex);
          else if (rightIndex < length2 && compare(right, node2) < 0)
            heap[index2] = right, heap[rightIndex] = node2, index2 = rightIndex;
          else
            return;
        }
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
      }
      var ImmediatePriority = 1, UserBlockingPriority = 2, NormalPriority = 3, LowPriority = 4, IdlePriority = 5;
      function markTaskErrored(task, ms) {
      }
      var hasPerformanceNow = typeof performance == "object" && typeof performance.now == "function";
      if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date, initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var maxSigned31BitInt = 1073741823, IMMEDIATE_PRIORITY_TIMEOUT = -1, USER_BLOCKING_PRIORITY_TIMEOUT = 250, NORMAL_PRIORITY_TIMEOUT = 5e3, LOW_PRIORITY_TIMEOUT = 1e4, IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt, taskQueue = [], timerQueue = [], taskIdCounter = 1, currentTask = null, currentPriorityLevel = NormalPriority, isPerformingWork = !1, isHostCallbackScheduled = !1, isHostTimeoutScheduled = !1, localSetTimeout = typeof setTimeout == "function" ? setTimeout : null, localClearTimeout = typeof clearTimeout == "function" ? clearTimeout : null, localSetImmediate = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function advanceTimers(currentTime) {
        for (var timer = peek2(timerQueue); timer !== null; ) {
          if (timer.callback === null)
            pop(timerQueue);
          else if (timer.startTime <= currentTime)
            pop(timerQueue), timer.sortIndex = timer.expirationTime, push(taskQueue, timer);
          else
            return;
          timer = peek2(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        if (isHostTimeoutScheduled = !1, advanceTimers(currentTime), !isHostCallbackScheduled)
          if (peek2(taskQueue) !== null)
            isHostCallbackScheduled = !0, requestHostCallback(flushWork);
          else {
            var firstTimer = peek2(timerQueue);
            firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
      }
      function flushWork(hasTimeRemaining, initialTime2) {
        isHostCallbackScheduled = !1, isHostTimeoutScheduled && (isHostTimeoutScheduled = !1, cancelHostTimeout()), isPerformingWork = !0;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          var currentTime;
          if (!enableProfiling) return workLoop(hasTimeRemaining, initialTime2);
        } finally {
          currentTask = null, currentPriorityLevel = previousPriorityLevel, isPerformingWork = !1;
        }
      }
      function workLoop(hasTimeRemaining, initialTime2) {
        var currentTime = initialTime2;
        for (advanceTimers(currentTime), currentTask = peek2(taskQueue); currentTask !== null && !enableSchedulerDebugging && !(currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())); ) {
          var callback = currentTask.callback;
          if (typeof callback == "function") {
            currentTask.callback = null, currentPriorityLevel = currentTask.priorityLevel;
            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime, continuationCallback = callback(didUserCallbackTimeout);
            currentTime = exports.unstable_now(), typeof continuationCallback == "function" ? currentTask.callback = continuationCallback : currentTask === peek2(taskQueue) && pop(taskQueue), advanceTimers(currentTime);
          } else
            pop(taskQueue);
          currentTask = peek2(taskQueue);
        }
        if (currentTask !== null)
          return !0;
        var firstTimer = peek2(timerQueue);
        return firstTimer !== null && requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime), !1;
      }
      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;
          default:
            priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_next(eventHandler) {
        var priorityLevel;
        switch (currentPriorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
            priorityLevel = NormalPriority;
            break;
          default:
            priorityLevel = currentPriorityLevel;
            break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      }
      function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now(), startTime2;
        if (typeof options == "object" && options !== null) {
          var delay2 = options.delay;
          typeof delay2 == "number" && delay2 > 0 ? startTime2 = currentTime + delay2 : startTime2 = currentTime;
        } else
          startTime2 = currentTime;
        var timeout;
        switch (priorityLevel) {
          case ImmediatePriority:
            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
          case UserBlockingPriority:
            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
          case IdlePriority:
            timeout = IDLE_PRIORITY_TIMEOUT;
            break;
          case LowPriority:
            timeout = LOW_PRIORITY_TIMEOUT;
            break;
          case NormalPriority:
          default:
            timeout = NORMAL_PRIORITY_TIMEOUT;
            break;
        }
        var expirationTime = startTime2 + timeout, newTask = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: startTime2,
          expirationTime,
          sortIndex: -1
        };
        return startTime2 > currentTime ? (newTask.sortIndex = startTime2, push(timerQueue, newTask), peek2(taskQueue) === null && newTask === peek2(timerQueue) && (isHostTimeoutScheduled ? cancelHostTimeout() : isHostTimeoutScheduled = !0, requestHostTimeout(handleTimeout, startTime2 - currentTime))) : (newTask.sortIndex = expirationTime, push(taskQueue, newTask), !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork))), newTask;
      }
      function unstable_pauseExecution() {
      }
      function unstable_continueExecution() {
        !isHostCallbackScheduled && !isPerformingWork && (isHostCallbackScheduled = !0, requestHostCallback(flushWork));
      }
      function unstable_getFirstCallbackNode() {
        return peek2(taskQueue);
      }
      function unstable_cancelCallback(task) {
        task.callback = null;
      }
      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }
      var isMessageLoopRunning = !1, scheduledHostCallback = null, taskTimeoutID = -1, frameInterval = frameYieldMs, startTime = -1;
      function shouldYieldToHost() {
        var timeElapsed = exports.unstable_now() - startTime;
        return !(timeElapsed < frameInterval);
      }
      function requestPaint() {
      }
      function forceFrameRate(fps) {
        if (fps < 0 || fps > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        fps > 0 ? frameInterval = Math.floor(1e3 / fps) : frameInterval = frameYieldMs;
      }
      var performWorkUntilDeadline = function() {
        if (scheduledHostCallback !== null) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasTimeRemaining = !0, hasMoreWork = !0;
          try {
            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
          } finally {
            hasMoreWork ? schedulePerformWorkUntilDeadline() : (isMessageLoopRunning = !1, scheduledHostCallback = null);
          }
        } else
          isMessageLoopRunning = !1;
      }, schedulePerformWorkUntilDeadline;
      if (typeof localSetImmediate == "function")
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      else if (typeof MessageChannel < "u") {
        var channel = new MessageChannel(), port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline, schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      function requestHostCallback(callback) {
        scheduledHostCallback = callback, isMessageLoopRunning || (isMessageLoopRunning = !0, schedulePerformWorkUntilDeadline());
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      function cancelHostTimeout() {
        localClearTimeout(taskTimeoutID), taskTimeoutID = -1;
      }
      var unstable_requestPaint = requestPaint, unstable_Profiling = null;
      exports.unstable_IdlePriority = IdlePriority, exports.unstable_ImmediatePriority = ImmediatePriority, exports.unstable_LowPriority = LowPriority, exports.unstable_NormalPriority = NormalPriority, exports.unstable_Profiling = unstable_Profiling, exports.unstable_UserBlockingPriority = UserBlockingPriority, exports.unstable_cancelCallback = unstable_cancelCallback, exports.unstable_continueExecution = unstable_continueExecution, exports.unstable_forceFrameRate = forceFrameRate, exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel, exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode, exports.unstable_next = unstable_next, exports.unstable_pauseExecution = unstable_pauseExecution, exports.unstable_requestPaint = unstable_requestPaint, exports.unstable_runWithPriority = unstable_runWithPriority, exports.unstable_scheduleCallback = unstable_scheduleCallback, exports.unstable_shouldYield = shouldYieldToHost, exports.unstable_wrapCallback = unstable_wrapCallback, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(scheduler_development)), scheduler_development;
}
var hasRequiredScheduler;
function requireScheduler() {
  return hasRequiredScheduler || (hasRequiredScheduler = 1, process.env.NODE_ENV === "production" ? scheduler$1.exports = requireScheduler_production_min() : scheduler$1.exports = requireScheduler_development()), scheduler$1.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_production_min;
function requireReactDom_production_min() {
  if (hasRequiredReactDom_production_min) return reactDom_production_min;
  hasRequiredReactDom_production_min = 1;
  var aa = React__default, ca = requireScheduler();
  function p(a) {
    for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);
    return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var da = /* @__PURE__ */ new Set(), ea = {};
  function fa(a, b) {
    ha(a, b), ha(a + "Capture", b);
  }
  function ha(a, b) {
    for (ea[a] = b, a = 0; a < b.length; a++) da.add(b[a]);
  }
  var ia = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
  function oa(a) {
    return ja.call(ma, a) ? !0 : ja.call(la, a) ? !1 : ka.test(a) ? ma[a] = !0 : (la[a] = !0, !1);
  }
  function pa(a, b, c, d) {
    if (c !== null && c.type === 0) return !1;
    switch (typeof b) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return d ? !1 : c !== null ? !c.acceptsBooleans : (a = a.toLowerCase().slice(0, 5), a !== "data-" && a !== "aria-");
      default:
        return !1;
    }
  }
  function qa(a, b, c, d) {
    if (b === null || typeof b > "u" || pa(a, b, c, d)) return !0;
    if (d) return !1;
    if (c !== null) switch (c.type) {
      case 3:
        return !b;
      case 4:
        return b === !1;
      case 5:
        return isNaN(b);
      case 6:
        return isNaN(b) || 1 > b;
    }
    return !1;
  }
  function v2(a, b, c, d, e, f2, g2) {
    this.acceptsBooleans = b === 2 || b === 3 || b === 4, this.attributeName = d, this.attributeNamespace = e, this.mustUseProperty = c, this.propertyName = a, this.type = b, this.sanitizeURL = f2, this.removeEmptyString = g2;
  }
  var z2 = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a) {
    z2[a] = new v2(a, 0, !1, a, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a) {
    var b = a[0];
    z2[b] = new v2(b, 1, !1, a[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a) {
    z2[a] = new v2(a, 2, !1, a.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a) {
    z2[a] = new v2(a, 2, !1, a, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a) {
    z2[a] = new v2(a, 3, !1, a.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(a) {
    z2[a] = new v2(a, 3, !0, a, null, !1, !1);
  }), ["capture", "download"].forEach(function(a) {
    z2[a] = new v2(a, 4, !1, a, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(a) {
    z2[a] = new v2(a, 6, !1, a, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(a) {
    z2[a] = new v2(a, 5, !1, a.toLowerCase(), null, !1, !1);
  });
  var ra = /[\-:]([a-z])/g;
  function sa(a) {
    return a[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a) {
    var b = a.replace(
      ra,
      sa
    );
    z2[b] = new v2(b, 1, !1, a, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a) {
    var b = a.replace(ra, sa);
    z2[b] = new v2(b, 1, !1, a, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(a) {
    var b = a.replace(ra, sa);
    z2[b] = new v2(b, 1, !1, a, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(a) {
    z2[a] = new v2(a, 1, !1, a.toLowerCase(), null, !1, !1);
  }), z2.xlinkHref = new v2("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(a) {
    z2[a] = new v2(a, 1, !1, a.toLowerCase(), null, !0, !0);
  });
  function ta(a, b, c, d) {
    var e = z2.hasOwnProperty(b) ? z2[b] : null;
    (e !== null ? e.type !== 0 : d || !(2 < b.length) || b[0] !== "o" && b[0] !== "O" || b[1] !== "n" && b[1] !== "N") && (qa(b, c, e, d) && (c = null), d || e === null ? oa(b) && (c === null ? a.removeAttribute(b) : a.setAttribute(b, "" + c)) : e.mustUseProperty ? a[e.propertyName] = c === null ? e.type === 3 ? !1 : "" : c : (b = e.attributeName, d = e.attributeNamespace, c === null ? a.removeAttribute(b) : (e = e.type, c = e === 3 || e === 4 && c === !0 ? "" : "" + c, d ? a.setAttributeNS(d, b, c) : a.setAttribute(b, c))));
  }
  var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy"), Ia = Symbol.for("react.offscreen"), Ja = Symbol.iterator;
  function Ka(a) {
    return a === null || typeof a != "object" ? null : (a = Ja && a[Ja] || a["@@iterator"], typeof a == "function" ? a : null);
  }
  var A2 = Object.assign, La;
  function Ma(a) {
    if (La === void 0) try {
      throw Error();
    } catch (c) {
      var b = c.stack.trim().match(/\n( *(at )?)/);
      La = b && b[1] || "";
    }
    return `
` + La + a;
  }
  var Na = !1;
  function Oa(a, b) {
    if (!a || Na) return "";
    Na = !0;
    var c = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (b) if (b = function() {
        throw Error();
      }, Object.defineProperty(b.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(b, []);
        } catch (l2) {
          var d = l2;
        }
        Reflect.construct(a, [], b);
      } else {
        try {
          b.call();
        } catch (l2) {
          d = l2;
        }
        a.call(b.prototype);
      }
      else {
        try {
          throw Error();
        } catch (l2) {
          d = l2;
        }
        a();
      }
    } catch (l2) {
      if (l2 && d && typeof l2.stack == "string") {
        for (var e = l2.stack.split(`
`), f2 = d.stack.split(`
`), g2 = e.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e[g2] !== f2[h2]; ) h2--;
        for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e[g2] !== f2[h2]) {
          if (g2 !== 1 || h2 !== 1)
            do
              if (g2--, h2--, 0 > h2 || e[g2] !== f2[h2]) {
                var k2 = `
` + e[g2].replace(" at new ", " at ");
                return a.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a.displayName)), k2;
              }
            while (1 <= g2 && 0 <= h2);
          break;
        }
      }
    } finally {
      Na = !1, Error.prepareStackTrace = c;
    }
    return (a = a ? a.displayName || a.name : "") ? Ma(a) : "";
  }
  function Pa(a) {
    switch (a.tag) {
      case 5:
        return Ma(a.type);
      case 16:
        return Ma("Lazy");
      case 13:
        return Ma("Suspense");
      case 19:
        return Ma("SuspenseList");
      case 0:
      case 2:
      case 15:
        return a = Oa(a.type, !1), a;
      case 11:
        return a = Oa(a.type.render, !1), a;
      case 1:
        return a = Oa(a.type, !0), a;
      default:
        return "";
    }
  }
  function Qa(a) {
    if (a == null) return null;
    if (typeof a == "function") return a.displayName || a.name || null;
    if (typeof a == "string") return a;
    switch (a) {
      case ya:
        return "Fragment";
      case wa:
        return "Portal";
      case Aa:
        return "Profiler";
      case za:
        return "StrictMode";
      case Ea:
        return "Suspense";
      case Fa:
        return "SuspenseList";
    }
    if (typeof a == "object") switch (a.$$typeof) {
      case Ca:
        return (a.displayName || "Context") + ".Consumer";
      case Ba:
        return (a._context.displayName || "Context") + ".Provider";
      case Da:
        var b = a.render;
        return a = a.displayName, a || (a = b.displayName || b.name || "", a = a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef"), a;
      case Ga:
        return b = a.displayName || null, b !== null ? b : Qa(a.type) || "Memo";
      case Ha:
        b = a._payload, a = a._init;
        try {
          return Qa(a(b));
        } catch {
        }
    }
    return null;
  }
  function Ra(a) {
    var b = a.type;
    switch (a.tag) {
      case 24:
        return "Cache";
      case 9:
        return (b.displayName || "Context") + ".Consumer";
      case 10:
        return (b._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return a = b.render, a = a.displayName || a.name || "", b.displayName || (a !== "" ? "ForwardRef(" + a + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return b;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return Qa(b);
      case 8:
        return b === za ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof b == "function") return b.displayName || b.name || null;
        if (typeof b == "string") return b;
    }
    return null;
  }
  function Sa(a) {
    switch (typeof a) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return a;
      case "object":
        return a;
      default:
        return "";
    }
  }
  function Ta(a) {
    var b = a.type;
    return (a = a.nodeName) && a.toLowerCase() === "input" && (b === "checkbox" || b === "radio");
  }
  function Ua(a) {
    var b = Ta(a) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b), d = "" + a[b];
    if (!a.hasOwnProperty(b) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
      var e = c.get, f2 = c.set;
      return Object.defineProperty(a, b, { configurable: !0, get: function() {
        return e.call(this);
      }, set: function(a2) {
        d = "" + a2, f2.call(this, a2);
      } }), Object.defineProperty(a, b, { enumerable: c.enumerable }), { getValue: function() {
        return d;
      }, setValue: function(a2) {
        d = "" + a2;
      }, stopTracking: function() {
        a._valueTracker = null, delete a[b];
      } };
    }
  }
  function Va(a) {
    a._valueTracker || (a._valueTracker = Ua(a));
  }
  function Wa(a) {
    if (!a) return !1;
    var b = a._valueTracker;
    if (!b) return !0;
    var c = b.getValue(), d = "";
    return a && (d = Ta(a) ? a.checked ? "true" : "false" : a.value), a = d, a !== c ? (b.setValue(a), !0) : !1;
  }
  function Xa(a) {
    if (a = a || (typeof document < "u" ? document : void 0), typeof a > "u") return null;
    try {
      return a.activeElement || a.body;
    } catch {
      return a.body;
    }
  }
  function Ya(a, b) {
    var c = b.checked;
    return A2({}, b, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: c ?? a._wrapperState.initialChecked });
  }
  function Za(a, b) {
    var c = b.defaultValue == null ? "" : b.defaultValue, d = b.checked != null ? b.checked : b.defaultChecked;
    c = Sa(b.value != null ? b.value : c), a._wrapperState = { initialChecked: d, initialValue: c, controlled: b.type === "checkbox" || b.type === "radio" ? b.checked != null : b.value != null };
  }
  function ab(a, b) {
    b = b.checked, b != null && ta(a, "checked", b, !1);
  }
  function bb(a, b) {
    ab(a, b);
    var c = Sa(b.value), d = b.type;
    if (c != null) d === "number" ? (c === 0 && a.value === "" || a.value != c) && (a.value = "" + c) : a.value !== "" + c && (a.value = "" + c);
    else if (d === "submit" || d === "reset") {
      a.removeAttribute("value");
      return;
    }
    b.hasOwnProperty("value") ? cb(a, b.type, c) : b.hasOwnProperty("defaultValue") && cb(a, b.type, Sa(b.defaultValue)), b.checked == null && b.defaultChecked != null && (a.defaultChecked = !!b.defaultChecked);
  }
  function db(a, b, c) {
    if (b.hasOwnProperty("value") || b.hasOwnProperty("defaultValue")) {
      var d = b.type;
      if (!(d !== "submit" && d !== "reset" || b.value !== void 0 && b.value !== null)) return;
      b = "" + a._wrapperState.initialValue, c || b === a.value || (a.value = b), a.defaultValue = b;
    }
    c = a.name, c !== "" && (a.name = ""), a.defaultChecked = !!a._wrapperState.initialChecked, c !== "" && (a.name = c);
  }
  function cb(a, b, c) {
    (b !== "number" || Xa(a.ownerDocument) !== a) && (c == null ? a.defaultValue = "" + a._wrapperState.initialValue : a.defaultValue !== "" + c && (a.defaultValue = "" + c));
  }
  var eb = Array.isArray;
  function fb(a, b, c, d) {
    if (a = a.options, b) {
      b = {};
      for (var e = 0; e < c.length; e++) b["$" + c[e]] = !0;
      for (c = 0; c < a.length; c++) e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    } else {
      for (c = "" + Sa(c), b = null, e = 0; e < a.length; e++) {
        if (a[e].value === c) {
          a[e].selected = !0, d && (a[e].defaultSelected = !0);
          return;
        }
        b !== null || a[e].disabled || (b = a[e]);
      }
      b !== null && (b.selected = !0);
    }
  }
  function gb(a, b) {
    if (b.dangerouslySetInnerHTML != null) throw Error(p(91));
    return A2({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
  }
  function hb(a, b) {
    var c = b.value;
    if (c == null) {
      if (c = b.children, b = b.defaultValue, c != null) {
        if (b != null) throw Error(p(92));
        if (eb(c)) {
          if (1 < c.length) throw Error(p(93));
          c = c[0];
        }
        b = c;
      }
      b == null && (b = ""), c = b;
    }
    a._wrapperState = { initialValue: Sa(c) };
  }
  function ib(a, b) {
    var c = Sa(b.value), d = Sa(b.defaultValue);
    c != null && (c = "" + c, c !== a.value && (a.value = c), b.defaultValue == null && a.defaultValue !== c && (a.defaultValue = c)), d != null && (a.defaultValue = "" + d);
  }
  function jb(a) {
    var b = a.textContent;
    b === a._wrapperState.initialValue && b !== "" && b !== null && (a.value = b);
  }
  function kb(a) {
    switch (a) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function lb(a, b) {
    return a == null || a === "http://www.w3.org/1999/xhtml" ? kb(b) : a === "http://www.w3.org/2000/svg" && b === "foreignObject" ? "http://www.w3.org/1999/xhtml" : a;
  }
  var mb, nb = function(a) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(b, c, d, e) {
      MSApp.execUnsafeLocalFunction(function() {
        return a(b, c, d, e);
      });
    } : a;
  }(function(a, b) {
    if (a.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in a) a.innerHTML = b;
    else {
      for (mb = mb || document.createElement("div"), mb.innerHTML = "<svg>" + b.valueOf().toString() + "</svg>", b = mb.firstChild; a.firstChild; ) a.removeChild(a.firstChild);
      for (; b.firstChild; ) a.appendChild(b.firstChild);
    }
  });
  function ob(a, b) {
    if (b) {
      var c = a.firstChild;
      if (c && c === a.lastChild && c.nodeType === 3) {
        c.nodeValue = b;
        return;
      }
    }
    a.textContent = b;
  }
  var pb = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, qb = ["Webkit", "ms", "Moz", "O"];
  Object.keys(pb).forEach(function(a) {
    qb.forEach(function(b) {
      b = b + a.charAt(0).toUpperCase() + a.substring(1), pb[b] = pb[a];
    });
  });
  function rb(a, b, c) {
    return b == null || typeof b == "boolean" || b === "" ? "" : c || typeof b != "number" || b === 0 || pb.hasOwnProperty(a) && pb[a] ? ("" + b).trim() : b + "px";
  }
  function sb(a, b) {
    a = a.style;
    for (var c in b) if (b.hasOwnProperty(c)) {
      var d = c.indexOf("--") === 0, e = rb(c, b[c], d);
      c === "float" && (c = "cssFloat"), d ? a.setProperty(c, e) : a[c] = e;
    }
  }
  var tb = A2({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function ub(a, b) {
    if (b) {
      if (tb[a] && (b.children != null || b.dangerouslySetInnerHTML != null)) throw Error(p(137, a));
      if (b.dangerouslySetInnerHTML != null) {
        if (b.children != null) throw Error(p(60));
        if (typeof b.dangerouslySetInnerHTML != "object" || !("__html" in b.dangerouslySetInnerHTML)) throw Error(p(61));
      }
      if (b.style != null && typeof b.style != "object") throw Error(p(62));
    }
  }
  function vb(a, b) {
    if (a.indexOf("-") === -1) return typeof b.is == "string";
    switch (a) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var wb = null;
  function xb(a) {
    return a = a.target || a.srcElement || window, a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === 3 ? a.parentNode : a;
  }
  var yb = null, zb = null, Ab = null;
  function Bb(a) {
    if (a = Cb(a)) {
      if (typeof yb != "function") throw Error(p(280));
      var b = a.stateNode;
      b && (b = Db(b), yb(a.stateNode, a.type, b));
    }
  }
  function Eb(a) {
    zb ? Ab ? Ab.push(a) : Ab = [a] : zb = a;
  }
  function Fb() {
    if (zb) {
      var a = zb, b = Ab;
      if (Ab = zb = null, Bb(a), b) for (a = 0; a < b.length; a++) Bb(b[a]);
    }
  }
  function Gb(a, b) {
    return a(b);
  }
  function Hb() {
  }
  var Ib = !1;
  function Jb(a, b, c) {
    if (Ib) return a(b, c);
    Ib = !0;
    try {
      return Gb(a, b, c);
    } finally {
      Ib = !1, (zb !== null || Ab !== null) && (Hb(), Fb());
    }
  }
  function Kb(a, b) {
    var c = a.stateNode;
    if (c === null) return null;
    var d = Db(c);
    if (d === null) return null;
    c = d[b];
    a: switch (b) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (d = !d.disabled) || (a = a.type, d = !(a === "button" || a === "input" || a === "select" || a === "textarea")), a = !d;
        break a;
      default:
        a = !1;
    }
    if (a) return null;
    if (c && typeof c != "function") throw Error(p(231, b, typeof c));
    return c;
  }
  var Lb = !1;
  if (ia) try {
    var Mb = {};
    Object.defineProperty(Mb, "passive", { get: function() {
      Lb = !0;
    } }), window.addEventListener("test", Mb, Mb), window.removeEventListener("test", Mb, Mb);
  } catch {
    Lb = !1;
  }
  function Nb(a, b, c, d, e, f2, g2, h2, k2) {
    var l2 = Array.prototype.slice.call(arguments, 3);
    try {
      b.apply(c, l2);
    } catch (m2) {
      this.onError(m2);
    }
  }
  var Ob = !1, Pb = null, Qb = !1, Rb = null, Sb = { onError: function(a) {
    Ob = !0, Pb = a;
  } };
  function Tb(a, b, c, d, e, f2, g2, h2, k2) {
    Ob = !1, Pb = null, Nb.apply(Sb, arguments);
  }
  function Ub(a, b, c, d, e, f2, g2, h2, k2) {
    if (Tb.apply(this, arguments), Ob) {
      if (Ob) {
        var l2 = Pb;
        Ob = !1, Pb = null;
      } else throw Error(p(198));
      Qb || (Qb = !0, Rb = l2);
    }
  }
  function Vb(a) {
    var b = a, c = a;
    if (a.alternate) for (; b.return; ) b = b.return;
    else {
      a = b;
      do
        b = a, b.flags & 4098 && (c = b.return), a = b.return;
      while (a);
    }
    return b.tag === 3 ? c : null;
  }
  function Wb(a) {
    if (a.tag === 13) {
      var b = a.memoizedState;
      if (b === null && (a = a.alternate, a !== null && (b = a.memoizedState)), b !== null) return b.dehydrated;
    }
    return null;
  }
  function Xb(a) {
    if (Vb(a) !== a) throw Error(p(188));
  }
  function Yb(a) {
    var b = a.alternate;
    if (!b) {
      if (b = Vb(a), b === null) throw Error(p(188));
      return b !== a ? null : a;
    }
    for (var c = a, d = b; ; ) {
      var e = c.return;
      if (e === null) break;
      var f2 = e.alternate;
      if (f2 === null) {
        if (d = e.return, d !== null) {
          c = d;
          continue;
        }
        break;
      }
      if (e.child === f2.child) {
        for (f2 = e.child; f2; ) {
          if (f2 === c) return Xb(e), a;
          if (f2 === d) return Xb(e), b;
          f2 = f2.sibling;
        }
        throw Error(p(188));
      }
      if (c.return !== d.return) c = e, d = f2;
      else {
        for (var g2 = !1, h2 = e.child; h2; ) {
          if (h2 === c) {
            g2 = !0, c = e, d = f2;
            break;
          }
          if (h2 === d) {
            g2 = !0, d = e, c = f2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) {
          for (h2 = f2.child; h2; ) {
            if (h2 === c) {
              g2 = !0, c = f2, d = e;
              break;
            }
            if (h2 === d) {
              g2 = !0, d = f2, c = e;
              break;
            }
            h2 = h2.sibling;
          }
          if (!g2) throw Error(p(189));
        }
      }
      if (c.alternate !== d) throw Error(p(190));
    }
    if (c.tag !== 3) throw Error(p(188));
    return c.stateNode.current === c ? a : b;
  }
  function Zb(a) {
    return a = Yb(a), a !== null ? $b(a) : null;
  }
  function $b(a) {
    if (a.tag === 5 || a.tag === 6) return a;
    for (a = a.child; a !== null; ) {
      var b = $b(a);
      if (b !== null) return b;
      a = a.sibling;
    }
    return null;
  }
  var ac2 = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B2 = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic2 = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
  function mc(a) {
    if (lc && typeof lc.onCommitFiberRoot == "function") try {
      lc.onCommitFiberRoot(kc, a, void 0, (a.current.flags & 128) === 128);
    } catch {
    }
  }
  var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
  function nc(a) {
    return a >>>= 0, a === 0 ? 32 : 31 - (pc(a) / qc | 0) | 0;
  }
  var rc = 64, sc2 = 4194304;
  function tc(a) {
    switch (a & -a) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return a & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return a & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return a;
    }
  }
  function uc(a, b) {
    var c = a.pendingLanes;
    if (c === 0) return 0;
    var d = 0, e = a.suspendedLanes, f2 = a.pingedLanes, g2 = c & 268435455;
    if (g2 !== 0) {
      var h2 = g2 & ~e;
      h2 !== 0 ? d = tc(h2) : (f2 &= g2, f2 !== 0 && (d = tc(f2)));
    } else g2 = c & ~e, g2 !== 0 ? d = tc(g2) : f2 !== 0 && (d = tc(f2));
    if (d === 0) return 0;
    if (b !== 0 && b !== d && !(b & e) && (e = d & -d, f2 = b & -b, e >= f2 || e === 16 && (f2 & 4194240) !== 0)) return b;
    if (d & 4 && (d |= c & 16), b = a.entangledLanes, b !== 0) for (a = a.entanglements, b &= d; 0 < b; ) c = 31 - oc(b), e = 1 << c, d |= a[c], b &= ~e;
    return d;
  }
  function vc(a, b) {
    switch (a) {
      case 1:
      case 2:
      case 4:
        return b + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return b + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function wc(a, b) {
    for (var c = a.suspendedLanes, d = a.pingedLanes, e = a.expirationTimes, f2 = a.pendingLanes; 0 < f2; ) {
      var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e[g2];
      k2 === -1 ? (!(h2 & c) || h2 & d) && (e[g2] = vc(h2, b)) : k2 <= b && (a.expiredLanes |= h2), f2 &= ~h2;
    }
  }
  function xc(a) {
    return a = a.pendingLanes & -1073741825, a !== 0 ? a : a & 1073741824 ? 1073741824 : 0;
  }
  function yc() {
    var a = rc;
    return rc <<= 1, !(rc & 4194240) && (rc = 64), a;
  }
  function zc(a) {
    for (var b = [], c = 0; 31 > c; c++) b.push(a);
    return b;
  }
  function Ac(a, b, c) {
    a.pendingLanes |= b, b !== 536870912 && (a.suspendedLanes = 0, a.pingedLanes = 0), a = a.eventTimes, b = 31 - oc(b), a[b] = c;
  }
  function Bc(a, b) {
    var c = a.pendingLanes & ~b;
    a.pendingLanes = b, a.suspendedLanes = 0, a.pingedLanes = 0, a.expiredLanes &= b, a.mutableReadLanes &= b, a.entangledLanes &= b, b = a.entanglements;
    var d = a.eventTimes;
    for (a = a.expirationTimes; 0 < c; ) {
      var e = 31 - oc(c), f2 = 1 << e;
      b[e] = 0, d[e] = -1, a[e] = -1, c &= ~f2;
    }
  }
  function Cc(a, b) {
    var c = a.entangledLanes |= b;
    for (a = a.entanglements; c; ) {
      var d = 31 - oc(c), e = 1 << d;
      e & b | a[d] & b && (a[d] |= b), c &= ~e;
    }
  }
  var C2 = 0;
  function Dc(a) {
    return a &= -a, 1 < a ? 4 < a ? a & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Ec, Fc, Gc, Hc, Ic, Jc = !1, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Sc2(a, b) {
    switch (a) {
      case "focusin":
      case "focusout":
        Lc = null;
        break;
      case "dragenter":
      case "dragleave":
        Mc = null;
        break;
      case "mouseover":
      case "mouseout":
        Nc = null;
        break;
      case "pointerover":
      case "pointerout":
        Oc.delete(b.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        Pc.delete(b.pointerId);
    }
  }
  function Tc(a, b, c, d, e, f2) {
    return a === null || a.nativeEvent !== f2 ? (a = { blockedOn: b, domEventName: c, eventSystemFlags: d, nativeEvent: f2, targetContainers: [e] }, b !== null && (b = Cb(b), b !== null && Fc(b)), a) : (a.eventSystemFlags |= d, b = a.targetContainers, e !== null && b.indexOf(e) === -1 && b.push(e), a);
  }
  function Uc(a, b, c, d, e) {
    switch (b) {
      case "focusin":
        return Lc = Tc(Lc, a, b, c, d, e), !0;
      case "dragenter":
        return Mc = Tc(Mc, a, b, c, d, e), !0;
      case "mouseover":
        return Nc = Tc(Nc, a, b, c, d, e), !0;
      case "pointerover":
        var f2 = e.pointerId;
        return Oc.set(f2, Tc(Oc.get(f2) || null, a, b, c, d, e)), !0;
      case "gotpointercapture":
        return f2 = e.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a, b, c, d, e)), !0;
    }
    return !1;
  }
  function Vc(a) {
    var b = Wc(a.target);
    if (b !== null) {
      var c = Vb(b);
      if (c !== null) {
        if (b = c.tag, b === 13) {
          if (b = Wb(c), b !== null) {
            a.blockedOn = b, Ic(a.priority, function() {
              Gc(c);
            });
            return;
          }
        } else if (b === 3 && c.stateNode.current.memoizedState.isDehydrated) {
          a.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
          return;
        }
      }
    }
    a.blockedOn = null;
  }
  function Xc(a) {
    if (a.blockedOn !== null) return !1;
    for (var b = a.targetContainers; 0 < b.length; ) {
      var c = Yc(a.domEventName, a.eventSystemFlags, b[0], a.nativeEvent);
      if (c === null) {
        c = a.nativeEvent;
        var d = new c.constructor(c.type, c);
        wb = d, c.target.dispatchEvent(d), wb = null;
      } else return b = Cb(c), b !== null && Fc(b), a.blockedOn = c, !1;
      b.shift();
    }
    return !0;
  }
  function Zc(a, b, c) {
    Xc(a) && c.delete(b);
  }
  function $c() {
    Jc = !1, Lc !== null && Xc(Lc) && (Lc = null), Mc !== null && Xc(Mc) && (Mc = null), Nc !== null && Xc(Nc) && (Nc = null), Oc.forEach(Zc), Pc.forEach(Zc);
  }
  function ad(a, b) {
    a.blockedOn === b && (a.blockedOn = null, Jc || (Jc = !0, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
  }
  function bd(a) {
    function b(b2) {
      return ad(b2, a);
    }
    if (0 < Kc.length) {
      ad(Kc[0], a);
      for (var c = 1; c < Kc.length; c++) {
        var d = Kc[c];
        d.blockedOn === a && (d.blockedOn = null);
      }
    }
    for (Lc !== null && ad(Lc, a), Mc !== null && ad(Mc, a), Nc !== null && ad(Nc, a), Oc.forEach(b), Pc.forEach(b), c = 0; c < Qc.length; c++) d = Qc[c], d.blockedOn === a && (d.blockedOn = null);
    for (; 0 < Qc.length && (c = Qc[0], c.blockedOn === null); ) Vc(c), c.blockedOn === null && Qc.shift();
  }
  var cd = ua.ReactCurrentBatchConfig, dd2 = !0;
  function ed(a, b, c, d) {
    var e = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 1, fd(a, b, c, d);
    } finally {
      C2 = e, cd.transition = f2;
    }
  }
  function gd(a, b, c, d) {
    var e = C2, f2 = cd.transition;
    cd.transition = null;
    try {
      C2 = 4, fd(a, b, c, d);
    } finally {
      C2 = e, cd.transition = f2;
    }
  }
  function fd(a, b, c, d) {
    if (dd2) {
      var e = Yc(a, b, c, d);
      if (e === null) hd(a, b, d, id2, c), Sc2(a, d);
      else if (Uc(e, a, b, c, d)) d.stopPropagation();
      else if (Sc2(a, d), b & 4 && -1 < Rc.indexOf(a)) {
        for (; e !== null; ) {
          var f2 = Cb(e);
          if (f2 !== null && Ec(f2), f2 = Yc(a, b, c, d), f2 === null && hd(a, b, d, id2, c), f2 === e) break;
          e = f2;
        }
        e !== null && d.stopPropagation();
      } else hd(a, b, d, null, c);
    }
  }
  var id2 = null;
  function Yc(a, b, c, d) {
    if (id2 = null, a = xb(d), a = Wc(a), a !== null) if (b = Vb(a), b === null) a = null;
    else if (c = b.tag, c === 13) {
      if (a = Wb(b), a !== null) return a;
      a = null;
    } else if (c === 3) {
      if (b.stateNode.current.memoizedState.isDehydrated) return b.tag === 3 ? b.stateNode.containerInfo : null;
      a = null;
    } else b !== a && (a = null);
    return id2 = a, null;
  }
  function jd(a) {
    switch (a) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (ec()) {
          case fc:
            return 1;
          case gc:
            return 4;
          case hc:
          case ic2:
            return 16;
          case jc:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var kd = null, ld = null, md = null;
  function nd() {
    if (md) return md;
    var a, b = ld, c = b.length, d, e = "value" in kd ? kd.value : kd.textContent, f2 = e.length;
    for (a = 0; a < c && b[a] === e[a]; a++) ;
    var g2 = c - a;
    for (d = 1; d <= g2 && b[c - d] === e[f2 - d]; d++) ;
    return md = e.slice(a, 1 < d ? 1 - d : void 0);
  }
  function od(a) {
    var b = a.keyCode;
    return "charCode" in a ? (a = a.charCode, a === 0 && b === 13 && (a = 13)) : a = b, a === 10 && (a = 13), 32 <= a || a === 13 ? a : 0;
  }
  function pd() {
    return !0;
  }
  function qd() {
    return !1;
  }
  function rd(a) {
    function b(b2, d, e, f2, g2) {
      this._reactName = b2, this._targetInst = e, this.type = d, this.nativeEvent = f2, this.target = g2, this.currentTarget = null;
      for (var c in a) a.hasOwnProperty(c) && (b2 = a[c], this[c] = b2 ? b2(f2) : f2[c]);
      return this.isDefaultPrevented = (f2.defaultPrevented != null ? f2.defaultPrevented : f2.returnValue === !1) ? pd : qd, this.isPropagationStopped = qd, this;
    }
    return A2(b.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var a2 = this.nativeEvent;
      a2 && (a2.preventDefault ? a2.preventDefault() : typeof a2.returnValue != "unknown" && (a2.returnValue = !1), this.isDefaultPrevented = pd);
    }, stopPropagation: function() {
      var a2 = this.nativeEvent;
      a2 && (a2.stopPropagation ? a2.stopPropagation() : typeof a2.cancelBubble != "unknown" && (a2.cancelBubble = !0), this.isPropagationStopped = pd);
    }, persist: function() {
    }, isPersistent: pd }), b;
  }
  var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A2({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A2({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a) {
    return a.relatedTarget === void 0 ? a.fromElement === a.srcElement ? a.toElement : a.fromElement : a.relatedTarget;
  }, movementX: function(a) {
    return "movementX" in a ? a.movementX : (a !== yd && (yd && a.type === "mousemove" ? (wd = a.screenX - yd.screenX, xd = a.screenY - yd.screenY) : xd = wd = 0, yd = a), wd);
  }, movementY: function(a) {
    return "movementY" in a ? a.movementY : xd;
  } }), Bd = rd(Ad), Cd = A2({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A2({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A2({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A2({}, sd, { clipboardData: function(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } }), Jd = rd(Id), Kd = A2({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, Nd = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function Pd(a) {
    var b = this.nativeEvent;
    return b.getModifierState ? b.getModifierState(a) : (a = Od[a]) ? !!b[a] : !1;
  }
  function zd() {
    return Pd;
  }
  var Qd = A2({}, ud, { key: function(a) {
    if (a.key) {
      var b = Md[a.key] || a.key;
      if (b !== "Unidentified") return b;
    }
    return a.type === "keypress" ? (a = od(a), a === 13 ? "Enter" : String.fromCharCode(a)) : a.type === "keydown" || a.type === "keyup" ? Nd[a.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a) {
    return a.type === "keypress" ? od(a) : 0;
  }, keyCode: function(a) {
    return a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  }, which: function(a) {
    return a.type === "keypress" ? od(a) : a.type === "keydown" || a.type === "keyup" ? a.keyCode : 0;
  } }), Rd = rd(Qd), Sd = A2({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A2({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A2({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A2({}, Ad, {
    deltaX: function(a) {
      return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
    },
    deltaY: function(a) {
      return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), Zd = rd(Yd), $d = [9, 13, 27, 32], ae2 = ia && "CompositionEvent" in window, be2 = null;
  ia && "documentMode" in document && (be2 = document.documentMode);
  var ce2 = ia && "TextEvent" in window && !be2, de2 = ia && (!ae2 || be2 && 8 < be2 && 11 >= be2), ee2 = " ", fe2 = !1;
  function ge2(a, b) {
    switch (a) {
      case "keyup":
        return $d.indexOf(b.keyCode) !== -1;
      case "keydown":
        return b.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function he2(a) {
    return a = a.detail, typeof a == "object" && "data" in a ? a.data : null;
  }
  var ie2 = !1;
  function je2(a, b) {
    switch (a) {
      case "compositionend":
        return he2(b);
      case "keypress":
        return b.which !== 32 ? null : (fe2 = !0, ee2);
      case "textInput":
        return a = b.data, a === ee2 && fe2 ? null : a;
      default:
        return null;
    }
  }
  function ke2(a, b) {
    if (ie2) return a === "compositionend" || !ae2 && ge2(a, b) ? (a = nd(), md = ld = kd = null, ie2 = !1, a) : null;
    switch (a) {
      case "paste":
        return null;
      case "keypress":
        if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
          if (b.char && 1 < b.char.length) return b.char;
          if (b.which) return String.fromCharCode(b.which);
        }
        return null;
      case "compositionend":
        return de2 && b.locale !== "ko" ? null : b.data;
      default:
        return null;
    }
  }
  var le2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function me2(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b === "input" ? !!le2[a.type] : b === "textarea";
  }
  function ne2(a, b, c, d) {
    Eb(d), b = oe2(b, "onChange"), 0 < b.length && (c = new td("onChange", "change", null, c, d), a.push({ event: c, listeners: b }));
  }
  var pe2 = null, qe2 = null;
  function re2(a) {
    se2(a, 0);
  }
  function te2(a) {
    var b = ue2(a);
    if (Wa(b)) return a;
  }
  function ve2(a, b) {
    if (a === "change") return b;
  }
  var we2 = !1;
  if (ia) {
    var xe2;
    if (ia) {
      var ye2 = "oninput" in document;
      if (!ye2) {
        var ze2 = document.createElement("div");
        ze2.setAttribute("oninput", "return;"), ye2 = typeof ze2.oninput == "function";
      }
      xe2 = ye2;
    } else xe2 = !1;
    we2 = xe2 && (!document.documentMode || 9 < document.documentMode);
  }
  function Ae2() {
    pe2 && (pe2.detachEvent("onpropertychange", Be), qe2 = pe2 = null);
  }
  function Be(a) {
    if (a.propertyName === "value" && te2(qe2)) {
      var b = [];
      ne2(b, qe2, a, xb(a)), Jb(re2, b);
    }
  }
  function Ce2(a, b, c) {
    a === "focusin" ? (Ae2(), pe2 = b, qe2 = c, pe2.attachEvent("onpropertychange", Be)) : a === "focusout" && Ae2();
  }
  function De2(a) {
    if (a === "selectionchange" || a === "keyup" || a === "keydown") return te2(qe2);
  }
  function Ee2(a, b) {
    if (a === "click") return te2(b);
  }
  function Fe2(a, b) {
    if (a === "input" || a === "change") return te2(b);
  }
  function Ge2(a, b) {
    return a === b && (a !== 0 || 1 / a === 1 / b) || a !== a && b !== b;
  }
  var He2 = typeof Object.is == "function" ? Object.is : Ge2;
  function Ie2(a, b) {
    if (He2(a, b)) return !0;
    if (typeof a != "object" || a === null || typeof b != "object" || b === null) return !1;
    var c = Object.keys(a), d = Object.keys(b);
    if (c.length !== d.length) return !1;
    for (d = 0; d < c.length; d++) {
      var e = c[d];
      if (!ja.call(b, e) || !He2(a[e], b[e])) return !1;
    }
    return !0;
  }
  function Je2(a) {
    for (; a && a.firstChild; ) a = a.firstChild;
    return a;
  }
  function Ke2(a, b) {
    var c = Je2(a);
    a = 0;
    for (var d; c; ) {
      if (c.nodeType === 3) {
        if (d = a + c.textContent.length, a <= b && d >= b) return { node: c, offset: b - a };
        a = d;
      }
      a: {
        for (; c; ) {
          if (c.nextSibling) {
            c = c.nextSibling;
            break a;
          }
          c = c.parentNode;
        }
        c = void 0;
      }
      c = Je2(c);
    }
  }
  function Le(a, b) {
    return a && b ? a === b ? !0 : a && a.nodeType === 3 ? !1 : b && b.nodeType === 3 ? Le(a, b.parentNode) : "contains" in a ? a.contains(b) : a.compareDocumentPosition ? !!(a.compareDocumentPosition(b) & 16) : !1 : !1;
  }
  function Me2() {
    for (var a = window, b = Xa(); b instanceof a.HTMLIFrameElement; ) {
      try {
        var c = typeof b.contentWindow.location.href == "string";
      } catch {
        c = !1;
      }
      if (c) a = b.contentWindow;
      else break;
      b = Xa(a.document);
    }
    return b;
  }
  function Ne2(a) {
    var b = a && a.nodeName && a.nodeName.toLowerCase();
    return b && (b === "input" && (a.type === "text" || a.type === "search" || a.type === "tel" || a.type === "url" || a.type === "password") || b === "textarea" || a.contentEditable === "true");
  }
  function Oe2(a) {
    var b = Me2(), c = a.focusedElem, d = a.selectionRange;
    if (b !== c && c && c.ownerDocument && Le(c.ownerDocument.documentElement, c)) {
      if (d !== null && Ne2(c)) {
        if (b = d.start, a = d.end, a === void 0 && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);
        else if (a = (b = c.ownerDocument || document) && b.defaultView || window, a.getSelection) {
          a = a.getSelection();
          var e = c.textContent.length, f2 = Math.min(d.start, e);
          d = d.end === void 0 ? f2 : Math.min(d.end, e), !a.extend && f2 > d && (e = d, d = f2, f2 = e), e = Ke2(c, f2);
          var g2 = Ke2(
            c,
            d
          );
          e && g2 && (a.rangeCount !== 1 || a.anchorNode !== e.node || a.anchorOffset !== e.offset || a.focusNode !== g2.node || a.focusOffset !== g2.offset) && (b = b.createRange(), b.setStart(e.node, e.offset), a.removeAllRanges(), f2 > d ? (a.addRange(b), a.extend(g2.node, g2.offset)) : (b.setEnd(g2.node, g2.offset), a.addRange(b)));
        }
      }
      for (b = [], a = c; a = a.parentNode; ) a.nodeType === 1 && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      for (typeof c.focus == "function" && c.focus(), c = 0; c < b.length; c++) a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
    }
  }
  var Pe2 = ia && "documentMode" in document && 11 >= document.documentMode, Qe2 = null, Re2 = null, Se2 = null, Te2 = !1;
  function Ue2(a, b, c) {
    var d = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
    Te2 || Qe2 == null || Qe2 !== Xa(d) || (d = Qe2, "selectionStart" in d && Ne2(d) ? d = { start: d.selectionStart, end: d.selectionEnd } : (d = (d.ownerDocument && d.ownerDocument.defaultView || window).getSelection(), d = { anchorNode: d.anchorNode, anchorOffset: d.anchorOffset, focusNode: d.focusNode, focusOffset: d.focusOffset }), Se2 && Ie2(Se2, d) || (Se2 = d, d = oe2(Re2, "onSelect"), 0 < d.length && (b = new td("onSelect", "select", null, b, c), a.push({ event: b, listeners: d }), b.target = Qe2)));
  }
  function Ve2(a, b) {
    var c = {};
    return c[a.toLowerCase()] = b.toLowerCase(), c["Webkit" + a] = "webkit" + b, c["Moz" + a] = "moz" + b, c;
  }
  var We2 = { animationend: Ve2("Animation", "AnimationEnd"), animationiteration: Ve2("Animation", "AnimationIteration"), animationstart: Ve2("Animation", "AnimationStart"), transitionend: Ve2("Transition", "TransitionEnd") }, Xe2 = {}, Ye = {};
  ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We2.animationend.animation, delete We2.animationiteration.animation, delete We2.animationstart.animation), "TransitionEvent" in window || delete We2.transitionend.transition);
  function Ze2(a) {
    if (Xe2[a]) return Xe2[a];
    if (!We2[a]) return a;
    var b = We2[a], c;
    for (c in b) if (b.hasOwnProperty(c) && c in Ye) return Xe2[a] = b[c];
    return a;
  }
  var $e2 = Ze2("animationend"), af2 = Ze2("animationiteration"), bf = Ze2("animationstart"), cf = Ze2("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function ff(a, b) {
    df.set(a, b), fa(b, [a]);
  }
  for (var gf = 0; gf < ef.length; gf++) {
    var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
    ff(jf, "on" + kf);
  }
  ff($e2, "onAnimationEnd"), ff(af2, "onAnimationIteration"), ff(bf, "onAnimationStart"), ff("dblclick", "onDoubleClick"), ff("focusin", "onFocus"), ff("focusout", "onBlur"), ff(cf, "onTransitionEnd"), ha("onMouseEnter", ["mouseout", "mouseover"]), ha("onMouseLeave", ["mouseout", "mouseover"]), ha("onPointerEnter", ["pointerout", "pointerover"]), ha("onPointerLeave", ["pointerout", "pointerover"]), fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
  function nf(a, b, c) {
    var d = a.type || "unknown-event";
    a.currentTarget = c, Ub(d, b, void 0, a), a.currentTarget = null;
  }
  function se2(a, b) {
    b = (b & 4) !== 0;
    for (var c = 0; c < a.length; c++) {
      var d = a[c], e = d.event;
      d = d.listeners;
      a: {
        var f2 = void 0;
        if (b) for (var g2 = d.length - 1; 0 <= g2; g2--) {
          var h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget;
          if (h2 = h2.listener, k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l2), f2 = k2;
        }
        else for (g2 = 0; g2 < d.length; g2++) {
          if (h2 = d[g2], k2 = h2.instance, l2 = h2.currentTarget, h2 = h2.listener, k2 !== f2 && e.isPropagationStopped()) break a;
          nf(e, h2, l2), f2 = k2;
        }
      }
    }
    if (Qb) throw a = Rb, Qb = !1, Rb = null, a;
  }
  function D2(a, b) {
    var c = b[of];
    c === void 0 && (c = b[of] = /* @__PURE__ */ new Set());
    var d = a + "__bubble";
    c.has(d) || (pf(b, a, 2, !1), c.add(d));
  }
  function qf(a, b, c) {
    var d = 0;
    b && (d |= 4), pf(c, a, d, b);
  }
  var rf = "_reactListening" + Math.random().toString(36).slice(2);
  function sf(a) {
    if (!a[rf]) {
      a[rf] = !0, da.forEach(function(b2) {
        b2 !== "selectionchange" && (mf.has(b2) || qf(b2, !1, a), qf(b2, !0, a));
      });
      var b = a.nodeType === 9 ? a : a.ownerDocument;
      b === null || b[rf] || (b[rf] = !0, qf("selectionchange", !1, b));
    }
  }
  function pf(a, b, c, d) {
    switch (jd(b)) {
      case 1:
        var e = ed;
        break;
      case 4:
        e = gd;
        break;
      default:
        e = fd;
    }
    c = e.bind(null, b, c, a), e = void 0, !Lb || b !== "touchstart" && b !== "touchmove" && b !== "wheel" || (e = !0), d ? e !== void 0 ? a.addEventListener(b, c, { capture: !0, passive: e }) : a.addEventListener(b, c, !0) : e !== void 0 ? a.addEventListener(b, c, { passive: e }) : a.addEventListener(b, c, !1);
  }
  function hd(a, b, c, d, e) {
    var f2 = d;
    if (!(b & 1) && !(b & 2) && d !== null) a: for (; ; ) {
      if (d === null) return;
      var g2 = d.tag;
      if (g2 === 3 || g2 === 4) {
        var h2 = d.stateNode.containerInfo;
        if (h2 === e || h2.nodeType === 8 && h2.parentNode === e) break;
        if (g2 === 4) for (g2 = d.return; g2 !== null; ) {
          var k2 = g2.tag;
          if ((k2 === 3 || k2 === 4) && (k2 = g2.stateNode.containerInfo, k2 === e || k2.nodeType === 8 && k2.parentNode === e)) return;
          g2 = g2.return;
        }
        for (; h2 !== null; ) {
          if (g2 = Wc(h2), g2 === null) return;
          if (k2 = g2.tag, k2 === 5 || k2 === 6) {
            d = f2 = g2;
            continue a;
          }
          h2 = h2.parentNode;
        }
      }
      d = d.return;
    }
    Jb(function() {
      var d2 = f2, e2 = xb(c), g3 = [];
      a: {
        var h3 = df.get(a);
        if (h3 !== void 0) {
          var k3 = td, n = a;
          switch (a) {
            case "keypress":
              if (od(c) === 0) break a;
            case "keydown":
            case "keyup":
              k3 = Rd;
              break;
            case "focusin":
              n = "focus", k3 = Fd;
              break;
            case "focusout":
              n = "blur", k3 = Fd;
              break;
            case "beforeblur":
            case "afterblur":
              k3 = Fd;
              break;
            case "click":
              if (c.button === 2) break a;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              k3 = Bd;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              k3 = Dd;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              k3 = Vd;
              break;
            case $e2:
            case af2:
            case bf:
              k3 = Hd;
              break;
            case cf:
              k3 = Xd;
              break;
            case "scroll":
              k3 = vd;
              break;
            case "wheel":
              k3 = Zd;
              break;
            case "copy":
            case "cut":
            case "paste":
              k3 = Jd;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              k3 = Td;
          }
          var t = (b & 4) !== 0, J2 = !t && a === "scroll", x2 = t ? h3 !== null ? h3 + "Capture" : null : h3;
          t = [];
          for (var w2 = d2, u; w2 !== null; ) {
            u = w2;
            var F2 = u.stateNode;
            if (u.tag === 5 && F2 !== null && (u = F2, x2 !== null && (F2 = Kb(w2, x2), F2 != null && t.push(tf(w2, F2, u)))), J2) break;
            w2 = w2.return;
          }
          0 < t.length && (h3 = new k3(h3, n, null, c, e2), g3.push({ event: h3, listeners: t }));
        }
      }
      if (!(b & 7)) {
        a: {
          if (h3 = a === "mouseover" || a === "pointerover", k3 = a === "mouseout" || a === "pointerout", h3 && c !== wb && (n = c.relatedTarget || c.fromElement) && (Wc(n) || n[uf])) break a;
          if ((k3 || h3) && (h3 = e2.window === e2 ? e2 : (h3 = e2.ownerDocument) ? h3.defaultView || h3.parentWindow : window, k3 ? (n = c.relatedTarget || c.toElement, k3 = d2, n = n ? Wc(n) : null, n !== null && (J2 = Vb(n), n !== J2 || n.tag !== 5 && n.tag !== 6) && (n = null)) : (k3 = null, n = d2), k3 !== n)) {
            if (t = Bd, F2 = "onMouseLeave", x2 = "onMouseEnter", w2 = "mouse", (a === "pointerout" || a === "pointerover") && (t = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer"), J2 = k3 == null ? h3 : ue2(k3), u = n == null ? h3 : ue2(n), h3 = new t(F2, w2 + "leave", k3, c, e2), h3.target = J2, h3.relatedTarget = u, F2 = null, Wc(e2) === d2 && (t = new t(x2, w2 + "enter", n, c, e2), t.target = u, t.relatedTarget = J2, F2 = t), J2 = F2, k3 && n) b: {
              for (t = k3, x2 = n, w2 = 0, u = t; u; u = vf(u)) w2++;
              for (u = 0, F2 = x2; F2; F2 = vf(F2)) u++;
              for (; 0 < w2 - u; ) t = vf(t), w2--;
              for (; 0 < u - w2; ) x2 = vf(x2), u--;
              for (; w2--; ) {
                if (t === x2 || x2 !== null && t === x2.alternate) break b;
                t = vf(t), x2 = vf(x2);
              }
              t = null;
            }
            else t = null;
            k3 !== null && wf(g3, h3, k3, t, !1), n !== null && J2 !== null && wf(g3, J2, n, t, !0);
          }
        }
        a: {
          if (h3 = d2 ? ue2(d2) : window, k3 = h3.nodeName && h3.nodeName.toLowerCase(), k3 === "select" || k3 === "input" && h3.type === "file") var na = ve2;
          else if (me2(h3)) if (we2) na = Fe2;
          else {
            na = De2;
            var xa = Ce2;
          }
          else (k3 = h3.nodeName) && k3.toLowerCase() === "input" && (h3.type === "checkbox" || h3.type === "radio") && (na = Ee2);
          if (na && (na = na(a, d2))) {
            ne2(g3, na, c, e2);
            break a;
          }
          xa && xa(a, h3, d2), a === "focusout" && (xa = h3._wrapperState) && xa.controlled && h3.type === "number" && cb(h3, "number", h3.value);
        }
        switch (xa = d2 ? ue2(d2) : window, a) {
          case "focusin":
            (me2(xa) || xa.contentEditable === "true") && (Qe2 = xa, Re2 = d2, Se2 = null);
            break;
          case "focusout":
            Se2 = Re2 = Qe2 = null;
            break;
          case "mousedown":
            Te2 = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            Te2 = !1, Ue2(g3, c, e2);
            break;
          case "selectionchange":
            if (Pe2) break;
          case "keydown":
          case "keyup":
            Ue2(g3, c, e2);
        }
        var $a;
        if (ae2) b: {
          switch (a) {
            case "compositionstart":
              var ba = "onCompositionStart";
              break b;
            case "compositionend":
              ba = "onCompositionEnd";
              break b;
            case "compositionupdate":
              ba = "onCompositionUpdate";
              break b;
          }
          ba = void 0;
        }
        else ie2 ? ge2(a, c) && (ba = "onCompositionEnd") : a === "keydown" && c.keyCode === 229 && (ba = "onCompositionStart");
        ba && (de2 && c.locale !== "ko" && (ie2 || ba !== "onCompositionStart" ? ba === "onCompositionEnd" && ie2 && ($a = nd()) : (kd = e2, ld = "value" in kd ? kd.value : kd.textContent, ie2 = !0)), xa = oe2(d2, ba), 0 < xa.length && (ba = new Ld(ba, a, null, c, e2), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he2(c), $a !== null && (ba.data = $a)))), ($a = ce2 ? je2(a, c) : ke2(a, c)) && (d2 = oe2(d2, "onBeforeInput"), 0 < d2.length && (e2 = new Ld("onBeforeInput", "beforeinput", null, c, e2), g3.push({ event: e2, listeners: d2 }), e2.data = $a));
      }
      se2(g3, b);
    });
  }
  function tf(a, b, c) {
    return { instance: a, listener: b, currentTarget: c };
  }
  function oe2(a, b) {
    for (var c = b + "Capture", d = []; a !== null; ) {
      var e = a, f2 = e.stateNode;
      e.tag === 5 && f2 !== null && (e = f2, f2 = Kb(a, c), f2 != null && d.unshift(tf(a, f2, e)), f2 = Kb(a, b), f2 != null && d.push(tf(a, f2, e))), a = a.return;
    }
    return d;
  }
  function vf(a) {
    if (a === null) return null;
    do
      a = a.return;
    while (a && a.tag !== 5);
    return a || null;
  }
  function wf(a, b, c, d, e) {
    for (var f2 = b._reactName, g2 = []; c !== null && c !== d; ) {
      var h2 = c, k2 = h2.alternate, l2 = h2.stateNode;
      if (k2 !== null && k2 === d) break;
      h2.tag === 5 && l2 !== null && (h2 = l2, e ? (k2 = Kb(c, f2), k2 != null && g2.unshift(tf(c, k2, h2))) : e || (k2 = Kb(c, f2), k2 != null && g2.push(tf(c, k2, h2)))), c = c.return;
    }
    g2.length !== 0 && a.push({ event: b, listeners: g2 });
  }
  var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
  function zf(a) {
    return (typeof a == "string" ? a : "" + a).replace(xf, `
`).replace(yf, "");
  }
  function Af(a, b, c) {
    if (b = zf(b), zf(a) !== b && c) throw Error(p(425));
  }
  function Bf() {
  }
  var Cf = null, Df = null;
  function Ef(a, b) {
    return a === "textarea" || a === "noscript" || typeof b.children == "string" || typeof b.children == "number" || typeof b.dangerouslySetInnerHTML == "object" && b.dangerouslySetInnerHTML !== null && b.dangerouslySetInnerHTML.__html != null;
  }
  var Ff = typeof setTimeout == "function" ? setTimeout : void 0, Gf = typeof clearTimeout == "function" ? clearTimeout : void 0, Hf = typeof Promise == "function" ? Promise : void 0, Jf = typeof queueMicrotask == "function" ? queueMicrotask : typeof Hf < "u" ? function(a) {
    return Hf.resolve(null).then(a).catch(If);
  } : Ff;
  function If(a) {
    setTimeout(function() {
      throw a;
    });
  }
  function Kf(a, b) {
    var c = b, d = 0;
    do {
      var e = c.nextSibling;
      if (a.removeChild(c), e && e.nodeType === 8) if (c = e.data, c === "/$") {
        if (d === 0) {
          a.removeChild(e), bd(b);
          return;
        }
        d--;
      } else c !== "$" && c !== "$?" && c !== "$!" || d++;
      c = e;
    } while (c);
    bd(b);
  }
  function Lf(a) {
    for (; a != null; a = a.nextSibling) {
      var b = a.nodeType;
      if (b === 1 || b === 3) break;
      if (b === 8) {
        if (b = a.data, b === "$" || b === "$!" || b === "$?") break;
        if (b === "/$") return null;
      }
    }
    return a;
  }
  function Mf(a) {
    a = a.previousSibling;
    for (var b = 0; a; ) {
      if (a.nodeType === 8) {
        var c = a.data;
        if (c === "$" || c === "$!" || c === "$?") {
          if (b === 0) return a;
          b--;
        } else c === "/$" && b++;
      }
      a = a.previousSibling;
    }
    return null;
  }
  var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
  function Wc(a) {
    var b = a[Of];
    if (b) return b;
    for (var c = a.parentNode; c; ) {
      if (b = c[uf] || c[Of]) {
        if (c = b.alternate, b.child !== null || c !== null && c.child !== null) for (a = Mf(a); a !== null; ) {
          if (c = a[Of]) return c;
          a = Mf(a);
        }
        return b;
      }
      a = c, c = a.parentNode;
    }
    return null;
  }
  function Cb(a) {
    return a = a[Of] || a[uf], !a || a.tag !== 5 && a.tag !== 6 && a.tag !== 13 && a.tag !== 3 ? null : a;
  }
  function ue2(a) {
    if (a.tag === 5 || a.tag === 6) return a.stateNode;
    throw Error(p(33));
  }
  function Db(a) {
    return a[Pf] || null;
  }
  var Sf = [], Tf = -1;
  function Uf(a) {
    return { current: a };
  }
  function E2(a) {
    0 > Tf || (a.current = Sf[Tf], Sf[Tf] = null, Tf--);
  }
  function G2(a, b) {
    Tf++, Sf[Tf] = a.current, a.current = b;
  }
  var Vf = {}, H2 = Uf(Vf), Wf = Uf(!1), Xf = Vf;
  function Yf(a, b) {
    var c = a.type.contextTypes;
    if (!c) return Vf;
    var d = a.stateNode;
    if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;
    var e = {}, f2;
    for (f2 in c) e[f2] = b[f2];
    return d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e), e;
  }
  function Zf(a) {
    return a = a.childContextTypes, a != null;
  }
  function $f() {
    E2(Wf), E2(H2);
  }
  function ag(a, b, c) {
    if (H2.current !== Vf) throw Error(p(168));
    G2(H2, b), G2(Wf, c);
  }
  function bg(a, b, c) {
    var d = a.stateNode;
    if (b = b.childContextTypes, typeof d.getChildContext != "function") return c;
    d = d.getChildContext();
    for (var e in d) if (!(e in b)) throw Error(p(108, Ra(a) || "Unknown", e));
    return A2({}, c, d);
  }
  function cg(a) {
    return a = (a = a.stateNode) && a.__reactInternalMemoizedMergedChildContext || Vf, Xf = H2.current, G2(H2, a), G2(Wf, Wf.current), !0;
  }
  function dg(a, b, c) {
    var d = a.stateNode;
    if (!d) throw Error(p(169));
    c ? (a = bg(a, b, Xf), d.__reactInternalMemoizedMergedChildContext = a, E2(Wf), E2(H2), G2(H2, a)) : E2(Wf), G2(Wf, c);
  }
  var eg2 = null, fg = !1, gg2 = !1;
  function hg(a) {
    eg2 === null ? eg2 = [a] : eg2.push(a);
  }
  function ig(a) {
    fg = !0, hg(a);
  }
  function jg() {
    if (!gg2 && eg2 !== null) {
      gg2 = !0;
      var a = 0, b = C2;
      try {
        var c = eg2;
        for (C2 = 1; a < c.length; a++) {
          var d = c[a];
          do
            d = d(!0);
          while (d !== null);
        }
        eg2 = null, fg = !1;
      } catch (e) {
        throw eg2 !== null && (eg2 = eg2.slice(a + 1)), ac2(fc, jg), e;
      } finally {
        C2 = b, gg2 = !1;
      }
    }
    return null;
  }
  var kg = [], lg2 = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
  function tg(a, b) {
    kg[lg2++] = ng, kg[lg2++] = mg, mg = a, ng = b;
  }
  function ug(a, b, c) {
    og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, qg = a;
    var d = rg;
    a = sg;
    var e = 32 - oc(d) - 1;
    d &= ~(1 << e), c += 1;
    var f2 = 32 - oc(b) + e;
    if (30 < f2) {
      var g2 = e - e % 5;
      f2 = (d & (1 << g2) - 1).toString(32), d >>= g2, e -= g2, rg = 1 << 32 - oc(b) + e | c << e | d, sg = f2 + a;
    } else rg = 1 << f2 | c << e | d, sg = a;
  }
  function vg(a) {
    a.return !== null && (tg(a, 1), ug(a, 1, 0));
  }
  function wg(a) {
    for (; a === mg; ) mg = kg[--lg2], kg[lg2] = null, ng = kg[--lg2], kg[lg2] = null;
    for (; a === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
  }
  var xg = null, yg = null, I2 = !1, zg = null;
  function Ag(a, b) {
    var c = Bg(5, null, null, 0);
    c.elementType = "DELETED", c.stateNode = b, c.return = a, b = a.deletions, b === null ? (a.deletions = [c], a.flags |= 16) : b.push(c);
  }
  function Cg(a, b) {
    switch (a.tag) {
      case 5:
        var c = a.type;
        return b = b.nodeType !== 1 || c.toLowerCase() !== b.nodeName.toLowerCase() ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = Lf(b.firstChild), !0) : !1;
      case 6:
        return b = a.pendingProps === "" || b.nodeType !== 3 ? null : b, b !== null ? (a.stateNode = b, xg = a, yg = null, !0) : !1;
      case 13:
        return b = b.nodeType !== 8 ? null : b, b !== null ? (c = qg !== null ? { id: rg, overflow: sg } : null, a.memoizedState = { dehydrated: b, treeContext: c, retryLane: 1073741824 }, c = Bg(18, null, null, 0), c.stateNode = b, c.return = a, a.child = c, xg = a, yg = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Dg(a) {
    return (a.mode & 1) !== 0 && (a.flags & 128) === 0;
  }
  function Eg(a) {
    if (I2) {
      var b = yg;
      if (b) {
        var c = b;
        if (!Cg(a, b)) {
          if (Dg(a)) throw Error(p(418));
          b = Lf(c.nextSibling);
          var d = xg;
          b && Cg(a, b) ? Ag(d, c) : (a.flags = a.flags & -4097 | 2, I2 = !1, xg = a);
        }
      } else {
        if (Dg(a)) throw Error(p(418));
        a.flags = a.flags & -4097 | 2, I2 = !1, xg = a;
      }
    }
  }
  function Fg(a) {
    for (a = a.return; a !== null && a.tag !== 5 && a.tag !== 3 && a.tag !== 13; ) a = a.return;
    xg = a;
  }
  function Gg2(a) {
    if (a !== xg) return !1;
    if (!I2) return Fg(a), I2 = !0, !1;
    var b;
    if ((b = a.tag !== 3) && !(b = a.tag !== 5) && (b = a.type, b = b !== "head" && b !== "body" && !Ef(a.type, a.memoizedProps)), b && (b = yg)) {
      if (Dg(a)) throw Hg(), Error(p(418));
      for (; b; ) Ag(a, b), b = Lf(b.nextSibling);
    }
    if (Fg(a), a.tag === 13) {
      if (a = a.memoizedState, a = a !== null ? a.dehydrated : null, !a) throw Error(p(317));
      a: {
        for (a = a.nextSibling, b = 0; a; ) {
          if (a.nodeType === 8) {
            var c = a.data;
            if (c === "/$") {
              if (b === 0) {
                yg = Lf(a.nextSibling);
                break a;
              }
              b--;
            } else c !== "$" && c !== "$!" && c !== "$?" || b++;
          }
          a = a.nextSibling;
        }
        yg = null;
      }
    } else yg = xg ? Lf(a.stateNode.nextSibling) : null;
    return !0;
  }
  function Hg() {
    for (var a = yg; a; ) a = Lf(a.nextSibling);
  }
  function Ig() {
    yg = xg = null, I2 = !1;
  }
  function Jg(a) {
    zg === null ? zg = [a] : zg.push(a);
  }
  var Kg = ua.ReactCurrentBatchConfig;
  function Lg(a, b, c) {
    if (a = c.ref, a !== null && typeof a != "function" && typeof a != "object") {
      if (c._owner) {
        if (c = c._owner, c) {
          if (c.tag !== 1) throw Error(p(309));
          var d = c.stateNode;
        }
        if (!d) throw Error(p(147, a));
        var e = d, f2 = "" + a;
        return b !== null && b.ref !== null && typeof b.ref == "function" && b.ref._stringRef === f2 ? b.ref : (b = function(a2) {
          var b2 = e.refs;
          a2 === null ? delete b2[f2] : b2[f2] = a2;
        }, b._stringRef = f2, b);
      }
      if (typeof a != "string") throw Error(p(284));
      if (!c._owner) throw Error(p(290, a));
    }
    return a;
  }
  function Mg(a, b) {
    throw a = Object.prototype.toString.call(b), Error(p(31, a === "[object Object]" ? "object with keys {" + Object.keys(b).join(", ") + "}" : a));
  }
  function Ng(a) {
    var b = a._init;
    return b(a._payload);
  }
  function Og(a) {
    function b(b2, c2) {
      if (a) {
        var d2 = b2.deletions;
        d2 === null ? (b2.deletions = [c2], b2.flags |= 16) : d2.push(c2);
      }
    }
    function c(c2, d2) {
      if (!a) return null;
      for (; d2 !== null; ) b(c2, d2), d2 = d2.sibling;
      return null;
    }
    function d(a2, b2) {
      for (a2 = /* @__PURE__ */ new Map(); b2 !== null; ) b2.key !== null ? a2.set(b2.key, b2) : a2.set(b2.index, b2), b2 = b2.sibling;
      return a2;
    }
    function e(a2, b2) {
      return a2 = Pg(a2, b2), a2.index = 0, a2.sibling = null, a2;
    }
    function f2(b2, c2, d2) {
      return b2.index = d2, a ? (d2 = b2.alternate, d2 !== null ? (d2 = d2.index, d2 < c2 ? (b2.flags |= 2, c2) : d2) : (b2.flags |= 2, c2)) : (b2.flags |= 1048576, c2);
    }
    function g2(b2) {
      return a && b2.alternate === null && (b2.flags |= 2), b2;
    }
    function h2(a2, b2, c2, d2) {
      return b2 === null || b2.tag !== 6 ? (b2 = Qg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
    }
    function k2(a2, b2, c2, d2) {
      var f3 = c2.type;
      return f3 === ya ? m2(a2, b2, c2.props.children, d2, c2.key) : b2 !== null && (b2.elementType === f3 || typeof f3 == "object" && f3 !== null && f3.$$typeof === Ha && Ng(f3) === b2.type) ? (d2 = e(b2, c2.props), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2) : (d2 = Rg(c2.type, c2.key, c2.props, null, a2.mode, d2), d2.ref = Lg(a2, b2, c2), d2.return = a2, d2);
    }
    function l2(a2, b2, c2, d2) {
      return b2 === null || b2.tag !== 4 || b2.stateNode.containerInfo !== c2.containerInfo || b2.stateNode.implementation !== c2.implementation ? (b2 = Sg(c2, a2.mode, d2), b2.return = a2, b2) : (b2 = e(b2, c2.children || []), b2.return = a2, b2);
    }
    function m2(a2, b2, c2, d2, f3) {
      return b2 === null || b2.tag !== 7 ? (b2 = Tg(c2, a2.mode, d2, f3), b2.return = a2, b2) : (b2 = e(b2, c2), b2.return = a2, b2);
    }
    function q2(a2, b2, c2) {
      if (typeof b2 == "string" && b2 !== "" || typeof b2 == "number") return b2 = Qg("" + b2, a2.mode, c2), b2.return = a2, b2;
      if (typeof b2 == "object" && b2 !== null) {
        switch (b2.$$typeof) {
          case va:
            return c2 = Rg(b2.type, b2.key, b2.props, null, a2.mode, c2), c2.ref = Lg(a2, null, b2), c2.return = a2, c2;
          case wa:
            return b2 = Sg(b2, a2.mode, c2), b2.return = a2, b2;
          case Ha:
            var d2 = b2._init;
            return q2(a2, d2(b2._payload), c2);
        }
        if (eb(b2) || Ka(b2)) return b2 = Tg(b2, a2.mode, c2, null), b2.return = a2, b2;
        Mg(a2, b2);
      }
      return null;
    }
    function r(a2, b2, c2, d2) {
      var e2 = b2 !== null ? b2.key : null;
      if (typeof c2 == "string" && c2 !== "" || typeof c2 == "number") return e2 !== null ? null : h2(a2, b2, "" + c2, d2);
      if (typeof c2 == "object" && c2 !== null) {
        switch (c2.$$typeof) {
          case va:
            return c2.key === e2 ? k2(a2, b2, c2, d2) : null;
          case wa:
            return c2.key === e2 ? l2(a2, b2, c2, d2) : null;
          case Ha:
            return e2 = c2._init, r(
              a2,
              b2,
              e2(c2._payload),
              d2
            );
        }
        if (eb(c2) || Ka(c2)) return e2 !== null ? null : m2(a2, b2, c2, d2, null);
        Mg(a2, c2);
      }
      return null;
    }
    function y2(a2, b2, c2, d2, e2) {
      if (typeof d2 == "string" && d2 !== "" || typeof d2 == "number") return a2 = a2.get(c2) || null, h2(b2, a2, "" + d2, e2);
      if (typeof d2 == "object" && d2 !== null) {
        switch (d2.$$typeof) {
          case va:
            return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, k2(b2, a2, d2, e2);
          case wa:
            return a2 = a2.get(d2.key === null ? c2 : d2.key) || null, l2(b2, a2, d2, e2);
          case Ha:
            var f3 = d2._init;
            return y2(a2, b2, c2, f3(d2._payload), e2);
        }
        if (eb(d2) || Ka(d2)) return a2 = a2.get(c2) || null, m2(b2, a2, d2, e2, null);
        Mg(b2, d2);
      }
      return null;
    }
    function n(e2, g3, h3, k3) {
      for (var l3 = null, m3 = null, u = g3, w2 = g3 = 0, x2 = null; u !== null && w2 < h3.length; w2++) {
        u.index > w2 ? (x2 = u, u = null) : x2 = u.sibling;
        var n2 = r(e2, u, h3[w2], k3);
        if (n2 === null) {
          u === null && (u = x2);
          break;
        }
        a && u && n2.alternate === null && b(e2, u), g3 = f2(n2, g3, w2), m3 === null ? l3 = n2 : m3.sibling = n2, m3 = n2, u = x2;
      }
      if (w2 === h3.length) return c(e2, u), I2 && tg(e2, w2), l3;
      if (u === null) {
        for (; w2 < h3.length; w2++) u = q2(e2, h3[w2], k3), u !== null && (g3 = f2(u, g3, w2), m3 === null ? l3 = u : m3.sibling = u, m3 = u);
        return I2 && tg(e2, w2), l3;
      }
      for (u = d(e2, u); w2 < h3.length; w2++) x2 = y2(u, e2, w2, h3[w2], k3), x2 !== null && (a && x2.alternate !== null && u.delete(x2.key === null ? w2 : x2.key), g3 = f2(x2, g3, w2), m3 === null ? l3 = x2 : m3.sibling = x2, m3 = x2);
      return a && u.forEach(function(a2) {
        return b(e2, a2);
      }), I2 && tg(e2, w2), l3;
    }
    function t(e2, g3, h3, k3) {
      var l3 = Ka(h3);
      if (typeof l3 != "function") throw Error(p(150));
      if (h3 = l3.call(h3), h3 == null) throw Error(p(151));
      for (var u = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n2 = h3.next(); m3 !== null && !n2.done; w2++, n2 = h3.next()) {
        m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
        var t2 = r(e2, m3, n2.value, k3);
        if (t2 === null) {
          m3 === null && (m3 = x2);
          break;
        }
        a && m3 && t2.alternate === null && b(e2, m3), g3 = f2(t2, g3, w2), u === null ? l3 = t2 : u.sibling = t2, u = t2, m3 = x2;
      }
      if (n2.done) return c(
        e2,
        m3
      ), I2 && tg(e2, w2), l3;
      if (m3 === null) {
        for (; !n2.done; w2++, n2 = h3.next()) n2 = q2(e2, n2.value, k3), n2 !== null && (g3 = f2(n2, g3, w2), u === null ? l3 = n2 : u.sibling = n2, u = n2);
        return I2 && tg(e2, w2), l3;
      }
      for (m3 = d(e2, m3); !n2.done; w2++, n2 = h3.next()) n2 = y2(m3, e2, w2, n2.value, k3), n2 !== null && (a && n2.alternate !== null && m3.delete(n2.key === null ? w2 : n2.key), g3 = f2(n2, g3, w2), u === null ? l3 = n2 : u.sibling = n2, u = n2);
      return a && m3.forEach(function(a2) {
        return b(e2, a2);
      }), I2 && tg(e2, w2), l3;
    }
    function J2(a2, d2, f3, h3) {
      if (typeof f3 == "object" && f3 !== null && f3.type === ya && f3.key === null && (f3 = f3.props.children), typeof f3 == "object" && f3 !== null) {
        switch (f3.$$typeof) {
          case va:
            a: {
              for (var k3 = f3.key, l3 = d2; l3 !== null; ) {
                if (l3.key === k3) {
                  if (k3 = f3.type, k3 === ya) {
                    if (l3.tag === 7) {
                      c(a2, l3.sibling), d2 = e(l3, f3.props.children), d2.return = a2, a2 = d2;
                      break a;
                    }
                  } else if (l3.elementType === k3 || typeof k3 == "object" && k3 !== null && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                    c(a2, l3.sibling), d2 = e(l3, f3.props), d2.ref = Lg(a2, l3, f3), d2.return = a2, a2 = d2;
                    break a;
                  }
                  c(a2, l3);
                  break;
                } else b(a2, l3);
                l3 = l3.sibling;
              }
              f3.type === ya ? (d2 = Tg(f3.props.children, a2.mode, h3, f3.key), d2.return = a2, a2 = d2) : (h3 = Rg(f3.type, f3.key, f3.props, null, a2.mode, h3), h3.ref = Lg(a2, d2, f3), h3.return = a2, a2 = h3);
            }
            return g2(a2);
          case wa:
            a: {
              for (l3 = f3.key; d2 !== null; ) {
                if (d2.key === l3) if (d2.tag === 4 && d2.stateNode.containerInfo === f3.containerInfo && d2.stateNode.implementation === f3.implementation) {
                  c(a2, d2.sibling), d2 = e(d2, f3.children || []), d2.return = a2, a2 = d2;
                  break a;
                } else {
                  c(a2, d2);
                  break;
                }
                else b(a2, d2);
                d2 = d2.sibling;
              }
              d2 = Sg(f3, a2.mode, h3), d2.return = a2, a2 = d2;
            }
            return g2(a2);
          case Ha:
            return l3 = f3._init, J2(a2, d2, l3(f3._payload), h3);
        }
        if (eb(f3)) return n(a2, d2, f3, h3);
        if (Ka(f3)) return t(a2, d2, f3, h3);
        Mg(a2, f3);
      }
      return typeof f3 == "string" && f3 !== "" || typeof f3 == "number" ? (f3 = "" + f3, d2 !== null && d2.tag === 6 ? (c(a2, d2.sibling), d2 = e(d2, f3), d2.return = a2, a2 = d2) : (c(a2, d2), d2 = Qg(f3, a2.mode, h3), d2.return = a2, a2 = d2), g2(a2)) : c(a2, d2);
    }
    return J2;
  }
  var Ug = Og(!0), Vg = Og(!1), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
  function $g() {
    Zg = Yg = Xg = null;
  }
  function ah(a) {
    var b = Wg.current;
    E2(Wg), a._currentValue = b;
  }
  function bh(a, b, c) {
    for (; a !== null; ) {
      var d = a.alternate;
      if ((a.childLanes & b) !== b ? (a.childLanes |= b, d !== null && (d.childLanes |= b)) : d !== null && (d.childLanes & b) !== b && (d.childLanes |= b), a === c) break;
      a = a.return;
    }
  }
  function ch(a, b) {
    Xg = a, Zg = Yg = null, a = a.dependencies, a !== null && a.firstContext !== null && (a.lanes & b && (dh = !0), a.firstContext = null);
  }
  function eh(a) {
    var b = a._currentValue;
    if (Zg !== a) if (a = { context: a, memoizedValue: b, next: null }, Yg === null) {
      if (Xg === null) throw Error(p(308));
      Yg = a, Xg.dependencies = { lanes: 0, firstContext: a };
    } else Yg = Yg.next = a;
    return b;
  }
  var fh = null;
  function gh(a) {
    fh === null ? fh = [a] : fh.push(a);
  }
  function hh(a, b, c, d) {
    var e = b.interleaved;
    return e === null ? (c.next = c, gh(b)) : (c.next = e.next, e.next = c), b.interleaved = c, ih(a, d);
  }
  function ih(a, b) {
    a.lanes |= b;
    var c = a.alternate;
    for (c !== null && (c.lanes |= b), c = a, a = a.return; a !== null; ) a.childLanes |= b, c = a.alternate, c !== null && (c.childLanes |= b), c = a, a = a.return;
    return c.tag === 3 ? c.stateNode : null;
  }
  var jh = !1;
  function kh(a) {
    a.updateQueue = { baseState: a.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function lh(a, b) {
    a = a.updateQueue, b.updateQueue === a && (b.updateQueue = { baseState: a.baseState, firstBaseUpdate: a.firstBaseUpdate, lastBaseUpdate: a.lastBaseUpdate, shared: a.shared, effects: a.effects });
  }
  function mh(a, b) {
    return { eventTime: a, lane: b, tag: 0, payload: null, callback: null, next: null };
  }
  function nh(a, b, c) {
    var d = a.updateQueue;
    if (d === null) return null;
    if (d = d.shared, K2 & 2) {
      var e = d.pending;
      return e === null ? b.next = b : (b.next = e.next, e.next = b), d.pending = b, ih(a, c);
    }
    return e = d.interleaved, e === null ? (b.next = b, gh(d)) : (b.next = e.next, e.next = b), d.interleaved = b, ih(a, c);
  }
  function oh(a, b, c) {
    if (b = b.updateQueue, b !== null && (b = b.shared, (c & 4194240) !== 0)) {
      var d = b.lanes;
      d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
    }
  }
  function ph(a, b) {
    var c = a.updateQueue, d = a.alternate;
    if (d !== null && (d = d.updateQueue, c === d)) {
      var e = null, f2 = null;
      if (c = c.firstBaseUpdate, c !== null) {
        do {
          var g2 = { eventTime: c.eventTime, lane: c.lane, tag: c.tag, payload: c.payload, callback: c.callback, next: null };
          f2 === null ? e = f2 = g2 : f2 = f2.next = g2, c = c.next;
        } while (c !== null);
        f2 === null ? e = f2 = b : f2 = f2.next = b;
      } else e = f2 = b;
      c = { baseState: d.baseState, firstBaseUpdate: e, lastBaseUpdate: f2, shared: d.shared, effects: d.effects }, a.updateQueue = c;
      return;
    }
    a = c.lastBaseUpdate, a === null ? c.firstBaseUpdate = b : a.next = b, c.lastBaseUpdate = b;
  }
  function qh(a, b, c, d) {
    var e = a.updateQueue;
    jh = !1;
    var f2 = e.firstBaseUpdate, g2 = e.lastBaseUpdate, h2 = e.shared.pending;
    if (h2 !== null) {
      e.shared.pending = null;
      var k2 = h2, l2 = k2.next;
      k2.next = null, g2 === null ? f2 = l2 : g2.next = l2, g2 = k2;
      var m2 = a.alternate;
      m2 !== null && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (h2 === null ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
    }
    if (f2 !== null) {
      var q2 = e.baseState;
      g2 = 0, m2 = l2 = k2 = null, h2 = f2;
      do {
        var r = h2.lane, y2 = h2.eventTime;
        if ((d & r) === r) {
          m2 !== null && (m2 = m2.next = {
            eventTime: y2,
            lane: 0,
            tag: h2.tag,
            payload: h2.payload,
            callback: h2.callback,
            next: null
          });
          a: {
            var n = a, t = h2;
            switch (r = b, y2 = c, t.tag) {
              case 1:
                if (n = t.payload, typeof n == "function") {
                  q2 = n.call(y2, q2, r);
                  break a;
                }
                q2 = n;
                break a;
              case 3:
                n.flags = n.flags & -65537 | 128;
              case 0:
                if (n = t.payload, r = typeof n == "function" ? n.call(y2, q2, r) : n, r == null) break a;
                q2 = A2({}, q2, r);
                break a;
              case 2:
                jh = !0;
            }
          }
          h2.callback !== null && h2.lane !== 0 && (a.flags |= 64, r = e.effects, r === null ? e.effects = [h2] : r.push(h2));
        } else y2 = { eventTime: y2, lane: r, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, m2 === null ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r;
        if (h2 = h2.next, h2 === null) {
          if (h2 = e.shared.pending, h2 === null) break;
          r = h2, h2 = r.next, r.next = null, e.lastBaseUpdate = r, e.shared.pending = null;
        }
      } while (!0);
      if (m2 === null && (k2 = q2), e.baseState = k2, e.firstBaseUpdate = l2, e.lastBaseUpdate = m2, b = e.shared.interleaved, b !== null) {
        e = b;
        do
          g2 |= e.lane, e = e.next;
        while (e !== b);
      } else f2 === null && (e.shared.lanes = 0);
      rh |= g2, a.lanes = g2, a.memoizedState = q2;
    }
  }
  function sh2(a, b, c) {
    if (a = b.effects, b.effects = null, a !== null) for (b = 0; b < a.length; b++) {
      var d = a[b], e = d.callback;
      if (e !== null) {
        if (d.callback = null, d = c, typeof e != "function") throw Error(p(191, e));
        e.call(d);
      }
    }
  }
  var th = {}, uh = Uf(th), vh2 = Uf(th), wh = Uf(th);
  function xh(a) {
    if (a === th) throw Error(p(174));
    return a;
  }
  function yh(a, b) {
    switch (G2(wh, b), G2(vh2, a), G2(uh, th), a = b.nodeType, a) {
      case 9:
      case 11:
        b = (b = b.documentElement) ? b.namespaceURI : lb(null, "");
        break;
      default:
        a = a === 8 ? b.parentNode : b, b = a.namespaceURI || null, a = a.tagName, b = lb(b, a);
    }
    E2(uh), G2(uh, b);
  }
  function zh() {
    E2(uh), E2(vh2), E2(wh);
  }
  function Ah(a) {
    xh(wh.current);
    var b = xh(uh.current), c = lb(b, a.type);
    b !== c && (G2(vh2, a), G2(uh, c));
  }
  function Bh(a) {
    vh2.current === a && (E2(uh), E2(vh2));
  }
  var L2 = Uf(0);
  function Ch(a) {
    for (var b = a; b !== null; ) {
      if (b.tag === 13) {
        var c = b.memoizedState;
        if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || c.data === "$!")) return b;
      } else if (b.tag === 19 && b.memoizedProps.revealOrder !== void 0) {
        if (b.flags & 128) return b;
      } else if (b.child !== null) {
        b.child.return = b, b = b.child;
        continue;
      }
      if (b === a) break;
      for (; b.sibling === null; ) {
        if (b.return === null || b.return === a) return null;
        b = b.return;
      }
      b.sibling.return = b.return, b = b.sibling;
    }
    return null;
  }
  var Dh = [];
  function Eh() {
    for (var a = 0; a < Dh.length; a++) Dh[a]._workInProgressVersionPrimary = null;
    Dh.length = 0;
  }
  var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M2 = null, N2 = null, O2 = null, Ih = !1, Jh = !1, Kh = 0, Lh = 0;
  function P2() {
    throw Error(p(321));
  }
  function Mh(a, b) {
    if (b === null) return !1;
    for (var c = 0; c < b.length && c < a.length; c++) if (!He2(a[c], b[c])) return !1;
    return !0;
  }
  function Nh(a, b, c, d, e, f2) {
    if (Hh = f2, M2 = b, b.memoizedState = null, b.updateQueue = null, b.lanes = 0, Fh.current = a === null || a.memoizedState === null ? Oh : Ph, a = c(d, e), Jh) {
      f2 = 0;
      do {
        if (Jh = !1, Kh = 0, 25 <= f2) throw Error(p(301));
        f2 += 1, O2 = N2 = null, b.updateQueue = null, Fh.current = Qh, a = c(d, e);
      } while (Jh);
    }
    if (Fh.current = Rh, b = N2 !== null && N2.next !== null, Hh = 0, O2 = N2 = M2 = null, Ih = !1, b) throw Error(p(300));
    return a;
  }
  function Sh() {
    var a = Kh !== 0;
    return Kh = 0, a;
  }
  function Th() {
    var a = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return O2 === null ? M2.memoizedState = O2 = a : O2 = O2.next = a, O2;
  }
  function Uh() {
    if (N2 === null) {
      var a = M2.alternate;
      a = a !== null ? a.memoizedState : null;
    } else a = N2.next;
    var b = O2 === null ? M2.memoizedState : O2.next;
    if (b !== null) O2 = b, N2 = a;
    else {
      if (a === null) throw Error(p(310));
      N2 = a, a = { memoizedState: N2.memoizedState, baseState: N2.baseState, baseQueue: N2.baseQueue, queue: N2.queue, next: null }, O2 === null ? M2.memoizedState = O2 = a : O2 = O2.next = a;
    }
    return O2;
  }
  function Vh(a, b) {
    return typeof b == "function" ? b(a) : b;
  }
  function Wh(a) {
    var b = Uh(), c = b.queue;
    if (c === null) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = N2, e = d.baseQueue, f2 = c.pending;
    if (f2 !== null) {
      if (e !== null) {
        var g2 = e.next;
        e.next = f2.next, f2.next = g2;
      }
      d.baseQueue = e = f2, c.pending = null;
    }
    if (e !== null) {
      f2 = e.next, d = d.baseState;
      var h2 = g2 = null, k2 = null, l2 = f2;
      do {
        var m2 = l2.lane;
        if ((Hh & m2) === m2) k2 !== null && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d = l2.hasEagerState ? l2.eagerState : a(d, l2.action);
        else {
          var q2 = {
            lane: m2,
            action: l2.action,
            hasEagerState: l2.hasEagerState,
            eagerState: l2.eagerState,
            next: null
          };
          k2 === null ? (h2 = k2 = q2, g2 = d) : k2 = k2.next = q2, M2.lanes |= m2, rh |= m2;
        }
        l2 = l2.next;
      } while (l2 !== null && l2 !== f2);
      k2 === null ? g2 = d : k2.next = h2, He2(d, b.memoizedState) || (dh = !0), b.memoizedState = d, b.baseState = g2, b.baseQueue = k2, c.lastRenderedState = d;
    }
    if (a = c.interleaved, a !== null) {
      e = a;
      do
        f2 = e.lane, M2.lanes |= f2, rh |= f2, e = e.next;
      while (e !== a);
    } else e === null && (c.lanes = 0);
    return [b.memoizedState, c.dispatch];
  }
  function Xh(a) {
    var b = Uh(), c = b.queue;
    if (c === null) throw Error(p(311));
    c.lastRenderedReducer = a;
    var d = c.dispatch, e = c.pending, f2 = b.memoizedState;
    if (e !== null) {
      c.pending = null;
      var g2 = e = e.next;
      do
        f2 = a(f2, g2.action), g2 = g2.next;
      while (g2 !== e);
      He2(f2, b.memoizedState) || (dh = !0), b.memoizedState = f2, b.baseQueue === null && (b.baseState = f2), c.lastRenderedState = f2;
    }
    return [f2, d];
  }
  function Yh() {
  }
  function Zh(a, b) {
    var c = M2, d = Uh(), e = b(), f2 = !He2(d.memoizedState, e);
    if (f2 && (d.memoizedState = e, dh = !0), d = d.queue, $h(ai.bind(null, c, d, a), [a]), d.getSnapshot !== b || f2 || O2 !== null && O2.memoizedState.tag & 1) {
      if (c.flags |= 2048, bi(9, ci.bind(null, c, d, e, b), void 0, null), Q2 === null) throw Error(p(349));
      Hh & 30 || di(c, b, e);
    }
    return e;
  }
  function di(a, b, c) {
    a.flags |= 16384, a = { getSnapshot: b, value: c }, b = M2.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M2.updateQueue = b, b.stores = [a]) : (c = b.stores, c === null ? b.stores = [a] : c.push(a));
  }
  function ci(a, b, c, d) {
    b.value = c, b.getSnapshot = d, ei(b) && fi(a);
  }
  function ai(a, b, c) {
    return c(function() {
      ei(b) && fi(a);
    });
  }
  function ei(a) {
    var b = a.getSnapshot;
    a = a.value;
    try {
      var c = b();
      return !He2(a, c);
    } catch {
      return !0;
    }
  }
  function fi(a) {
    var b = ih(a, 1);
    b !== null && gi(b, a, 1, -1);
  }
  function hi(a) {
    var b = Th();
    return typeof a == "function" && (a = a()), b.memoizedState = b.baseState = a, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a }, b.queue = a, a = a.dispatch = ii2.bind(null, M2, a), [b.memoizedState, a];
  }
  function bi(a, b, c, d) {
    return a = { tag: a, create: b, destroy: c, deps: d, next: null }, b = M2.updateQueue, b === null ? (b = { lastEffect: null, stores: null }, M2.updateQueue = b, b.lastEffect = a.next = a) : (c = b.lastEffect, c === null ? b.lastEffect = a.next = a : (d = c.next, c.next = a, a.next = d, b.lastEffect = a)), a;
  }
  function ji() {
    return Uh().memoizedState;
  }
  function ki(a, b, c, d) {
    var e = Th();
    M2.flags |= a, e.memoizedState = bi(1 | b, c, void 0, d === void 0 ? null : d);
  }
  function li(a, b, c, d) {
    var e = Uh();
    d = d === void 0 ? null : d;
    var f2 = void 0;
    if (N2 !== null) {
      var g2 = N2.memoizedState;
      if (f2 = g2.destroy, d !== null && Mh(d, g2.deps)) {
        e.memoizedState = bi(b, c, f2, d);
        return;
      }
    }
    M2.flags |= a, e.memoizedState = bi(1 | b, c, f2, d);
  }
  function mi(a, b) {
    return ki(8390656, 8, a, b);
  }
  function $h(a, b) {
    return li(2048, 8, a, b);
  }
  function ni2(a, b) {
    return li(4, 2, a, b);
  }
  function oi(a, b) {
    return li(4, 4, a, b);
  }
  function pi2(a, b) {
    if (typeof b == "function") return a = a(), b(a), function() {
      b(null);
    };
    if (b != null) return a = a(), b.current = a, function() {
      b.current = null;
    };
  }
  function qi(a, b, c) {
    return c = c != null ? c.concat([a]) : null, li(4, 4, pi2.bind(null, b, a), c);
  }
  function ri() {
  }
  function si(a, b) {
    var c = Uh();
    b = b === void 0 ? null : b;
    var d = c.memoizedState;
    return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (c.memoizedState = [a, b], a);
  }
  function ti(a, b) {
    var c = Uh();
    b = b === void 0 ? null : b;
    var d = c.memoizedState;
    return d !== null && b !== null && Mh(b, d[1]) ? d[0] : (a = a(), c.memoizedState = [a, b], a);
  }
  function ui(a, b, c) {
    return Hh & 21 ? (He2(c, b) || (c = yc(), M2.lanes |= c, rh |= c, a.baseState = !0), b) : (a.baseState && (a.baseState = !1, dh = !0), a.memoizedState = c);
  }
  function vi(a, b) {
    var c = C2;
    C2 = c !== 0 && 4 > c ? c : 4, a(!0);
    var d = Gh.transition;
    Gh.transition = {};
    try {
      a(!1), b();
    } finally {
      C2 = c, Gh.transition = d;
    }
  }
  function wi() {
    return Uh().memoizedState;
  }
  function xi2(a, b, c) {
    var d = yi(a);
    if (c = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null }, zi(a)) Ai(b, c);
    else if (c = hh(a, b, c, d), c !== null) {
      var e = R2();
      gi(c, a, d, e), Bi(c, b, d);
    }
  }
  function ii2(a, b, c) {
    var d = yi(a), e = { lane: d, action: c, hasEagerState: !1, eagerState: null, next: null };
    if (zi(a)) Ai(b, e);
    else {
      var f2 = a.alternate;
      if (a.lanes === 0 && (f2 === null || f2.lanes === 0) && (f2 = b.lastRenderedReducer, f2 !== null)) try {
        var g2 = b.lastRenderedState, h2 = f2(g2, c);
        if (e.hasEagerState = !0, e.eagerState = h2, He2(h2, g2)) {
          var k2 = b.interleaved;
          k2 === null ? (e.next = e, gh(b)) : (e.next = k2.next, k2.next = e), b.interleaved = e;
          return;
        }
      } catch {
      } finally {
      }
      c = hh(a, b, e, d), c !== null && (e = R2(), gi(c, a, d, e), Bi(c, b, d));
    }
  }
  function zi(a) {
    var b = a.alternate;
    return a === M2 || b !== null && b === M2;
  }
  function Ai(a, b) {
    Jh = Ih = !0;
    var c = a.pending;
    c === null ? b.next = b : (b.next = c.next, c.next = b), a.pending = b;
  }
  function Bi(a, b, c) {
    if (c & 4194240) {
      var d = b.lanes;
      d &= a.pendingLanes, c |= d, b.lanes = c, Cc(a, c);
    }
  }
  var Rh = { readContext: eh, useCallback: P2, useContext: P2, useEffect: P2, useImperativeHandle: P2, useInsertionEffect: P2, useLayoutEffect: P2, useMemo: P2, useReducer: P2, useRef: P2, useState: P2, useDebugValue: P2, useDeferredValue: P2, useTransition: P2, useMutableSource: P2, useSyncExternalStore: P2, useId: P2, unstable_isNewReconciler: !1 }, Oh = { readContext: eh, useCallback: function(a, b) {
    return Th().memoizedState = [a, b === void 0 ? null : b], a;
  }, useContext: eh, useEffect: mi, useImperativeHandle: function(a, b, c) {
    return c = c != null ? c.concat([a]) : null, ki(
      4194308,
      4,
      pi2.bind(null, b, a),
      c
    );
  }, useLayoutEffect: function(a, b) {
    return ki(4194308, 4, a, b);
  }, useInsertionEffect: function(a, b) {
    return ki(4, 2, a, b);
  }, useMemo: function(a, b) {
    var c = Th();
    return b = b === void 0 ? null : b, a = a(), c.memoizedState = [a, b], a;
  }, useReducer: function(a, b, c) {
    var d = Th();
    return b = c !== void 0 ? c(b) : b, d.memoizedState = d.baseState = b, a = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a, lastRenderedState: b }, d.queue = a, a = a.dispatch = xi2.bind(null, M2, a), [d.memoizedState, a];
  }, useRef: function(a) {
    var b = Th();
    return a = { current: a }, b.memoizedState = a;
  }, useState: hi, useDebugValue: ri, useDeferredValue: function(a) {
    return Th().memoizedState = a;
  }, useTransition: function() {
    var a = hi(!1), b = a[0];
    return a = vi.bind(null, a[1]), Th().memoizedState = a, [b, a];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(a, b, c) {
    var d = M2, e = Th();
    if (I2) {
      if (c === void 0) throw Error(p(407));
      c = c();
    } else {
      if (c = b(), Q2 === null) throw Error(p(349));
      Hh & 30 || di(d, b, c);
    }
    e.memoizedState = c;
    var f2 = { value: c, getSnapshot: b };
    return e.queue = f2, mi(ai.bind(
      null,
      d,
      f2,
      a
    ), [a]), d.flags |= 2048, bi(9, ci.bind(null, d, f2, c, b), void 0, null), c;
  }, useId: function() {
    var a = Th(), b = Q2.identifierPrefix;
    if (I2) {
      var c = sg, d = rg;
      c = (d & ~(1 << 32 - oc(d) - 1)).toString(32) + c, b = ":" + b + "R" + c, c = Kh++, 0 < c && (b += "H" + c.toString(32)), b += ":";
    } else c = Lh++, b = ":" + b + "r" + c.toString(32) + ":";
    return a.memoizedState = b;
  }, unstable_isNewReconciler: !1 }, Ph = {
    readContext: eh,
    useCallback: si,
    useContext: eh,
    useEffect: $h,
    useImperativeHandle: qi,
    useInsertionEffect: ni2,
    useLayoutEffect: oi,
    useMemo: ti,
    useReducer: Wh,
    useRef: ji,
    useState: function() {
      return Wh(Vh);
    },
    useDebugValue: ri,
    useDeferredValue: function(a) {
      var b = Uh();
      return ui(b, N2.memoizedState, a);
    },
    useTransition: function() {
      var a = Wh(Vh)[0], b = Uh().memoizedState;
      return [a, b];
    },
    useMutableSource: Yh,
    useSyncExternalStore: Zh,
    useId: wi,
    unstable_isNewReconciler: !1
  }, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni2, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
    return Xh(Vh);
  }, useDebugValue: ri, useDeferredValue: function(a) {
    var b = Uh();
    return N2 === null ? b.memoizedState = a : ui(b, N2.memoizedState, a);
  }, useTransition: function() {
    var a = Xh(Vh)[0], b = Uh().memoizedState;
    return [a, b];
  }, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: !1 };
  function Ci(a, b) {
    if (a && a.defaultProps) {
      b = A2({}, b), a = a.defaultProps;
      for (var c in a) b[c] === void 0 && (b[c] = a[c]);
      return b;
    }
    return b;
  }
  function Di(a, b, c, d) {
    b = a.memoizedState, c = c(d, b), c = c == null ? b : A2({}, b, c), a.memoizedState = c, a.lanes === 0 && (a.updateQueue.baseState = c);
  }
  var Ei = { isMounted: function(a) {
    return (a = a._reactInternals) ? Vb(a) === a : !1;
  }, enqueueSetState: function(a, b, c) {
    a = a._reactInternals;
    var d = R2(), e = yi(a), f2 = mh(d, e);
    f2.payload = b, c != null && (f2.callback = c), b = nh(a, f2, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueReplaceState: function(a, b, c) {
    a = a._reactInternals;
    var d = R2(), e = yi(a), f2 = mh(d, e);
    f2.tag = 1, f2.payload = b, c != null && (f2.callback = c), b = nh(a, f2, e), b !== null && (gi(b, a, e, d), oh(b, a, e));
  }, enqueueForceUpdate: function(a, b) {
    a = a._reactInternals;
    var c = R2(), d = yi(a), e = mh(c, d);
    e.tag = 2, b != null && (e.callback = b), b = nh(a, e, d), b !== null && (gi(b, a, d, c), oh(b, a, d));
  } };
  function Fi(a, b, c, d, e, f2, g2) {
    return a = a.stateNode, typeof a.shouldComponentUpdate == "function" ? a.shouldComponentUpdate(d, f2, g2) : b.prototype && b.prototype.isPureReactComponent ? !Ie2(c, d) || !Ie2(e, f2) : !0;
  }
  function Gi(a, b, c) {
    var d = !1, e = Vf, f2 = b.contextType;
    return typeof f2 == "object" && f2 !== null ? f2 = eh(f2) : (e = Zf(b) ? Xf : H2.current, d = b.contextTypes, f2 = (d = d != null) ? Yf(a, e) : Vf), b = new b(c, f2), a.memoizedState = b.state !== null && b.state !== void 0 ? b.state : null, b.updater = Ei, a.stateNode = b, b._reactInternals = a, d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = e, a.__reactInternalMemoizedMaskedChildContext = f2), b;
  }
  function Hi(a, b, c, d) {
    a = b.state, typeof b.componentWillReceiveProps == "function" && b.componentWillReceiveProps(c, d), typeof b.UNSAFE_componentWillReceiveProps == "function" && b.UNSAFE_componentWillReceiveProps(c, d), b.state !== a && Ei.enqueueReplaceState(b, b.state, null);
  }
  function Ii(a, b, c, d) {
    var e = a.stateNode;
    e.props = c, e.state = a.memoizedState, e.refs = {}, kh(a);
    var f2 = b.contextType;
    typeof f2 == "object" && f2 !== null ? e.context = eh(f2) : (f2 = Zf(b) ? Xf : H2.current, e.context = Yf(a, f2)), e.state = a.memoizedState, f2 = b.getDerivedStateFromProps, typeof f2 == "function" && (Di(a, b, f2, c), e.state = a.memoizedState), typeof b.getDerivedStateFromProps == "function" || typeof e.getSnapshotBeforeUpdate == "function" || typeof e.UNSAFE_componentWillMount != "function" && typeof e.componentWillMount != "function" || (b = e.state, typeof e.componentWillMount == "function" && e.componentWillMount(), typeof e.UNSAFE_componentWillMount == "function" && e.UNSAFE_componentWillMount(), b !== e.state && Ei.enqueueReplaceState(e, e.state, null), qh(a, c, e, d), e.state = a.memoizedState), typeof e.componentDidMount == "function" && (a.flags |= 4194308);
  }
  function Ji(a, b) {
    try {
      var c = "", d = b;
      do
        c += Pa(d), d = d.return;
      while (d);
      var e = c;
    } catch (f2) {
      e = `
Error generating stack: ` + f2.message + `
` + f2.stack;
    }
    return { value: a, source: b, stack: e, digest: null };
  }
  function Ki(a, b, c) {
    return { value: a, source: null, stack: c ?? null, digest: b ?? null };
  }
  function Li(a, b) {
    try {
      console.error(b.value);
    } catch (c) {
      setTimeout(function() {
        throw c;
      });
    }
  }
  var Mi = typeof WeakMap == "function" ? WeakMap : Map;
  function Ni(a, b, c) {
    c = mh(-1, c), c.tag = 3, c.payload = { element: null };
    var d = b.value;
    return c.callback = function() {
      Oi || (Oi = !0, Pi2 = d), Li(a, b);
    }, c;
  }
  function Qi(a, b, c) {
    c = mh(-1, c), c.tag = 3;
    var d = a.type.getDerivedStateFromError;
    if (typeof d == "function") {
      var e = b.value;
      c.payload = function() {
        return d(e);
      }, c.callback = function() {
        Li(a, b);
      };
    }
    var f2 = a.stateNode;
    return f2 !== null && typeof f2.componentDidCatch == "function" && (c.callback = function() {
      Li(a, b), typeof d != "function" && (Ri === null ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
      var c2 = b.stack;
      this.componentDidCatch(b.value, { componentStack: c2 !== null ? c2 : "" });
    }), c;
  }
  function Si(a, b, c) {
    var d = a.pingCache;
    if (d === null) {
      d = a.pingCache = new Mi();
      var e = /* @__PURE__ */ new Set();
      d.set(b, e);
    } else e = d.get(b), e === void 0 && (e = /* @__PURE__ */ new Set(), d.set(b, e));
    e.has(c) || (e.add(c), a = Ti.bind(null, a, b, c), b.then(a, a));
  }
  function Ui(a) {
    do {
      var b;
      if ((b = a.tag === 13) && (b = a.memoizedState, b = b !== null ? b.dehydrated !== null : !0), b) return a;
      a = a.return;
    } while (a !== null);
    return null;
  }
  function Vi(a, b, c, d, e) {
    return a.mode & 1 ? (a.flags |= 65536, a.lanes = e, a) : (a === b ? a.flags |= 65536 : (a.flags |= 128, c.flags |= 131072, c.flags &= -52805, c.tag === 1 && (c.alternate === null ? c.tag = 17 : (b = mh(-1, 1), b.tag = 2, nh(c, b, 1))), c.lanes |= 1), a);
  }
  var Wi = ua.ReactCurrentOwner, dh = !1;
  function Xi2(a, b, c, d) {
    b.child = a === null ? Vg(b, null, c, d) : Ug(b, a.child, c, d);
  }
  function Yi(a, b, c, d, e) {
    c = c.render;
    var f2 = b.ref;
    return ch(b, e), d = Nh(a, b, c, d, f2, e), c = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I2 && c && vg(b), b.flags |= 1, Xi2(a, b, d, e), b.child);
  }
  function $i(a, b, c, d, e) {
    if (a === null) {
      var f2 = c.type;
      return typeof f2 == "function" && !aj(f2) && f2.defaultProps === void 0 && c.compare === null && c.defaultProps === void 0 ? (b.tag = 15, b.type = f2, bj(a, b, f2, d, e)) : (a = Rg(c.type, null, d, b, b.mode, e), a.ref = b.ref, a.return = b, b.child = a);
    }
    if (f2 = a.child, !(a.lanes & e)) {
      var g2 = f2.memoizedProps;
      if (c = c.compare, c = c !== null ? c : Ie2, c(g2, d) && a.ref === b.ref) return Zi(a, b, e);
    }
    return b.flags |= 1, a = Pg(f2, d), a.ref = b.ref, a.return = b, b.child = a;
  }
  function bj(a, b, c, d, e) {
    if (a !== null) {
      var f2 = a.memoizedProps;
      if (Ie2(f2, d) && a.ref === b.ref) if (dh = !1, b.pendingProps = d = f2, (a.lanes & e) !== 0) a.flags & 131072 && (dh = !0);
      else return b.lanes = a.lanes, Zi(a, b, e);
    }
    return cj(a, b, c, d, e);
  }
  function dj(a, b, c) {
    var d = b.pendingProps, e = d.children, f2 = a !== null ? a.memoizedState : null;
    if (d.mode === "hidden") if (!(b.mode & 1)) b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G2(ej, fj), fj |= c;
    else {
      if (!(c & 1073741824)) return a = f2 !== null ? f2.baseLanes | c : c, b.lanes = b.childLanes = 1073741824, b.memoizedState = { baseLanes: a, cachePool: null, transitions: null }, b.updateQueue = null, G2(ej, fj), fj |= a, null;
      b.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, d = f2 !== null ? f2.baseLanes : c, G2(ej, fj), fj |= d;
    }
    else f2 !== null ? (d = f2.baseLanes | c, b.memoizedState = null) : d = c, G2(ej, fj), fj |= d;
    return Xi2(a, b, e, c), b.child;
  }
  function gj(a, b) {
    var c = b.ref;
    (a === null && c !== null || a !== null && a.ref !== c) && (b.flags |= 512, b.flags |= 2097152);
  }
  function cj(a, b, c, d, e) {
    var f2 = Zf(c) ? Xf : H2.current;
    return f2 = Yf(b, f2), ch(b, e), c = Nh(a, b, c, d, f2, e), d = Sh(), a !== null && !dh ? (b.updateQueue = a.updateQueue, b.flags &= -2053, a.lanes &= ~e, Zi(a, b, e)) : (I2 && d && vg(b), b.flags |= 1, Xi2(a, b, c, e), b.child);
  }
  function hj(a, b, c, d, e) {
    if (Zf(c)) {
      var f2 = !0;
      cg(b);
    } else f2 = !1;
    if (ch(b, e), b.stateNode === null) ij(a, b), Gi(b, c, d), Ii(b, c, d, e), d = !0;
    else if (a === null) {
      var g2 = b.stateNode, h2 = b.memoizedProps;
      g2.props = h2;
      var k2 = g2.context, l2 = c.contextType;
      typeof l2 == "object" && l2 !== null ? l2 = eh(l2) : (l2 = Zf(c) ? Xf : H2.current, l2 = Yf(b, l2));
      var m2 = c.getDerivedStateFromProps, q2 = typeof m2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function";
      q2 || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== d || k2 !== l2) && Hi(b, g2, d, l2), jh = !1;
      var r = b.memoizedState;
      g2.state = r, qh(b, d, g2, e), k2 = b.memoizedState, h2 !== d || r !== k2 || Wf.current || jh ? (typeof m2 == "function" && (Di(b, c, m2, d), k2 = b.memoizedState), (h2 = jh || Fi(b, c, h2, d, r, k2, l2)) ? (q2 || typeof g2.UNSAFE_componentWillMount != "function" && typeof g2.componentWillMount != "function" || (typeof g2.componentWillMount == "function" && g2.componentWillMount(), typeof g2.UNSAFE_componentWillMount == "function" && g2.UNSAFE_componentWillMount()), typeof g2.componentDidMount == "function" && (b.flags |= 4194308)) : (typeof g2.componentDidMount == "function" && (b.flags |= 4194308), b.memoizedProps = d, b.memoizedState = k2), g2.props = d, g2.state = k2, g2.context = l2, d = h2) : (typeof g2.componentDidMount == "function" && (b.flags |= 4194308), d = !1);
    } else {
      g2 = b.stateNode, lh(a, b), h2 = b.memoizedProps, l2 = b.type === b.elementType ? h2 : Ci(b.type, h2), g2.props = l2, q2 = b.pendingProps, r = g2.context, k2 = c.contextType, typeof k2 == "object" && k2 !== null ? k2 = eh(k2) : (k2 = Zf(c) ? Xf : H2.current, k2 = Yf(b, k2));
      var y2 = c.getDerivedStateFromProps;
      (m2 = typeof y2 == "function" || typeof g2.getSnapshotBeforeUpdate == "function") || typeof g2.UNSAFE_componentWillReceiveProps != "function" && typeof g2.componentWillReceiveProps != "function" || (h2 !== q2 || r !== k2) && Hi(b, g2, d, k2), jh = !1, r = b.memoizedState, g2.state = r, qh(b, d, g2, e);
      var n = b.memoizedState;
      h2 !== q2 || r !== n || Wf.current || jh ? (typeof y2 == "function" && (Di(b, c, y2, d), n = b.memoizedState), (l2 = jh || Fi(b, c, l2, d, r, n, k2) || !1) ? (m2 || typeof g2.UNSAFE_componentWillUpdate != "function" && typeof g2.componentWillUpdate != "function" || (typeof g2.componentWillUpdate == "function" && g2.componentWillUpdate(d, n, k2), typeof g2.UNSAFE_componentWillUpdate == "function" && g2.UNSAFE_componentWillUpdate(d, n, k2)), typeof g2.componentDidUpdate == "function" && (b.flags |= 4), typeof g2.getSnapshotBeforeUpdate == "function" && (b.flags |= 1024)) : (typeof g2.componentDidUpdate != "function" || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), b.memoizedProps = d, b.memoizedState = n), g2.props = d, g2.state = n, g2.context = k2, d = l2) : (typeof g2.componentDidUpdate != "function" || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 4), typeof g2.getSnapshotBeforeUpdate != "function" || h2 === a.memoizedProps && r === a.memoizedState || (b.flags |= 1024), d = !1);
    }
    return jj(a, b, c, d, f2, e);
  }
  function jj(a, b, c, d, e, f2) {
    gj(a, b);
    var g2 = (b.flags & 128) !== 0;
    if (!d && !g2) return e && dg(b, c, !1), Zi(a, b, f2);
    d = b.stateNode, Wi.current = b;
    var h2 = g2 && typeof c.getDerivedStateFromError != "function" ? null : d.render();
    return b.flags |= 1, a !== null && g2 ? (b.child = Ug(b, a.child, null, f2), b.child = Ug(b, null, h2, f2)) : Xi2(a, b, h2, f2), b.memoizedState = d.state, e && dg(b, c, !0), b.child;
  }
  function kj(a) {
    var b = a.stateNode;
    b.pendingContext ? ag(a, b.pendingContext, b.pendingContext !== b.context) : b.context && ag(a, b.context, !1), yh(a, b.containerInfo);
  }
  function lj(a, b, c, d, e) {
    return Ig(), Jg(e), b.flags |= 256, Xi2(a, b, c, d), b.child;
  }
  var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
  function nj(a) {
    return { baseLanes: a, cachePool: null, transitions: null };
  }
  function oj(a, b, c) {
    var d = b.pendingProps, e = L2.current, f2 = !1, g2 = (b.flags & 128) !== 0, h2;
    if ((h2 = g2) || (h2 = a !== null && a.memoizedState === null ? !1 : (e & 2) !== 0), h2 ? (f2 = !0, b.flags &= -129) : (a === null || a.memoizedState !== null) && (e |= 1), G2(L2, e & 1), a === null)
      return Eg(b), a = b.memoizedState, a !== null && (a = a.dehydrated, a !== null) ? (b.mode & 1 ? a.data === "$!" ? b.lanes = 8 : b.lanes = 1073741824 : b.lanes = 1, null) : (g2 = d.children, a = d.fallback, f2 ? (d = b.mode, f2 = b.child, g2 = { mode: "hidden", children: g2 }, !(d & 1) && f2 !== null ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d, 0, null), a = Tg(a, d, c, null), f2.return = b, a.return = b, f2.sibling = a, b.child = f2, b.child.memoizedState = nj(c), b.memoizedState = mj, a) : qj(b, g2));
    if (e = a.memoizedState, e !== null && (h2 = e.dehydrated, h2 !== null)) return rj(a, b, g2, d, h2, e, c);
    if (f2) {
      f2 = d.fallback, g2 = b.mode, e = a.child, h2 = e.sibling;
      var k2 = { mode: "hidden", children: d.children };
      return !(g2 & 1) && b.child !== e ? (d = b.child, d.childLanes = 0, d.pendingProps = k2, b.deletions = null) : (d = Pg(e, k2), d.subtreeFlags = e.subtreeFlags & 14680064), h2 !== null ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c, null), f2.flags |= 2), f2.return = b, d.return = b, d.sibling = f2, b.child = d, d = f2, f2 = b.child, g2 = a.child.memoizedState, g2 = g2 === null ? nj(c) : { baseLanes: g2.baseLanes | c, cachePool: null, transitions: g2.transitions }, f2.memoizedState = g2, f2.childLanes = a.childLanes & ~c, b.memoizedState = mj, d;
    }
    return f2 = a.child, a = f2.sibling, d = Pg(f2, { mode: "visible", children: d.children }), !(b.mode & 1) && (d.lanes = c), d.return = b, d.sibling = null, a !== null && (c = b.deletions, c === null ? (b.deletions = [a], b.flags |= 16) : c.push(a)), b.child = d, b.memoizedState = null, d;
  }
  function qj(a, b) {
    return b = pj({ mode: "visible", children: b }, a.mode, 0, null), b.return = a, a.child = b;
  }
  function sj(a, b, c, d) {
    return d !== null && Jg(d), Ug(b, a.child, null, c), a = qj(b, b.pendingProps.children), a.flags |= 2, b.memoizedState = null, a;
  }
  function rj(a, b, c, d, e, f2, g2) {
    if (c)
      return b.flags & 256 ? (b.flags &= -257, d = Ki(Error(p(422))), sj(a, b, g2, d)) : b.memoizedState !== null ? (b.child = a.child, b.flags |= 128, null) : (f2 = d.fallback, e = b.mode, d = pj({ mode: "visible", children: d.children }, e, 0, null), f2 = Tg(f2, e, g2, null), f2.flags |= 2, d.return = b, f2.return = b, d.sibling = f2, b.child = d, b.mode & 1 && Ug(b, a.child, null, g2), b.child.memoizedState = nj(g2), b.memoizedState = mj, f2);
    if (!(b.mode & 1)) return sj(a, b, g2, null);
    if (e.data === "$!") {
      if (d = e.nextSibling && e.nextSibling.dataset, d) var h2 = d.dgst;
      return d = h2, f2 = Error(p(419)), d = Ki(f2, d, void 0), sj(a, b, g2, d);
    }
    if (h2 = (g2 & a.childLanes) !== 0, dh || h2) {
      if (d = Q2, d !== null) {
        switch (g2 & -g2) {
          case 4:
            e = 2;
            break;
          case 16:
            e = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            e = 32;
            break;
          case 536870912:
            e = 268435456;
            break;
          default:
            e = 0;
        }
        e = e & (d.suspendedLanes | g2) ? 0 : e, e !== 0 && e !== f2.retryLane && (f2.retryLane = e, ih(a, e), gi(d, a, e, -1));
      }
      return tj(), d = Ki(Error(p(421))), sj(a, b, g2, d);
    }
    return e.data === "$?" ? (b.flags |= 128, b.child = a.child, b = uj.bind(null, a), e._reactRetry = b, null) : (a = f2.treeContext, yg = Lf(e.nextSibling), xg = b, I2 = !0, zg = null, a !== null && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a.id, sg = a.overflow, qg = b), b = qj(b, d.children), b.flags |= 4096, b);
  }
  function vj(a, b, c) {
    a.lanes |= b;
    var d = a.alternate;
    d !== null && (d.lanes |= b), bh(a.return, b, c);
  }
  function wj(a, b, c, d, e) {
    var f2 = a.memoizedState;
    f2 === null ? a.memoizedState = { isBackwards: b, rendering: null, renderingStartTime: 0, last: d, tail: c, tailMode: e } : (f2.isBackwards = b, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d, f2.tail = c, f2.tailMode = e);
  }
  function xj(a, b, c) {
    var d = b.pendingProps, e = d.revealOrder, f2 = d.tail;
    if (Xi2(a, b, d.children, c), d = L2.current, d & 2) d = d & 1 | 2, b.flags |= 128;
    else {
      if (a !== null && a.flags & 128) a: for (a = b.child; a !== null; ) {
        if (a.tag === 13) a.memoizedState !== null && vj(a, c, b);
        else if (a.tag === 19) vj(a, c, b);
        else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === b) break a;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === b) break a;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      d &= 1;
    }
    if (G2(L2, d), !(b.mode & 1)) b.memoizedState = null;
    else switch (e) {
      case "forwards":
        for (c = b.child, e = null; c !== null; ) a = c.alternate, a !== null && Ch(a) === null && (e = c), c = c.sibling;
        c = e, c === null ? (e = b.child, b.child = null) : (e = c.sibling, c.sibling = null), wj(b, !1, e, c, f2);
        break;
      case "backwards":
        for (c = null, e = b.child, b.child = null; e !== null; ) {
          if (a = e.alternate, a !== null && Ch(a) === null) {
            b.child = e;
            break;
          }
          a = e.sibling, e.sibling = c, c = e, e = a;
        }
        wj(b, !0, c, null, f2);
        break;
      case "together":
        wj(b, !1, null, null, void 0);
        break;
      default:
        b.memoizedState = null;
    }
    return b.child;
  }
  function ij(a, b) {
    !(b.mode & 1) && a !== null && (a.alternate = null, b.alternate = null, b.flags |= 2);
  }
  function Zi(a, b, c) {
    if (a !== null && (b.dependencies = a.dependencies), rh |= b.lanes, !(c & b.childLanes)) return null;
    if (a !== null && b.child !== a.child) throw Error(p(153));
    if (b.child !== null) {
      for (a = b.child, c = Pg(a, a.pendingProps), b.child = c, c.return = b; a.sibling !== null; ) a = a.sibling, c = c.sibling = Pg(a, a.pendingProps), c.return = b;
      c.sibling = null;
    }
    return b.child;
  }
  function yj(a, b, c) {
    switch (b.tag) {
      case 3:
        kj(b), Ig();
        break;
      case 5:
        Ah(b);
        break;
      case 1:
        Zf(b.type) && cg(b);
        break;
      case 4:
        yh(b, b.stateNode.containerInfo);
        break;
      case 10:
        var d = b.type._context, e = b.memoizedProps.value;
        G2(Wg, d._currentValue), d._currentValue = e;
        break;
      case 13:
        if (d = b.memoizedState, d !== null)
          return d.dehydrated !== null ? (G2(L2, L2.current & 1), b.flags |= 128, null) : c & b.child.childLanes ? oj(a, b, c) : (G2(L2, L2.current & 1), a = Zi(a, b, c), a !== null ? a.sibling : null);
        G2(L2, L2.current & 1);
        break;
      case 19:
        if (d = (c & b.childLanes) !== 0, a.flags & 128) {
          if (d) return xj(a, b, c);
          b.flags |= 128;
        }
        if (e = b.memoizedState, e !== null && (e.rendering = null, e.tail = null, e.lastEffect = null), G2(L2, L2.current), d) break;
        return null;
      case 22:
      case 23:
        return b.lanes = 0, dj(a, b, c);
    }
    return Zi(a, b, c);
  }
  var zj, Aj, Bj, Cj;
  zj = function(a, b) {
    for (var c = b.child; c !== null; ) {
      if (c.tag === 5 || c.tag === 6) a.appendChild(c.stateNode);
      else if (c.tag !== 4 && c.child !== null) {
        c.child.return = c, c = c.child;
        continue;
      }
      if (c === b) break;
      for (; c.sibling === null; ) {
        if (c.return === null || c.return === b) return;
        c = c.return;
      }
      c.sibling.return = c.return, c = c.sibling;
    }
  }, Aj = function() {
  }, Bj = function(a, b, c, d) {
    var e = a.memoizedProps;
    if (e !== d) {
      a = b.stateNode, xh(uh.current);
      var f2 = null;
      switch (c) {
        case "input":
          e = Ya(a, e), d = Ya(a, d), f2 = [];
          break;
        case "select":
          e = A2({}, e, { value: void 0 }), d = A2({}, d, { value: void 0 }), f2 = [];
          break;
        case "textarea":
          e = gb(a, e), d = gb(a, d), f2 = [];
          break;
        default:
          typeof e.onClick != "function" && typeof d.onClick == "function" && (a.onclick = Bf);
      }
      ub(c, d);
      var g2;
      c = null;
      for (l2 in e) if (!d.hasOwnProperty(l2) && e.hasOwnProperty(l2) && e[l2] != null) if (l2 === "style") {
        var h2 = e[l2];
        for (g2 in h2) h2.hasOwnProperty(g2) && (c || (c = {}), c[g2] = "");
      } else l2 !== "dangerouslySetInnerHTML" && l2 !== "children" && l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && l2 !== "autoFocus" && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
      for (l2 in d) {
        var k2 = d[l2];
        if (h2 = e?.[l2], d.hasOwnProperty(l2) && k2 !== h2 && (k2 != null || h2 != null)) if (l2 === "style") if (h2) {
          for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c || (c = {}), c[g2] = "");
          for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c || (c = {}), c[g2] = k2[g2]);
        } else c || (f2 || (f2 = []), f2.push(
          l2,
          c
        )), c = k2;
        else l2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, k2 != null && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : l2 === "children" ? typeof k2 != "string" && typeof k2 != "number" || (f2 = f2 || []).push(l2, "" + k2) : l2 !== "suppressContentEditableWarning" && l2 !== "suppressHydrationWarning" && (ea.hasOwnProperty(l2) ? (k2 != null && l2 === "onScroll" && D2("scroll", a), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
      }
      c && (f2 = f2 || []).push("style", c);
      var l2 = f2;
      (b.updateQueue = l2) && (b.flags |= 4);
    }
  }, Cj = function(a, b, c, d) {
    c !== d && (b.flags |= 4);
  };
  function Dj(a, b) {
    if (!I2) switch (a.tailMode) {
      case "hidden":
        b = a.tail;
        for (var c = null; b !== null; ) b.alternate !== null && (c = b), b = b.sibling;
        c === null ? a.tail = null : c.sibling = null;
        break;
      case "collapsed":
        c = a.tail;
        for (var d = null; c !== null; ) c.alternate !== null && (d = c), c = c.sibling;
        d === null ? b || a.tail === null ? a.tail = null : a.tail.sibling = null : d.sibling = null;
    }
  }
  function S2(a) {
    var b = a.alternate !== null && a.alternate.child === a.child, c = 0, d = 0;
    if (b) for (var e = a.child; e !== null; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags & 14680064, d |= e.flags & 14680064, e.return = a, e = e.sibling;
    else for (e = a.child; e !== null; ) c |= e.lanes | e.childLanes, d |= e.subtreeFlags, d |= e.flags, e.return = a, e = e.sibling;
    return a.subtreeFlags |= d, a.childLanes = c, b;
  }
  function Ej(a, b, c) {
    var d = b.pendingProps;
    switch (wg(b), b.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return S2(b), null;
      case 1:
        return Zf(b.type) && $f(), S2(b), null;
      case 3:
        return d = b.stateNode, zh(), E2(Wf), E2(H2), Eh(), d.pendingContext && (d.context = d.pendingContext, d.pendingContext = null), (a === null || a.child === null) && (Gg2(b) ? b.flags |= 4 : a === null || a.memoizedState.isDehydrated && !(b.flags & 256) || (b.flags |= 1024, zg !== null && (Fj(zg), zg = null))), Aj(a, b), S2(b), null;
      case 5:
        Bh(b);
        var e = xh(wh.current);
        if (c = b.type, a !== null && b.stateNode != null) Bj(a, b, c, d, e), a.ref !== b.ref && (b.flags |= 512, b.flags |= 2097152);
        else {
          if (!d) {
            if (b.stateNode === null) throw Error(p(166));
            return S2(b), null;
          }
          if (a = xh(uh.current), Gg2(b)) {
            d = b.stateNode, c = b.type;
            var f2 = b.memoizedProps;
            switch (d[Of] = b, d[Pf] = f2, a = (b.mode & 1) !== 0, c) {
              case "dialog":
                D2("cancel", d), D2("close", d);
                break;
              case "iframe":
              case "object":
              case "embed":
                D2("load", d);
                break;
              case "video":
              case "audio":
                for (e = 0; e < lf.length; e++) D2(lf[e], d);
                break;
              case "source":
                D2("error", d);
                break;
              case "img":
              case "image":
              case "link":
                D2(
                  "error",
                  d
                ), D2("load", d);
                break;
              case "details":
                D2("toggle", d);
                break;
              case "input":
                Za(d, f2), D2("invalid", d);
                break;
              case "select":
                d._wrapperState = { wasMultiple: !!f2.multiple }, D2("invalid", d);
                break;
              case "textarea":
                hb(d, f2), D2("invalid", d);
            }
            ub(c, f2), e = null;
            for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
              var h2 = f2[g2];
              g2 === "children" ? typeof h2 == "string" ? d.textContent !== h2 && (f2.suppressHydrationWarning !== !0 && Af(d.textContent, h2, a), e = ["children", h2]) : typeof h2 == "number" && d.textContent !== "" + h2 && (f2.suppressHydrationWarning !== !0 && Af(
                d.textContent,
                h2,
                a
              ), e = ["children", "" + h2]) : ea.hasOwnProperty(g2) && h2 != null && g2 === "onScroll" && D2("scroll", d);
            }
            switch (c) {
              case "input":
                Va(d), db(d, f2, !0);
                break;
              case "textarea":
                Va(d), jb(d);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof f2.onClick == "function" && (d.onclick = Bf);
            }
            d = e, b.updateQueue = d, d !== null && (b.flags |= 4);
          } else {
            g2 = e.nodeType === 9 ? e : e.ownerDocument, a === "http://www.w3.org/1999/xhtml" && (a = kb(c)), a === "http://www.w3.org/1999/xhtml" ? c === "script" ? (a = g2.createElement("div"), a.innerHTML = "<script><\/script>", a = a.removeChild(a.firstChild)) : typeof d.is == "string" ? a = g2.createElement(c, { is: d.is }) : (a = g2.createElement(c), c === "select" && (g2 = a, d.multiple ? g2.multiple = !0 : d.size && (g2.size = d.size))) : a = g2.createElementNS(a, c), a[Of] = b, a[Pf] = d, zj(a, b, !1, !1), b.stateNode = a;
            a: {
              switch (g2 = vb(c, d), c) {
                case "dialog":
                  D2("cancel", a), D2("close", a), e = d;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  D2("load", a), e = d;
                  break;
                case "video":
                case "audio":
                  for (e = 0; e < lf.length; e++) D2(lf[e], a);
                  e = d;
                  break;
                case "source":
                  D2("error", a), e = d;
                  break;
                case "img":
                case "image":
                case "link":
                  D2(
                    "error",
                    a
                  ), D2("load", a), e = d;
                  break;
                case "details":
                  D2("toggle", a), e = d;
                  break;
                case "input":
                  Za(a, d), e = Ya(a, d), D2("invalid", a);
                  break;
                case "option":
                  e = d;
                  break;
                case "select":
                  a._wrapperState = { wasMultiple: !!d.multiple }, e = A2({}, d, { value: void 0 }), D2("invalid", a);
                  break;
                case "textarea":
                  hb(a, d), e = gb(a, d), D2("invalid", a);
                  break;
                default:
                  e = d;
              }
              ub(c, e), h2 = e;
              for (f2 in h2) if (h2.hasOwnProperty(f2)) {
                var k2 = h2[f2];
                f2 === "style" ? sb(a, k2) : f2 === "dangerouslySetInnerHTML" ? (k2 = k2 ? k2.__html : void 0, k2 != null && nb(a, k2)) : f2 === "children" ? typeof k2 == "string" ? (c !== "textarea" || k2 !== "") && ob(a, k2) : typeof k2 == "number" && ob(a, "" + k2) : f2 !== "suppressContentEditableWarning" && f2 !== "suppressHydrationWarning" && f2 !== "autoFocus" && (ea.hasOwnProperty(f2) ? k2 != null && f2 === "onScroll" && D2("scroll", a) : k2 != null && ta(a, f2, k2, g2));
              }
              switch (c) {
                case "input":
                  Va(a), db(a, d, !1);
                  break;
                case "textarea":
                  Va(a), jb(a);
                  break;
                case "option":
                  d.value != null && a.setAttribute("value", "" + Sa(d.value));
                  break;
                case "select":
                  a.multiple = !!d.multiple, f2 = d.value, f2 != null ? fb(a, !!d.multiple, f2, !1) : d.defaultValue != null && fb(
                    a,
                    !!d.multiple,
                    d.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof e.onClick == "function" && (a.onclick = Bf);
              }
              switch (c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  d = !!d.autoFocus;
                  break a;
                case "img":
                  d = !0;
                  break a;
                default:
                  d = !1;
              }
            }
            d && (b.flags |= 4);
          }
          b.ref !== null && (b.flags |= 512, b.flags |= 2097152);
        }
        return S2(b), null;
      case 6:
        if (a && b.stateNode != null) Cj(a, b, a.memoizedProps, d);
        else {
          if (typeof d != "string" && b.stateNode === null) throw Error(p(166));
          if (c = xh(wh.current), xh(uh.current), Gg2(b)) {
            if (d = b.stateNode, c = b.memoizedProps, d[Of] = b, (f2 = d.nodeValue !== c) && (a = xg, a !== null)) switch (a.tag) {
              case 3:
                Af(d.nodeValue, c, (a.mode & 1) !== 0);
                break;
              case 5:
                a.memoizedProps.suppressHydrationWarning !== !0 && Af(d.nodeValue, c, (a.mode & 1) !== 0);
            }
            f2 && (b.flags |= 4);
          } else d = (c.nodeType === 9 ? c : c.ownerDocument).createTextNode(d), d[Of] = b, b.stateNode = d;
        }
        return S2(b), null;
      case 13:
        if (E2(L2), d = b.memoizedState, a === null || a.memoizedState !== null && a.memoizedState.dehydrated !== null) {
          if (I2 && yg !== null && b.mode & 1 && !(b.flags & 128)) Hg(), Ig(), b.flags |= 98560, f2 = !1;
          else if (f2 = Gg2(b), d !== null && d.dehydrated !== null) {
            if (a === null) {
              if (!f2) throw Error(p(318));
              if (f2 = b.memoizedState, f2 = f2 !== null ? f2.dehydrated : null, !f2) throw Error(p(317));
              f2[Of] = b;
            } else Ig(), !(b.flags & 128) && (b.memoizedState = null), b.flags |= 4;
            S2(b), f2 = !1;
          } else zg !== null && (Fj(zg), zg = null), f2 = !0;
          if (!f2) return b.flags & 65536 ? b : null;
        }
        return b.flags & 128 ? (b.lanes = c, b) : (d = d !== null, d !== (a !== null && a.memoizedState !== null) && d && (b.child.flags |= 8192, b.mode & 1 && (a === null || L2.current & 1 ? T2 === 0 && (T2 = 3) : tj())), b.updateQueue !== null && (b.flags |= 4), S2(b), null);
      case 4:
        return zh(), Aj(a, b), a === null && sf(b.stateNode.containerInfo), S2(b), null;
      case 10:
        return ah(b.type._context), S2(b), null;
      case 17:
        return Zf(b.type) && $f(), S2(b), null;
      case 19:
        if (E2(L2), f2 = b.memoizedState, f2 === null) return S2(b), null;
        if (d = (b.flags & 128) !== 0, g2 = f2.rendering, g2 === null) if (d) Dj(f2, !1);
        else {
          if (T2 !== 0 || a !== null && a.flags & 128) for (a = b.child; a !== null; ) {
            if (g2 = Ch(a), g2 !== null) {
              for (b.flags |= 128, Dj(f2, !1), d = g2.updateQueue, d !== null && (b.updateQueue = d, b.flags |= 4), b.subtreeFlags = 0, d = c, c = b.child; c !== null; ) f2 = c, a = d, f2.flags &= 14680066, g2 = f2.alternate, g2 === null ? (f2.childLanes = 0, f2.lanes = a, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a = g2.dependencies, f2.dependencies = a === null ? null : { lanes: a.lanes, firstContext: a.firstContext }), c = c.sibling;
              return G2(L2, L2.current & 1 | 2), b.child;
            }
            a = a.sibling;
          }
          f2.tail !== null && B2() > Gj && (b.flags |= 128, d = !0, Dj(f2, !1), b.lanes = 4194304);
        }
        else {
          if (!d) if (a = Ch(g2), a !== null) {
            if (b.flags |= 128, d = !0, c = a.updateQueue, c !== null && (b.updateQueue = c, b.flags |= 4), Dj(f2, !0), f2.tail === null && f2.tailMode === "hidden" && !g2.alternate && !I2) return S2(b), null;
          } else 2 * B2() - f2.renderingStartTime > Gj && c !== 1073741824 && (b.flags |= 128, d = !0, Dj(f2, !1), b.lanes = 4194304);
          f2.isBackwards ? (g2.sibling = b.child, b.child = g2) : (c = f2.last, c !== null ? c.sibling = g2 : b.child = g2, f2.last = g2);
        }
        return f2.tail !== null ? (b = f2.tail, f2.rendering = b, f2.tail = b.sibling, f2.renderingStartTime = B2(), b.sibling = null, c = L2.current, G2(L2, d ? c & 1 | 2 : c & 1), b) : (S2(b), null);
      case 22:
      case 23:
        return Hj(), d = b.memoizedState !== null, a !== null && a.memoizedState !== null !== d && (b.flags |= 8192), d && b.mode & 1 ? fj & 1073741824 && (S2(b), b.subtreeFlags & 6 && (b.flags |= 8192)) : S2(b), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(p(156, b.tag));
  }
  function Ij(a, b) {
    switch (wg(b), b.tag) {
      case 1:
        return Zf(b.type) && $f(), a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 3:
        return zh(), E2(Wf), E2(H2), Eh(), a = b.flags, a & 65536 && !(a & 128) ? (b.flags = a & -65537 | 128, b) : null;
      case 5:
        return Bh(b), null;
      case 13:
        if (E2(L2), a = b.memoizedState, a !== null && a.dehydrated !== null) {
          if (b.alternate === null) throw Error(p(340));
          Ig();
        }
        return a = b.flags, a & 65536 ? (b.flags = a & -65537 | 128, b) : null;
      case 19:
        return E2(L2), null;
      case 4:
        return zh(), null;
      case 10:
        return ah(b.type._context), null;
      case 22:
      case 23:
        return Hj(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var Jj = !1, U2 = !1, Kj = typeof WeakSet == "function" ? WeakSet : Set, V2 = null;
  function Lj(a, b) {
    var c = a.ref;
    if (c !== null) if (typeof c == "function") try {
      c(null);
    } catch (d) {
      W2(a, b, d);
    }
    else c.current = null;
  }
  function Mj(a, b, c) {
    try {
      c();
    } catch (d) {
      W2(a, b, d);
    }
  }
  var Nj = !1;
  function Oj(a, b) {
    if (Cf = dd2, a = Me2(), Ne2(a)) {
      if ("selectionStart" in a) var c = { start: a.selectionStart, end: a.selectionEnd };
      else a: {
        c = (c = a.ownerDocument) && c.defaultView || window;
        var d = c.getSelection && c.getSelection();
        if (d && d.rangeCount !== 0) {
          c = d.anchorNode;
          var e = d.anchorOffset, f2 = d.focusNode;
          d = d.focusOffset;
          try {
            c.nodeType, f2.nodeType;
          } catch {
            c = null;
            break a;
          }
          var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a, r = null;
          b: for (; ; ) {
            for (var y2; q2 !== c || e !== 0 && q2.nodeType !== 3 || (h2 = g2 + e), q2 !== f2 || d !== 0 && q2.nodeType !== 3 || (k2 = g2 + d), q2.nodeType === 3 && (g2 += q2.nodeValue.length), (y2 = q2.firstChild) !== null; )
              r = q2, q2 = y2;
            for (; ; ) {
              if (q2 === a) break b;
              if (r === c && ++l2 === e && (h2 = g2), r === f2 && ++m2 === d && (k2 = g2), (y2 = q2.nextSibling) !== null) break;
              q2 = r, r = q2.parentNode;
            }
            q2 = y2;
          }
          c = h2 === -1 || k2 === -1 ? null : { start: h2, end: k2 };
        } else c = null;
      }
      c = c || { start: 0, end: 0 };
    } else c = null;
    for (Df = { focusedElem: a, selectionRange: c }, dd2 = !1, V2 = b; V2 !== null; ) if (b = V2, a = b.child, (b.subtreeFlags & 1028) !== 0 && a !== null) a.return = b, V2 = a;
    else for (; V2 !== null; ) {
      b = V2;
      try {
        var n = b.alternate;
        if (b.flags & 1024) switch (b.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (n !== null) {
              var t = n.memoizedProps, J2 = n.memoizedState, x2 = b.stateNode, w2 = x2.getSnapshotBeforeUpdate(b.elementType === b.type ? t : Ci(b.type, t), J2);
              x2.__reactInternalSnapshotBeforeUpdate = w2;
            }
            break;
          case 3:
            var u = b.stateNode.containerInfo;
            u.nodeType === 1 ? u.textContent = "" : u.nodeType === 9 && u.documentElement && u.removeChild(u.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(p(163));
        }
      } catch (F2) {
        W2(b, b.return, F2);
      }
      if (a = b.sibling, a !== null) {
        a.return = b.return, V2 = a;
        break;
      }
      V2 = b.return;
    }
    return n = Nj, Nj = !1, n;
  }
  function Pj(a, b, c) {
    var d = b.updateQueue;
    if (d = d !== null ? d.lastEffect : null, d !== null) {
      var e = d = d.next;
      do {
        if ((e.tag & a) === a) {
          var f2 = e.destroy;
          e.destroy = void 0, f2 !== void 0 && Mj(b, c, f2);
        }
        e = e.next;
      } while (e !== d);
    }
  }
  function Qj(a, b) {
    if (b = b.updateQueue, b = b !== null ? b.lastEffect : null, b !== null) {
      var c = b = b.next;
      do {
        if ((c.tag & a) === a) {
          var d = c.create;
          c.destroy = d();
        }
        c = c.next;
      } while (c !== b);
    }
  }
  function Rj(a) {
    var b = a.ref;
    if (b !== null) {
      var c = a.stateNode;
      switch (a.tag) {
        case 5:
          a = c;
          break;
        default:
          a = c;
      }
      typeof b == "function" ? b(a) : b.current = a;
    }
  }
  function Sj(a) {
    var b = a.alternate;
    b !== null && (a.alternate = null, Sj(b)), a.child = null, a.deletions = null, a.sibling = null, a.tag === 5 && (b = a.stateNode, b !== null && (delete b[Of], delete b[Pf], delete b[of], delete b[Qf], delete b[Rf])), a.stateNode = null, a.return = null, a.dependencies = null, a.memoizedProps = null, a.memoizedState = null, a.pendingProps = null, a.stateNode = null, a.updateQueue = null;
  }
  function Tj(a) {
    return a.tag === 5 || a.tag === 3 || a.tag === 4;
  }
  function Uj(a) {
    a: for (; ; ) {
      for (; a.sibling === null; ) {
        if (a.return === null || Tj(a.return)) return null;
        a = a.return;
      }
      for (a.sibling.return = a.return, a = a.sibling; a.tag !== 5 && a.tag !== 6 && a.tag !== 18; ) {
        if (a.flags & 2 || a.child === null || a.tag === 4) continue a;
        a.child.return = a, a = a.child;
      }
      if (!(a.flags & 2)) return a.stateNode;
    }
  }
  function Vj(a, b, c) {
    var d = a.tag;
    if (d === 5 || d === 6) a = a.stateNode, b ? c.nodeType === 8 ? c.parentNode.insertBefore(a, b) : c.insertBefore(a, b) : (c.nodeType === 8 ? (b = c.parentNode, b.insertBefore(a, c)) : (b = c, b.appendChild(a)), c = c._reactRootContainer, c != null || b.onclick !== null || (b.onclick = Bf));
    else if (d !== 4 && (a = a.child, a !== null)) for (Vj(a, b, c), a = a.sibling; a !== null; ) Vj(a, b, c), a = a.sibling;
  }
  function Wj(a, b, c) {
    var d = a.tag;
    if (d === 5 || d === 6) a = a.stateNode, b ? c.insertBefore(a, b) : c.appendChild(a);
    else if (d !== 4 && (a = a.child, a !== null)) for (Wj(a, b, c), a = a.sibling; a !== null; ) Wj(a, b, c), a = a.sibling;
  }
  var X2 = null, Xj = !1;
  function Yj(a, b, c) {
    for (c = c.child; c !== null; ) Zj(a, b, c), c = c.sibling;
  }
  function Zj(a, b, c) {
    if (lc && typeof lc.onCommitFiberUnmount == "function") try {
      lc.onCommitFiberUnmount(kc, c);
    } catch {
    }
    switch (c.tag) {
      case 5:
        U2 || Lj(c, b);
      case 6:
        var d = X2, e = Xj;
        X2 = null, Yj(a, b, c), X2 = d, Xj = e, X2 !== null && (Xj ? (a = X2, c = c.stateNode, a.nodeType === 8 ? a.parentNode.removeChild(c) : a.removeChild(c)) : X2.removeChild(c.stateNode));
        break;
      case 18:
        X2 !== null && (Xj ? (a = X2, c = c.stateNode, a.nodeType === 8 ? Kf(a.parentNode, c) : a.nodeType === 1 && Kf(a, c), bd(a)) : Kf(X2, c.stateNode));
        break;
      case 4:
        d = X2, e = Xj, X2 = c.stateNode.containerInfo, Xj = !0, Yj(a, b, c), X2 = d, Xj = e;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!U2 && (d = c.updateQueue, d !== null && (d = d.lastEffect, d !== null))) {
          e = d = d.next;
          do {
            var f2 = e, g2 = f2.destroy;
            f2 = f2.tag, g2 !== void 0 && (f2 & 2 || f2 & 4) && Mj(c, b, g2), e = e.next;
          } while (e !== d);
        }
        Yj(a, b, c);
        break;
      case 1:
        if (!U2 && (Lj(c, b), d = c.stateNode, typeof d.componentWillUnmount == "function")) try {
          d.props = c.memoizedProps, d.state = c.memoizedState, d.componentWillUnmount();
        } catch (h2) {
          W2(c, b, h2);
        }
        Yj(a, b, c);
        break;
      case 21:
        Yj(a, b, c);
        break;
      case 22:
        c.mode & 1 ? (U2 = (d = U2) || c.memoizedState !== null, Yj(a, b, c), U2 = d) : Yj(a, b, c);
        break;
      default:
        Yj(a, b, c);
    }
  }
  function ak(a) {
    var b = a.updateQueue;
    if (b !== null) {
      a.updateQueue = null;
      var c = a.stateNode;
      c === null && (c = a.stateNode = new Kj()), b.forEach(function(b2) {
        var d = bk.bind(null, a, b2);
        c.has(b2) || (c.add(b2), b2.then(d, d));
      });
    }
  }
  function ck(a, b) {
    var c = b.deletions;
    if (c !== null) for (var d = 0; d < c.length; d++) {
      var e = c[d];
      try {
        var f2 = a, g2 = b, h2 = g2;
        a: for (; h2 !== null; ) {
          switch (h2.tag) {
            case 5:
              X2 = h2.stateNode, Xj = !1;
              break a;
            case 3:
              X2 = h2.stateNode.containerInfo, Xj = !0;
              break a;
            case 4:
              X2 = h2.stateNode.containerInfo, Xj = !0;
              break a;
          }
          h2 = h2.return;
        }
        if (X2 === null) throw Error(p(160));
        Zj(f2, g2, e), X2 = null, Xj = !1;
        var k2 = e.alternate;
        k2 !== null && (k2.return = null), e.return = null;
      } catch (l2) {
        W2(e, b, l2);
      }
    }
    if (b.subtreeFlags & 12854) for (b = b.child; b !== null; ) dk(b, a), b = b.sibling;
  }
  function dk(a, b) {
    var c = a.alternate, d = a.flags;
    switch (a.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if (ck(b, a), ek(a), d & 4) {
          try {
            Pj(3, a, a.return), Qj(3, a);
          } catch (t) {
            W2(a, a.return, t);
          }
          try {
            Pj(5, a, a.return);
          } catch (t) {
            W2(a, a.return, t);
          }
        }
        break;
      case 1:
        ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return);
        break;
      case 5:
        if (ck(b, a), ek(a), d & 512 && c !== null && Lj(c, c.return), a.flags & 32) {
          var e = a.stateNode;
          try {
            ob(e, "");
          } catch (t) {
            W2(a, a.return, t);
          }
        }
        if (d & 4 && (e = a.stateNode, e != null)) {
          var f2 = a.memoizedProps, g2 = c !== null ? c.memoizedProps : f2, h2 = a.type, k2 = a.updateQueue;
          if (a.updateQueue = null, k2 !== null) try {
            h2 === "input" && f2.type === "radio" && f2.name != null && ab(e, f2), vb(h2, g2);
            var l2 = vb(h2, f2);
            for (g2 = 0; g2 < k2.length; g2 += 2) {
              var m2 = k2[g2], q2 = k2[g2 + 1];
              m2 === "style" ? sb(e, q2) : m2 === "dangerouslySetInnerHTML" ? nb(e, q2) : m2 === "children" ? ob(e, q2) : ta(e, m2, q2, l2);
            }
            switch (h2) {
              case "input":
                bb(e, f2);
                break;
              case "textarea":
                ib(e, f2);
                break;
              case "select":
                var r = e._wrapperState.wasMultiple;
                e._wrapperState.wasMultiple = !!f2.multiple;
                var y2 = f2.value;
                y2 != null ? fb(e, !!f2.multiple, y2, !1) : r !== !!f2.multiple && (f2.defaultValue != null ? fb(
                  e,
                  !!f2.multiple,
                  f2.defaultValue,
                  !0
                ) : fb(e, !!f2.multiple, f2.multiple ? [] : "", !1));
            }
            e[Pf] = f2;
          } catch (t) {
            W2(a, a.return, t);
          }
        }
        break;
      case 6:
        if (ck(b, a), ek(a), d & 4) {
          if (a.stateNode === null) throw Error(p(162));
          e = a.stateNode, f2 = a.memoizedProps;
          try {
            e.nodeValue = f2;
          } catch (t) {
            W2(a, a.return, t);
          }
        }
        break;
      case 3:
        if (ck(b, a), ek(a), d & 4 && c !== null && c.memoizedState.isDehydrated) try {
          bd(b.containerInfo);
        } catch (t) {
          W2(a, a.return, t);
        }
        break;
      case 4:
        ck(b, a), ek(a);
        break;
      case 13:
        ck(b, a), ek(a), e = a.child, e.flags & 8192 && (f2 = e.memoizedState !== null, e.stateNode.isHidden = f2, !f2 || e.alternate !== null && e.alternate.memoizedState !== null || (fk = B2())), d & 4 && ak(a);
        break;
      case 22:
        if (m2 = c !== null && c.memoizedState !== null, a.mode & 1 ? (U2 = (l2 = U2) || m2, ck(b, a), U2 = l2) : ck(b, a), ek(a), d & 8192) {
          if (l2 = a.memoizedState !== null, (a.stateNode.isHidden = l2) && !m2 && a.mode & 1) for (V2 = a, m2 = a.child; m2 !== null; ) {
            for (q2 = V2 = m2; V2 !== null; ) {
              switch (r = V2, y2 = r.child, r.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  Pj(4, r, r.return);
                  break;
                case 1:
                  Lj(r, r.return);
                  var n = r.stateNode;
                  if (typeof n.componentWillUnmount == "function") {
                    d = r, c = r.return;
                    try {
                      b = d, n.props = b.memoizedProps, n.state = b.memoizedState, n.componentWillUnmount();
                    } catch (t) {
                      W2(d, c, t);
                    }
                  }
                  break;
                case 5:
                  Lj(r, r.return);
                  break;
                case 22:
                  if (r.memoizedState !== null) {
                    gk(q2);
                    continue;
                  }
              }
              y2 !== null ? (y2.return = r, V2 = y2) : gk(q2);
            }
            m2 = m2.sibling;
          }
          a: for (m2 = null, q2 = a; ; ) {
            if (q2.tag === 5) {
              if (m2 === null) {
                m2 = q2;
                try {
                  e = q2.stateNode, l2 ? (f2 = e.style, typeof f2.setProperty == "function" ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = k2 != null && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
                } catch (t) {
                  W2(a, a.return, t);
                }
              }
            } else if (q2.tag === 6) {
              if (m2 === null) try {
                q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
              } catch (t) {
                W2(a, a.return, t);
              }
            } else if ((q2.tag !== 22 && q2.tag !== 23 || q2.memoizedState === null || q2 === a) && q2.child !== null) {
              q2.child.return = q2, q2 = q2.child;
              continue;
            }
            if (q2 === a) break a;
            for (; q2.sibling === null; ) {
              if (q2.return === null || q2.return === a) break a;
              m2 === q2 && (m2 = null), q2 = q2.return;
            }
            m2 === q2 && (m2 = null), q2.sibling.return = q2.return, q2 = q2.sibling;
          }
        }
        break;
      case 19:
        ck(b, a), ek(a), d & 4 && ak(a);
        break;
      case 21:
        break;
      default:
        ck(
          b,
          a
        ), ek(a);
    }
  }
  function ek(a) {
    var b = a.flags;
    if (b & 2) {
      try {
        a: {
          for (var c = a.return; c !== null; ) {
            if (Tj(c)) {
              var d = c;
              break a;
            }
            c = c.return;
          }
          throw Error(p(160));
        }
        switch (d.tag) {
          case 5:
            var e = d.stateNode;
            d.flags & 32 && (ob(e, ""), d.flags &= -33);
            var f2 = Uj(a);
            Wj(a, f2, e);
            break;
          case 3:
          case 4:
            var g2 = d.stateNode.containerInfo, h2 = Uj(a);
            Vj(a, h2, g2);
            break;
          default:
            throw Error(p(161));
        }
      } catch (k2) {
        W2(a, a.return, k2);
      }
      a.flags &= -3;
    }
    b & 4096 && (a.flags &= -4097);
  }
  function hk(a, b, c) {
    V2 = a, ik(a);
  }
  function ik(a, b, c) {
    for (var d = (a.mode & 1) !== 0; V2 !== null; ) {
      var e = V2, f2 = e.child;
      if (e.tag === 22 && d) {
        var g2 = e.memoizedState !== null || Jj;
        if (!g2) {
          var h2 = e.alternate, k2 = h2 !== null && h2.memoizedState !== null || U2;
          h2 = Jj;
          var l2 = U2;
          if (Jj = g2, (U2 = k2) && !l2) for (V2 = e; V2 !== null; ) g2 = V2, k2 = g2.child, g2.tag === 22 && g2.memoizedState !== null ? jk(e) : k2 !== null ? (k2.return = g2, V2 = k2) : jk(e);
          for (; f2 !== null; ) V2 = f2, ik(f2), f2 = f2.sibling;
          V2 = e, Jj = h2, U2 = l2;
        }
        kk(a);
      } else e.subtreeFlags & 8772 && f2 !== null ? (f2.return = e, V2 = f2) : kk(a);
    }
  }
  function kk(a) {
    for (; V2 !== null; ) {
      var b = V2;
      if (b.flags & 8772) {
        var c = b.alternate;
        try {
          if (b.flags & 8772) switch (b.tag) {
            case 0:
            case 11:
            case 15:
              U2 || Qj(5, b);
              break;
            case 1:
              var d = b.stateNode;
              if (b.flags & 4 && !U2) if (c === null) d.componentDidMount();
              else {
                var e = b.elementType === b.type ? c.memoizedProps : Ci(b.type, c.memoizedProps);
                d.componentDidUpdate(e, c.memoizedState, d.__reactInternalSnapshotBeforeUpdate);
              }
              var f2 = b.updateQueue;
              f2 !== null && sh2(b, f2, d);
              break;
            case 3:
              var g2 = b.updateQueue;
              if (g2 !== null) {
                if (c = null, b.child !== null) switch (b.child.tag) {
                  case 5:
                    c = b.child.stateNode;
                    break;
                  case 1:
                    c = b.child.stateNode;
                }
                sh2(b, g2, c);
              }
              break;
            case 5:
              var h2 = b.stateNode;
              if (c === null && b.flags & 4) {
                c = h2;
                var k2 = b.memoizedProps;
                switch (b.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    k2.autoFocus && c.focus();
                    break;
                  case "img":
                    k2.src && (c.src = k2.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (b.memoizedState === null) {
                var l2 = b.alternate;
                if (l2 !== null) {
                  var m2 = l2.memoizedState;
                  if (m2 !== null) {
                    var q2 = m2.dehydrated;
                    q2 !== null && bd(q2);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(p(163));
          }
          U2 || b.flags & 512 && Rj(b);
        } catch (r) {
          W2(b, b.return, r);
        }
      }
      if (b === a) {
        V2 = null;
        break;
      }
      if (c = b.sibling, c !== null) {
        c.return = b.return, V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function gk(a) {
    for (; V2 !== null; ) {
      var b = V2;
      if (b === a) {
        V2 = null;
        break;
      }
      var c = b.sibling;
      if (c !== null) {
        c.return = b.return, V2 = c;
        break;
      }
      V2 = b.return;
    }
  }
  function jk(a) {
    for (; V2 !== null; ) {
      var b = V2;
      try {
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            var c = b.return;
            try {
              Qj(4, b);
            } catch (k2) {
              W2(b, c, k2);
            }
            break;
          case 1:
            var d = b.stateNode;
            if (typeof d.componentDidMount == "function") {
              var e = b.return;
              try {
                d.componentDidMount();
              } catch (k2) {
                W2(b, e, k2);
              }
            }
            var f2 = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W2(b, f2, k2);
            }
            break;
          case 5:
            var g2 = b.return;
            try {
              Rj(b);
            } catch (k2) {
              W2(b, g2, k2);
            }
        }
      } catch (k2) {
        W2(b, b.return, k2);
      }
      if (b === a) {
        V2 = null;
        break;
      }
      var h2 = b.sibling;
      if (h2 !== null) {
        h2.return = b.return, V2 = h2;
        break;
      }
      V2 = b.return;
    }
  }
  var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok2 = ua.ReactCurrentBatchConfig, K2 = 0, Q2 = null, Y2 = null, Z2 = 0, fj = 0, ej = Uf(0), T2 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = 1 / 0, uk = null, Oi = !1, Pi2 = null, Ri = null, vk = !1, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
  function R2() {
    return K2 & 6 ? B2() : Ak !== -1 ? Ak : Ak = B2();
  }
  function yi(a) {
    return a.mode & 1 ? K2 & 2 && Z2 !== 0 ? Z2 & -Z2 : Kg.transition !== null ? (Bk === 0 && (Bk = yc()), Bk) : (a = C2, a !== 0 || (a = window.event, a = a === void 0 ? 16 : jd(a.type)), a) : 1;
  }
  function gi(a, b, c, d) {
    if (50 < yk) throw yk = 0, zk = null, Error(p(185));
    Ac(a, c, d), (!(K2 & 2) || a !== Q2) && (a === Q2 && (!(K2 & 2) && (qk |= c), T2 === 4 && Ck(a, Z2)), Dk(a, d), c === 1 && K2 === 0 && !(b.mode & 1) && (Gj = B2() + 500, fg && jg()));
  }
  function Dk(a, b) {
    var c = a.callbackNode;
    wc(a, b);
    var d = uc(a, a === Q2 ? Z2 : 0);
    if (d === 0) c !== null && bc(c), a.callbackNode = null, a.callbackPriority = 0;
    else if (b = d & -d, a.callbackPriority !== b) {
      if (c != null && bc(c), b === 1) a.tag === 0 ? ig(Ek.bind(null, a)) : hg(Ek.bind(null, a)), Jf(function() {
        !(K2 & 6) && jg();
      }), c = null;
      else {
        switch (Dc(d)) {
          case 1:
            c = fc;
            break;
          case 4:
            c = gc;
            break;
          case 16:
            c = hc;
            break;
          case 536870912:
            c = jc;
            break;
          default:
            c = hc;
        }
        c = Fk(c, Gk.bind(null, a));
      }
      a.callbackPriority = b, a.callbackNode = c;
    }
  }
  function Gk(a, b) {
    if (Ak = -1, Bk = 0, K2 & 6) throw Error(p(327));
    var c = a.callbackNode;
    if (Hk() && a.callbackNode !== c) return null;
    var d = uc(a, a === Q2 ? Z2 : 0);
    if (d === 0) return null;
    if (d & 30 || d & a.expiredLanes || b) b = Ik(a, d);
    else {
      b = d;
      var e = K2;
      K2 |= 2;
      var f2 = Jk();
      (Q2 !== a || Z2 !== b) && (uk = null, Gj = B2() + 500, Kk(a, b));
      do
        try {
          Lk();
          break;
        } catch (h2) {
          Mk(a, h2);
        }
      while (!0);
      $g(), mk.current = f2, K2 = e, Y2 !== null ? b = 0 : (Q2 = null, Z2 = 0, b = T2);
    }
    if (b !== 0) {
      if (b === 2 && (e = xc(a), e !== 0 && (d = e, b = Nk(a, e))), b === 1) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B2()), c;
      if (b === 6) Ck(a, d);
      else {
        if (e = a.current.alternate, !(d & 30) && !Ok(e) && (b = Ik(a, d), b === 2 && (f2 = xc(a), f2 !== 0 && (d = f2, b = Nk(a, f2))), b === 1)) throw c = pk, Kk(a, 0), Ck(a, d), Dk(a, B2()), c;
        switch (a.finishedWork = e, a.finishedLanes = d, b) {
          case 0:
          case 1:
            throw Error(p(345));
          case 2:
            Pk(a, tk, uk);
            break;
          case 3:
            if (Ck(a, d), (d & 130023424) === d && (b = fk + 500 - B2(), 10 < b)) {
              if (uc(a, 0) !== 0) break;
              if (e = a.suspendedLanes, (e & d) !== d) {
                R2(), a.pingedLanes |= a.suspendedLanes & e;
                break;
              }
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), b);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 4:
            if (Ck(a, d), (d & 4194240) === d) break;
            for (b = a.eventTimes, e = -1; 0 < d; ) {
              var g2 = 31 - oc(d);
              f2 = 1 << g2, g2 = b[g2], g2 > e && (e = g2), d &= ~f2;
            }
            if (d = e, d = B2() - d, d = (120 > d ? 120 : 480 > d ? 480 : 1080 > d ? 1080 : 1920 > d ? 1920 : 3e3 > d ? 3e3 : 4320 > d ? 4320 : 1960 * lk(d / 1960)) - d, 10 < d) {
              a.timeoutHandle = Ff(Pk.bind(null, a, tk, uk), d);
              break;
            }
            Pk(a, tk, uk);
            break;
          case 5:
            Pk(a, tk, uk);
            break;
          default:
            throw Error(p(329));
        }
      }
    }
    return Dk(a, B2()), a.callbackNode === c ? Gk.bind(null, a) : null;
  }
  function Nk(a, b) {
    var c = sk;
    return a.current.memoizedState.isDehydrated && (Kk(a, b).flags |= 256), a = Ik(a, b), a !== 2 && (b = tk, tk = c, b !== null && Fj(b)), a;
  }
  function Fj(a) {
    tk === null ? tk = a : tk.push.apply(tk, a);
  }
  function Ok(a) {
    for (var b = a; ; ) {
      if (b.flags & 16384) {
        var c = b.updateQueue;
        if (c !== null && (c = c.stores, c !== null)) for (var d = 0; d < c.length; d++) {
          var e = c[d], f2 = e.getSnapshot;
          e = e.value;
          try {
            if (!He2(f2(), e)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (c = b.child, b.subtreeFlags & 16384 && c !== null) c.return = b, b = c;
      else {
        if (b === a) break;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a) return !0;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }
    return !0;
  }
  function Ck(a, b) {
    for (b &= ~rk, b &= ~qk, a.suspendedLanes |= b, a.pingedLanes &= ~b, a = a.expirationTimes; 0 < b; ) {
      var c = 31 - oc(b), d = 1 << c;
      a[c] = -1, b &= ~d;
    }
  }
  function Ek(a) {
    if (K2 & 6) throw Error(p(327));
    Hk();
    var b = uc(a, 0);
    if (!(b & 1)) return Dk(a, B2()), null;
    var c = Ik(a, b);
    if (a.tag !== 0 && c === 2) {
      var d = xc(a);
      d !== 0 && (b = d, c = Nk(a, d));
    }
    if (c === 1) throw c = pk, Kk(a, 0), Ck(a, b), Dk(a, B2()), c;
    if (c === 6) throw Error(p(345));
    return a.finishedWork = a.current.alternate, a.finishedLanes = b, Pk(a, tk, uk), Dk(a, B2()), null;
  }
  function Qk(a, b) {
    var c = K2;
    K2 |= 1;
    try {
      return a(b);
    } finally {
      K2 = c, K2 === 0 && (Gj = B2() + 500, fg && jg());
    }
  }
  function Rk(a) {
    wk !== null && wk.tag === 0 && !(K2 & 6) && Hk();
    var b = K2;
    K2 |= 1;
    var c = ok2.transition, d = C2;
    try {
      if (ok2.transition = null, C2 = 1, a) return a();
    } finally {
      C2 = d, ok2.transition = c, K2 = b, !(K2 & 6) && jg();
    }
  }
  function Hj() {
    fj = ej.current, E2(ej);
  }
  function Kk(a, b) {
    a.finishedWork = null, a.finishedLanes = 0;
    var c = a.timeoutHandle;
    if (c !== -1 && (a.timeoutHandle = -1, Gf(c)), Y2 !== null) for (c = Y2.return; c !== null; ) {
      var d = c;
      switch (wg(d), d.tag) {
        case 1:
          d = d.type.childContextTypes, d != null && $f();
          break;
        case 3:
          zh(), E2(Wf), E2(H2), Eh();
          break;
        case 5:
          Bh(d);
          break;
        case 4:
          zh();
          break;
        case 13:
          E2(L2);
          break;
        case 19:
          E2(L2);
          break;
        case 10:
          ah(d.type._context);
          break;
        case 22:
        case 23:
          Hj();
      }
      c = c.return;
    }
    if (Q2 = a, Y2 = a = Pg(a.current, null), Z2 = fj = b, T2 = 0, pk = null, rk = qk = rh = 0, tk = sk = null, fh !== null) {
      for (b = 0; b < fh.length; b++) if (c = fh[b], d = c.interleaved, d !== null) {
        c.interleaved = null;
        var e = d.next, f2 = c.pending;
        if (f2 !== null) {
          var g2 = f2.next;
          f2.next = e, d.next = g2;
        }
        c.pending = d;
      }
      fh = null;
    }
    return a;
  }
  function Mk(a, b) {
    do {
      var c = Y2;
      try {
        if ($g(), Fh.current = Rh, Ih) {
          for (var d = M2.memoizedState; d !== null; ) {
            var e = d.queue;
            e !== null && (e.pending = null), d = d.next;
          }
          Ih = !1;
        }
        if (Hh = 0, O2 = N2 = M2 = null, Jh = !1, Kh = 0, nk.current = null, c === null || c.return === null) {
          T2 = 1, pk = b, Y2 = null;
          break;
        }
        a: {
          var f2 = a, g2 = c.return, h2 = c, k2 = b;
          if (b = Z2, h2.flags |= 32768, k2 !== null && typeof k2 == "object" && typeof k2.then == "function") {
            var l2 = k2, m2 = h2, q2 = m2.tag;
            if (!(m2.mode & 1) && (q2 === 0 || q2 === 11 || q2 === 15)) {
              var r = m2.alternate;
              r ? (m2.updateQueue = r.updateQueue, m2.memoizedState = r.memoizedState, m2.lanes = r.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
            }
            var y2 = Ui(g2);
            if (y2 !== null) {
              y2.flags &= -257, Vi(y2, g2, h2, f2, b), y2.mode & 1 && Si(f2, l2, b), b = y2, k2 = l2;
              var n = b.updateQueue;
              if (n === null) {
                var t = /* @__PURE__ */ new Set();
                t.add(k2), b.updateQueue = t;
              } else n.add(k2);
              break a;
            } else {
              if (!(b & 1)) {
                Si(f2, l2, b), tj();
                break a;
              }
              k2 = Error(p(426));
            }
          } else if (I2 && h2.mode & 1) {
            var J2 = Ui(g2);
            if (J2 !== null) {
              !(J2.flags & 65536) && (J2.flags |= 256), Vi(J2, g2, h2, f2, b), Jg(Ji(k2, h2));
              break a;
            }
          }
          f2 = k2 = Ji(k2, h2), T2 !== 4 && (T2 = 2), sk === null ? sk = [f2] : sk.push(f2), f2 = g2;
          do {
            switch (f2.tag) {
              case 3:
                f2.flags |= 65536, b &= -b, f2.lanes |= b;
                var x2 = Ni(f2, k2, b);
                ph(f2, x2);
                break a;
              case 1:
                h2 = k2;
                var w2 = f2.type, u = f2.stateNode;
                if (!(f2.flags & 128) && (typeof w2.getDerivedStateFromError == "function" || u !== null && typeof u.componentDidCatch == "function" && (Ri === null || !Ri.has(u)))) {
                  f2.flags |= 65536, b &= -b, f2.lanes |= b;
                  var F2 = Qi(f2, h2, b);
                  ph(f2, F2);
                  break a;
                }
            }
            f2 = f2.return;
          } while (f2 !== null);
        }
        Sk(c);
      } catch (na) {
        b = na, Y2 === c && c !== null && (Y2 = c = c.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Jk() {
    var a = mk.current;
    return mk.current = Rh, a === null ? Rh : a;
  }
  function tj() {
    (T2 === 0 || T2 === 3 || T2 === 2) && (T2 = 4), Q2 === null || !(rh & 268435455) && !(qk & 268435455) || Ck(Q2, Z2);
  }
  function Ik(a, b) {
    var c = K2;
    K2 |= 2;
    var d = Jk();
    (Q2 !== a || Z2 !== b) && (uk = null, Kk(a, b));
    do
      try {
        Tk();
        break;
      } catch (e) {
        Mk(a, e);
      }
    while (!0);
    if ($g(), K2 = c, mk.current = d, Y2 !== null) throw Error(p(261));
    return Q2 = null, Z2 = 0, T2;
  }
  function Tk() {
    for (; Y2 !== null; ) Uk(Y2);
  }
  function Lk() {
    for (; Y2 !== null && !cc(); ) Uk(Y2);
  }
  function Uk(a) {
    var b = Vk(a.alternate, a, fj);
    a.memoizedProps = a.pendingProps, b === null ? Sk(a) : Y2 = b, nk.current = null;
  }
  function Sk(a) {
    var b = a;
    do {
      var c = b.alternate;
      if (a = b.return, b.flags & 32768) {
        if (c = Ij(c, b), c !== null) {
          c.flags &= 32767, Y2 = c;
          return;
        }
        if (a !== null) a.flags |= 32768, a.subtreeFlags = 0, a.deletions = null;
        else {
          T2 = 6, Y2 = null;
          return;
        }
      } else if (c = Ej(c, b, fj), c !== null) {
        Y2 = c;
        return;
      }
      if (b = b.sibling, b !== null) {
        Y2 = b;
        return;
      }
      Y2 = b = a;
    } while (b !== null);
    T2 === 0 && (T2 = 5);
  }
  function Pk(a, b, c) {
    var d = C2, e = ok2.transition;
    try {
      ok2.transition = null, C2 = 1, Wk(a, b, c, d);
    } finally {
      ok2.transition = e, C2 = d;
    }
    return null;
  }
  function Wk(a, b, c, d) {
    do
      Hk();
    while (wk !== null);
    if (K2 & 6) throw Error(p(327));
    c = a.finishedWork;
    var e = a.finishedLanes;
    if (c === null) return null;
    if (a.finishedWork = null, a.finishedLanes = 0, c === a.current) throw Error(p(177));
    a.callbackNode = null, a.callbackPriority = 0;
    var f2 = c.lanes | c.childLanes;
    if (Bc(a, f2), a === Q2 && (Y2 = Q2 = null, Z2 = 0), !(c.subtreeFlags & 2064) && !(c.flags & 2064) || vk || (vk = !0, Fk(hc, function() {
      return Hk(), null;
    })), f2 = (c.flags & 15990) !== 0, c.subtreeFlags & 15990 || f2) {
      f2 = ok2.transition, ok2.transition = null;
      var g2 = C2;
      C2 = 1;
      var h2 = K2;
      K2 |= 4, nk.current = null, Oj(a, c), dk(c, a), Oe2(Df), dd2 = !!Cf, Df = Cf = null, a.current = c, hk(c), dc(), K2 = h2, C2 = g2, ok2.transition = f2;
    } else a.current = c;
    if (vk && (vk = !1, wk = a, xk = e), f2 = a.pendingLanes, f2 === 0 && (Ri = null), mc(c.stateNode), Dk(a, B2()), b !== null) for (d = a.onRecoverableError, c = 0; c < b.length; c++) e = b[c], d(e.value, { componentStack: e.stack, digest: e.digest });
    if (Oi) throw Oi = !1, a = Pi2, Pi2 = null, a;
    return xk & 1 && a.tag !== 0 && Hk(), f2 = a.pendingLanes, f2 & 1 ? a === zk ? yk++ : (yk = 0, zk = a) : yk = 0, jg(), null;
  }
  function Hk() {
    if (wk !== null) {
      var a = Dc(xk), b = ok2.transition, c = C2;
      try {
        if (ok2.transition = null, C2 = 16 > a ? 16 : a, wk === null) var d = !1;
        else {
          if (a = wk, wk = null, xk = 0, K2 & 6) throw Error(p(331));
          var e = K2;
          for (K2 |= 4, V2 = a.current; V2 !== null; ) {
            var f2 = V2, g2 = f2.child;
            if (V2.flags & 16) {
              var h2 = f2.deletions;
              if (h2 !== null) {
                for (var k2 = 0; k2 < h2.length; k2++) {
                  var l2 = h2[k2];
                  for (V2 = l2; V2 !== null; ) {
                    var m2 = V2;
                    switch (m2.tag) {
                      case 0:
                      case 11:
                      case 15:
                        Pj(8, m2, f2);
                    }
                    var q2 = m2.child;
                    if (q2 !== null) q2.return = m2, V2 = q2;
                    else for (; V2 !== null; ) {
                      m2 = V2;
                      var r = m2.sibling, y2 = m2.return;
                      if (Sj(m2), m2 === l2) {
                        V2 = null;
                        break;
                      }
                      if (r !== null) {
                        r.return = y2, V2 = r;
                        break;
                      }
                      V2 = y2;
                    }
                  }
                }
                var n = f2.alternate;
                if (n !== null) {
                  var t = n.child;
                  if (t !== null) {
                    n.child = null;
                    do {
                      var J2 = t.sibling;
                      t.sibling = null, t = J2;
                    } while (t !== null);
                  }
                }
                V2 = f2;
              }
            }
            if (f2.subtreeFlags & 2064 && g2 !== null) g2.return = f2, V2 = g2;
            else b: for (; V2 !== null; ) {
              if (f2 = V2, f2.flags & 2048) switch (f2.tag) {
                case 0:
                case 11:
                case 15:
                  Pj(9, f2, f2.return);
              }
              var x2 = f2.sibling;
              if (x2 !== null) {
                x2.return = f2.return, V2 = x2;
                break b;
              }
              V2 = f2.return;
            }
          }
          var w2 = a.current;
          for (V2 = w2; V2 !== null; ) {
            g2 = V2;
            var u = g2.child;
            if (g2.subtreeFlags & 2064 && u !== null) u.return = g2, V2 = u;
            else b: for (g2 = w2; V2 !== null; ) {
              if (h2 = V2, h2.flags & 2048) try {
                switch (h2.tag) {
                  case 0:
                  case 11:
                  case 15:
                    Qj(9, h2);
                }
              } catch (na) {
                W2(h2, h2.return, na);
              }
              if (h2 === g2) {
                V2 = null;
                break b;
              }
              var F2 = h2.sibling;
              if (F2 !== null) {
                F2.return = h2.return, V2 = F2;
                break b;
              }
              V2 = h2.return;
            }
          }
          if (K2 = e, jg(), lc && typeof lc.onPostCommitFiberRoot == "function") try {
            lc.onPostCommitFiberRoot(kc, a);
          } catch {
          }
          d = !0;
        }
        return d;
      } finally {
        C2 = c, ok2.transition = b;
      }
    }
    return !1;
  }
  function Xk(a, b, c) {
    b = Ji(c, b), b = Ni(a, b, 1), a = nh(a, b, 1), b = R2(), a !== null && (Ac(a, 1, b), Dk(a, b));
  }
  function W2(a, b, c) {
    if (a.tag === 3) Xk(a, a, c);
    else for (; b !== null; ) {
      if (b.tag === 3) {
        Xk(b, a, c);
        break;
      } else if (b.tag === 1) {
        var d = b.stateNode;
        if (typeof b.type.getDerivedStateFromError == "function" || typeof d.componentDidCatch == "function" && (Ri === null || !Ri.has(d))) {
          a = Ji(c, a), a = Qi(b, a, 1), b = nh(b, a, 1), a = R2(), b !== null && (Ac(b, 1, a), Dk(b, a));
          break;
        }
      }
      b = b.return;
    }
  }
  function Ti(a, b, c) {
    var d = a.pingCache;
    d !== null && d.delete(b), b = R2(), a.pingedLanes |= a.suspendedLanes & c, Q2 === a && (Z2 & c) === c && (T2 === 4 || T2 === 3 && (Z2 & 130023424) === Z2 && 500 > B2() - fk ? Kk(a, 0) : rk |= c), Dk(a, b);
  }
  function Yk(a, b) {
    b === 0 && (a.mode & 1 ? (b = sc2, sc2 <<= 1, !(sc2 & 130023424) && (sc2 = 4194304)) : b = 1);
    var c = R2();
    a = ih(a, b), a !== null && (Ac(a, b, c), Dk(a, c));
  }
  function uj(a) {
    var b = a.memoizedState, c = 0;
    b !== null && (c = b.retryLane), Yk(a, c);
  }
  function bk(a, b) {
    var c = 0;
    switch (a.tag) {
      case 13:
        var d = a.stateNode, e = a.memoizedState;
        e !== null && (c = e.retryLane);
        break;
      case 19:
        d = a.stateNode;
        break;
      default:
        throw Error(p(314));
    }
    d !== null && d.delete(b), Yk(a, c);
  }
  var Vk;
  Vk = function(a, b, c) {
    if (a !== null) if (a.memoizedProps !== b.pendingProps || Wf.current) dh = !0;
    else {
      if (!(a.lanes & c) && !(b.flags & 128)) return dh = !1, yj(a, b, c);
      dh = !!(a.flags & 131072);
    }
    else dh = !1, I2 && b.flags & 1048576 && ug(b, ng, b.index);
    switch (b.lanes = 0, b.tag) {
      case 2:
        var d = b.type;
        ij(a, b), a = b.pendingProps;
        var e = Yf(b, H2.current);
        ch(b, c), e = Nh(null, b, d, a, e, c);
        var f2 = Sh();
        return b.flags |= 1, typeof e == "object" && e !== null && typeof e.render == "function" && e.$$typeof === void 0 ? (b.tag = 1, b.memoizedState = null, b.updateQueue = null, Zf(d) ? (f2 = !0, cg(b)) : f2 = !1, b.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null, kh(b), e.updater = Ei, b.stateNode = e, e._reactInternals = b, Ii(b, d, a, c), b = jj(null, b, d, !0, f2, c)) : (b.tag = 0, I2 && f2 && vg(b), Xi2(null, b, e, c), b = b.child), b;
      case 16:
        d = b.elementType;
        a: {
          switch (ij(a, b), a = b.pendingProps, e = d._init, d = e(d._payload), b.type = d, e = b.tag = Zk(d), a = Ci(d, a), e) {
            case 0:
              b = cj(null, b, d, a, c);
              break a;
            case 1:
              b = hj(null, b, d, a, c);
              break a;
            case 11:
              b = Yi(null, b, d, a, c);
              break a;
            case 14:
              b = $i(null, b, d, Ci(d.type, a), c);
              break a;
          }
          throw Error(p(
            306,
            d,
            ""
          ));
        }
        return b;
      case 0:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), cj(a, b, d, e, c);
      case 1:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), hj(a, b, d, e, c);
      case 3:
        a: {
          if (kj(b), a === null) throw Error(p(387));
          d = b.pendingProps, f2 = b.memoizedState, e = f2.element, lh(a, b), qh(b, d, null, c);
          var g2 = b.memoizedState;
          if (d = g2.element, f2.isDehydrated) if (f2 = { element: d, isDehydrated: !1, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b.updateQueue.baseState = f2, b.memoizedState = f2, b.flags & 256) {
            e = Ji(Error(p(423)), b), b = lj(a, b, d, c, e);
            break a;
          } else if (d !== e) {
            e = Ji(Error(p(424)), b), b = lj(a, b, d, c, e);
            break a;
          } else for (yg = Lf(b.stateNode.containerInfo.firstChild), xg = b, I2 = !0, zg = null, c = Vg(b, null, d, c), b.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
          else {
            if (Ig(), d === e) {
              b = Zi(a, b, c);
              break a;
            }
            Xi2(a, b, d, c);
          }
          b = b.child;
        }
        return b;
      case 5:
        return Ah(b), a === null && Eg(b), d = b.type, e = b.pendingProps, f2 = a !== null ? a.memoizedProps : null, g2 = e.children, Ef(d, e) ? g2 = null : f2 !== null && Ef(d, f2) && (b.flags |= 32), gj(a, b), Xi2(a, b, g2, c), b.child;
      case 6:
        return a === null && Eg(b), null;
      case 13:
        return oj(a, b, c);
      case 4:
        return yh(b, b.stateNode.containerInfo), d = b.pendingProps, a === null ? b.child = Ug(b, null, d, c) : Xi2(a, b, d, c), b.child;
      case 11:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), Yi(a, b, d, e, c);
      case 7:
        return Xi2(a, b, b.pendingProps, c), b.child;
      case 8:
        return Xi2(a, b, b.pendingProps.children, c), b.child;
      case 12:
        return Xi2(a, b, b.pendingProps.children, c), b.child;
      case 10:
        a: {
          if (d = b.type._context, e = b.pendingProps, f2 = b.memoizedProps, g2 = e.value, G2(Wg, d._currentValue), d._currentValue = g2, f2 !== null) if (He2(f2.value, g2)) {
            if (f2.children === e.children && !Wf.current) {
              b = Zi(a, b, c);
              break a;
            }
          } else for (f2 = b.child, f2 !== null && (f2.return = b); f2 !== null; ) {
            var h2 = f2.dependencies;
            if (h2 !== null) {
              g2 = f2.child;
              for (var k2 = h2.firstContext; k2 !== null; ) {
                if (k2.context === d) {
                  if (f2.tag === 1) {
                    k2 = mh(-1, c & -c), k2.tag = 2;
                    var l2 = f2.updateQueue;
                    if (l2 !== null) {
                      l2 = l2.shared;
                      var m2 = l2.pending;
                      m2 === null ? k2.next = k2 : (k2.next = m2.next, m2.next = k2), l2.pending = k2;
                    }
                  }
                  f2.lanes |= c, k2 = f2.alternate, k2 !== null && (k2.lanes |= c), bh(
                    f2.return,
                    c,
                    b
                  ), h2.lanes |= c;
                  break;
                }
                k2 = k2.next;
              }
            } else if (f2.tag === 10) g2 = f2.type === b.type ? null : f2.child;
            else if (f2.tag === 18) {
              if (g2 = f2.return, g2 === null) throw Error(p(341));
              g2.lanes |= c, h2 = g2.alternate, h2 !== null && (h2.lanes |= c), bh(g2, c, b), g2 = f2.sibling;
            } else g2 = f2.child;
            if (g2 !== null) g2.return = f2;
            else for (g2 = f2; g2 !== null; ) {
              if (g2 === b) {
                g2 = null;
                break;
              }
              if (f2 = g2.sibling, f2 !== null) {
                f2.return = g2.return, g2 = f2;
                break;
              }
              g2 = g2.return;
            }
            f2 = g2;
          }
          Xi2(a, b, e.children, c), b = b.child;
        }
        return b;
      case 9:
        return e = b.type, d = b.pendingProps.children, ch(b, c), e = eh(e), d = d(e), b.flags |= 1, Xi2(a, b, d, c), b.child;
      case 14:
        return d = b.type, e = Ci(d, b.pendingProps), e = Ci(d.type, e), $i(a, b, d, e, c);
      case 15:
        return bj(a, b, b.type, b.pendingProps, c);
      case 17:
        return d = b.type, e = b.pendingProps, e = b.elementType === d ? e : Ci(d, e), ij(a, b), b.tag = 1, Zf(d) ? (a = !0, cg(b)) : a = !1, ch(b, c), Gi(b, d, e), Ii(b, d, e, c), jj(null, b, d, !0, a, c);
      case 19:
        return xj(a, b, c);
      case 22:
        return dj(a, b, c);
    }
    throw Error(p(156, b.tag));
  };
  function Fk(a, b) {
    return ac2(a, b);
  }
  function $k(a, b, c, d) {
    this.tag = a, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = b, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = d, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function Bg(a, b, c, d) {
    return new $k(a, b, c, d);
  }
  function aj(a) {
    return a = a.prototype, !(!a || !a.isReactComponent);
  }
  function Zk(a) {
    if (typeof a == "function") return aj(a) ? 1 : 0;
    if (a != null) {
      if (a = a.$$typeof, a === Da) return 11;
      if (a === Ga) return 14;
    }
    return 2;
  }
  function Pg(a, b) {
    var c = a.alternate;
    return c === null ? (c = Bg(a.tag, b, a.key, a.mode), c.elementType = a.elementType, c.type = a.type, c.stateNode = a.stateNode, c.alternate = a, a.alternate = c) : (c.pendingProps = b, c.type = a.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = a.flags & 14680064, c.childLanes = a.childLanes, c.lanes = a.lanes, c.child = a.child, c.memoizedProps = a.memoizedProps, c.memoizedState = a.memoizedState, c.updateQueue = a.updateQueue, b = a.dependencies, c.dependencies = b === null ? null : { lanes: b.lanes, firstContext: b.firstContext }, c.sibling = a.sibling, c.index = a.index, c.ref = a.ref, c;
  }
  function Rg(a, b, c, d, e, f2) {
    var g2 = 2;
    if (d = a, typeof a == "function") aj(a) && (g2 = 1);
    else if (typeof a == "string") g2 = 5;
    else a: switch (a) {
      case ya:
        return Tg(c.children, e, f2, b);
      case za:
        g2 = 8, e |= 8;
        break;
      case Aa:
        return a = Bg(12, c, b, e | 2), a.elementType = Aa, a.lanes = f2, a;
      case Ea:
        return a = Bg(13, c, b, e), a.elementType = Ea, a.lanes = f2, a;
      case Fa:
        return a = Bg(19, c, b, e), a.elementType = Fa, a.lanes = f2, a;
      case Ia:
        return pj(c, e, f2, b);
      default:
        if (typeof a == "object" && a !== null) switch (a.$$typeof) {
          case Ba:
            g2 = 10;
            break a;
          case Ca:
            g2 = 9;
            break a;
          case Da:
            g2 = 11;
            break a;
          case Ga:
            g2 = 14;
            break a;
          case Ha:
            g2 = 16, d = null;
            break a;
        }
        throw Error(p(130, a == null ? a : typeof a, ""));
    }
    return b = Bg(g2, c, b, e), b.elementType = a, b.type = d, b.lanes = f2, b;
  }
  function Tg(a, b, c, d) {
    return a = Bg(7, a, d, b), a.lanes = c, a;
  }
  function pj(a, b, c, d) {
    return a = Bg(22, a, d, b), a.elementType = Ia, a.lanes = c, a.stateNode = { isHidden: !1 }, a;
  }
  function Qg(a, b, c) {
    return a = Bg(6, a, null, b), a.lanes = c, a;
  }
  function Sg(a, b, c) {
    return b = Bg(4, a.children !== null ? a.children : [], a.key, b), b.lanes = c, b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation }, b;
  }
  function al(a, b, c, d, e) {
    this.tag = b, this.containerInfo = a, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = zc(0), this.expirationTimes = zc(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = zc(0), this.identifierPrefix = d, this.onRecoverableError = e, this.mutableSourceEagerHydrationData = null;
  }
  function bl(a, b, c, d, e, f2, g2, h2, k2) {
    return a = new al(a, b, c, h2, k2), b === 1 ? (b = 1, f2 === !0 && (b |= 8)) : b = 0, f2 = Bg(3, null, null, b), a.current = f2, f2.stateNode = a, f2.memoizedState = { element: d, isDehydrated: c, cache: null, transitions: null, pendingSuspenseBoundaries: null }, kh(f2), a;
  }
  function cl(a, b, c) {
    var d = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: wa, key: d == null ? null : "" + d, children: a, containerInfo: b, implementation: c };
  }
  function dl(a) {
    if (!a) return Vf;
    a = a._reactInternals;
    a: {
      if (Vb(a) !== a || a.tag !== 1) throw Error(p(170));
      var b = a;
      do {
        switch (b.tag) {
          case 3:
            b = b.stateNode.context;
            break a;
          case 1:
            if (Zf(b.type)) {
              b = b.stateNode.__reactInternalMemoizedMergedChildContext;
              break a;
            }
        }
        b = b.return;
      } while (b !== null);
      throw Error(p(171));
    }
    if (a.tag === 1) {
      var c = a.type;
      if (Zf(c)) return bg(a, c, b);
    }
    return b;
  }
  function el2(a, b, c, d, e, f2, g2, h2, k2) {
    return a = bl(c, d, !0, a, e, f2, g2, h2, k2), a.context = dl(null), c = a.current, d = R2(), e = yi(c), f2 = mh(d, e), f2.callback = b ?? null, nh(c, f2, e), a.current.lanes = e, Ac(a, e, d), Dk(a, d), a;
  }
  function fl(a, b, c, d) {
    var e = b.current, f2 = R2(), g2 = yi(e);
    return c = dl(c), b.context === null ? b.context = c : b.pendingContext = c, b = mh(f2, g2), b.payload = { element: a }, d = d === void 0 ? null : d, d !== null && (b.callback = d), a = nh(e, b, g2), a !== null && (gi(a, e, g2, f2), oh(a, e, g2)), g2;
  }
  function gl2(a) {
    if (a = a.current, !a.child) return null;
    switch (a.child.tag) {
      case 5:
        return a.child.stateNode;
      default:
        return a.child.stateNode;
    }
  }
  function hl(a, b) {
    if (a = a.memoizedState, a !== null && a.dehydrated !== null) {
      var c = a.retryLane;
      a.retryLane = c !== 0 && c < b ? c : b;
    }
  }
  function il(a, b) {
    hl(a, b), (a = a.alternate) && hl(a, b);
  }
  function jl() {
    return null;
  }
  var kl = typeof reportError == "function" ? reportError : function(a) {
    console.error(a);
  };
  function ll2(a) {
    this._internalRoot = a;
  }
  ml.prototype.render = ll2.prototype.render = function(a) {
    var b = this._internalRoot;
    if (b === null) throw Error(p(409));
    fl(a, b, null, null);
  }, ml.prototype.unmount = ll2.prototype.unmount = function() {
    var a = this._internalRoot;
    if (a !== null) {
      this._internalRoot = null;
      var b = a.containerInfo;
      Rk(function() {
        fl(null, a, null, null);
      }), b[uf] = null;
    }
  };
  function ml(a) {
    this._internalRoot = a;
  }
  ml.prototype.unstable_scheduleHydration = function(a) {
    if (a) {
      var b = Hc();
      a = { blockedOn: null, target: a, priority: b };
      for (var c = 0; c < Qc.length && b !== 0 && b < Qc[c].priority; c++) ;
      Qc.splice(c, 0, a), c === 0 && Vc(a);
    }
  };
  function nl(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11);
  }
  function ol(a) {
    return !(!a || a.nodeType !== 1 && a.nodeType !== 9 && a.nodeType !== 11 && (a.nodeType !== 8 || a.nodeValue !== " react-mount-point-unstable "));
  }
  function pl() {
  }
  function ql(a, b, c, d, e) {
    if (e) {
      if (typeof d == "function") {
        var f2 = d;
        d = function() {
          var a2 = gl2(g2);
          f2.call(a2);
        };
      }
      var g2 = el2(b, d, a, 0, null, !1, !1, "", pl);
      return a._reactRootContainer = g2, a[uf] = g2.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(), g2;
    }
    for (; e = a.lastChild; ) a.removeChild(e);
    if (typeof d == "function") {
      var h2 = d;
      d = function() {
        var a2 = gl2(k2);
        h2.call(a2);
      };
    }
    var k2 = bl(a, 0, !1, null, null, !1, !1, "", pl);
    return a._reactRootContainer = k2, a[uf] = k2.current, sf(a.nodeType === 8 ? a.parentNode : a), Rk(function() {
      fl(b, k2, c, d);
    }), k2;
  }
  function rl(a, b, c, d, e) {
    var f2 = c._reactRootContainer;
    if (f2) {
      var g2 = f2;
      if (typeof e == "function") {
        var h2 = e;
        e = function() {
          var a2 = gl2(g2);
          h2.call(a2);
        };
      }
      fl(b, g2, a, e);
    } else g2 = ql(c, b, a, e, d);
    return gl2(g2);
  }
  Ec = function(a) {
    switch (a.tag) {
      case 3:
        var b = a.stateNode;
        if (b.current.memoizedState.isDehydrated) {
          var c = tc(b.pendingLanes);
          c !== 0 && (Cc(b, c | 1), Dk(b, B2()), !(K2 & 6) && (Gj = B2() + 500, jg()));
        }
        break;
      case 13:
        Rk(function() {
          var b2 = ih(a, 1);
          if (b2 !== null) {
            var c2 = R2();
            gi(b2, a, 1, c2);
          }
        }), il(a, 1);
    }
  }, Fc = function(a) {
    if (a.tag === 13) {
      var b = ih(a, 134217728);
      if (b !== null) {
        var c = R2();
        gi(b, a, 134217728, c);
      }
      il(a, 134217728);
    }
  }, Gc = function(a) {
    if (a.tag === 13) {
      var b = yi(a), c = ih(a, b);
      if (c !== null) {
        var d = R2();
        gi(c, a, b, d);
      }
      il(a, b);
    }
  }, Hc = function() {
    return C2;
  }, Ic = function(a, b) {
    var c = C2;
    try {
      return C2 = a, b();
    } finally {
      C2 = c;
    }
  }, yb = function(a, b, c) {
    switch (b) {
      case "input":
        if (bb(a, c), b = c.name, c.type === "radio" && b != null) {
          for (c = a; c.parentNode; ) c = c.parentNode;
          for (c = c.querySelectorAll("input[name=" + JSON.stringify("" + b) + '][type="radio"]'), b = 0; b < c.length; b++) {
            var d = c[b];
            if (d !== a && d.form === a.form) {
              var e = Db(d);
              if (!e) throw Error(p(90));
              Wa(d), bb(d, e);
            }
          }
        }
        break;
      case "textarea":
        ib(a, c);
        break;
      case "select":
        b = c.value, b != null && fb(a, !!c.multiple, b, !1);
    }
  }, Gb = Qk, Hb = Rk;
  var sl = { usingClientEntryPoint: !1, Events: [Cb, ue2, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a) {
    return a = Zb(a), a === null ? null : a.stateNode;
  }, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!vl.isDisabled && vl.supportsFiber) try {
      kc = vl.inject(ul), lc = vl;
    } catch {
    }
  }
  return reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl, reactDom_production_min.createPortal = function(a, b) {
    var c = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!nl(b)) throw Error(p(200));
    return cl(a, b, null, c);
  }, reactDom_production_min.createRoot = function(a, b) {
    if (!nl(a)) throw Error(p(299));
    var c = !1, d = "", e = kl;
    return b != null && (b.unstable_strictMode === !0 && (c = !0), b.identifierPrefix !== void 0 && (d = b.identifierPrefix), b.onRecoverableError !== void 0 && (e = b.onRecoverableError)), b = bl(a, 1, !1, null, null, c, !1, d, e), a[uf] = b.current, sf(a.nodeType === 8 ? a.parentNode : a), new ll2(b);
  }, reactDom_production_min.findDOMNode = function(a) {
    if (a == null) return null;
    if (a.nodeType === 1) return a;
    var b = a._reactInternals;
    if (b === void 0)
      throw typeof a.render == "function" ? Error(p(188)) : (a = Object.keys(a).join(","), Error(p(268, a)));
    return a = Zb(b), a = a === null ? null : a.stateNode, a;
  }, reactDom_production_min.flushSync = function(a) {
    return Rk(a);
  }, reactDom_production_min.hydrate = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, !0, c);
  }, reactDom_production_min.hydrateRoot = function(a, b, c) {
    if (!nl(a)) throw Error(p(405));
    var d = c != null && c.hydratedSources || null, e = !1, f2 = "", g2 = kl;
    if (c != null && (c.unstable_strictMode === !0 && (e = !0), c.identifierPrefix !== void 0 && (f2 = c.identifierPrefix), c.onRecoverableError !== void 0 && (g2 = c.onRecoverableError)), b = el2(b, null, a, 1, c ?? null, e, !1, f2, g2), a[uf] = b.current, sf(a), d) for (a = 0; a < d.length; a++) c = d[a], e = c._getVersion, e = e(c._source), b.mutableSourceEagerHydrationData == null ? b.mutableSourceEagerHydrationData = [c, e] : b.mutableSourceEagerHydrationData.push(
      c,
      e
    );
    return new ml(b);
  }, reactDom_production_min.render = function(a, b, c) {
    if (!ol(b)) throw Error(p(200));
    return rl(null, a, b, !1, c);
  }, reactDom_production_min.unmountComponentAtNode = function(a) {
    if (!ol(a)) throw Error(p(40));
    return a._reactRootContainer ? (Rk(function() {
      rl(null, null, a, !1, function() {
        a._reactRootContainer = null, a[uf] = null;
      });
    }), !0) : !1;
  }, reactDom_production_min.unstable_batchedUpdates = Qk, reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a, b, c, d) {
    if (!ol(c)) throw Error(p(200));
    if (a == null || a._reactInternals === void 0) throw Error(p(38));
    return rl(a, b, c, !1, d);
  }, reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426", reactDom_production_min;
}
var reactDom_development = {};
/**
 * @license React
 * react-dom.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactDom_development;
function requireReactDom_development() {
  return hasRequiredReactDom_development || (hasRequiredReactDom_development = 1, process.env.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var React2 = React__default, Scheduler2 = requireScheduler(), ReactSharedInternals = React2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, suppressWarning = !1;
    function setSuppressWarning(newSuppressWarning) {
      suppressWarning = newSuppressWarning;
    }
    function warn(format) {
      if (!suppressWarning) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++)
          args[_key - 1] = arguments[_key];
        printWarning("warn", format, args);
      }
    }
    function error(format) {
      if (!suppressWarning) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++)
          args[_key2 - 1] = arguments[_key2];
        printWarning("error", format, args);
      }
    }
    function printWarning(level, format, args) {
      {
        var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame, stack = ReactDebugCurrentFrame2.getStackAddendum();
        stack !== "" && (format += "%s", args = args.concat([stack]));
        var argsWithFormat = args.map(function(item) {
          return String(item);
        });
        argsWithFormat.unshift("Warning: " + format), Function.prototype.apply.call(console[level], console, argsWithFormat);
      }
    }
    var FunctionComponent = 0, ClassComponent = 1, IndeterminateComponent = 2, HostRoot = 3, HostPortal = 4, HostComponent = 5, HostText = 6, Fragment2 = 7, Mode = 8, ContextConsumer = 9, ContextProvider = 10, ForwardRef = 11, Profiler = 12, SuspenseComponent = 13, MemoComponent = 14, SimpleMemoComponent = 15, LazyComponent = 16, IncompleteClassComponent = 17, DehydratedFragment = 18, SuspenseListComponent = 19, ScopeComponent = 21, OffscreenComponent = 22, LegacyHiddenComponent = 23, CacheComponent = 24, TracingMarkerComponent = 25, enableClientRenderFallbackOnTextMismatch = !0, enableNewReconciler = !1, enableLazyContextPropagation = !1, enableLegacyHidden = !1, enableSuspenseAvoidThisFallback = !1, disableCommentsAsDOMContainers = !0, enableCustomElementPropertySupport = !1, warnAboutStringRefs = !0, enableSchedulingProfiler = !0, enableProfilerTimer = !0, enableProfilerCommitHooks = !0, allNativeEvents = /* @__PURE__ */ new Set(), registrationNameDependencies = {}, possibleRegistrationNames = {};
    function registerTwoPhaseEvent(registrationName, dependencies) {
      registerDirectEvent(registrationName, dependencies), registerDirectEvent(registrationName + "Capture", dependencies);
    }
    function registerDirectEvent(registrationName, dependencies) {
      registrationNameDependencies[registrationName] && error("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", registrationName), registrationNameDependencies[registrationName] = dependencies;
      {
        var lowerCasedName = registrationName.toLowerCase();
        possibleRegistrationNames[lowerCasedName] = registrationName, registrationName === "onDoubleClick" && (possibleRegistrationNames.ondblclick = registrationName);
      }
      for (var i = 0; i < dependencies.length; i++)
        allNativeEvents.add(dependencies[i]);
    }
    var canUseDOM = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function typeName(value) {
      {
        var hasToStringTag = typeof Symbol == "function" && Symbol.toStringTag, type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
        return type;
      }
    }
    function willCoercionThrow(value) {
      try {
        return testStringCoercion(value), !1;
      } catch {
        return !0;
      }
    }
    function testStringCoercion(value) {
      return "" + value;
    }
    function checkAttributeStringCoercion(value, attributeName) {
      if (willCoercionThrow(value))
        return error("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", attributeName, typeName(value)), testStringCoercion(value);
    }
    function checkKeyStringCoercion(value) {
      if (willCoercionThrow(value))
        return error("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
    }
    function checkPropStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return error("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkCSSPropertyStringCoercion(value, propName) {
      if (willCoercionThrow(value))
        return error("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", propName, typeName(value)), testStringCoercion(value);
    }
    function checkHtmlStringCoercion(value) {
      if (willCoercionThrow(value))
        return error("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
    }
    function checkFormFieldValueStringCoercion(value) {
      if (willCoercionThrow(value))
        return error("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", typeName(value)), testStringCoercion(value);
    }
    var RESERVED = 0, STRING = 1, BOOLEANISH_STRING = 2, BOOLEAN = 3, OVERLOADED_BOOLEAN = 4, NUMERIC = 5, POSITIVE_NUMERIC = 6, ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$"), illegalAttributeNameCache = {}, validatedAttributeNameCache = {};
    function isAttributeNameSafe(attributeName) {
      return hasOwnProperty2.call(validatedAttributeNameCache, attributeName) ? !0 : hasOwnProperty2.call(illegalAttributeNameCache, attributeName) ? !1 : VALID_ATTRIBUTE_NAME_REGEX.test(attributeName) ? (validatedAttributeNameCache[attributeName] = !0, !0) : (illegalAttributeNameCache[attributeName] = !0, error("Invalid attribute name: `%s`", attributeName), !1);
    }
    function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
      return propertyInfo !== null ? propertyInfo.type === RESERVED : isCustomComponentTag ? !1 : name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N");
    }
    function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
      if (propertyInfo !== null && propertyInfo.type === RESERVED)
        return !1;
      switch (typeof value) {
        case "function":
        case "symbol":
          return !0;
        case "boolean": {
          if (isCustomComponentTag)
            return !1;
          if (propertyInfo !== null)
            return !propertyInfo.acceptsBooleans;
          var prefix3 = name2.toLowerCase().slice(0, 5);
          return prefix3 !== "data-" && prefix3 !== "aria-";
        }
        default:
          return !1;
      }
    }
    function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
      if (value === null || typeof value > "u" || shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag))
        return !0;
      if (isCustomComponentTag)
        return !1;
      if (propertyInfo !== null)
        switch (propertyInfo.type) {
          case BOOLEAN:
            return !value;
          case OVERLOADED_BOOLEAN:
            return value === !1;
          case NUMERIC:
            return isNaN(value);
          case POSITIVE_NUMERIC:
            return isNaN(value) || value < 1;
        }
      return !1;
    }
    function getPropertyInfo(name2) {
      return properties.hasOwnProperty(name2) ? properties[name2] : null;
    }
    function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
      this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN, this.attributeName = attributeName, this.attributeNamespace = attributeNamespace, this.mustUseProperty = mustUseProperty, this.propertyName = name2, this.type = type, this.sanitizeURL = sanitizeURL2, this.removeEmptyString = removeEmptyString;
    }
    var properties = {}, reservedProps = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    reservedProps.forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        RESERVED,
        !1,
        // mustUseProperty
        name2,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
      var name2 = _ref[0], attributeName = _ref[1];
      properties[name2] = new PropertyInfoRecord(
        name2,
        STRING,
        !1,
        // mustUseProperty
        attributeName,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        BOOLEANISH_STRING,
        !1,
        // mustUseProperty
        name2.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        BOOLEANISH_STRING,
        !1,
        // mustUseProperty
        name2,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        BOOLEAN,
        !1,
        // mustUseProperty
        name2.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        BOOLEAN,
        !0,
        // mustUseProperty
        name2,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        OVERLOADED_BOOLEAN,
        !1,
        // mustUseProperty
        name2,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        POSITIVE_NUMERIC,
        !1,
        // mustUseProperty
        name2,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(name2) {
      properties[name2] = new PropertyInfoRecord(
        name2,
        NUMERIC,
        !1,
        // mustUseProperty
        name2.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var CAMELIZE = /[\-\:]([a-z])/g, capitalize = function(token2) {
      return token2[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name2 = attributeName.replace(CAMELIZE, capitalize);
      properties[name2] = new PropertyInfoRecord(
        name2,
        STRING,
        !1,
        // mustUseProperty
        attributeName,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name2 = attributeName.replace(CAMELIZE, capitalize);
      properties[name2] = new PropertyInfoRecord(
        name2,
        STRING,
        !1,
        // mustUseProperty
        attributeName,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(attributeName) {
      var name2 = attributeName.replace(CAMELIZE, capitalize);
      properties[name2] = new PropertyInfoRecord(
        name2,
        STRING,
        !1,
        // mustUseProperty
        attributeName,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
      properties[attributeName] = new PropertyInfoRecord(
        attributeName,
        STRING,
        !1,
        // mustUseProperty
        attributeName.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var xlinkHref = "xlinkHref";
    properties[xlinkHref] = new PropertyInfoRecord(
      "xlinkHref",
      STRING,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(attributeName) {
      properties[attributeName] = new PropertyInfoRecord(
        attributeName,
        STRING,
        !1,
        // mustUseProperty
        attributeName.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, didWarn = !1;
    function sanitizeURL(url) {
      !didWarn && isJavaScriptProtocol.test(url) && (didWarn = !0, error("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url)));
    }
    function getValueForProperty(node2, name2, expected, propertyInfo) {
      if (propertyInfo.mustUseProperty) {
        var propertyName = propertyInfo.propertyName;
        return node2[propertyName];
      } else {
        checkAttributeStringCoercion(expected, name2), propertyInfo.sanitizeURL && sanitizeURL("" + expected);
        var attributeName = propertyInfo.attributeName, stringValue = null;
        if (propertyInfo.type === OVERLOADED_BOOLEAN) {
          if (node2.hasAttribute(attributeName)) {
            var value = node2.getAttribute(attributeName);
            return value === "" ? !0 : shouldRemoveAttribute(name2, expected, propertyInfo, !1) ? value : value === "" + expected ? expected : value;
          }
        } else if (node2.hasAttribute(attributeName)) {
          if (shouldRemoveAttribute(name2, expected, propertyInfo, !1))
            return node2.getAttribute(attributeName);
          if (propertyInfo.type === BOOLEAN)
            return expected;
          stringValue = node2.getAttribute(attributeName);
        }
        return shouldRemoveAttribute(name2, expected, propertyInfo, !1) ? stringValue === null ? expected : stringValue : stringValue === "" + expected ? expected : stringValue;
      }
    }
    function getValueForAttribute(node2, name2, expected, isCustomComponentTag) {
      {
        if (!isAttributeNameSafe(name2))
          return;
        if (!node2.hasAttribute(name2))
          return expected === void 0 ? void 0 : null;
        var value = node2.getAttribute(name2);
        return checkAttributeStringCoercion(expected, name2), value === "" + expected ? expected : value;
      }
    }
    function setValueForProperty(node2, name2, value, isCustomComponentTag) {
      var propertyInfo = getPropertyInfo(name2);
      if (!shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag)) {
        if (shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) && (value = null), isCustomComponentTag || propertyInfo === null) {
          if (isAttributeNameSafe(name2)) {
            var _attributeName = name2;
            value === null ? node2.removeAttribute(_attributeName) : (checkAttributeStringCoercion(value, name2), node2.setAttribute(_attributeName, "" + value));
          }
          return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          if (value === null) {
            var type = propertyInfo.type;
            node2[propertyName] = type === BOOLEAN ? !1 : "";
          } else
            node2[propertyName] = value;
          return;
        }
        var attributeName = propertyInfo.attributeName, attributeNamespace = propertyInfo.attributeNamespace;
        if (value === null)
          node2.removeAttribute(attributeName);
        else {
          var _type = propertyInfo.type, attributeValue;
          _type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === !0 ? attributeValue = "" : (checkAttributeStringCoercion(value, attributeName), attributeValue = "" + value, propertyInfo.sanitizeURL && sanitizeURL(attributeValue.toString())), attributeNamespace ? node2.setAttributeNS(attributeNamespace, attributeName, attributeValue) : node2.setAttribute(attributeName, attributeValue);
        }
      }
    }
    var REACT_ELEMENT_TYPE = Symbol.for("react.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler"), REACT_PROVIDER_TYPE = Symbol.for("react.provider"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_SCOPE_TYPE = Symbol.for("react.scope"), REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode"), REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen"), REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden"), REACT_CACHE_TYPE = Symbol.for("react.cache"), REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker"), MAYBE_ITERATOR_SYMBOL = Symbol.iterator, FAUX_ITERATOR_SYMBOL = "@@iterator";
    function getIteratorFn(maybeIterable) {
      if (maybeIterable === null || typeof maybeIterable != "object")
        return null;
      var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
      return typeof maybeIterator == "function" ? maybeIterator : null;
    }
    var assign2 = Object.assign, disabledDepth = 0, prevLog, prevInfo, prevWarn, prevError, prevGroup, prevGroupCollapsed, prevGroupEnd;
    function disabledLog() {
    }
    disabledLog.__reactDisabledLog = !0;
    function disableLogs() {
      {
        if (disabledDepth === 0) {
          prevLog = console.log, prevInfo = console.info, prevWarn = console.warn, prevError = console.error, prevGroup = console.group, prevGroupCollapsed = console.groupCollapsed, prevGroupEnd = console.groupEnd;
          var props = {
            configurable: !0,
            enumerable: !0,
            value: disabledLog,
            writable: !0
          };
          Object.defineProperties(console, {
            info: props,
            log: props,
            warn: props,
            error: props,
            group: props,
            groupCollapsed: props,
            groupEnd: props
          });
        }
        disabledDepth++;
      }
    }
    function reenableLogs() {
      {
        if (disabledDepth--, disabledDepth === 0) {
          var props = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: assign2({}, props, {
              value: prevLog
            }),
            info: assign2({}, props, {
              value: prevInfo
            }),
            warn: assign2({}, props, {
              value: prevWarn
            }),
            error: assign2({}, props, {
              value: prevError
            }),
            group: assign2({}, props, {
              value: prevGroup
            }),
            groupCollapsed: assign2({}, props, {
              value: prevGroupCollapsed
            }),
            groupEnd: assign2({}, props, {
              value: prevGroupEnd
            })
          });
        }
        disabledDepth < 0 && error("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher, prefix2;
    function describeBuiltInComponentFrame(name2, source, ownerFn) {
      {
        if (prefix2 === void 0)
          try {
            throw Error();
          } catch (x2) {
            var match2 = x2.stack.trim().match(/\n( *(at )?)/);
            prefix2 = match2 && match2[1] || "";
          }
        return `
` + prefix2 + name2;
      }
    }
    var reentry = !1, componentFrameCache;
    {
      var PossiblyWeakMap = typeof WeakMap == "function" ? WeakMap : Map;
      componentFrameCache = new PossiblyWeakMap();
    }
    function describeNativeComponentFrame(fn, construct) {
      if (!fn || reentry)
        return "";
      {
        var frame2 = componentFrameCache.get(fn);
        if (frame2 !== void 0)
          return frame2;
      }
      var control;
      reentry = !0;
      var previousPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var previousDispatcher;
      previousDispatcher = ReactCurrentDispatcher.current, ReactCurrentDispatcher.current = null, disableLogs();
      try {
        if (construct) {
          var Fake = function() {
            throw Error();
          };
          if (Object.defineProperty(Fake.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Fake, []);
            } catch (x2) {
              control = x2;
            }
            Reflect.construct(fn, [], Fake);
          } else {
            try {
              Fake.call();
            } catch (x2) {
              control = x2;
            }
            fn.call(Fake.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (x2) {
            control = x2;
          }
          fn();
        }
      } catch (sample) {
        if (sample && control && typeof sample.stack == "string") {
          for (var sampleLines = sample.stack.split(`
`), controlLines = control.stack.split(`
`), s = sampleLines.length - 1, c = controlLines.length - 1; s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]; )
            c--;
          for (; s >= 1 && c >= 0; s--, c--)
            if (sampleLines[s] !== controlLines[c]) {
              if (s !== 1 || c !== 1)
                do
                  if (s--, c--, c < 0 || sampleLines[s] !== controlLines[c]) {
                    var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                    return fn.displayName && _frame.includes("<anonymous>") && (_frame = _frame.replace("<anonymous>", fn.displayName)), typeof fn == "function" && componentFrameCache.set(fn, _frame), _frame;
                  }
                while (s >= 1 && c >= 0);
              break;
            }
        }
      } finally {
        reentry = !1, ReactCurrentDispatcher.current = previousDispatcher, reenableLogs(), Error.prepareStackTrace = previousPrepareStackTrace;
      }
      var name2 = fn ? fn.displayName || fn.name : "", syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
      return typeof fn == "function" && componentFrameCache.set(fn, syntheticFrame), syntheticFrame;
    }
    function describeClassComponentFrame(ctor, source, ownerFn) {
      return describeNativeComponentFrame(ctor, !0);
    }
    function describeFunctionComponentFrame(fn, source, ownerFn) {
      return describeNativeComponentFrame(fn, !1);
    }
    function shouldConstruct(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
      if (type == null)
        return "";
      if (typeof type == "function")
        return describeNativeComponentFrame(type, shouldConstruct(type));
      if (typeof type == "string")
        return describeBuiltInComponentFrame(type);
      switch (type) {
        case REACT_SUSPENSE_TYPE:
          return describeBuiltInComponentFrame("Suspense");
        case REACT_SUSPENSE_LIST_TYPE:
          return describeBuiltInComponentFrame("SuspenseList");
      }
      if (typeof type == "object")
        switch (type.$$typeof) {
          case REACT_FORWARD_REF_TYPE:
            return describeFunctionComponentFrame(type.render);
          case REACT_MEMO_TYPE:
            return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
          case REACT_LAZY_TYPE: {
            var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
            try {
              return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
            } catch {
            }
          }
        }
      return "";
    }
    function describeFiber(fiber) {
      switch (fiber.tag) {
        case HostComponent:
          return describeBuiltInComponentFrame(fiber.type);
        case LazyComponent:
          return describeBuiltInComponentFrame("Lazy");
        case SuspenseComponent:
          return describeBuiltInComponentFrame("Suspense");
        case SuspenseListComponent:
          return describeBuiltInComponentFrame("SuspenseList");
        case FunctionComponent:
        case IndeterminateComponent:
        case SimpleMemoComponent:
          return describeFunctionComponentFrame(fiber.type);
        case ForwardRef:
          return describeFunctionComponentFrame(fiber.type.render);
        case ClassComponent:
          return describeClassComponentFrame(fiber.type);
        default:
          return "";
      }
    }
    function getStackByFiberInDevAndProd(workInProgress2) {
      try {
        var info2 = "", node2 = workInProgress2;
        do
          info2 += describeFiber(node2), node2 = node2.return;
        while (node2);
        return info2;
      } catch (x2) {
        return `
Error generating stack: ` + x2.message + `
` + x2.stack;
      }
    }
    function getWrappedName(outerType, innerType, wrapperName) {
      var displayName = outerType.displayName;
      if (displayName)
        return displayName;
      var functionName = innerType.displayName || innerType.name || "";
      return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
    }
    function getContextName(type) {
      return type.displayName || "Context";
    }
    function getComponentNameFromType(type) {
      if (type == null)
        return null;
      if (typeof type.tag == "number" && error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof type == "function")
        return type.displayName || type.name || null;
      if (typeof type == "string")
        return type;
      switch (type) {
        case REACT_FRAGMENT_TYPE:
          return "Fragment";
        case REACT_PORTAL_TYPE:
          return "Portal";
        case REACT_PROFILER_TYPE:
          return "Profiler";
        case REACT_STRICT_MODE_TYPE:
          return "StrictMode";
        case REACT_SUSPENSE_TYPE:
          return "Suspense";
        case REACT_SUSPENSE_LIST_TYPE:
          return "SuspenseList";
      }
      if (typeof type == "object")
        switch (type.$$typeof) {
          case REACT_CONTEXT_TYPE:
            var context = type;
            return getContextName(context) + ".Consumer";
          case REACT_PROVIDER_TYPE:
            var provider = type;
            return getContextName(provider._context) + ".Provider";
          case REACT_FORWARD_REF_TYPE:
            return getWrappedName(type, type.render, "ForwardRef");
          case REACT_MEMO_TYPE:
            var outerName = type.displayName || null;
            return outerName !== null ? outerName : getComponentNameFromType(type.type) || "Memo";
          case REACT_LAZY_TYPE: {
            var lazyComponent = type, payload = lazyComponent._payload, init = lazyComponent._init;
            try {
              return getComponentNameFromType(init(payload));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function getWrappedName$1(outerType, innerType, wrapperName) {
      var functionName = innerType.displayName || innerType.name || "";
      return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
    }
    function getContextName$1(type) {
      return type.displayName || "Context";
    }
    function getComponentNameFromFiber(fiber) {
      var tag = fiber.tag, type = fiber.type;
      switch (tag) {
        case CacheComponent:
          return "Cache";
        case ContextConsumer:
          var context = type;
          return getContextName$1(context) + ".Consumer";
        case ContextProvider:
          var provider = type;
          return getContextName$1(provider._context) + ".Provider";
        case DehydratedFragment:
          return "DehydratedFragment";
        case ForwardRef:
          return getWrappedName$1(type, type.render, "ForwardRef");
        case Fragment2:
          return "Fragment";
        case HostComponent:
          return type;
        case HostPortal:
          return "Portal";
        case HostRoot:
          return "Root";
        case HostText:
          return "Text";
        case LazyComponent:
          return getComponentNameFromType(type);
        case Mode:
          return type === REACT_STRICT_MODE_TYPE ? "StrictMode" : "Mode";
        case OffscreenComponent:
          return "Offscreen";
        case Profiler:
          return "Profiler";
        case ScopeComponent:
          return "Scope";
        case SuspenseComponent:
          return "Suspense";
        case SuspenseListComponent:
          return "SuspenseList";
        case TracingMarkerComponent:
          return "TracingMarker";
        case ClassComponent:
        case FunctionComponent:
        case IncompleteClassComponent:
        case IndeterminateComponent:
        case MemoComponent:
        case SimpleMemoComponent:
          if (typeof type == "function")
            return type.displayName || type.name || null;
          if (typeof type == "string")
            return type;
          break;
      }
      return null;
    }
    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame, current = null, isRendering = !1;
    function getCurrentFiberOwnerNameInDevOrNull() {
      {
        if (current === null)
          return null;
        var owner = current._debugOwner;
        if (owner !== null && typeof owner < "u")
          return getComponentNameFromFiber(owner);
      }
      return null;
    }
    function getCurrentFiberStackInDev() {
      return current === null ? "" : getStackByFiberInDevAndProd(current);
    }
    function resetCurrentFiber() {
      ReactDebugCurrentFrame.getCurrentStack = null, current = null, isRendering = !1;
    }
    function setCurrentFiber(fiber) {
      ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev, current = fiber, isRendering = !1;
    }
    function getCurrentFiber() {
      return current;
    }
    function setIsRendering(rendering) {
      isRendering = rendering;
    }
    function toString(value) {
      return "" + value;
    }
    function getToStringValue(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return value;
        case "object":
          return checkFormFieldValueStringCoercion(value), value;
        default:
          return "";
      }
    }
    var hasReadOnlyValue = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function checkControlledValueProps(tagName, props) {
      hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null || error("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), props.onChange || props.readOnly || props.disabled || props.checked == null || error("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function isCheckable(elem) {
      var type = elem.type, nodeName = elem.nodeName;
      return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
    }
    function getTracker(node2) {
      return node2._valueTracker;
    }
    function detachTracker(node2) {
      node2._valueTracker = null;
    }
    function getValueFromNode(node2) {
      var value = "";
      return node2 && (isCheckable(node2) ? value = node2.checked ? "true" : "false" : value = node2.value), value;
    }
    function trackValueOnNode(node2) {
      var valueField = isCheckable(node2) ? "checked" : "value", descriptor = Object.getOwnPropertyDescriptor(node2.constructor.prototype, valueField);
      checkFormFieldValueStringCoercion(node2[valueField]);
      var currentValue = "" + node2[valueField];
      if (!(node2.hasOwnProperty(valueField) || typeof descriptor > "u" || typeof descriptor.get != "function" || typeof descriptor.set != "function")) {
        var get2 = descriptor.get, set2 = descriptor.set;
        Object.defineProperty(node2, valueField, {
          configurable: !0,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            checkFormFieldValueStringCoercion(value), currentValue = "" + value, set2.call(this, value);
          }
        }), Object.defineProperty(node2, valueField, {
          enumerable: descriptor.enumerable
        });
        var tracker = {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            checkFormFieldValueStringCoercion(value), currentValue = "" + value;
          },
          stopTracking: function() {
            detachTracker(node2), delete node2[valueField];
          }
        };
        return tracker;
      }
    }
    function track(node2) {
      getTracker(node2) || (node2._valueTracker = trackValueOnNode(node2));
    }
    function updateValueIfChanged(node2) {
      if (!node2)
        return !1;
      var tracker = getTracker(node2);
      if (!tracker)
        return !0;
      var lastValue = tracker.getValue(), nextValue = getValueFromNode(node2);
      return nextValue !== lastValue ? (tracker.setValue(nextValue), !0) : !1;
    }
    function getActiveElement(doc) {
      if (doc = doc || (typeof document < "u" ? document : void 0), typeof doc > "u")
        return null;
      try {
        return doc.activeElement || doc.body;
      } catch {
        return doc.body;
      }
    }
    var didWarnValueDefaultValue = !1, didWarnCheckedDefaultChecked = !1, didWarnControlledToUncontrolled = !1, didWarnUncontrolledToControlled = !1;
    function isControlled(props) {
      var usesChecked = props.type === "checkbox" || props.type === "radio";
      return usesChecked ? props.checked != null : props.value != null;
    }
    function getHostProps(element, props) {
      var node2 = element, checked = props.checked, hostProps = assign2({}, props, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: checked ?? node2._wrapperState.initialChecked
      });
      return hostProps;
    }
    function initWrapperState(element, props) {
      checkControlledValueProps("input", props), props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnCheckedDefaultChecked && (error("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnCheckedDefaultChecked = !0), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue && (error("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type), didWarnValueDefaultValue = !0);
      var node2 = element, defaultValue = props.defaultValue == null ? "" : props.defaultValue;
      node2._wrapperState = {
        initialChecked: props.checked != null ? props.checked : props.defaultChecked,
        initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
        controlled: isControlled(props)
      };
    }
    function updateChecked(element, props) {
      var node2 = element, checked = props.checked;
      checked != null && setValueForProperty(node2, "checked", checked, !1);
    }
    function updateWrapper(element, props) {
      var node2 = element;
      {
        var controlled = isControlled(props);
        !node2._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled && (error("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), didWarnUncontrolledToControlled = !0), node2._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled && (error("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), didWarnControlledToUncontrolled = !0);
      }
      updateChecked(element, props);
      var value = getToStringValue(props.value), type = props.type;
      if (value != null)
        type === "number" ? (value === 0 && node2.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        node2.value != value) && (node2.value = toString(value)) : node2.value !== toString(value) && (node2.value = toString(value));
      else if (type === "submit" || type === "reset") {
        node2.removeAttribute("value");
        return;
      }
      props.hasOwnProperty("value") ? setDefaultValue(node2, props.type, value) : props.hasOwnProperty("defaultValue") && setDefaultValue(node2, props.type, getToStringValue(props.defaultValue)), props.checked == null && props.defaultChecked != null && (node2.defaultChecked = !!props.defaultChecked);
    }
    function postMountWrapper(element, props, isHydrating2) {
      var node2 = element;
      if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
        var type = props.type, isButton = type === "submit" || type === "reset";
        if (isButton && (props.value === void 0 || props.value === null))
          return;
        var initialValue = toString(node2._wrapperState.initialValue);
        isHydrating2 || initialValue !== node2.value && (node2.value = initialValue), node2.defaultValue = initialValue;
      }
      var name2 = node2.name;
      name2 !== "" && (node2.name = ""), node2.defaultChecked = !node2.defaultChecked, node2.defaultChecked = !!node2._wrapperState.initialChecked, name2 !== "" && (node2.name = name2);
    }
    function restoreControlledState(element, props) {
      var node2 = element;
      updateWrapper(node2, props), updateNamedCousins(node2, props);
    }
    function updateNamedCousins(rootNode, props) {
      var name2 = props.name;
      if (props.type === "radio" && name2 != null) {
        for (var queryRoot = rootNode; queryRoot.parentNode; )
          queryRoot = queryRoot.parentNode;
        checkAttributeStringCoercion(name2, "name");
        for (var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name2) + '][type="radio"]'), i = 0; i < group.length; i++) {
          var otherNode = group[i];
          if (!(otherNode === rootNode || otherNode.form !== rootNode.form)) {
            var otherProps = getFiberCurrentPropsFromNode(otherNode);
            if (!otherProps)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            updateValueIfChanged(otherNode), updateWrapper(otherNode, otherProps);
          }
        }
      }
    }
    function setDefaultValue(node2, type, value) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (type !== "number" || getActiveElement(node2.ownerDocument) !== node2) && (value == null ? node2.defaultValue = toString(node2._wrapperState.initialValue) : node2.defaultValue !== toString(value) && (node2.defaultValue = toString(value)));
    }
    var didWarnSelectedSetOnOption = !1, didWarnInvalidChild = !1, didWarnInvalidInnerHTML = !1;
    function validateProps(element, props) {
      props.value == null && (typeof props.children == "object" && props.children !== null ? React2.Children.forEach(props.children, function(child) {
        child != null && (typeof child == "string" || typeof child == "number" || didWarnInvalidChild || (didWarnInvalidChild = !0, error("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : props.dangerouslySetInnerHTML != null && (didWarnInvalidInnerHTML || (didWarnInvalidInnerHTML = !0, error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), props.selected != null && !didWarnSelectedSetOnOption && (error("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), didWarnSelectedSetOnOption = !0);
    }
    function postMountWrapper$1(element, props) {
      props.value != null && element.setAttribute("value", toString(getToStringValue(props.value)));
    }
    var isArrayImpl = Array.isArray;
    function isArray(a) {
      return isArrayImpl(a);
    }
    var didWarnValueDefaultValue$1;
    didWarnValueDefaultValue$1 = !1;
    function getDeclarationErrorAddendum() {
      var ownerName = getCurrentFiberOwnerNameInDevOrNull();
      return ownerName ? `

Check the render method of \`` + ownerName + "`." : "";
    }
    var valuePropNames = ["value", "defaultValue"];
    function checkSelectPropTypes(props) {
      {
        checkControlledValueProps("select", props);
        for (var i = 0; i < valuePropNames.length; i++) {
          var propName = valuePropNames[i];
          if (props[propName] != null) {
            var propNameIsArray = isArray(props[propName]);
            props.multiple && !propNameIsArray ? error("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", propName, getDeclarationErrorAddendum()) : !props.multiple && propNameIsArray && error("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
          }
        }
      }
    }
    function updateOptions(node2, multiple, propValue, setDefaultSelected) {
      var options2 = node2.options;
      if (multiple) {
        for (var selectedValues = propValue, selectedValue = {}, i = 0; i < selectedValues.length; i++)
          selectedValue["$" + selectedValues[i]] = !0;
        for (var _i = 0; _i < options2.length; _i++) {
          var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
          options2[_i].selected !== selected && (options2[_i].selected = selected), selected && setDefaultSelected && (options2[_i].defaultSelected = !0);
        }
      } else {
        for (var _selectedValue = toString(getToStringValue(propValue)), defaultSelected = null, _i2 = 0; _i2 < options2.length; _i2++) {
          if (options2[_i2].value === _selectedValue) {
            options2[_i2].selected = !0, setDefaultSelected && (options2[_i2].defaultSelected = !0);
            return;
          }
          defaultSelected === null && !options2[_i2].disabled && (defaultSelected = options2[_i2]);
        }
        defaultSelected !== null && (defaultSelected.selected = !0);
      }
    }
    function getHostProps$1(element, props) {
      return assign2({}, props, {
        value: void 0
      });
    }
    function initWrapperState$1(element, props) {
      var node2 = element;
      checkSelectPropTypes(props), node2._wrapperState = {
        wasMultiple: !!props.multiple
      }, props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValueDefaultValue$1 && (error("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), didWarnValueDefaultValue$1 = !0);
    }
    function postMountWrapper$2(element, props) {
      var node2 = element;
      node2.multiple = !!props.multiple;
      var value = props.value;
      value != null ? updateOptions(node2, !!props.multiple, value, !1) : props.defaultValue != null && updateOptions(node2, !!props.multiple, props.defaultValue, !0);
    }
    function postUpdateWrapper(element, props) {
      var node2 = element, wasMultiple = node2._wrapperState.wasMultiple;
      node2._wrapperState.wasMultiple = !!props.multiple;
      var value = props.value;
      value != null ? updateOptions(node2, !!props.multiple, value, !1) : wasMultiple !== !!props.multiple && (props.defaultValue != null ? updateOptions(node2, !!props.multiple, props.defaultValue, !0) : updateOptions(node2, !!props.multiple, props.multiple ? [] : "", !1));
    }
    function restoreControlledState$1(element, props) {
      var node2 = element, value = props.value;
      value != null && updateOptions(node2, !!props.multiple, value, !1);
    }
    var didWarnValDefaultVal = !1;
    function getHostProps$2(element, props) {
      var node2 = element;
      if (props.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var hostProps = assign2({}, props, {
        value: void 0,
        defaultValue: void 0,
        children: toString(node2._wrapperState.initialValue)
      });
      return hostProps;
    }
    function initWrapperState$2(element, props) {
      var node2 = element;
      checkControlledValueProps("textarea", props), props.value !== void 0 && props.defaultValue !== void 0 && !didWarnValDefaultVal && (error("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component"), didWarnValDefaultVal = !0);
      var initialValue = props.value;
      if (initialValue == null) {
        var children = props.children, defaultValue = props.defaultValue;
        if (children != null) {
          error("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (defaultValue != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (isArray(children)) {
              if (children.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              children = children[0];
            }
            defaultValue = children;
          }
        }
        defaultValue == null && (defaultValue = ""), initialValue = defaultValue;
      }
      node2._wrapperState = {
        initialValue: getToStringValue(initialValue)
      };
    }
    function updateWrapper$1(element, props) {
      var node2 = element, value = getToStringValue(props.value), defaultValue = getToStringValue(props.defaultValue);
      if (value != null) {
        var newValue = toString(value);
        newValue !== node2.value && (node2.value = newValue), props.defaultValue == null && node2.defaultValue !== newValue && (node2.defaultValue = newValue);
      }
      defaultValue != null && (node2.defaultValue = toString(defaultValue));
    }
    function postMountWrapper$3(element, props) {
      var node2 = element, textContent = node2.textContent;
      textContent === node2._wrapperState.initialValue && textContent !== "" && textContent !== null && (node2.value = textContent);
    }
    function restoreControlledState$2(element, props) {
      updateWrapper$1(element, props);
    }
    var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml", MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML", SVG_NAMESPACE = "http://www.w3.org/2000/svg";
    function getIntrinsicNamespace(type) {
      switch (type) {
        case "svg":
          return SVG_NAMESPACE;
        case "math":
          return MATH_NAMESPACE;
        default:
          return HTML_NAMESPACE;
      }
    }
    function getChildNamespace(parentNamespace, type) {
      return parentNamespace == null || parentNamespace === HTML_NAMESPACE ? getIntrinsicNamespace(type) : parentNamespace === SVG_NAMESPACE && type === "foreignObject" ? HTML_NAMESPACE : parentNamespace;
    }
    var createMicrosoftUnsafeLocalFunction = function(func) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(arg0, arg1, arg2, arg3) {
        MSApp.execUnsafeLocalFunction(function() {
          return func(arg0, arg1, arg2, arg3);
        });
      } : func;
    }, reusableSVGContainer, setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node2, html2) {
      if (node2.namespaceURI === SVG_NAMESPACE && !("innerHTML" in node2)) {
        reusableSVGContainer = reusableSVGContainer || document.createElement("div"), reusableSVGContainer.innerHTML = "<svg>" + html2.valueOf().toString() + "</svg>";
        for (var svgNode = reusableSVGContainer.firstChild; node2.firstChild; )
          node2.removeChild(node2.firstChild);
        for (; svgNode.firstChild; )
          node2.appendChild(svgNode.firstChild);
        return;
      }
      node2.innerHTML = html2;
    }), ELEMENT_NODE = 1, TEXT_NODE = 3, COMMENT_NODE = 8, DOCUMENT_NODE = 9, DOCUMENT_FRAGMENT_NODE = 11, setTextContent = function(node2, text) {
      if (text) {
        var firstChild = node2.firstChild;
        if (firstChild && firstChild === node2.lastChild && firstChild.nodeType === TEXT_NODE) {
          firstChild.nodeValue = text;
          return;
        }
      }
      node2.textContent = text;
    }, shorthandToLonghand = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, isUnitlessNumber = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function prefixKey(prefix3, key2) {
      return prefix3 + key2.charAt(0).toUpperCase() + key2.substring(1);
    }
    var prefixes = ["Webkit", "ms", "Moz", "O"];
    Object.keys(isUnitlessNumber).forEach(function(prop2) {
      prefixes.forEach(function(prefix3) {
        isUnitlessNumber[prefixKey(prefix3, prop2)] = isUnitlessNumber[prop2];
      });
    });
    function dangerousStyleValue(name2, value, isCustomProperty) {
      var isEmpty = value == null || typeof value == "boolean" || value === "";
      return isEmpty ? "" : !isCustomProperty && typeof value == "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2]) ? value + "px" : (checkCSSPropertyStringCoercion(value, name2), ("" + value).trim());
    }
    var uppercasePattern = /([A-Z])/g, msPattern = /^ms-/;
    function hyphenateStyleName(name2) {
      return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
    }
    var warnValidStyle = function() {
    };
    {
      var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/, msPattern$1 = /^-ms-/, hyphenPattern = /-(.)/g, badStyleValueWithSemicolonPattern = /;\s*$/, warnedStyleNames = {}, warnedStyleValues = {}, warnedForNaNValue = !1, warnedForInfinityValue = !1, camelize = function(string) {
        return string.replace(hyphenPattern, function(_2, character2) {
          return character2.toUpperCase();
        });
      }, warnHyphenatedStyleName = function(name2) {
        warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = !0, error(
          "Unsupported style property %s. Did you mean %s?",
          name2,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          camelize(name2.replace(msPattern$1, "ms-"))
        ));
      }, warnBadVendoredStyleName = function(name2) {
        warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2] || (warnedStyleNames[name2] = !0, error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1)));
      }, warnStyleValueWithSemicolon = function(name2, value) {
        warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value] || (warnedStyleValues[value] = !0, error(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, "")));
      }, warnStyleValueIsNaN = function(name2, value) {
        warnedForNaNValue || (warnedForNaNValue = !0, error("`NaN` is an invalid value for the `%s` css style property.", name2));
      }, warnStyleValueIsInfinity = function(name2, value) {
        warnedForInfinityValue || (warnedForInfinityValue = !0, error("`Infinity` is an invalid value for the `%s` css style property.", name2));
      };
      warnValidStyle = function(name2, value) {
        name2.indexOf("-") > -1 ? warnHyphenatedStyleName(name2) : badVendoredStyleNamePattern.test(name2) ? warnBadVendoredStyleName(name2) : badStyleValueWithSemicolonPattern.test(value) && warnStyleValueWithSemicolon(name2, value), typeof value == "number" && (isNaN(value) ? warnStyleValueIsNaN(name2, value) : isFinite(value) || warnStyleValueIsInfinity(name2, value));
      };
    }
    var warnValidStyle$1 = warnValidStyle;
    function createDangerousStringForStyles(styles) {
      {
        var serialized = "", delimiter2 = "";
        for (var styleName in styles)
          if (styles.hasOwnProperty(styleName)) {
            var styleValue = styles[styleName];
            if (styleValue != null) {
              var isCustomProperty = styleName.indexOf("--") === 0;
              serialized += delimiter2 + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":", serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty), delimiter2 = ";";
            }
          }
        return serialized || null;
      }
    }
    function setValueForStyles(node2, styles) {
      var style3 = node2.style;
      for (var styleName in styles)
        if (styles.hasOwnProperty(styleName)) {
          var isCustomProperty = styleName.indexOf("--") === 0;
          isCustomProperty || warnValidStyle$1(styleName, styles[styleName]);
          var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
          styleName === "float" && (styleName = "cssFloat"), isCustomProperty ? style3.setProperty(styleName, styleValue) : style3[styleName] = styleValue;
        }
    }
    function isValueEmpty(value) {
      return value == null || typeof value == "boolean" || value === "";
    }
    function expandShorthandMap(styles) {
      var expanded = {};
      for (var key2 in styles)
        for (var longhands = shorthandToLonghand[key2] || [key2], i = 0; i < longhands.length; i++)
          expanded[longhands[i]] = key2;
      return expanded;
    }
    function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
      {
        if (!nextStyles)
          return;
        var expandedUpdates = expandShorthandMap(styleUpdates), expandedStyles = expandShorthandMap(nextStyles), warnedAbout = {};
        for (var key2 in expandedUpdates) {
          var originalKey = expandedUpdates[key2], correctOriginalKey = expandedStyles[key2];
          if (correctOriginalKey && originalKey !== correctOriginalKey) {
            var warningKey = originalKey + "," + correctOriginalKey;
            if (warnedAbout[warningKey])
              continue;
            warnedAbout[warningKey] = !0, error("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
          }
        }
      }
    }
    var omittedCloseTags = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, voidElementTags = assign2({
      menuitem: !0
    }, omittedCloseTags), HTML = "__html";
    function assertValidProps(tag, props) {
      if (props) {
        if (voidElementTags[tag] && (props.children != null || props.dangerouslySetInnerHTML != null))
          throw new Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (props.dangerouslySetInnerHTML != null) {
          if (props.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof props.dangerouslySetInnerHTML != "object" || !(HTML in props.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null && error("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), props.style != null && typeof props.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function isCustomComponent(tagName, props) {
      if (tagName.indexOf("-") === -1)
        return typeof props.is == "string";
      switch (tagName) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var possibleStandardNames = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, ariaProperties = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, warnedProperties = {}, rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
    function validateProperty(tagName, name2) {
      {
        if (hasOwnProperty2.call(warnedProperties, name2) && warnedProperties[name2])
          return !0;
        if (rARIACamel.test(name2)) {
          var ariaName = "aria-" + name2.slice(4).toLowerCase(), correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
          if (correctName == null)
            return error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2), warnedProperties[name2] = !0, !0;
          if (name2 !== correctName)
            return error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName), warnedProperties[name2] = !0, !0;
        }
        if (rARIA.test(name2)) {
          var lowerCasedName = name2.toLowerCase(), standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
          if (standardName == null)
            return warnedProperties[name2] = !0, !1;
          if (name2 !== standardName)
            return error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName), warnedProperties[name2] = !0, !0;
        }
      }
      return !0;
    }
    function warnInvalidARIAProps(type, props) {
      {
        var invalidProps = [];
        for (var key2 in props) {
          var isValid = validateProperty(type, key2);
          isValid || invalidProps.push(key2);
        }
        var unknownPropString = invalidProps.map(function(prop2) {
          return "`" + prop2 + "`";
        }).join(", ");
        invalidProps.length === 1 ? error("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type) : invalidProps.length > 1 && error("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
      }
    }
    function validateProperties(type, props) {
      isCustomComponent(type, props) || warnInvalidARIAProps(type, props);
    }
    var didWarnValueNull = !1;
    function validateProperties$1(type, props) {
      {
        if (type !== "input" && type !== "textarea" && type !== "select")
          return;
        props != null && props.value === null && !didWarnValueNull && (didWarnValueNull = !0, type === "select" && props.multiple ? error("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type) : error("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type));
      }
    }
    var validateProperty$1 = function() {
    };
    {
      var warnedProperties$1 = {}, EVENT_NAME_REGEX = /^on./, INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/, rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$"), rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      validateProperty$1 = function(tagName, name2, value, eventRegistry) {
        if (hasOwnProperty2.call(warnedProperties$1, name2) && warnedProperties$1[name2])
          return !0;
        var lowerCasedName = name2.toLowerCase();
        if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout")
          return error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), warnedProperties$1[name2] = !0, !0;
        if (eventRegistry != null) {
          var registrationNameDependencies2 = eventRegistry.registrationNameDependencies, possibleRegistrationNames2 = eventRegistry.possibleRegistrationNames;
          if (registrationNameDependencies2.hasOwnProperty(name2))
            return !0;
          var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
          if (registrationName != null)
            return error("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName), warnedProperties$1[name2] = !0, !0;
          if (EVENT_NAME_REGEX.test(name2))
            return error("Unknown event handler property `%s`. It will be ignored.", name2), warnedProperties$1[name2] = !0, !0;
        } else if (EVENT_NAME_REGEX.test(name2))
          return INVALID_EVENT_NAME_REGEX.test(name2) && error("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2), warnedProperties$1[name2] = !0, !0;
        if (rARIA$1.test(name2) || rARIACamel$1.test(name2))
          return !0;
        if (lowerCasedName === "innerhtml")
          return error("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), warnedProperties$1[name2] = !0, !0;
        if (lowerCasedName === "aria")
          return error("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), warnedProperties$1[name2] = !0, !0;
        if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value != "string")
          return error("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value), warnedProperties$1[name2] = !0, !0;
        if (typeof value == "number" && isNaN(value))
          return error("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2), warnedProperties$1[name2] = !0, !0;
        var propertyInfo = getPropertyInfo(name2), isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
        if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
          var standardName = possibleStandardNames[lowerCasedName];
          if (standardName !== name2)
            return error("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName), warnedProperties$1[name2] = !0, !0;
        } else if (!isReserved && name2 !== lowerCasedName)
          return error("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName), warnedProperties$1[name2] = !0, !0;
        return typeof value == "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, !1) ? (value ? error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2) : error('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2), warnedProperties$1[name2] = !0, !0) : isReserved ? !0 : shouldRemoveAttributeWithWarning(name2, value, propertyInfo, !1) ? (warnedProperties$1[name2] = !0, !1) : ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN && (error("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value), warnedProperties$1[name2] = !0), !0);
      };
    }
    var warnUnknownProperties = function(type, props, eventRegistry) {
      {
        var unknownProps = [];
        for (var key2 in props) {
          var isValid = validateProperty$1(type, key2, props[key2], eventRegistry);
          isValid || unknownProps.push(key2);
        }
        var unknownPropString = unknownProps.map(function(prop2) {
          return "`" + prop2 + "`";
        }).join(", ");
        unknownProps.length === 1 ? error("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type) : unknownProps.length > 1 && error("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
      }
    };
    function validateProperties$2(type, props, eventRegistry) {
      isCustomComponent(type, props) || warnUnknownProperties(type, props, eventRegistry);
    }
    var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1, IS_NON_DELEGATED = 2, IS_CAPTURE_PHASE = 4, SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE, currentReplayingEvent = null;
    function setReplayingEvent(event) {
      currentReplayingEvent !== null && error("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), currentReplayingEvent = event;
    }
    function resetReplayingEvent() {
      currentReplayingEvent === null && error("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), currentReplayingEvent = null;
    }
    function isReplayingEvent(event) {
      return event === currentReplayingEvent;
    }
    function getEventTarget(nativeEvent) {
      var target2 = nativeEvent.target || nativeEvent.srcElement || window;
      return target2.correspondingUseElement && (target2 = target2.correspondingUseElement), target2.nodeType === TEXT_NODE ? target2.parentNode : target2;
    }
    var restoreImpl = null, restoreTarget = null, restoreQueue = null;
    function restoreStateOfTarget(target2) {
      var internalInstance = getInstanceFromNode(target2);
      if (internalInstance) {
        if (typeof restoreImpl != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var stateNode = internalInstance.stateNode;
        if (stateNode) {
          var _props = getFiberCurrentPropsFromNode(stateNode);
          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
      }
    }
    function setRestoreImplementation(impl) {
      restoreImpl = impl;
    }
    function enqueueStateRestore(target2) {
      restoreTarget ? restoreQueue ? restoreQueue.push(target2) : restoreQueue = [target2] : restoreTarget = target2;
    }
    function needsStateRestore() {
      return restoreTarget !== null || restoreQueue !== null;
    }
    function restoreStateIfNeeded() {
      if (restoreTarget) {
        var target2 = restoreTarget, queuedTargets = restoreQueue;
        if (restoreTarget = null, restoreQueue = null, restoreStateOfTarget(target2), queuedTargets)
          for (var i = 0; i < queuedTargets.length; i++)
            restoreStateOfTarget(queuedTargets[i]);
      }
    }
    var batchedUpdatesImpl = function(fn, bookkeeping) {
      return fn(bookkeeping);
    }, flushSyncImpl = function() {
    }, isInsideEventHandler = !1;
    function finishEventHandler() {
      var controlledComponentsHavePendingUpdates = needsStateRestore();
      controlledComponentsHavePendingUpdates && (flushSyncImpl(), restoreStateIfNeeded());
    }
    function batchedUpdates(fn, a, b) {
      if (isInsideEventHandler)
        return fn(a, b);
      isInsideEventHandler = !0;
      try {
        return batchedUpdatesImpl(fn, a, b);
      } finally {
        isInsideEventHandler = !1, finishEventHandler();
      }
    }
    function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
      batchedUpdatesImpl = _batchedUpdatesImpl, flushSyncImpl = _flushSyncImpl;
    }
    function isInteractive(tag) {
      return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
    }
    function shouldPreventMouseEvent(name2, type, props) {
      switch (name2) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(props.disabled && isInteractive(type));
        default:
          return !1;
      }
    }
    function getListener(inst, registrationName) {
      var stateNode = inst.stateNode;
      if (stateNode === null)
        return null;
      var props = getFiberCurrentPropsFromNode(stateNode);
      if (props === null)
        return null;
      var listener = props[registrationName];
      if (shouldPreventMouseEvent(registrationName, inst.type, props))
        return null;
      if (listener && typeof listener != "function")
        throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
      return listener;
    }
    var passiveBrowserEventsSupported = !1;
    if (canUseDOM)
      try {
        var options = {};
        Object.defineProperty(options, "passive", {
          get: function() {
            passiveBrowserEventsSupported = !0;
          }
        }), window.addEventListener("test", options, options), window.removeEventListener("test", options, options);
      } catch {
        passiveBrowserEventsSupported = !1;
      }
    function invokeGuardedCallbackProd(name2, func, context, a, b, c, d, e, f2) {
      var funcArgs = Array.prototype.slice.call(arguments, 3);
      try {
        func.apply(context, funcArgs);
      } catch (error2) {
        this.onError(error2);
      }
    }
    var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var fakeNode = document.createElement("react");
      invokeGuardedCallbackImpl = function(name2, func, context, a, b, c, d, e, f2) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var evt = document.createEvent("Event"), didCall = !1, didError = !0, windowEvent = window.event, windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
        function restoreAfterDispatch() {
          fakeNode.removeEventListener(evtType, callCallback2, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = windowEvent);
        }
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        function callCallback2() {
          didCall = !0, restoreAfterDispatch(), func.apply(context, funcArgs), didError = !1;
        }
        var error2, didSetError = !1, isCrossOriginError = !1;
        function handleWindowError(event) {
          if (error2 = event.error, didSetError = !0, error2 === null && event.colno === 0 && event.lineno === 0 && (isCrossOriginError = !0), event.defaultPrevented && error2 != null && typeof error2 == "object")
            try {
              error2._suppressLogging = !0;
            } catch {
            }
        }
        var evtType = "react-" + (name2 || "invokeguardedcallback");
        if (window.addEventListener("error", handleWindowError), fakeNode.addEventListener(evtType, callCallback2, !1), evt.initEvent(evtType, !1, !1), fakeNode.dispatchEvent(evt), windowEventDescriptor && Object.defineProperty(window, "event", windowEventDescriptor), didCall && didError && (didSetError ? isCrossOriginError && (error2 = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : error2 = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(error2)), window.removeEventListener("error", handleWindowError), !didCall)
          return restoreAfterDispatch(), invokeGuardedCallbackProd.apply(this, arguments);
      };
    }
    var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl, hasError = !1, caughtError = null, hasRethrowError = !1, rethrowError = null, reporter = {
      onError: function(error2) {
        hasError = !0, caughtError = error2;
      }
    };
    function invokeGuardedCallback(name2, func, context, a, b, c, d, e, f2) {
      hasError = !1, caughtError = null, invokeGuardedCallbackImpl$1.apply(reporter, arguments);
    }
    function invokeGuardedCallbackAndCatchFirstError(name2, func, context, a, b, c, d, e, f2) {
      if (invokeGuardedCallback.apply(this, arguments), hasError) {
        var error2 = clearCaughtError();
        hasRethrowError || (hasRethrowError = !0, rethrowError = error2);
      }
    }
    function rethrowCaughtError() {
      if (hasRethrowError) {
        var error2 = rethrowError;
        throw hasRethrowError = !1, rethrowError = null, error2;
      }
    }
    function hasCaughtError() {
      return hasError;
    }
    function clearCaughtError() {
      if (hasError) {
        var error2 = caughtError;
        return hasError = !1, caughtError = null, error2;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function get(key2) {
      return key2._reactInternals;
    }
    function has(key2) {
      return key2._reactInternals !== void 0;
    }
    function set(key2, value) {
      key2._reactInternals = value;
    }
    var NoFlags = (
      /*                      */
      0
    ), PerformedWork = (
      /*                */
      1
    ), Placement = (
      /*                    */
      2
    ), Update = (
      /*                       */
      4
    ), ChildDeletion = (
      /*                */
      16
    ), ContentReset = (
      /*                 */
      32
    ), Callback = (
      /*                     */
      64
    ), DidCapture = (
      /*                   */
      128
    ), ForceClientRender = (
      /*            */
      256
    ), Ref = (
      /*                          */
      512
    ), Snapshot = (
      /*                     */
      1024
    ), Passive = (
      /*                      */
      2048
    ), Hydrating = (
      /*                    */
      4096
    ), Visibility = (
      /*                   */
      8192
    ), StoreConsistency = (
      /*             */
      16384
    ), LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency, HostEffectMask = (
      /*               */
      32767
    ), Incomplete = (
      /*                   */
      32768
    ), ShouldCapture = (
      /*                */
      65536
    ), ForceUpdateForLegacySuspense = (
      /* */
      131072
    ), Forked = (
      /*                       */
      1048576
    ), RefStatic = (
      /*                    */
      2097152
    ), LayoutStatic = (
      /*                 */
      4194304
    ), PassiveStatic = (
      /*                */
      8388608
    ), MountLayoutDev = (
      /*               */
      16777216
    ), MountPassiveDev = (
      /*              */
      33554432
    ), BeforeMutationMask = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Update | Snapshot | 0
    ), MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility, LayoutMask = Update | Callback | Ref | Visibility, PassiveMask = Passive | ChildDeletion, StaticMask = LayoutStatic | PassiveStatic | RefStatic, ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
    function getNearestMountedFiber(fiber) {
      var node2 = fiber, nearestMounted = fiber;
      if (fiber.alternate)
        for (; node2.return; )
          node2 = node2.return;
      else {
        var nextNode = node2;
        do
          node2 = nextNode, (node2.flags & (Placement | Hydrating)) !== NoFlags && (nearestMounted = node2.return), nextNode = node2.return;
        while (nextNode);
      }
      return node2.tag === HostRoot ? nearestMounted : null;
    }
    function getSuspenseInstanceFromFiber(fiber) {
      if (fiber.tag === SuspenseComponent) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState === null) {
          var current2 = fiber.alternate;
          current2 !== null && (suspenseState = current2.memoizedState);
        }
        if (suspenseState !== null)
          return suspenseState.dehydrated;
      }
      return null;
    }
    function getContainerFromFiber(fiber) {
      return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
    }
    function isFiberMounted(fiber) {
      return getNearestMountedFiber(fiber) === fiber;
    }
    function isMounted(component) {
      {
        var owner = ReactCurrentOwner.current;
        if (owner !== null && owner.tag === ClassComponent) {
          var ownerFiber = owner, instance = ownerFiber.stateNode;
          instance._warnedAboutRefsInRender || error("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component"), instance._warnedAboutRefsInRender = !0;
        }
      }
      var fiber = get(component);
      return fiber ? getNearestMountedFiber(fiber) === fiber : !1;
    }
    function assertIsMounted(fiber) {
      if (getNearestMountedFiber(fiber) !== fiber)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function findCurrentFiberUsingSlowPath(fiber) {
      var alternate = fiber.alternate;
      if (!alternate) {
        var nearestMounted = getNearestMountedFiber(fiber);
        if (nearestMounted === null)
          throw new Error("Unable to find node on an unmounted component.");
        return nearestMounted !== fiber ? null : fiber;
      }
      for (var a = fiber, b = alternate; ; ) {
        var parentA = a.return;
        if (parentA === null)
          break;
        var parentB = parentA.alternate;
        if (parentB === null) {
          var nextParent = parentA.return;
          if (nextParent !== null) {
            a = b = nextParent;
            continue;
          }
          break;
        }
        if (parentA.child === parentB.child) {
          for (var child = parentA.child; child; ) {
            if (child === a)
              return assertIsMounted(parentA), fiber;
            if (child === b)
              return assertIsMounted(parentA), alternate;
            child = child.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a.return !== b.return)
          a = parentA, b = parentB;
        else {
          for (var didFindChild = !1, _child = parentA.child; _child; ) {
            if (_child === a) {
              didFindChild = !0, a = parentA, b = parentB;
              break;
            }
            if (_child === b) {
              didFindChild = !0, b = parentA, a = parentB;
              break;
            }
            _child = _child.sibling;
          }
          if (!didFindChild) {
            for (_child = parentB.child; _child; ) {
              if (_child === a) {
                didFindChild = !0, a = parentB, b = parentA;
                break;
              }
              if (_child === b) {
                didFindChild = !0, b = parentB, a = parentA;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (a.alternate !== b)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (a.tag !== HostRoot)
        throw new Error("Unable to find node on an unmounted component.");
      return a.stateNode.current === a ? fiber : alternate;
    }
    function findCurrentHostFiber(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);
      return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
    }
    function findCurrentHostFiberImpl(node2) {
      if (node2.tag === HostComponent || node2.tag === HostText)
        return node2;
      for (var child = node2.child; child !== null; ) {
        var match2 = findCurrentHostFiberImpl(child);
        if (match2 !== null)
          return match2;
        child = child.sibling;
      }
      return null;
    }
    function findCurrentHostFiberWithNoPortals(parent) {
      var currentParent = findCurrentFiberUsingSlowPath(parent);
      return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
    }
    function findCurrentHostFiberWithNoPortalsImpl(node2) {
      if (node2.tag === HostComponent || node2.tag === HostText)
        return node2;
      for (var child = node2.child; child !== null; ) {
        if (child.tag !== HostPortal) {
          var match2 = findCurrentHostFiberWithNoPortalsImpl(child);
          if (match2 !== null)
            return match2;
        }
        child = child.sibling;
      }
      return null;
    }
    var scheduleCallback = Scheduler2.unstable_scheduleCallback, cancelCallback = Scheduler2.unstable_cancelCallback, shouldYield = Scheduler2.unstable_shouldYield, requestPaint = Scheduler2.unstable_requestPaint, now2 = Scheduler2.unstable_now, getCurrentPriorityLevel = Scheduler2.unstable_getCurrentPriorityLevel, ImmediatePriority = Scheduler2.unstable_ImmediatePriority, UserBlockingPriority = Scheduler2.unstable_UserBlockingPriority, NormalPriority = Scheduler2.unstable_NormalPriority, LowPriority = Scheduler2.unstable_LowPriority, IdlePriority = Scheduler2.unstable_IdlePriority, unstable_yieldValue = Scheduler2.unstable_yieldValue, unstable_setDisableYieldValue = Scheduler2.unstable_setDisableYieldValue, rendererID = null, injectedHook = null, injectedProfilingHooks = null, hasLoggedError = !1, isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function injectInternals(internals) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (hook.isDisabled)
        return !0;
      if (!hook.supportsFiber)
        return error("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        enableSchedulingProfiler && (internals = assign2({}, internals, {
          getLaneLabelMap,
          injectProfilingHooks
        })), rendererID = hook.inject(internals), injectedHook = hook;
      } catch (err) {
        error("React instrumentation encountered an error: %s.", err);
      }
      return !!hook.checkDCE;
    }
    function onScheduleRoot(root2, children) {
      if (injectedHook && typeof injectedHook.onScheduleFiberRoot == "function")
        try {
          injectedHook.onScheduleFiberRoot(rendererID, root2, children);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
        }
    }
    function onCommitRoot(root2, eventPriority) {
      if (injectedHook && typeof injectedHook.onCommitFiberRoot == "function")
        try {
          var didError = (root2.current.flags & DidCapture) === DidCapture;
          if (enableProfilerTimer) {
            var schedulerPriority;
            switch (eventPriority) {
              case DiscreteEventPriority:
                schedulerPriority = ImmediatePriority;
                break;
              case ContinuousEventPriority:
                schedulerPriority = UserBlockingPriority;
                break;
              case DefaultEventPriority:
                schedulerPriority = NormalPriority;
                break;
              case IdleEventPriority:
                schedulerPriority = IdlePriority;
                break;
              default:
                schedulerPriority = NormalPriority;
                break;
            }
            injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
          }
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
        }
    }
    function onPostCommitRoot(root2) {
      if (injectedHook && typeof injectedHook.onPostCommitFiberRoot == "function")
        try {
          injectedHook.onPostCommitFiberRoot(rendererID, root2);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
        }
    }
    function onCommitUnmount(fiber) {
      if (injectedHook && typeof injectedHook.onCommitFiberUnmount == "function")
        try {
          injectedHook.onCommitFiberUnmount(rendererID, fiber);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
        }
    }
    function setIsStrictModeForDevtools(newIsStrictMode) {
      if (typeof unstable_yieldValue == "function" && (unstable_setDisableYieldValue(newIsStrictMode), setSuppressWarning(newIsStrictMode)), injectedHook && typeof injectedHook.setStrictMode == "function")
        try {
          injectedHook.setStrictMode(rendererID, newIsStrictMode);
        } catch (err) {
          hasLoggedError || (hasLoggedError = !0, error("React instrumentation encountered an error: %s", err));
        }
    }
    function injectProfilingHooks(profilingHooks) {
      injectedProfilingHooks = profilingHooks;
    }
    function getLaneLabelMap() {
      {
        for (var map2 = /* @__PURE__ */ new Map(), lane = 1, index3 = 0; index3 < TotalLanes; index3++) {
          var label = getLabelForLane(lane);
          map2.set(lane, label), lane *= 2;
        }
        return map2;
      }
    }
    function markCommitStarted(lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted == "function" && injectedProfilingHooks.markCommitStarted(lanes);
    }
    function markCommitStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped == "function" && injectedProfilingHooks.markCommitStopped();
    }
    function markComponentRenderStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted == "function" && injectedProfilingHooks.markComponentRenderStarted(fiber);
    }
    function markComponentRenderStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped == "function" && injectedProfilingHooks.markComponentRenderStopped();
    }
    function markComponentPassiveEffectMountStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted == "function" && injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
    }
    function markComponentPassiveEffectMountStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped == "function" && injectedProfilingHooks.markComponentPassiveEffectMountStopped();
    }
    function markComponentPassiveEffectUnmountStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted == "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
    }
    function markComponentPassiveEffectUnmountStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped == "function" && injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
    }
    function markComponentLayoutEffectMountStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted == "function" && injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
    }
    function markComponentLayoutEffectMountStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped == "function" && injectedProfilingHooks.markComponentLayoutEffectMountStopped();
    }
    function markComponentLayoutEffectUnmountStarted(fiber) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted == "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
    }
    function markComponentLayoutEffectUnmountStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped == "function" && injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
    }
    function markComponentErrored(fiber, thrownValue, lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored == "function" && injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
    }
    function markComponentSuspended(fiber, wakeable, lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended == "function" && injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
    }
    function markLayoutEffectsStarted(lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted == "function" && injectedProfilingHooks.markLayoutEffectsStarted(lanes);
    }
    function markLayoutEffectsStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped == "function" && injectedProfilingHooks.markLayoutEffectsStopped();
    }
    function markPassiveEffectsStarted(lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted == "function" && injectedProfilingHooks.markPassiveEffectsStarted(lanes);
    }
    function markPassiveEffectsStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped == "function" && injectedProfilingHooks.markPassiveEffectsStopped();
    }
    function markRenderStarted(lanes) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted == "function" && injectedProfilingHooks.markRenderStarted(lanes);
    }
    function markRenderYielded() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded == "function" && injectedProfilingHooks.markRenderYielded();
    }
    function markRenderStopped() {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped == "function" && injectedProfilingHooks.markRenderStopped();
    }
    function markRenderScheduled(lane) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled == "function" && injectedProfilingHooks.markRenderScheduled(lane);
    }
    function markForceUpdateScheduled(fiber, lane) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled == "function" && injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
    }
    function markStateUpdateScheduled(fiber, lane) {
      injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled == "function" && injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
    }
    var NoMode = (
      /*                         */
      0
    ), ConcurrentMode = (
      /*                 */
      1
    ), ProfileMode = (
      /*                    */
      2
    ), StrictLegacyMode = (
      /*               */
      8
    ), StrictEffectsMode = (
      /*              */
      16
    ), clz32 = Math.clz32 ? Math.clz32 : clz32Fallback, log = Math.log, LN2 = Math.LN2;
    function clz32Fallback(x2) {
      var asUint = x2 >>> 0;
      return asUint === 0 ? 32 : 31 - (log(asUint) / LN2 | 0) | 0;
    }
    var TotalLanes = 31, NoLanes = (
      /*                        */
      0
    ), NoLane = (
      /*                          */
      0
    ), SyncLane = (
      /*                        */
      1
    ), InputContinuousHydrationLane = (
      /*    */
      2
    ), InputContinuousLane = (
      /*             */
      4
    ), DefaultHydrationLane = (
      /*            */
      8
    ), DefaultLane = (
      /*                     */
      16
    ), TransitionHydrationLane = (
      /*                */
      32
    ), TransitionLanes = (
      /*                       */
      4194240
    ), TransitionLane1 = (
      /*                        */
      64
    ), TransitionLane2 = (
      /*                        */
      128
    ), TransitionLane3 = (
      /*                        */
      256
    ), TransitionLane4 = (
      /*                        */
      512
    ), TransitionLane5 = (
      /*                        */
      1024
    ), TransitionLane6 = (
      /*                        */
      2048
    ), TransitionLane7 = (
      /*                        */
      4096
    ), TransitionLane8 = (
      /*                        */
      8192
    ), TransitionLane9 = (
      /*                        */
      16384
    ), TransitionLane10 = (
      /*                       */
      32768
    ), TransitionLane11 = (
      /*                       */
      65536
    ), TransitionLane12 = (
      /*                       */
      131072
    ), TransitionLane13 = (
      /*                       */
      262144
    ), TransitionLane14 = (
      /*                       */
      524288
    ), TransitionLane15 = (
      /*                       */
      1048576
    ), TransitionLane16 = (
      /*                       */
      2097152
    ), RetryLanes = (
      /*                            */
      130023424
    ), RetryLane1 = (
      /*                             */
      4194304
    ), RetryLane2 = (
      /*                             */
      8388608
    ), RetryLane3 = (
      /*                             */
      16777216
    ), RetryLane4 = (
      /*                             */
      33554432
    ), RetryLane5 = (
      /*                             */
      67108864
    ), SomeRetryLane = RetryLane1, SelectiveHydrationLane = (
      /*          */
      134217728
    ), NonIdleLanes = (
      /*                          */
      268435455
    ), IdleHydrationLane = (
      /*               */
      268435456
    ), IdleLane = (
      /*                        */
      536870912
    ), OffscreenLane = (
      /*                   */
      1073741824
    );
    function getLabelForLane(lane) {
      {
        if (lane & SyncLane)
          return "Sync";
        if (lane & InputContinuousHydrationLane)
          return "InputContinuousHydration";
        if (lane & InputContinuousLane)
          return "InputContinuous";
        if (lane & DefaultHydrationLane)
          return "DefaultHydration";
        if (lane & DefaultLane)
          return "Default";
        if (lane & TransitionHydrationLane)
          return "TransitionHydration";
        if (lane & TransitionLanes)
          return "Transition";
        if (lane & RetryLanes)
          return "Retry";
        if (lane & SelectiveHydrationLane)
          return "SelectiveHydration";
        if (lane & IdleHydrationLane)
          return "IdleHydration";
        if (lane & IdleLane)
          return "Idle";
        if (lane & OffscreenLane)
          return "Offscreen";
      }
    }
    var NoTimestamp = -1, nextTransitionLane = TransitionLane1, nextRetryLane = RetryLane1;
    function getHighestPriorityLanes(lanes) {
      switch (getHighestPriorityLane(lanes)) {
        case SyncLane:
          return SyncLane;
        case InputContinuousHydrationLane:
          return InputContinuousHydrationLane;
        case InputContinuousLane:
          return InputContinuousLane;
        case DefaultHydrationLane:
          return DefaultHydrationLane;
        case DefaultLane:
          return DefaultLane;
        case TransitionHydrationLane:
          return TransitionHydrationLane;
        case TransitionLane1:
        case TransitionLane2:
        case TransitionLane3:
        case TransitionLane4:
        case TransitionLane5:
        case TransitionLane6:
        case TransitionLane7:
        case TransitionLane8:
        case TransitionLane9:
        case TransitionLane10:
        case TransitionLane11:
        case TransitionLane12:
        case TransitionLane13:
        case TransitionLane14:
        case TransitionLane15:
        case TransitionLane16:
          return lanes & TransitionLanes;
        case RetryLane1:
        case RetryLane2:
        case RetryLane3:
        case RetryLane4:
        case RetryLane5:
          return lanes & RetryLanes;
        case SelectiveHydrationLane:
          return SelectiveHydrationLane;
        case IdleHydrationLane:
          return IdleHydrationLane;
        case IdleLane:
          return IdleLane;
        case OffscreenLane:
          return OffscreenLane;
        default:
          return error("Should have found matching lanes. This is a bug in React."), lanes;
      }
    }
    function getNextLanes(root2, wipLanes) {
      var pendingLanes = root2.pendingLanes;
      if (pendingLanes === NoLanes)
        return NoLanes;
      var nextLanes = NoLanes, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, nonIdlePendingLanes = pendingLanes & NonIdleLanes;
      if (nonIdlePendingLanes !== NoLanes) {
        var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
        if (nonIdleUnblockedLanes !== NoLanes)
          nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
        else {
          var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
          nonIdlePingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(nonIdlePingedLanes));
        }
      } else {
        var unblockedLanes = pendingLanes & ~suspendedLanes;
        unblockedLanes !== NoLanes ? nextLanes = getHighestPriorityLanes(unblockedLanes) : pingedLanes !== NoLanes && (nextLanes = getHighestPriorityLanes(pingedLanes));
      }
      if (nextLanes === NoLanes)
        return NoLanes;
      if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (wipLanes & suspendedLanes) === NoLanes) {
        var nextLane = getHighestPriorityLane(nextLanes), wipLane = getHighestPriorityLane(wipLanes);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes
        )
          return wipLanes;
      }
      (nextLanes & InputContinuousLane) !== NoLanes && (nextLanes |= pendingLanes & DefaultLane);
      var entangledLanes = root2.entangledLanes;
      if (entangledLanes !== NoLanes)
        for (var entanglements = root2.entanglements, lanes = nextLanes & entangledLanes; lanes > 0; ) {
          var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3;
          nextLanes |= entanglements[index3], lanes &= ~lane;
        }
      return nextLanes;
    }
    function getMostRecentEventTime(root2, lanes) {
      for (var eventTimes = root2.eventTimes, mostRecentEventTime = NoTimestamp; lanes > 0; ) {
        var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3, eventTime = eventTimes[index3];
        eventTime > mostRecentEventTime && (mostRecentEventTime = eventTime), lanes &= ~lane;
      }
      return mostRecentEventTime;
    }
    function computeExpirationTime(lane, currentTime) {
      switch (lane) {
        case SyncLane:
        case InputContinuousHydrationLane:
        case InputContinuousLane:
          return currentTime + 250;
        case DefaultHydrationLane:
        case DefaultLane:
        case TransitionHydrationLane:
        case TransitionLane1:
        case TransitionLane2:
        case TransitionLane3:
        case TransitionLane4:
        case TransitionLane5:
        case TransitionLane6:
        case TransitionLane7:
        case TransitionLane8:
        case TransitionLane9:
        case TransitionLane10:
        case TransitionLane11:
        case TransitionLane12:
        case TransitionLane13:
        case TransitionLane14:
        case TransitionLane15:
        case TransitionLane16:
          return currentTime + 5e3;
        case RetryLane1:
        case RetryLane2:
        case RetryLane3:
        case RetryLane4:
        case RetryLane5:
          return NoTimestamp;
        case SelectiveHydrationLane:
        case IdleHydrationLane:
        case IdleLane:
        case OffscreenLane:
          return NoTimestamp;
        default:
          return error("Should have found matching lanes. This is a bug in React."), NoTimestamp;
      }
    }
    function markStarvedLanesAsExpired(root2, currentTime) {
      for (var pendingLanes = root2.pendingLanes, suspendedLanes = root2.suspendedLanes, pingedLanes = root2.pingedLanes, expirationTimes = root2.expirationTimes, lanes = pendingLanes; lanes > 0; ) {
        var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3, expirationTime = expirationTimes[index3];
        expirationTime === NoTimestamp ? ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) && (expirationTimes[index3] = computeExpirationTime(lane, currentTime)) : expirationTime <= currentTime && (root2.expiredLanes |= lane), lanes &= ~lane;
      }
    }
    function getHighestPriorityPendingLanes(root2) {
      return getHighestPriorityLanes(root2.pendingLanes);
    }
    function getLanesToRetrySynchronouslyOnError(root2) {
      var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
      return everythingButOffscreen !== NoLanes ? everythingButOffscreen : everythingButOffscreen & OffscreenLane ? OffscreenLane : NoLanes;
    }
    function includesSyncLane(lanes) {
      return (lanes & SyncLane) !== NoLanes;
    }
    function includesNonIdleWork(lanes) {
      return (lanes & NonIdleLanes) !== NoLanes;
    }
    function includesOnlyRetries(lanes) {
      return (lanes & RetryLanes) === lanes;
    }
    function includesOnlyNonUrgentLanes(lanes) {
      var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
      return (lanes & UrgentLanes) === NoLanes;
    }
    function includesOnlyTransitions(lanes) {
      return (lanes & TransitionLanes) === lanes;
    }
    function includesBlockingLane(root2, lanes) {
      var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
      return (lanes & SyncDefaultLanes) !== NoLanes;
    }
    function includesExpiredLane(root2, lanes) {
      return (lanes & root2.expiredLanes) !== NoLanes;
    }
    function isTransitionLane(lane) {
      return (lane & TransitionLanes) !== NoLanes;
    }
    function claimNextTransitionLane() {
      var lane = nextTransitionLane;
      return nextTransitionLane <<= 1, (nextTransitionLane & TransitionLanes) === NoLanes && (nextTransitionLane = TransitionLane1), lane;
    }
    function claimNextRetryLane() {
      var lane = nextRetryLane;
      return nextRetryLane <<= 1, (nextRetryLane & RetryLanes) === NoLanes && (nextRetryLane = RetryLane1), lane;
    }
    function getHighestPriorityLane(lanes) {
      return lanes & -lanes;
    }
    function pickArbitraryLane(lanes) {
      return getHighestPriorityLane(lanes);
    }
    function pickArbitraryLaneIndex(lanes) {
      return 31 - clz32(lanes);
    }
    function laneToIndex(lane) {
      return pickArbitraryLaneIndex(lane);
    }
    function includesSomeLane(a, b) {
      return (a & b) !== NoLanes;
    }
    function isSubsetOfLanes(set2, subset2) {
      return (set2 & subset2) === subset2;
    }
    function mergeLanes(a, b) {
      return a | b;
    }
    function removeLanes(set2, subset2) {
      return set2 & ~subset2;
    }
    function intersectLanes(a, b) {
      return a & b;
    }
    function laneToLanes(lane) {
      return lane;
    }
    function higherPriorityLane(a, b) {
      return a !== NoLane && a < b ? a : b;
    }
    function createLaneMap(initial) {
      for (var laneMap = [], i = 0; i < TotalLanes; i++)
        laneMap.push(initial);
      return laneMap;
    }
    function markRootUpdated(root2, updateLane, eventTime) {
      root2.pendingLanes |= updateLane, updateLane !== IdleLane && (root2.suspendedLanes = NoLanes, root2.pingedLanes = NoLanes);
      var eventTimes = root2.eventTimes, index3 = laneToIndex(updateLane);
      eventTimes[index3] = eventTime;
    }
    function markRootSuspended(root2, suspendedLanes) {
      root2.suspendedLanes |= suspendedLanes, root2.pingedLanes &= ~suspendedLanes;
      for (var expirationTimes = root2.expirationTimes, lanes = suspendedLanes; lanes > 0; ) {
        var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3;
        expirationTimes[index3] = NoTimestamp, lanes &= ~lane;
      }
    }
    function markRootPinged(root2, pingedLanes, eventTime) {
      root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
    }
    function markRootFinished(root2, remainingLanes) {
      var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
      root2.pendingLanes = remainingLanes, root2.suspendedLanes = NoLanes, root2.pingedLanes = NoLanes, root2.expiredLanes &= remainingLanes, root2.mutableReadLanes &= remainingLanes, root2.entangledLanes &= remainingLanes;
      for (var entanglements = root2.entanglements, eventTimes = root2.eventTimes, expirationTimes = root2.expirationTimes, lanes = noLongerPendingLanes; lanes > 0; ) {
        var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3;
        entanglements[index3] = NoLanes, eventTimes[index3] = NoTimestamp, expirationTimes[index3] = NoTimestamp, lanes &= ~lane;
      }
    }
    function markRootEntangled(root2, entangledLanes) {
      for (var rootEntangledLanes = root2.entangledLanes |= entangledLanes, entanglements = root2.entanglements, lanes = rootEntangledLanes; lanes; ) {
        var index3 = pickArbitraryLaneIndex(lanes), lane = 1 << index3;
        // Is this one of the newly entangled lanes?
        lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?
        entanglements[index3] & entangledLanes && (entanglements[index3] |= entangledLanes), lanes &= ~lane;
      }
    }
    function getBumpedLaneForHydration(root2, renderLanes2) {
      var renderLane = getHighestPriorityLane(renderLanes2), lane;
      switch (renderLane) {
        case InputContinuousLane:
          lane = InputContinuousHydrationLane;
          break;
        case DefaultLane:
          lane = DefaultHydrationLane;
          break;
        case TransitionLane1:
        case TransitionLane2:
        case TransitionLane3:
        case TransitionLane4:
        case TransitionLane5:
        case TransitionLane6:
        case TransitionLane7:
        case TransitionLane8:
        case TransitionLane9:
        case TransitionLane10:
        case TransitionLane11:
        case TransitionLane12:
        case TransitionLane13:
        case TransitionLane14:
        case TransitionLane15:
        case TransitionLane16:
        case RetryLane1:
        case RetryLane2:
        case RetryLane3:
        case RetryLane4:
        case RetryLane5:
          lane = TransitionHydrationLane;
          break;
        case IdleLane:
          lane = IdleHydrationLane;
          break;
        default:
          lane = NoLane;
          break;
      }
      return (lane & (root2.suspendedLanes | renderLanes2)) !== NoLane ? NoLane : lane;
    }
    function addFiberToLanesMap(root2, fiber, lanes) {
      if (isDevToolsPresent)
        for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap; lanes > 0; ) {
          var index3 = laneToIndex(lanes), lane = 1 << index3, updaters = pendingUpdatersLaneMap[index3];
          updaters.add(fiber), lanes &= ~lane;
        }
    }
    function movePendingFibersToMemoized(root2, lanes) {
      if (isDevToolsPresent)
        for (var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap, memoizedUpdaters = root2.memoizedUpdaters; lanes > 0; ) {
          var index3 = laneToIndex(lanes), lane = 1 << index3, updaters = pendingUpdatersLaneMap[index3];
          updaters.size > 0 && (updaters.forEach(function(fiber) {
            var alternate = fiber.alternate;
            (alternate === null || !memoizedUpdaters.has(alternate)) && memoizedUpdaters.add(fiber);
          }), updaters.clear()), lanes &= ~lane;
        }
    }
    function getTransitionsForLanes(root2, lanes) {
      return null;
    }
    var DiscreteEventPriority = SyncLane, ContinuousEventPriority = InputContinuousLane, DefaultEventPriority = DefaultLane, IdleEventPriority = IdleLane, currentUpdatePriority = NoLane;
    function getCurrentUpdatePriority() {
      return currentUpdatePriority;
    }
    function setCurrentUpdatePriority(newPriority) {
      currentUpdatePriority = newPriority;
    }
    function runWithPriority(priority, fn) {
      var previousPriority = currentUpdatePriority;
      try {
        return currentUpdatePriority = priority, fn();
      } finally {
        currentUpdatePriority = previousPriority;
      }
    }
    function higherEventPriority(a, b) {
      return a !== 0 && a < b ? a : b;
    }
    function lowerEventPriority(a, b) {
      return a > b ? a : b;
    }
    function isHigherEventPriority(a, b) {
      return a !== 0 && a < b;
    }
    function lanesToEventPriority(lanes) {
      var lane = getHighestPriorityLane(lanes);
      return isHigherEventPriority(DiscreteEventPriority, lane) ? isHigherEventPriority(ContinuousEventPriority, lane) ? includesNonIdleWork(lane) ? DefaultEventPriority : IdleEventPriority : ContinuousEventPriority : DiscreteEventPriority;
    }
    function isRootDehydrated(root2) {
      var currentState = root2.current.memoizedState;
      return currentState.isDehydrated;
    }
    var _attemptSynchronousHydration;
    function setAttemptSynchronousHydration(fn) {
      _attemptSynchronousHydration = fn;
    }
    function attemptSynchronousHydration(fiber) {
      _attemptSynchronousHydration(fiber);
    }
    var attemptContinuousHydration;
    function setAttemptContinuousHydration(fn) {
      attemptContinuousHydration = fn;
    }
    var attemptHydrationAtCurrentPriority;
    function setAttemptHydrationAtCurrentPriority(fn) {
      attemptHydrationAtCurrentPriority = fn;
    }
    var getCurrentUpdatePriority$1;
    function setGetCurrentUpdatePriority(fn) {
      getCurrentUpdatePriority$1 = fn;
    }
    var attemptHydrationAtPriority;
    function setAttemptHydrationAtPriority(fn) {
      attemptHydrationAtPriority = fn;
    }
    var hasScheduledReplayAttempt = !1, queuedDiscreteEvents = [], queuedFocus = null, queuedDrag = null, queuedMouse = null, queuedPointers = /* @__PURE__ */ new Map(), queuedPointerCaptures = /* @__PURE__ */ new Map(), queuedExplicitHydrationTargets = [], discreteReplayableEvents = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function isDiscreteEventThatRequiresHydration(eventType) {
      return discreteReplayableEvents.indexOf(eventType) > -1;
    }
    function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      return {
        blockedOn,
        domEventName,
        eventSystemFlags,
        nativeEvent,
        targetContainers: [targetContainer]
      };
    }
    function clearIfContinuousEvent(domEventName, nativeEvent) {
      switch (domEventName) {
        case "focusin":
        case "focusout":
          queuedFocus = null;
          break;
        case "dragenter":
        case "dragleave":
          queuedDrag = null;
          break;
        case "mouseover":
        case "mouseout":
          queuedMouse = null;
          break;
        case "pointerover":
        case "pointerout": {
          var pointerId = nativeEvent.pointerId;
          queuedPointers.delete(pointerId);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var _pointerId = nativeEvent.pointerId;
          queuedPointerCaptures.delete(_pointerId);
          break;
        }
      }
    }
    function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
        var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn !== null) {
          var _fiber2 = getInstanceFromNode(blockedOn);
          _fiber2 !== null && attemptContinuousHydration(_fiber2);
        }
        return queuedEvent;
      }
      existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
      var targetContainers = existingQueuedEvent.targetContainers;
      return targetContainer !== null && targetContainers.indexOf(targetContainer) === -1 && targetContainers.push(targetContainer), existingQueuedEvent;
    }
    function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      switch (domEventName) {
        case "focusin": {
          var focusEvent = nativeEvent;
          return queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent), !0;
        }
        case "dragenter": {
          var dragEvent = nativeEvent;
          return queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent), !0;
        }
        case "mouseover": {
          var mouseEvent = nativeEvent;
          return queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent), !0;
        }
        case "pointerover": {
          var pointerEvent = nativeEvent, pointerId = pointerEvent.pointerId;
          return queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent)), !0;
        }
        case "gotpointercapture": {
          var _pointerEvent = nativeEvent, _pointerId2 = _pointerEvent.pointerId;
          return queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent)), !0;
        }
      }
      return !1;
    }
    function attemptExplicitHydrationTarget(queuedTarget) {
      var targetInst = getClosestInstanceFromNode(queuedTarget.target);
      if (targetInst !== null) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (nearestMounted !== null) {
          var tag = nearestMounted.tag;
          if (tag === SuspenseComponent) {
            var instance = getSuspenseInstanceFromFiber(nearestMounted);
            if (instance !== null) {
              queuedTarget.blockedOn = instance, attemptHydrationAtPriority(queuedTarget.priority, function() {
                attemptHydrationAtCurrentPriority(nearestMounted);
              });
              return;
            }
          } else if (tag === HostRoot) {
            var root2 = nearestMounted.stateNode;
            if (isRootDehydrated(root2)) {
              queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
              return;
            }
          }
        }
      }
      queuedTarget.blockedOn = null;
    }
    function queueExplicitHydrationTarget(target2) {
      for (var updatePriority = getCurrentUpdatePriority$1(), queuedTarget = {
        blockedOn: null,
        target: target2,
        priority: updatePriority
      }, i = 0; i < queuedExplicitHydrationTargets.length && isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority); i++)
        ;
      queuedExplicitHydrationTargets.splice(i, 0, queuedTarget), i === 0 && attemptExplicitHydrationTarget(queuedTarget);
    }
    function attemptReplayContinuousQueuedEvent(queuedEvent) {
      if (queuedEvent.blockedOn !== null)
        return !1;
      for (var targetContainers = queuedEvent.targetContainers; targetContainers.length > 0; ) {
        var targetContainer = targetContainers[0], nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
        if (nextBlockedOn === null) {
          var nativeEvent = queuedEvent.nativeEvent, nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
          setReplayingEvent(nativeEventClone), nativeEvent.target.dispatchEvent(nativeEventClone), resetReplayingEvent();
        } else {
          var _fiber3 = getInstanceFromNode(nextBlockedOn);
          return _fiber3 !== null && attemptContinuousHydration(_fiber3), queuedEvent.blockedOn = nextBlockedOn, !1;
        }
        targetContainers.shift();
      }
      return !0;
    }
    function attemptReplayContinuousQueuedEventInMap(queuedEvent, key2, map2) {
      attemptReplayContinuousQueuedEvent(queuedEvent) && map2.delete(key2);
    }
    function replayUnblockedEvents() {
      hasScheduledReplayAttempt = !1, queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus) && (queuedFocus = null), queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag) && (queuedDrag = null), queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse) && (queuedMouse = null), queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap), queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
    }
    function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
      queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null, hasScheduledReplayAttempt || (hasScheduledReplayAttempt = !0, Scheduler2.unstable_scheduleCallback(Scheduler2.unstable_NormalPriority, replayUnblockedEvents)));
    }
    function retryIfBlockedOn(unblocked) {
      if (queuedDiscreteEvents.length > 0) {
        scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
        for (var i = 1; i < queuedDiscreteEvents.length; i++) {
          var queuedEvent = queuedDiscreteEvents[i];
          queuedEvent.blockedOn === unblocked && (queuedEvent.blockedOn = null);
        }
      }
      queuedFocus !== null && scheduleCallbackIfUnblocked(queuedFocus, unblocked), queuedDrag !== null && scheduleCallbackIfUnblocked(queuedDrag, unblocked), queuedMouse !== null && scheduleCallbackIfUnblocked(queuedMouse, unblocked);
      var unblock = function(queuedEvent2) {
        return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
      };
      queuedPointers.forEach(unblock), queuedPointerCaptures.forEach(unblock);
      for (var _i = 0; _i < queuedExplicitHydrationTargets.length; _i++) {
        var queuedTarget = queuedExplicitHydrationTargets[_i];
        queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);
      }
      for (; queuedExplicitHydrationTargets.length > 0; ) {
        var nextExplicitTarget = queuedExplicitHydrationTargets[0];
        if (nextExplicitTarget.blockedOn !== null)
          break;
        attemptExplicitHydrationTarget(nextExplicitTarget), nextExplicitTarget.blockedOn === null && queuedExplicitHydrationTargets.shift();
      }
    }
    var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig, _enabled = !0;
    function setEnabled(enabled) {
      _enabled = !!enabled;
    }
    function isEnabled() {
      return _enabled;
    }
    function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
      var eventPriority = getEventPriority(domEventName), listenerWrapper;
      switch (eventPriority) {
        case DiscreteEventPriority:
          listenerWrapper = dispatchDiscreteEvent;
          break;
        case ContinuousEventPriority:
          listenerWrapper = dispatchContinuousEvent;
          break;
        case DefaultEventPriority:
        default:
          listenerWrapper = dispatchEvent;
          break;
      }
      return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
    }
    function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var previousPriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig.transition;
      ReactCurrentBatchConfig.transition = null;
      try {
        setCurrentUpdatePriority(DiscreteEventPriority), dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig.transition = prevTransition;
      }
    }
    function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
      var previousPriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig.transition;
      ReactCurrentBatchConfig.transition = null;
      try {
        setCurrentUpdatePriority(ContinuousEventPriority), dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig.transition = prevTransition;
      }
    }
    function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      _enabled && dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
    }
    function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
      if (blockedOn === null) {
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), clearIfContinuousEvent(domEventName, nativeEvent);
        return;
      }
      if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
        nativeEvent.stopPropagation();
        return;
      }
      if (clearIfContinuousEvent(domEventName, nativeEvent), eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
        for (; blockedOn !== null; ) {
          var fiber = getInstanceFromNode(blockedOn);
          fiber !== null && attemptSynchronousHydration(fiber);
          var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (nextBlockedOn === null && dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer), nextBlockedOn === blockedOn)
            break;
          blockedOn = nextBlockedOn;
        }
        blockedOn !== null && nativeEvent.stopPropagation();
        return;
      }
      dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
    }
    var return_targetInst = null;
    function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
      return_targetInst = null;
      var nativeEventTarget = getEventTarget(nativeEvent), targetInst = getClosestInstanceFromNode(nativeEventTarget);
      if (targetInst !== null) {
        var nearestMounted = getNearestMountedFiber(targetInst);
        if (nearestMounted === null)
          targetInst = null;
        else {
          var tag = nearestMounted.tag;
          if (tag === SuspenseComponent) {
            var instance = getSuspenseInstanceFromFiber(nearestMounted);
            if (instance !== null)
              return instance;
            targetInst = null;
          } else if (tag === HostRoot) {
            var root2 = nearestMounted.stateNode;
            if (isRootDehydrated(root2))
              return getContainerFromFiber(nearestMounted);
            targetInst = null;
          } else nearestMounted !== targetInst && (targetInst = null);
        }
      }
      return return_targetInst = targetInst, null;
    }
    function getEventPriority(domEventName) {
      switch (domEventName) {
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return DiscreteEventPriority;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ContinuousEventPriority;
        case "message": {
          var schedulerPriority = getCurrentPriorityLevel();
          switch (schedulerPriority) {
            case ImmediatePriority:
              return DiscreteEventPriority;
            case UserBlockingPriority:
              return ContinuousEventPriority;
            case NormalPriority:
            case LowPriority:
              return DefaultEventPriority;
            case IdlePriority:
              return IdleEventPriority;
            default:
              return DefaultEventPriority;
          }
        }
        default:
          return DefaultEventPriority;
      }
    }
    function addEventBubbleListener(target2, eventType, listener) {
      return target2.addEventListener(eventType, listener, !1), listener;
    }
    function addEventCaptureListener(target2, eventType, listener) {
      return target2.addEventListener(eventType, listener, !0), listener;
    }
    function addEventCaptureListenerWithPassiveFlag(target2, eventType, listener, passive) {
      return target2.addEventListener(eventType, listener, {
        capture: !0,
        passive
      }), listener;
    }
    function addEventBubbleListenerWithPassiveFlag(target2, eventType, listener, passive) {
      return target2.addEventListener(eventType, listener, {
        passive
      }), listener;
    }
    var root = null, startText = null, fallbackText = null;
    function initialize(nativeEventTarget) {
      return root = nativeEventTarget, startText = getText(), !0;
    }
    function reset() {
      root = null, startText = null, fallbackText = null;
    }
    function getData() {
      if (fallbackText)
        return fallbackText;
      var start, startValue = startText, startLength = startValue.length, end, endValue = getText(), endLength = endValue.length;
      for (start = 0; start < startLength && startValue[start] === endValue[start]; start++)
        ;
      var minEnd = startLength - start;
      for (end = 1; end <= minEnd && startValue[startLength - end] === endValue[endLength - end]; end++)
        ;
      var sliceTail = end > 1 ? 1 - end : void 0;
      return fallbackText = endValue.slice(start, sliceTail), fallbackText;
    }
    function getText() {
      return "value" in root ? root.value : root.textContent;
    }
    function getEventCharCode(nativeEvent) {
      var charCode, keyCode = nativeEvent.keyCode;
      return "charCode" in nativeEvent ? (charCode = nativeEvent.charCode, charCode === 0 && keyCode === 13 && (charCode = 13)) : charCode = keyCode, charCode === 10 && (charCode = 13), charCode >= 32 || charCode === 13 ? charCode : 0;
    }
    function functionThatReturnsTrue() {
      return !0;
    }
    function functionThatReturnsFalse() {
      return !1;
    }
    function createSyntheticEvent(Interface) {
      function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
        this._reactName = reactName, this._targetInst = targetInst, this.type = reactEventType, this.nativeEvent = nativeEvent, this.target = nativeEventTarget, this.currentTarget = null;
        for (var _propName in Interface)
          if (Interface.hasOwnProperty(_propName)) {
            var normalize2 = Interface[_propName];
            normalize2 ? this[_propName] = normalize2(nativeEvent) : this[_propName] = nativeEvent[_propName];
          }
        var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === !1;
        return defaultPrevented ? this.isDefaultPrevented = functionThatReturnsTrue : this.isDefaultPrevented = functionThatReturnsFalse, this.isPropagationStopped = functionThatReturnsFalse, this;
      }
      return assign2(SyntheticBaseEvent.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var event = this.nativeEvent;
          event && (event.preventDefault ? event.preventDefault() : typeof event.returnValue != "unknown" && (event.returnValue = !1), this.isDefaultPrevented = functionThatReturnsTrue);
        },
        stopPropagation: function() {
          var event = this.nativeEvent;
          event && (event.stopPropagation ? event.stopPropagation() : typeof event.cancelBubble != "unknown" && (event.cancelBubble = !0), this.isPropagationStopped = functionThatReturnsTrue);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: functionThatReturnsTrue
      }), SyntheticBaseEvent;
    }
    var EventInterface = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(event) {
        return event.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, SyntheticEvent = createSyntheticEvent(EventInterface), UIEventInterface = assign2({}, EventInterface, {
      view: 0,
      detail: 0
    }), SyntheticUIEvent = createSyntheticEvent(UIEventInterface), lastMovementX, lastMovementY, lastMouseEvent;
    function updateMouseMovementPolyfillState(event) {
      event !== lastMouseEvent && (lastMouseEvent && event.type === "mousemove" ? (lastMovementX = event.screenX - lastMouseEvent.screenX, lastMovementY = event.screenY - lastMouseEvent.screenY) : (lastMovementX = 0, lastMovementY = 0), lastMouseEvent = event);
    }
    var MouseEventInterface = assign2({}, UIEventInterface, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: getEventModifierState,
      button: 0,
      buttons: 0,
      relatedTarget: function(event) {
        return event.relatedTarget === void 0 ? event.fromElement === event.srcElement ? event.toElement : event.fromElement : event.relatedTarget;
      },
      movementX: function(event) {
        return "movementX" in event ? event.movementX : (updateMouseMovementPolyfillState(event), lastMovementX);
      },
      movementY: function(event) {
        return "movementY" in event ? event.movementY : lastMovementY;
      }
    }), SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface), DragEventInterface = assign2({}, MouseEventInterface, {
      dataTransfer: 0
    }), SyntheticDragEvent = createSyntheticEvent(DragEventInterface), FocusEventInterface = assign2({}, UIEventInterface, {
      relatedTarget: 0
    }), SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface), AnimationEventInterface = assign2({}, EventInterface, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface), ClipboardEventInterface = assign2({}, EventInterface, {
      clipboardData: function(event) {
        return "clipboardData" in event ? event.clipboardData : window.clipboardData;
      }
    }), SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface), CompositionEventInterface = assign2({}, EventInterface, {
      data: 0
    }), SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface), SyntheticInputEvent = SyntheticCompositionEvent, normalizeKey = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, translateToKey = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function getEventKey(nativeEvent) {
      if (nativeEvent.key) {
        var key2 = normalizeKey[nativeEvent.key] || nativeEvent.key;
        if (key2 !== "Unidentified")
          return key2;
      }
      if (nativeEvent.type === "keypress") {
        var charCode = getEventCharCode(nativeEvent);
        return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
      }
      return nativeEvent.type === "keydown" || nativeEvent.type === "keyup" ? translateToKey[nativeEvent.keyCode] || "Unidentified" : "";
    }
    var modifierKeyToProp = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function modifierStateGetter(keyArg) {
      var syntheticEvent = this, nativeEvent = syntheticEvent.nativeEvent;
      if (nativeEvent.getModifierState)
        return nativeEvent.getModifierState(keyArg);
      var keyProp = modifierKeyToProp[keyArg];
      return keyProp ? !!nativeEvent[keyProp] : !1;
    }
    function getEventModifierState(nativeEvent) {
      return modifierStateGetter;
    }
    var KeyboardEventInterface = assign2({}, UIEventInterface, {
      key: getEventKey,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: getEventModifierState,
      // Legacy Interface
      charCode: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : 0;
      },
      keyCode: function(event) {
        return event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
      },
      which: function(event) {
        return event.type === "keypress" ? getEventCharCode(event) : event.type === "keydown" || event.type === "keyup" ? event.keyCode : 0;
      }
    }), SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface), PointerEventInterface = assign2({}, MouseEventInterface, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface), TouchEventInterface = assign2({}, UIEventInterface, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: getEventModifierState
    }), SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface), TransitionEventInterface = assign2({}, EventInterface, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface), WheelEventInterface = assign2({}, MouseEventInterface, {
      deltaX: function(event) {
        return "deltaX" in event ? event.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in event ? -event.wheelDeltaX : 0
        );
      },
      deltaY: function(event) {
        return "deltaY" in event ? event.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in event ? -event.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in event ? -event.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface), END_KEYCODES = [9, 13, 27, 32], START_KEYCODE = 229, canUseCompositionEvent = canUseDOM && "CompositionEvent" in window, documentMode = null;
    canUseDOM && "documentMode" in document && (documentMode = document.documentMode);
    var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode, useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11), SPACEBAR_CODE = 32, SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
    function registerEvents() {
      registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var hasSpaceKeypress = !1;
    function isKeypressCommand(nativeEvent) {
      return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(nativeEvent.ctrlKey && nativeEvent.altKey);
    }
    function getCompositionEventType(domEventName) {
      switch (domEventName) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function isFallbackCompositionStart(domEventName, nativeEvent) {
      return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
    }
    function isFallbackCompositionEnd(domEventName, nativeEvent) {
      switch (domEventName) {
        case "keyup":
          return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
        case "keydown":
          return nativeEvent.keyCode !== START_KEYCODE;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function getDataFromCustomEvent(nativeEvent) {
      var detail = nativeEvent.detail;
      return typeof detail == "object" && "data" in detail ? detail.data : null;
    }
    function isUsingKoreanIME(nativeEvent) {
      return nativeEvent.locale === "ko";
    }
    var isComposing = !1;
    function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
      var eventType, fallbackData;
      if (canUseCompositionEvent ? eventType = getCompositionEventType(domEventName) : isComposing ? isFallbackCompositionEnd(domEventName, nativeEvent) && (eventType = "onCompositionEnd") : isFallbackCompositionStart(domEventName, nativeEvent) && (eventType = "onCompositionStart"), !eventType)
        return null;
      useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) && (!isComposing && eventType === "onCompositionStart" ? isComposing = initialize(nativeEventTarget) : eventType === "onCompositionEnd" && isComposing && (fallbackData = getData()));
      var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
      if (listeners.length > 0) {
        var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
        if (dispatchQueue.push({
          event,
          listeners
        }), fallbackData)
          event.data = fallbackData;
        else {
          var customData = getDataFromCustomEvent(nativeEvent);
          customData !== null && (event.data = customData);
        }
      }
    }
    function getNativeBeforeInputChars(domEventName, nativeEvent) {
      switch (domEventName) {
        case "compositionend":
          return getDataFromCustomEvent(nativeEvent);
        case "keypress":
          var which = nativeEvent.which;
          return which !== SPACEBAR_CODE ? null : (hasSpaceKeypress = !0, SPACEBAR_CHAR);
        case "textInput":
          var chars = nativeEvent.data;
          return chars === SPACEBAR_CHAR && hasSpaceKeypress ? null : chars;
        default:
          return null;
      }
    }
    function getFallbackBeforeInputChars(domEventName, nativeEvent) {
      if (isComposing) {
        if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
          var chars = getData();
          return reset(), isComposing = !1, chars;
        }
        return null;
      }
      switch (domEventName) {
        case "paste":
          return null;
        case "keypress":
          if (!isKeypressCommand(nativeEvent)) {
            if (nativeEvent.char && nativeEvent.char.length > 1)
              return nativeEvent.char;
            if (nativeEvent.which)
              return String.fromCharCode(nativeEvent.which);
          }
          return null;
        case "compositionend":
          return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
        default:
          return null;
      }
    }
    function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
      var chars;
      if (canUseTextInputEvent ? chars = getNativeBeforeInputChars(domEventName, nativeEvent) : chars = getFallbackBeforeInputChars(domEventName, nativeEvent), !chars)
        return null;
      var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
      if (listeners.length > 0) {
        var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
        dispatchQueue.push({
          event,
          listeners
        }), event.data = chars;
      }
    }
    function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
    }
    var supportedInputTypes = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function isTextInputElement(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === "input" ? !!supportedInputTypes[elem.type] : nodeName === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function isEventSupported(eventNameSuffix) {
      if (!canUseDOM)
        return !1;
      var eventName = "on" + eventNameSuffix, isSupported = eventName in document;
      if (!isSupported) {
        var element = document.createElement("div");
        element.setAttribute(eventName, "return;"), isSupported = typeof element[eventName] == "function";
      }
      return isSupported;
    }
    function registerEvents$1() {
      registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target2) {
      enqueueStateRestore(target2);
      var listeners = accumulateTwoPhaseListeners(inst, "onChange");
      if (listeners.length > 0) {
        var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target2);
        dispatchQueue.push({
          event,
          listeners
        });
      }
    }
    var activeElement = null, activeElementInst = null;
    function shouldUseChangeEvent(elem) {
      var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName === "select" || nodeName === "input" && elem.type === "file";
    }
    function manualDispatchChangeEvent(nativeEvent) {
      var dispatchQueue = [];
      createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent)), batchedUpdates(runEventInBatch, dispatchQueue);
    }
    function runEventInBatch(dispatchQueue) {
      processDispatchQueue(dispatchQueue, 0);
    }
    function getInstIfValueChanged(targetInst) {
      var targetNode = getNodeFromInstance(targetInst);
      if (updateValueIfChanged(targetNode))
        return targetInst;
    }
    function getTargetInstForChangeEvent(domEventName, targetInst) {
      if (domEventName === "change")
        return targetInst;
    }
    var isInputEventSupported = !1;
    canUseDOM && (isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9));
    function startWatchingForValueChange(target2, targetInst) {
      activeElement = target2, activeElementInst = targetInst, activeElement.attachEvent("onpropertychange", handlePropertyChange);
    }
    function stopWatchingForValueChange() {
      activeElement && (activeElement.detachEvent("onpropertychange", handlePropertyChange), activeElement = null, activeElementInst = null);
    }
    function handlePropertyChange(nativeEvent) {
      nativeEvent.propertyName === "value" && getInstIfValueChanged(activeElementInst) && manualDispatchChangeEvent(nativeEvent);
    }
    function handleEventsForInputEventPolyfill(domEventName, target2, targetInst) {
      domEventName === "focusin" ? (stopWatchingForValueChange(), startWatchingForValueChange(target2, targetInst)) : domEventName === "focusout" && stopWatchingForValueChange();
    }
    function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
      if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown")
        return getInstIfValueChanged(activeElementInst);
    }
    function shouldUseClickEvent(elem) {
      var nodeName = elem.nodeName;
      return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
    }
    function getTargetInstForClickEvent(domEventName, targetInst) {
      if (domEventName === "click")
        return getInstIfValueChanged(targetInst);
    }
    function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
      if (domEventName === "input" || domEventName === "change")
        return getInstIfValueChanged(targetInst);
    }
    function handleControlledInputBlur(node2) {
      var state = node2._wrapperState;
      !state || !state.controlled || node2.type !== "number" || setDefaultValue(node2, "number", node2.value);
    }
    function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      var targetNode = targetInst ? getNodeFromInstance(targetInst) : window, getTargetInstFunc, handleEventFunc;
      if (shouldUseChangeEvent(targetNode) ? getTargetInstFunc = getTargetInstForChangeEvent : isTextInputElement(targetNode) ? isInputEventSupported ? getTargetInstFunc = getTargetInstForInputOrChangeEvent : (getTargetInstFunc = getTargetInstForInputEventPolyfill, handleEventFunc = handleEventsForInputEventPolyfill) : shouldUseClickEvent(targetNode) && (getTargetInstFunc = getTargetInstForClickEvent), getTargetInstFunc) {
        var inst = getTargetInstFunc(domEventName, targetInst);
        if (inst) {
          createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
          return;
        }
      }
      handleEventFunc && handleEventFunc(domEventName, targetNode, targetInst), domEventName === "focusout" && handleControlledInputBlur(targetNode);
    }
    function registerEvents$2() {
      registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]), registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]), registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]), registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover", isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
      if (isOverEvent && !isReplayingEvent(nativeEvent)) {
        var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
        if (related && (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)))
          return;
      }
      if (!(!isOutEvent && !isOverEvent)) {
        var win;
        if (nativeEventTarget.window === nativeEventTarget)
          win = nativeEventTarget;
        else {
          var doc = nativeEventTarget.ownerDocument;
          doc ? win = doc.defaultView || doc.parentWindow : win = window;
        }
        var from2, to;
        if (isOutEvent) {
          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
          if (from2 = targetInst, to = _related ? getClosestInstanceFromNode(_related) : null, to !== null) {
            var nearestMounted = getNearestMountedFiber(to);
            (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) && (to = null);
          }
        } else
          from2 = null, to = targetInst;
        if (from2 !== to) {
          var SyntheticEventCtor = SyntheticMouseEvent, leaveEventType = "onMouseLeave", enterEventType = "onMouseEnter", eventTypePrefix = "mouse";
          (domEventName === "pointerout" || domEventName === "pointerover") && (SyntheticEventCtor = SyntheticPointerEvent, leaveEventType = "onPointerLeave", enterEventType = "onPointerEnter", eventTypePrefix = "pointer");
          var fromNode = from2 == null ? win : getNodeFromInstance(from2), toNode = to == null ? win : getNodeFromInstance(to), leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from2, nativeEvent, nativeEventTarget);
          leave.target = fromNode, leave.relatedTarget = toNode;
          var enter = null, nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
          if (nativeTargetInst === targetInst) {
            var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
            enterEvent.target = toNode, enterEvent.relatedTarget = fromNode, enter = enterEvent;
          }
          accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from2, to);
        }
      }
    }
    function is(x2, y2) {
      return x2 === y2 && (x2 !== 0 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
    }
    var objectIs = typeof Object.is == "function" ? Object.is : is;
    function shallowEqual(objA, objB) {
      if (objectIs(objA, objB))
        return !0;
      if (typeof objA != "object" || objA === null || typeof objB != "object" || objB === null)
        return !1;
      var keysA = Object.keys(objA), keysB = Object.keys(objB);
      if (keysA.length !== keysB.length)
        return !1;
      for (var i = 0; i < keysA.length; i++) {
        var currentKey = keysA[i];
        if (!hasOwnProperty2.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey]))
          return !1;
      }
      return !0;
    }
    function getLeafNode(node2) {
      for (; node2 && node2.firstChild; )
        node2 = node2.firstChild;
      return node2;
    }
    function getSiblingNode(node2) {
      for (; node2; ) {
        if (node2.nextSibling)
          return node2.nextSibling;
        node2 = node2.parentNode;
      }
    }
    function getNodeForCharacterOffset(root2, offset2) {
      for (var node2 = getLeafNode(root2), nodeStart = 0, nodeEnd = 0; node2; ) {
        if (node2.nodeType === TEXT_NODE) {
          if (nodeEnd = nodeStart + node2.textContent.length, nodeStart <= offset2 && nodeEnd >= offset2)
            return {
              node: node2,
              offset: offset2 - nodeStart
            };
          nodeStart = nodeEnd;
        }
        node2 = getLeafNode(getSiblingNode(node2));
      }
    }
    function getOffsets(outerNode) {
      var ownerDocument = outerNode.ownerDocument, win = ownerDocument && ownerDocument.defaultView || window, selection = win.getSelection && win.getSelection();
      if (!selection || selection.rangeCount === 0)
        return null;
      var anchorNode = selection.anchorNode, anchorOffset = selection.anchorOffset, focusNode = selection.focusNode, focusOffset = selection.focusOffset;
      try {
        anchorNode.nodeType, focusNode.nodeType;
      } catch {
        return null;
      }
      return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
    }
    function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
      var length2 = 0, start = -1, end = -1, indexWithinAnchor = 0, indexWithinFocus = 0, node2 = outerNode, parentNode = null;
      outer: for (; ; ) {
        for (var next2 = null; node2 === anchorNode && (anchorOffset === 0 || node2.nodeType === TEXT_NODE) && (start = length2 + anchorOffset), node2 === focusNode && (focusOffset === 0 || node2.nodeType === TEXT_NODE) && (end = length2 + focusOffset), node2.nodeType === TEXT_NODE && (length2 += node2.nodeValue.length), (next2 = node2.firstChild) !== null; )
          parentNode = node2, node2 = next2;
        for (; ; ) {
          if (node2 === outerNode)
            break outer;
          if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset && (start = length2), parentNode === focusNode && ++indexWithinFocus === focusOffset && (end = length2), (next2 = node2.nextSibling) !== null)
            break;
          node2 = parentNode, parentNode = node2.parentNode;
        }
        node2 = next2;
      }
      return start === -1 || end === -1 ? null : {
        start,
        end
      };
    }
    function setOffsets(node2, offsets) {
      var doc = node2.ownerDocument || document, win = doc && doc.defaultView || window;
      if (win.getSelection) {
        var selection = win.getSelection(), length2 = node2.textContent.length, start = Math.min(offsets.start, length2), end = offsets.end === void 0 ? start : Math.min(offsets.end, length2);
        if (!selection.extend && start > end) {
          var temp = end;
          end = start, start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node2, start), endMarker = getNodeForCharacterOffset(node2, end);
        if (startMarker && endMarker) {
          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset)
            return;
          var range2 = doc.createRange();
          range2.setStart(startMarker.node, startMarker.offset), selection.removeAllRanges(), start > end ? (selection.addRange(range2), selection.extend(endMarker.node, endMarker.offset)) : (range2.setEnd(endMarker.node, endMarker.offset), selection.addRange(range2));
        }
      }
    }
    function isTextNode(node2) {
      return node2 && node2.nodeType === TEXT_NODE;
    }
    function containsNode(outerNode, innerNode) {
      return !outerNode || !innerNode ? !1 : outerNode === innerNode ? !0 : isTextNode(outerNode) ? !1 : isTextNode(innerNode) ? containsNode(outerNode, innerNode.parentNode) : "contains" in outerNode ? outerNode.contains(innerNode) : outerNode.compareDocumentPosition ? !!(outerNode.compareDocumentPosition(innerNode) & 16) : !1;
    }
    function isInDocument(node2) {
      return node2 && node2.ownerDocument && containsNode(node2.ownerDocument.documentElement, node2);
    }
    function isSameOriginFrame(iframe) {
      try {
        return typeof iframe.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function getActiveElementDeep() {
      for (var win = window, element = getActiveElement(); element instanceof win.HTMLIFrameElement; ) {
        if (isSameOriginFrame(element))
          win = element.contentWindow;
        else
          return element;
        element = getActiveElement(win.document);
      }
      return element;
    }
    function hasSelectionCapabilities(elem) {
      var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
      return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
    }
    function getSelectionInformation() {
      var focusedElem = getActiveElementDeep();
      return {
        focusedElem,
        selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
      };
    }
    function restoreSelection(priorSelectionInformation) {
      var curFocusedElem = getActiveElementDeep(), priorFocusedElem = priorSelectionInformation.focusedElem, priorSelectionRange = priorSelectionInformation.selectionRange;
      if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
        priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem) && setSelection(priorFocusedElem, priorSelectionRange);
        for (var ancestors = [], ancestor = priorFocusedElem; ancestor = ancestor.parentNode; )
          ancestor.nodeType === ELEMENT_NODE && ancestors.push({
            element: ancestor,
            left: ancestor.scrollLeft,
            top: ancestor.scrollTop
          });
        typeof priorFocusedElem.focus == "function" && priorFocusedElem.focus();
        for (var i = 0; i < ancestors.length; i++) {
          var info2 = ancestors[i];
          info2.element.scrollLeft = info2.left, info2.element.scrollTop = info2.top;
        }
      }
    }
    function getSelection(input) {
      var selection;
      return "selectionStart" in input ? selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      } : selection = getOffsets(input), selection || {
        start: 0,
        end: 0
      };
    }
    function setSelection(input, offsets) {
      var start = offsets.start, end = offsets.end;
      end === void 0 && (end = start), "selectionStart" in input ? (input.selectionStart = start, input.selectionEnd = Math.min(end, input.value.length)) : setOffsets(input, offsets);
    }
    var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
    function registerEvents$3() {
      registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var activeElement$1 = null, activeElementInst$1 = null, lastSelection = null, mouseDown = !1;
    function getSelection$1(node2) {
      if ("selectionStart" in node2 && hasSelectionCapabilities(node2))
        return {
          start: node2.selectionStart,
          end: node2.selectionEnd
        };
      var win = node2.ownerDocument && node2.ownerDocument.defaultView || window, selection = win.getSelection();
      return {
        anchorNode: selection.anchorNode,
        anchorOffset: selection.anchorOffset,
        focusNode: selection.focusNode,
        focusOffset: selection.focusOffset
      };
    }
    function getEventTargetDocument(eventTarget) {
      return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
    }
    function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
      var doc = getEventTargetDocument(nativeEventTarget);
      if (!(mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc))) {
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            }), event.target = activeElement$1;
          }
        }
      }
    }
    function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
      switch (domEventName) {
        case "focusin":
          (isTextInputElement(targetNode) || targetNode.contentEditable === "true") && (activeElement$1 = targetNode, activeElementInst$1 = targetInst, lastSelection = null);
          break;
        case "focusout":
          activeElement$1 = null, activeElementInst$1 = null, lastSelection = null;
          break;
        case "mousedown":
          mouseDown = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          mouseDown = !1, constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
          break;
        case "selectionchange":
          if (skipSelectionChangeEvent)
            break;
        case "keydown":
        case "keyup":
          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
      }
    }
    function makePrefixMap(styleProp, eventName) {
      var prefixes2 = {};
      return prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase(), prefixes2["Webkit" + styleProp] = "webkit" + eventName, prefixes2["Moz" + styleProp] = "moz" + eventName, prefixes2;
    }
    var vendorPrefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      animationiteration: makePrefixMap("Animation", "AnimationIteration"),
      animationstart: makePrefixMap("Animation", "AnimationStart"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    }, prefixedEventNames = {}, style2 = {};
    canUseDOM && (style2 = document.createElement("div").style, "AnimationEvent" in window || (delete vendorPrefixes.animationend.animation, delete vendorPrefixes.animationiteration.animation, delete vendorPrefixes.animationstart.animation), "TransitionEvent" in window || delete vendorPrefixes.transitionend.transition);
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName])
        return prefixedEventNames[eventName];
      if (!vendorPrefixes[eventName])
        return eventName;
      var prefixMap = vendorPrefixes[eventName];
      for (var styleProp in prefixMap)
        if (prefixMap.hasOwnProperty(styleProp) && styleProp in style2)
          return prefixedEventNames[eventName] = prefixMap[styleProp];
      return eventName;
    }
    var ANIMATION_END = getVendorPrefixedEventName("animationend"), ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration"), ANIMATION_START = getVendorPrefixedEventName("animationstart"), TRANSITION_END = getVendorPrefixedEventName("transitionend"), topLevelEventsToReactNames = /* @__PURE__ */ new Map(), simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function registerSimpleEvent(domEventName, reactName) {
      topLevelEventsToReactNames.set(domEventName, reactName), registerTwoPhaseEvent(reactName, [domEventName]);
    }
    function registerSimpleEvents() {
      for (var i = 0; i < simpleEventPluginEvents.length; i++) {
        var eventName = simpleEventPluginEvents[i], domEventName = eventName.toLowerCase(), capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
        registerSimpleEvent(domEventName, "on" + capitalizedEvent);
      }
      registerSimpleEvent(ANIMATION_END, "onAnimationEnd"), registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration"), registerSimpleEvent(ANIMATION_START, "onAnimationStart"), registerSimpleEvent("dblclick", "onDoubleClick"), registerSimpleEvent("focusin", "onFocus"), registerSimpleEvent("focusout", "onBlur"), registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
    }
    function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      var reactName = topLevelEventsToReactNames.get(domEventName);
      if (reactName !== void 0) {
        var SyntheticEventCtor = SyntheticEvent, reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0)
              return;
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus", SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur", SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2)
              return;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        {
          var accumulateTargetOnly = !inCapturePhase && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          domEventName === "scroll", _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
          if (_listeners.length > 0) {
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: _event,
              listeners: _listeners
            });
          }
        }
      }
    }
    registerSimpleEvents(), registerEvents$2(), registerEvents$1(), registerEvents$3(), registerEvents();
    function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
      extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
      var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
      shouldProcessPolyfillPlugins && (extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget), extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget));
    }
    var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
    function executeDispatch(event, listener, currentTarget) {
      var type = event.type || "unknown-event";
      event.currentTarget = currentTarget, invokeGuardedCallbackAndCatchFirstError(type, listener, void 0, event), event.currentTarget = null;
    }
    function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
      var previousInstance;
      if (inCapturePhase)
        for (var i = dispatchListeners.length - 1; i >= 0; i--) {
          var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
          if (instance !== previousInstance && event.isPropagationStopped())
            return;
          executeDispatch(event, listener, currentTarget), previousInstance = instance;
        }
      else
        for (var _i = 0; _i < dispatchListeners.length; _i++) {
          var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
          if (_instance !== previousInstance && event.isPropagationStopped())
            return;
          executeDispatch(event, _listener, _currentTarget), previousInstance = _instance;
        }
    }
    function processDispatchQueue(dispatchQueue, eventSystemFlags) {
      for (var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0, i = 0; i < dispatchQueue.length; i++) {
        var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
        processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
      }
      rethrowCaughtError();
    }
    function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
      var nativeEventTarget = getEventTarget(nativeEvent), dispatchQueue = [];
      extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags), processDispatchQueue(dispatchQueue, eventSystemFlags);
    }
    function listenToNonDelegatedEvent(domEventName, targetElement) {
      nonDelegatedEvents.has(domEventName) || error('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', domEventName);
      var isCapturePhaseListener = !1, listenerSet = getEventListenerSet(targetElement), listenerSetKey = getListenerSetKey(domEventName);
      listenerSet.has(listenerSetKey) || (addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener), listenerSet.add(listenerSetKey));
    }
    function listenToNativeEvent(domEventName, isCapturePhaseListener, target2) {
      nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener && error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', domEventName);
      var eventSystemFlags = 0;
      isCapturePhaseListener && (eventSystemFlags |= IS_CAPTURE_PHASE), addTrappedEventListener(target2, domEventName, eventSystemFlags, isCapturePhaseListener);
    }
    var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
    function listenToAllSupportedEvents(rootContainerElement) {
      if (!rootContainerElement[listeningMarker]) {
        rootContainerElement[listeningMarker] = !0, allNativeEvents.forEach(function(domEventName) {
          domEventName !== "selectionchange" && (nonDelegatedEvents.has(domEventName) || listenToNativeEvent(domEventName, !1, rootContainerElement), listenToNativeEvent(domEventName, !0, rootContainerElement));
        });
        var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
        ownerDocument !== null && (ownerDocument[listeningMarker] || (ownerDocument[listeningMarker] = !0, listenToNativeEvent("selectionchange", !1, ownerDocument)));
      }
    }
    function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
      var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags), isPassiveListener = void 0;
      passiveBrowserEventsSupported && (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") && (isPassiveListener = !0), targetContainer = targetContainer, isCapturePhaseListener ? isPassiveListener !== void 0 ? addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener) : addEventCaptureListener(targetContainer, domEventName, listener) : isPassiveListener !== void 0 ? addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener) : addEventBubbleListener(targetContainer, domEventName, listener);
    }
    function isMatchingRootContainer(grandContainer, targetContainer) {
      return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
    }
    function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
      var ancestorInst = targetInst;
      if (!(eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) && !(eventSystemFlags & IS_NON_DELEGATED)) {
        var targetContainerNode = targetContainer;
        if (targetInst !== null) {
          var node2 = targetInst;
          mainLoop: for (; ; ) {
            if (node2 === null)
              return;
            var nodeTag = node2.tag;
            if (nodeTag === HostRoot || nodeTag === HostPortal) {
              var container = node2.stateNode.containerInfo;
              if (isMatchingRootContainer(container, targetContainerNode))
                break;
              if (nodeTag === HostPortal)
                for (var grandNode = node2.return; grandNode !== null; ) {
                  var grandTag = grandNode.tag;
                  if (grandTag === HostRoot || grandTag === HostPortal) {
                    var grandContainer = grandNode.stateNode.containerInfo;
                    if (isMatchingRootContainer(grandContainer, targetContainerNode))
                      return;
                  }
                  grandNode = grandNode.return;
                }
              for (; container !== null; ) {
                var parentNode = getClosestInstanceFromNode(container);
                if (parentNode === null)
                  return;
                var parentTag = parentNode.tag;
                if (parentTag === HostComponent || parentTag === HostText) {
                  node2 = ancestorInst = parentNode;
                  continue mainLoop;
                }
                container = container.parentNode;
              }
            }
            node2 = node2.return;
          }
        }
      }
      batchedUpdates(function() {
        return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
      });
    }
    function createDispatchListener(instance, listener, currentTarget) {
      return {
        instance,
        listener,
        currentTarget
      };
    }
    function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
      for (var captureName = reactName !== null ? reactName + "Capture" : null, reactEventName = inCapturePhase ? captureName : reactName, listeners = [], instance = targetFiber, lastHostComponent = null; instance !== null; ) {
        var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
        if (tag === HostComponent && stateNode !== null && (lastHostComponent = stateNode, reactEventName !== null)) {
          var listener = getListener(instance, reactEventName);
          listener != null && listeners.push(createDispatchListener(instance, listener, lastHostComponent));
        }
        if (accumulateTargetOnly)
          break;
        instance = instance.return;
      }
      return listeners;
    }
    function accumulateTwoPhaseListeners(targetFiber, reactName) {
      for (var captureName = reactName + "Capture", listeners = [], instance = targetFiber; instance !== null; ) {
        var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
        if (tag === HostComponent && stateNode !== null) {
          var currentTarget = stateNode, captureListener = getListener(instance, captureName);
          captureListener != null && listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
          var bubbleListener = getListener(instance, reactName);
          bubbleListener != null && listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
        }
        instance = instance.return;
      }
      return listeners;
    }
    function getParent(inst) {
      if (inst === null)
        return null;
      do
        inst = inst.return;
      while (inst && inst.tag !== HostComponent);
      return inst || null;
    }
    function getLowestCommonAncestor(instA, instB) {
      for (var nodeA = instA, nodeB = instB, depthA = 0, tempA = nodeA; tempA; tempA = getParent(tempA))
        depthA++;
      for (var depthB = 0, tempB = nodeB; tempB; tempB = getParent(tempB))
        depthB++;
      for (; depthA - depthB > 0; )
        nodeA = getParent(nodeA), depthA--;
      for (; depthB - depthA > 0; )
        nodeB = getParent(nodeB), depthB--;
      for (var depth = depthA; depth--; ) {
        if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate)
          return nodeA;
        nodeA = getParent(nodeA), nodeB = getParent(nodeB);
      }
      return null;
    }
    function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target2, common, inCapturePhase) {
      for (var registrationName = event._reactName, listeners = [], instance = target2; instance !== null && instance !== common; ) {
        var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
        if (alternate !== null && alternate === common)
          break;
        if (tag === HostComponent && stateNode !== null) {
          var currentTarget = stateNode;
          if (inCapturePhase) {
            var captureListener = getListener(instance, registrationName);
            captureListener != null && listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
          } else if (!inCapturePhase) {
            var bubbleListener = getListener(instance, registrationName);
            bubbleListener != null && listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
          }
        }
        instance = instance.return;
      }
      listeners.length !== 0 && dispatchQueue.push({
        event,
        listeners
      });
    }
    function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from2, to) {
      var common = from2 && to ? getLowestCommonAncestor(from2, to) : null;
      from2 !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from2, common, !1), to !== null && enterEvent !== null && accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, !0);
    }
    function getListenerSetKey(domEventName, capture2) {
      return domEventName + "__bubble";
    }
    var didWarnInvalidHydration = !1, DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML", SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning", SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning", AUTOFOCUS = "autoFocus", CHILDREN = "children", STYLE = "style", HTML$1 = "__html", warnedUnknownTags, validatePropertiesInDevelopment, warnForPropDifference, warnForExtraAttributes, warnForInvalidEventListener, canDiffStyleForHydrationWarning, normalizeHTML;
    warnedUnknownTags = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, validatePropertiesInDevelopment = function(type, props) {
      validateProperties(type, props), validateProperties$1(type, props), validateProperties$2(type, props, {
        registrationNameDependencies,
        possibleRegistrationNames
      });
    }, canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode, warnForPropDifference = function(propName, serverValue, clientValue) {
      if (!didWarnInvalidHydration) {
        var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue), normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
        normalizedServerValue !== normalizedClientValue && (didWarnInvalidHydration = !0, error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue)));
      }
    }, warnForExtraAttributes = function(attributeNames) {
      if (!didWarnInvalidHydration) {
        didWarnInvalidHydration = !0;
        var names = [];
        attributeNames.forEach(function(name2) {
          names.push(name2);
        }), error("Extra attributes from the server: %s", names);
      }
    }, warnForInvalidEventListener = function(registrationName, listener) {
      listener === !1 ? error("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName) : error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
    }, normalizeHTML = function(parent, html2) {
      var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
      return testElement.innerHTML = html2, testElement.innerHTML;
    };
    var NORMALIZE_NEWLINES_REGEX = /\r\n?/g, NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
    function normalizeMarkupForTextOrAttribute(markup2) {
      checkHtmlStringCoercion(markup2);
      var markupString = typeof markup2 == "string" ? markup2 : "" + markup2;
      return markupString.replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
    }
    function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
      var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText), normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
      if (normalizedServerText !== normalizedClientText && (shouldWarnDev && (didWarnInvalidHydration || (didWarnInvalidHydration = !0, error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText))), isConcurrentMode && enableClientRenderFallbackOnTextMismatch))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function getOwnerDocumentFromRootContainer(rootContainerElement) {
      return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
    }
    function noop2() {
    }
    function trapClickOnNonInteractiveElement(node2) {
      node2.onclick = noop2;
    }
    function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
      for (var propKey in nextProps)
        if (nextProps.hasOwnProperty(propKey)) {
          var nextProp = nextProps[propKey];
          if (propKey === STYLE)
            nextProp && Object.freeze(nextProp), setValueForStyles(domElement, nextProp);
          else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0;
            nextHtml != null && setInnerHTML(domElement, nextHtml);
          } else if (propKey === CHILDREN)
            if (typeof nextProp == "string") {
              var canSetTextContent = tag !== "textarea" || nextProp !== "";
              canSetTextContent && setTextContent(domElement, nextProp);
            } else typeof nextProp == "number" && setTextContent(domElement, "" + nextProp);
          else propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === AUTOFOCUS || (registrationNameDependencies.hasOwnProperty(propKey) ? nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement)) : nextProp != null && setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag));
        }
    }
    function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
      for (var i = 0; i < updatePayload.length; i += 2) {
        var propKey = updatePayload[i], propValue = updatePayload[i + 1];
        propKey === STYLE ? setValueForStyles(domElement, propValue) : propKey === DANGEROUSLY_SET_INNER_HTML ? setInnerHTML(domElement, propValue) : propKey === CHILDREN ? setTextContent(domElement, propValue) : setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
      }
    }
    function createElement2(type, props, rootContainerElement, parentNamespace) {
      var isCustomComponentTag, ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement), domElement, namespaceURI = parentNamespace;
      if (namespaceURI === HTML_NAMESPACE && (namespaceURI = getIntrinsicNamespace(type)), namespaceURI === HTML_NAMESPACE) {
        if (isCustomComponentTag = isCustomComponent(type, props), !isCustomComponentTag && type !== type.toLowerCase() && error("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", type), type === "script") {
          var div2 = ownerDocument.createElement("div");
          div2.innerHTML = "<script><\/script>";
          var firstChild = div2.firstChild;
          domElement = div2.removeChild(firstChild);
        } else if (typeof props.is == "string")
          domElement = ownerDocument.createElement(type, {
            is: props.is
          });
        else if (domElement = ownerDocument.createElement(type), type === "select") {
          var node2 = domElement;
          props.multiple ? node2.multiple = !0 : props.size && (node2.size = props.size);
        }
      } else
        domElement = ownerDocument.createElementNS(namespaceURI, type);
      return namespaceURI === HTML_NAMESPACE && !isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty2.call(warnedUnknownTags, type) && (warnedUnknownTags[type] = !0, error("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", type)), domElement;
    }
    function createTextNode(text, rootContainerElement) {
      return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
    }
    function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
      var isCustomComponentTag = isCustomComponent(tag, rawProps);
      validatePropertiesInDevelopment(tag, rawProps);
      var props;
      switch (tag) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", domElement), listenToNonDelegatedEvent("close", domElement), props = rawProps;
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", domElement), props = rawProps;
          break;
        case "video":
        case "audio":
          for (var i = 0; i < mediaEventTypes.length; i++)
            listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
          props = rawProps;
          break;
        case "source":
          listenToNonDelegatedEvent("error", domElement), props = rawProps;
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement), props = rawProps;
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement), props = rawProps;
          break;
        case "input":
          initWrapperState(domElement, rawProps), props = getHostProps(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
        case "option":
          validateProps(domElement, rawProps), props = rawProps;
          break;
        case "select":
          initWrapperState$1(domElement, rawProps), props = getHostProps$1(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
        case "textarea":
          initWrapperState$2(domElement, rawProps), props = getHostProps$2(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
        default:
          props = rawProps;
      }
      switch (assertValidProps(tag, props), setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag), tag) {
        case "input":
          track(domElement), postMountWrapper(domElement, rawProps, !1);
          break;
        case "textarea":
          track(domElement), postMountWrapper$3(domElement);
          break;
        case "option":
          postMountWrapper$1(domElement, rawProps);
          break;
        case "select":
          postMountWrapper$2(domElement, rawProps);
          break;
        default:
          typeof props.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
          break;
      }
    }
    function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
      validatePropertiesInDevelopment(tag, nextRawProps);
      var updatePayload = null, lastProps, nextProps;
      switch (tag) {
        case "input":
          lastProps = getHostProps(domElement, lastRawProps), nextProps = getHostProps(domElement, nextRawProps), updatePayload = [];
          break;
        case "select":
          lastProps = getHostProps$1(domElement, lastRawProps), nextProps = getHostProps$1(domElement, nextRawProps), updatePayload = [];
          break;
        case "textarea":
          lastProps = getHostProps$2(domElement, lastRawProps), nextProps = getHostProps$2(domElement, nextRawProps), updatePayload = [];
          break;
        default:
          lastProps = lastRawProps, nextProps = nextRawProps, typeof lastProps.onClick != "function" && typeof nextProps.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
          break;
      }
      assertValidProps(tag, nextProps);
      var propKey, styleName, styleUpdates = null;
      for (propKey in lastProps)
        if (!(nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null))
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle)
              lastStyle.hasOwnProperty(styleName) && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = "");
          } else propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN || propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === AUTOFOCUS || (registrationNameDependencies.hasOwnProperty(propKey) ? updatePayload || (updatePayload = []) : (updatePayload = updatePayload || []).push(propKey, null));
      for (propKey in nextProps) {
        var nextProp = nextProps[propKey], lastProp = lastProps?.[propKey];
        if (!(!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null))
          if (propKey === STYLE)
            if (nextProp && Object.freeze(nextProp), lastProp) {
              for (styleName in lastProp)
                lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName)) && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = "");
              for (styleName in nextProp)
                nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName] && (styleUpdates || (styleUpdates = {}), styleUpdates[styleName] = nextProp[styleName]);
            } else
              styleUpdates || (updatePayload || (updatePayload = []), updatePayload.push(propKey, styleUpdates)), styleUpdates = nextProp;
          else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : void 0, lastHtml = lastProp ? lastProp[HTML$1] : void 0;
            nextHtml != null && lastHtml !== nextHtml && (updatePayload = updatePayload || []).push(propKey, nextHtml);
          } else propKey === CHILDREN ? (typeof nextProp == "string" || typeof nextProp == "number") && (updatePayload = updatePayload || []).push(propKey, "" + nextProp) : propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || (registrationNameDependencies.hasOwnProperty(propKey) ? (nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement)), !updatePayload && lastProp !== nextProp && (updatePayload = [])) : (updatePayload = updatePayload || []).push(propKey, nextProp));
      }
      return styleUpdates && (validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]), (updatePayload = updatePayload || []).push(STYLE, styleUpdates)), updatePayload;
    }
    function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
      tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null && updateChecked(domElement, nextRawProps);
      var wasCustomComponentTag = isCustomComponent(tag, lastRawProps), isCustomComponentTag = isCustomComponent(tag, nextRawProps);
      switch (updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag), tag) {
        case "input":
          updateWrapper(domElement, nextRawProps);
          break;
        case "textarea":
          updateWrapper$1(domElement, nextRawProps);
          break;
        case "select":
          postUpdateWrapper(domElement, nextRawProps);
          break;
      }
    }
    function getPossibleStandardName(propName) {
      {
        var lowerCasedName = propName.toLowerCase();
        return possibleStandardNames.hasOwnProperty(lowerCasedName) && possibleStandardNames[lowerCasedName] || null;
      }
    }
    function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
      var isCustomComponentTag, extraAttributeNames;
      switch (isCustomComponentTag = isCustomComponent(tag, rawProps), validatePropertiesInDevelopment(tag, rawProps), tag) {
        case "dialog":
          listenToNonDelegatedEvent("cancel", domElement), listenToNonDelegatedEvent("close", domElement);
          break;
        case "iframe":
        case "object":
        case "embed":
          listenToNonDelegatedEvent("load", domElement);
          break;
        case "video":
        case "audio":
          for (var i = 0; i < mediaEventTypes.length; i++)
            listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
          break;
        case "source":
          listenToNonDelegatedEvent("error", domElement);
          break;
        case "img":
        case "image":
        case "link":
          listenToNonDelegatedEvent("error", domElement), listenToNonDelegatedEvent("load", domElement);
          break;
        case "details":
          listenToNonDelegatedEvent("toggle", domElement);
          break;
        case "input":
          initWrapperState(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
        case "option":
          validateProps(domElement, rawProps);
          break;
        case "select":
          initWrapperState$1(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
        case "textarea":
          initWrapperState$2(domElement, rawProps), listenToNonDelegatedEvent("invalid", domElement);
          break;
      }
      assertValidProps(tag, rawProps);
      {
        extraAttributeNames = /* @__PURE__ */ new Set();
        for (var attributes2 = domElement.attributes, _i = 0; _i < attributes2.length; _i++) {
          var name2 = attributes2[_i].name.toLowerCase();
          switch (name2) {
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              extraAttributeNames.add(attributes2[_i].name);
          }
        }
      }
      var updatePayload = null;
      for (var propKey in rawProps)
        if (rawProps.hasOwnProperty(propKey)) {
          var nextProp = rawProps[propKey];
          if (propKey === CHILDREN)
            typeof nextProp == "string" ? domElement.textContent !== nextProp && (rawProps[SUPPRESS_HYDRATION_WARNING] !== !0 && checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev), updatePayload = [CHILDREN, nextProp]) : typeof nextProp == "number" && domElement.textContent !== "" + nextProp && (rawProps[SUPPRESS_HYDRATION_WARNING] !== !0 && checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev), updatePayload = [CHILDREN, "" + nextProp]);
          else if (registrationNameDependencies.hasOwnProperty(propKey))
            nextProp != null && (typeof nextProp != "function" && warnForInvalidEventListener(propKey, nextProp), propKey === "onScroll" && listenToNonDelegatedEvent("scroll", domElement));
          else if (shouldWarnDev && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof isCustomComponentTag == "boolean") {
            var serverValue = void 0, propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
            if (rawProps[SUPPRESS_HYDRATION_WARNING] !== !0) {
              if (!(propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              propKey === "value" || propKey === "checked" || propKey === "selected")) {
                if (propKey === DANGEROUSLY_SET_INNER_HTML) {
                  var serverHTML = domElement.innerHTML, nextHtml = nextProp ? nextProp[HTML$1] : void 0;
                  if (nextHtml != null) {
                    var expectedHTML = normalizeHTML(domElement, nextHtml);
                    expectedHTML !== serverHTML && warnForPropDifference(propKey, serverHTML, expectedHTML);
                  }
                } else if (propKey === STYLE) {
                  if (extraAttributeNames.delete(propKey), canDiffStyleForHydrationWarning) {
                    var expectedStyle = createDangerousStringForStyles(nextProp);
                    serverValue = domElement.getAttribute("style"), expectedStyle !== serverValue && warnForPropDifference(propKey, serverValue, expectedStyle);
                  }
                } else if (isCustomComponentTag && !enableCustomElementPropertySupport)
                  extraAttributeNames.delete(propKey.toLowerCase()), serverValue = getValueForAttribute(domElement, propKey, nextProp), nextProp !== serverValue && warnForPropDifference(propKey, serverValue, nextProp);
                else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
                  var isMismatchDueToBadCasing = !1;
                  if (propertyInfo !== null)
                    extraAttributeNames.delete(propertyInfo.attributeName), serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
                  else {
                    var ownNamespace = parentNamespace;
                    if (ownNamespace === HTML_NAMESPACE && (ownNamespace = getIntrinsicNamespace(tag)), ownNamespace === HTML_NAMESPACE)
                      extraAttributeNames.delete(propKey.toLowerCase());
                    else {
                      var standardName = getPossibleStandardName(propKey);
                      standardName !== null && standardName !== propKey && (isMismatchDueToBadCasing = !0, extraAttributeNames.delete(standardName)), extraAttributeNames.delete(propKey);
                    }
                    serverValue = getValueForAttribute(domElement, propKey, nextProp);
                  }
                  var dontWarnCustomElement = enableCustomElementPropertySupport;
                  !dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing && warnForPropDifference(propKey, serverValue, nextProp);
                }
              }
            }
          }
        }
      switch (shouldWarnDev && // $FlowFixMe - Should be inferred as not undefined.
      extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== !0 && warnForExtraAttributes(extraAttributeNames), tag) {
        case "input":
          track(domElement), postMountWrapper(domElement, rawProps, !0);
          break;
        case "textarea":
          track(domElement), postMountWrapper$3(domElement);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof rawProps.onClick == "function" && trapClickOnNonInteractiveElement(domElement);
          break;
      }
      return updatePayload;
    }
    function diffHydratedText(textNode, text, isConcurrentMode) {
      var isDifferent = textNode.nodeValue !== text;
      return isDifferent;
    }
    function warnForDeletedHydratableElement(parentNode, child) {
      {
        if (didWarnInvalidHydration)
          return;
        didWarnInvalidHydration = !0, error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
      }
    }
    function warnForDeletedHydratableText(parentNode, child) {
      {
        if (didWarnInvalidHydration)
          return;
        didWarnInvalidHydration = !0, error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
      }
    }
    function warnForInsertedHydratedElement(parentNode, tag, props) {
      {
        if (didWarnInvalidHydration)
          return;
        didWarnInvalidHydration = !0, error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
      }
    }
    function warnForInsertedHydratedText(parentNode, text) {
      {
        if (text === "" || didWarnInvalidHydration)
          return;
        didWarnInvalidHydration = !0, error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
      }
    }
    function restoreControlledState$3(domElement, tag, props) {
      switch (tag) {
        case "input":
          restoreControlledState(domElement, props);
          return;
        case "textarea":
          restoreControlledState$2(domElement, props);
          return;
        case "select":
          restoreControlledState$1(domElement, props);
          return;
      }
    }
    var validateDOMNesting = function() {
    }, updatedAncestorInfo = function() {
    };
    {
      var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], inScopeTags = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], buttonScopeTags = inScopeTags.concat(["button"]), impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], emptyAncestorInfo = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      updatedAncestorInfo = function(oldInfo, tag) {
        var ancestorInfo = assign2({}, oldInfo || emptyAncestorInfo), info2 = {
          tag
        };
        return inScopeTags.indexOf(tag) !== -1 && (ancestorInfo.aTagInScope = null, ancestorInfo.buttonTagInScope = null, ancestorInfo.nobrTagInScope = null), buttonScopeTags.indexOf(tag) !== -1 && (ancestorInfo.pTagInButtonScope = null), specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p" && (ancestorInfo.listItemTagAutoclosing = null, ancestorInfo.dlItemTagAutoclosing = null), ancestorInfo.current = info2, tag === "form" && (ancestorInfo.formTag = info2), tag === "a" && (ancestorInfo.aTagInScope = info2), tag === "button" && (ancestorInfo.buttonTagInScope = info2), tag === "nobr" && (ancestorInfo.nobrTagInScope = info2), tag === "p" && (ancestorInfo.pTagInButtonScope = info2), tag === "li" && (ancestorInfo.listItemTagAutoclosing = info2), (tag === "dd" || tag === "dt") && (ancestorInfo.dlItemTagAutoclosing = info2), ancestorInfo;
      };
      var isTagValidWithParent = function(tag, parentTag) {
        switch (parentTag) {
          case "select":
            return tag === "option" || tag === "optgroup" || tag === "#text";
          case "optgroup":
            return tag === "option" || tag === "#text";
          case "option":
            return tag === "#text";
          case "tr":
            return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
          case "tbody":
          case "thead":
          case "tfoot":
            return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
          case "colgroup":
            return tag === "col" || tag === "template";
          case "table":
            return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
          case "head":
            return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
          case "html":
            return tag === "head" || tag === "body" || tag === "frameset";
          case "frameset":
            return tag === "frame";
          case "#document":
            return tag === "html";
        }
        switch (tag) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
          case "rp":
          case "rt":
            return impliedEndTags.indexOf(parentTag) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return parentTag == null;
        }
        return !0;
      }, findInvalidAncestorForTag = function(tag, ancestorInfo) {
        switch (tag) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return ancestorInfo.pTagInButtonScope;
          case "form":
            return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
          case "li":
            return ancestorInfo.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return ancestorInfo.dlItemTagAutoclosing;
          case "button":
            return ancestorInfo.buttonTagInScope;
          case "a":
            return ancestorInfo.aTagInScope;
          case "nobr":
            return ancestorInfo.nobrTagInScope;
        }
        return null;
      }, didWarn$1 = {};
      validateDOMNesting = function(childTag, childText, ancestorInfo) {
        ancestorInfo = ancestorInfo || emptyAncestorInfo;
        var parentInfo = ancestorInfo.current, parentTag = parentInfo && parentInfo.tag;
        childText != null && (childTag != null && error("validateDOMNesting: when childText is passed, childTag should be null"), childTag = "#text");
        var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo, invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo), invalidParentOrAncestor = invalidParent || invalidAncestor;
        if (invalidParentOrAncestor) {
          var ancestorTag = invalidParentOrAncestor.tag, warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
          if (!didWarn$1[warnKey]) {
            didWarn$1[warnKey] = !0;
            var tagDisplayName = childTag, whitespaceInfo = "";
            if (childTag === "#text" ? /\S/.test(childText) ? tagDisplayName = "Text nodes" : (tagDisplayName = "Whitespace text nodes", whitespaceInfo = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : tagDisplayName = "<" + childTag + ">", invalidParent) {
              var info2 = "";
              ancestorTag === "table" && childTag === "tr" && (info2 += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info2);
            } else
              error("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", tagDisplayName, ancestorTag);
          }
        }
      };
    }
    var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning", SUSPENSE_START_DATA = "$", SUSPENSE_END_DATA = "/$", SUSPENSE_PENDING_START_DATA = "$?", SUSPENSE_FALLBACK_START_DATA = "$!", STYLE$1 = "style", eventsEnabled = null, selectionInformation = null;
    function getRootHostContext(rootContainerInstance) {
      var type, namespace, nodeType = rootContainerInstance.nodeType;
      switch (nodeType) {
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE: {
          type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
          var root2 = rootContainerInstance.documentElement;
          namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
          break;
        }
        default: {
          var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance, ownNamespace = container.namespaceURI || null;
          type = container.tagName, namespace = getChildNamespace(ownNamespace, type);
          break;
        }
      }
      {
        var validatedTag = type.toLowerCase(), ancestorInfo = updatedAncestorInfo(null, validatedTag);
        return {
          namespace,
          ancestorInfo
        };
      }
    }
    function getChildHostContext(parentHostContext, type, rootContainerInstance) {
      {
        var parentHostContextDev = parentHostContext, namespace = getChildNamespace(parentHostContextDev.namespace, type), ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
        return {
          namespace,
          ancestorInfo
        };
      }
    }
    function getPublicInstance(instance) {
      return instance;
    }
    function prepareForCommit(containerInfo) {
      eventsEnabled = isEnabled(), selectionInformation = getSelectionInformation();
      var activeInstance = null;
      return setEnabled(!1), activeInstance;
    }
    function resetAfterCommit(containerInfo) {
      restoreSelection(selectionInformation), setEnabled(eventsEnabled), eventsEnabled = null, selectionInformation = null;
    }
    function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
      var parentNamespace;
      {
        var hostContextDev = hostContext;
        if (validateDOMNesting(type, null, hostContextDev.ancestorInfo), typeof props.children == "string" || typeof props.children == "number") {
          var string = "" + props.children, ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
          validateDOMNesting(null, string, ownAncestorInfo);
        }
        parentNamespace = hostContextDev.namespace;
      }
      var domElement = createElement2(type, props, rootContainerInstance, parentNamespace);
      return precacheFiberNode(internalInstanceHandle, domElement), updateFiberProps(domElement, props), domElement;
    }
    function appendInitialChild(parentInstance, child) {
      parentInstance.appendChild(child);
    }
    function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
      switch (setInitialProperties(domElement, type, props, rootContainerInstance), type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!props.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
      {
        var hostContextDev = hostContext;
        if (typeof newProps.children != typeof oldProps.children && (typeof newProps.children == "string" || typeof newProps.children == "number")) {
          var string = "" + newProps.children, ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
          validateDOMNesting(null, string, ownAncestorInfo);
        }
      }
      return diffProperties(domElement, type, oldProps, newProps);
    }
    function shouldSetTextContent(type, props) {
      return type === "textarea" || type === "noscript" || typeof props.children == "string" || typeof props.children == "number" || typeof props.dangerouslySetInnerHTML == "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
    }
    function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
      {
        var hostContextDev = hostContext;
        validateDOMNesting(null, text, hostContextDev.ancestorInfo);
      }
      var textNode = createTextNode(text, rootContainerInstance);
      return precacheFiberNode(internalInstanceHandle, textNode), textNode;
    }
    function getCurrentEventPriority() {
      var currentEvent = window.event;
      return currentEvent === void 0 ? DefaultEventPriority : getEventPriority(currentEvent.type);
    }
    var scheduleTimeout = typeof setTimeout == "function" ? setTimeout : void 0, cancelTimeout = typeof clearTimeout == "function" ? clearTimeout : void 0, noTimeout = -1, localPromise = typeof Promise == "function" ? Promise : void 0, scheduleMicrotask = typeof queueMicrotask == "function" ? queueMicrotask : typeof localPromise < "u" ? function(callback) {
      return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
    } : scheduleTimeout;
    function handleErrorInNextTick(error2) {
      setTimeout(function() {
        throw error2;
      });
    }
    function commitMount(domElement, type, newProps, internalInstanceHandle) {
      switch (type) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          newProps.autoFocus && domElement.focus();
          return;
        case "img": {
          newProps.src && (domElement.src = newProps.src);
          return;
        }
      }
    }
    function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
      updateProperties(domElement, updatePayload, type, oldProps, newProps), updateFiberProps(domElement, newProps);
    }
    function resetTextContent(domElement) {
      setTextContent(domElement, "");
    }
    function commitTextUpdate(textInstance, oldText, newText) {
      textInstance.nodeValue = newText;
    }
    function appendChild(parentInstance, child) {
      parentInstance.appendChild(child);
    }
    function appendChildToContainer(container, child) {
      var parentNode;
      container.nodeType === COMMENT_NODE ? (parentNode = container.parentNode, parentNode.insertBefore(child, container)) : (parentNode = container, parentNode.appendChild(child));
      var reactRootContainer = container._reactRootContainer;
      reactRootContainer == null && parentNode.onclick === null && trapClickOnNonInteractiveElement(parentNode);
    }
    function insertBefore(parentInstance, child, beforeChild) {
      parentInstance.insertBefore(child, beforeChild);
    }
    function insertInContainerBefore(container, child, beforeChild) {
      container.nodeType === COMMENT_NODE ? container.parentNode.insertBefore(child, beforeChild) : container.insertBefore(child, beforeChild);
    }
    function removeChild(parentInstance, child) {
      parentInstance.removeChild(child);
    }
    function removeChildFromContainer(container, child) {
      container.nodeType === COMMENT_NODE ? container.parentNode.removeChild(child) : container.removeChild(child);
    }
    function clearSuspenseBoundary(parentInstance, suspenseInstance) {
      var node2 = suspenseInstance, depth = 0;
      do {
        var nextNode = node2.nextSibling;
        if (parentInstance.removeChild(node2), nextNode && nextNode.nodeType === COMMENT_NODE) {
          var data2 = nextNode.data;
          if (data2 === SUSPENSE_END_DATA)
            if (depth === 0) {
              parentInstance.removeChild(nextNode), retryIfBlockedOn(suspenseInstance);
              return;
            } else
              depth--;
          else (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_PENDING_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA) && depth++;
        }
        node2 = nextNode;
      } while (node2);
      retryIfBlockedOn(suspenseInstance);
    }
    function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
      container.nodeType === COMMENT_NODE ? clearSuspenseBoundary(container.parentNode, suspenseInstance) : container.nodeType === ELEMENT_NODE && clearSuspenseBoundary(container, suspenseInstance), retryIfBlockedOn(container);
    }
    function hideInstance(instance) {
      instance = instance;
      var style3 = instance.style;
      typeof style3.setProperty == "function" ? style3.setProperty("display", "none", "important") : style3.display = "none";
    }
    function hideTextInstance(textInstance) {
      textInstance.nodeValue = "";
    }
    function unhideInstance(instance, props) {
      instance = instance;
      var styleProp = props[STYLE$1], display = styleProp != null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
      instance.style.display = dangerousStyleValue("display", display);
    }
    function unhideTextInstance(textInstance, text) {
      textInstance.nodeValue = text;
    }
    function clearContainer(container) {
      container.nodeType === ELEMENT_NODE ? container.textContent = "" : container.nodeType === DOCUMENT_NODE && container.documentElement && container.removeChild(container.documentElement);
    }
    function canHydrateInstance(instance, type, props) {
      return instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase() ? null : instance;
    }
    function canHydrateTextInstance(instance, text) {
      return text === "" || instance.nodeType !== TEXT_NODE ? null : instance;
    }
    function canHydrateSuspenseInstance(instance) {
      return instance.nodeType !== COMMENT_NODE ? null : instance;
    }
    function isSuspenseInstancePending(instance) {
      return instance.data === SUSPENSE_PENDING_START_DATA;
    }
    function isSuspenseInstanceFallback(instance) {
      return instance.data === SUSPENSE_FALLBACK_START_DATA;
    }
    function getSuspenseInstanceFallbackErrorDetails(instance) {
      var dataset = instance.nextSibling && instance.nextSibling.dataset, digest, message, stack;
      return dataset && (digest = dataset.dgst, message = dataset.msg, stack = dataset.stck), {
        message,
        digest,
        stack
      };
    }
    function registerSuspenseInstanceRetry(instance, callback) {
      instance._reactRetry = callback;
    }
    function getNextHydratable(node2) {
      for (; node2 != null; node2 = node2.nextSibling) {
        var nodeType = node2.nodeType;
        if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE)
          break;
        if (nodeType === COMMENT_NODE) {
          var nodeData = node2.data;
          if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA)
            break;
          if (nodeData === SUSPENSE_END_DATA)
            return null;
        }
      }
      return node2;
    }
    function getNextHydratableSibling(instance) {
      return getNextHydratable(instance.nextSibling);
    }
    function getFirstHydratableChild(parentInstance) {
      return getNextHydratable(parentInstance.firstChild);
    }
    function getFirstHydratableChildWithinContainer(parentContainer) {
      return getNextHydratable(parentContainer.firstChild);
    }
    function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
      return getNextHydratable(parentInstance.nextSibling);
    }
    function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
      precacheFiberNode(internalInstanceHandle, instance), updateFiberProps(instance, props);
      var parentNamespace;
      {
        var hostContextDev = hostContext;
        parentNamespace = hostContextDev.namespace;
      }
      var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
      return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
    }
    function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
      return precacheFiberNode(internalInstanceHandle, textInstance), diffHydratedText(textInstance, text);
    }
    function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
      precacheFiberNode(internalInstanceHandle, suspenseInstance);
    }
    function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
      for (var node2 = suspenseInstance.nextSibling, depth = 0; node2; ) {
        if (node2.nodeType === COMMENT_NODE) {
          var data2 = node2.data;
          if (data2 === SUSPENSE_END_DATA) {
            if (depth === 0)
              return getNextHydratableSibling(node2);
            depth--;
          } else (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA) && depth++;
        }
        node2 = node2.nextSibling;
      }
      return null;
    }
    function getParentSuspenseInstance(targetInstance) {
      for (var node2 = targetInstance.previousSibling, depth = 0; node2; ) {
        if (node2.nodeType === COMMENT_NODE) {
          var data2 = node2.data;
          if (data2 === SUSPENSE_START_DATA || data2 === SUSPENSE_FALLBACK_START_DATA || data2 === SUSPENSE_PENDING_START_DATA) {
            if (depth === 0)
              return node2;
            depth--;
          } else data2 === SUSPENSE_END_DATA && depth++;
        }
        node2 = node2.previousSibling;
      }
      return null;
    }
    function commitHydratedContainer(container) {
      retryIfBlockedOn(container);
    }
    function commitHydratedSuspenseInstance(suspenseInstance) {
      retryIfBlockedOn(suspenseInstance);
    }
    function shouldDeleteUnhydratedTailInstances(parentType) {
      return parentType !== "head" && parentType !== "body";
    }
    function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
      var shouldWarnDev = !0;
      checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
    }
    function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
      if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0) {
        var shouldWarnDev = !0;
        checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
      }
    }
    function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
      instance.nodeType === ELEMENT_NODE ? warnForDeletedHydratableElement(parentContainer, instance) : instance.nodeType === COMMENT_NODE || warnForDeletedHydratableText(parentContainer, instance);
    }
    function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
      {
        var parentNode = parentInstance.parentNode;
        parentNode !== null && (instance.nodeType === ELEMENT_NODE ? warnForDeletedHydratableElement(parentNode, instance) : instance.nodeType === COMMENT_NODE || warnForDeletedHydratableText(parentNode, instance));
      }
    }
    function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
      (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0) && (instance.nodeType === ELEMENT_NODE ? warnForDeletedHydratableElement(parentInstance, instance) : instance.nodeType === COMMENT_NODE || warnForDeletedHydratableText(parentInstance, instance));
    }
    function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
      warnForInsertedHydratedElement(parentContainer, type);
    }
    function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
      warnForInsertedHydratedText(parentContainer, text);
    }
    function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
      {
        var parentNode = parentInstance.parentNode;
        parentNode !== null && warnForInsertedHydratedElement(parentNode, type);
      }
    }
    function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
      {
        var parentNode = parentInstance.parentNode;
        parentNode !== null && warnForInsertedHydratedText(parentNode, text);
      }
    }
    function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
      (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0) && warnForInsertedHydratedElement(parentInstance, type);
    }
    function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
      (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== !0) && warnForInsertedHydratedText(parentInstance, text);
    }
    function errorHydratingContainer(parentContainer) {
      error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
    }
    function preparePortalMount(portalInstance) {
      listenToAllSupportedEvents(portalInstance);
    }
    var randomKey = Math.random().toString(36).slice(2), internalInstanceKey = "__reactFiber$" + randomKey, internalPropsKey = "__reactProps$" + randomKey, internalContainerInstanceKey = "__reactContainer$" + randomKey, internalEventHandlersKey = "__reactEvents$" + randomKey, internalEventHandlerListenersKey = "__reactListeners$" + randomKey, internalEventHandlesSetKey = "__reactHandles$" + randomKey;
    function detachDeletedInstance(node2) {
      delete node2[internalInstanceKey], delete node2[internalPropsKey], delete node2[internalEventHandlersKey], delete node2[internalEventHandlerListenersKey], delete node2[internalEventHandlesSetKey];
    }
    function precacheFiberNode(hostInst, node2) {
      node2[internalInstanceKey] = hostInst;
    }
    function markContainerAsRoot(hostRoot, node2) {
      node2[internalContainerInstanceKey] = hostRoot;
    }
    function unmarkContainerAsRoot(node2) {
      node2[internalContainerInstanceKey] = null;
    }
    function isContainerMarkedAsRoot(node2) {
      return !!node2[internalContainerInstanceKey];
    }
    function getClosestInstanceFromNode(targetNode) {
      var targetInst = targetNode[internalInstanceKey];
      if (targetInst)
        return targetInst;
      for (var parentNode = targetNode.parentNode; parentNode; ) {
        if (targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey], targetInst) {
          var alternate = targetInst.alternate;
          if (targetInst.child !== null || alternate !== null && alternate.child !== null)
            for (var suspenseInstance = getParentSuspenseInstance(targetNode); suspenseInstance !== null; ) {
              var targetSuspenseInst = suspenseInstance[internalInstanceKey];
              if (targetSuspenseInst)
                return targetSuspenseInst;
              suspenseInstance = getParentSuspenseInstance(suspenseInstance);
            }
          return targetInst;
        }
        targetNode = parentNode, parentNode = targetNode.parentNode;
      }
      return null;
    }
    function getInstanceFromNode(node2) {
      var inst = node2[internalInstanceKey] || node2[internalContainerInstanceKey];
      return inst && (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) ? inst : null;
    }
    function getNodeFromInstance(inst) {
      if (inst.tag === HostComponent || inst.tag === HostText)
        return inst.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function getFiberCurrentPropsFromNode(node2) {
      return node2[internalPropsKey] || null;
    }
    function updateFiberProps(node2, props) {
      node2[internalPropsKey] = props;
    }
    function getEventListenerSet(node2) {
      var elementListenerSet = node2[internalEventHandlersKey];
      return elementListenerSet === void 0 && (elementListenerSet = node2[internalEventHandlersKey] = /* @__PURE__ */ new Set()), elementListenerSet;
    }
    var loggedTypeFailures = {}, ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
    function setCurrentlyValidatingElement(element) {
      if (element) {
        var owner = element._owner, stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
        ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
      } else
        ReactDebugCurrentFrame$1.setExtraStackFrame(null);
    }
    function checkPropTypes(typeSpecs, values, location, componentName, element) {
      {
        var has2 = Function.call.bind(hasOwnProperty2);
        for (var typeSpecName in typeSpecs)
          if (has2(typeSpecs, typeSpecName)) {
            var error$1 = void 0;
            try {
              if (typeof typeSpecs[typeSpecName] != "function") {
                var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw err.name = "Invariant Violation", err;
              }
              error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ex) {
              error$1 = ex;
            }
            error$1 && !(error$1 instanceof Error) && (setCurrentlyValidatingElement(element), error("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1), setCurrentlyValidatingElement(null)), error$1 instanceof Error && !(error$1.message in loggedTypeFailures) && (loggedTypeFailures[error$1.message] = !0, setCurrentlyValidatingElement(element), error("Failed %s type: %s", location, error$1.message), setCurrentlyValidatingElement(null));
          }
      }
    }
    var valueStack = [], fiberStack;
    fiberStack = [];
    var index2 = -1;
    function createCursor(defaultValue) {
      return {
        current: defaultValue
      };
    }
    function pop(cursor, fiber) {
      if (index2 < 0) {
        error("Unexpected pop.");
        return;
      }
      fiber !== fiberStack[index2] && error("Unexpected Fiber popped."), cursor.current = valueStack[index2], valueStack[index2] = null, fiberStack[index2] = null, index2--;
    }
    function push(cursor, value, fiber) {
      index2++, valueStack[index2] = cursor.current, fiberStack[index2] = fiber, cursor.current = value;
    }
    var warnedAboutMissingGetChildContext;
    warnedAboutMissingGetChildContext = {};
    var emptyContextObject = {};
    Object.freeze(emptyContextObject);
    var contextStackCursor = createCursor(emptyContextObject), didPerformWorkStackCursor = createCursor(!1), previousContext = emptyContextObject;
    function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
      return didPushOwnContextIfProvider && isContextProvider(Component) ? previousContext : contextStackCursor.current;
    }
    function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
      {
        var instance = workInProgress2.stateNode;
        instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext, instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
      }
    }
    function getMaskedContext(workInProgress2, unmaskedContext) {
      {
        var type = workInProgress2.type, contextTypes = type.contextTypes;
        if (!contextTypes)
          return emptyContextObject;
        var instance = workInProgress2.stateNode;
        if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext)
          return instance.__reactInternalMemoizedMaskedChildContext;
        var context = {};
        for (var key2 in contextTypes)
          context[key2] = unmaskedContext[key2];
        {
          var name2 = getComponentNameFromFiber(workInProgress2) || "Unknown";
          checkPropTypes(contextTypes, context, "context", name2);
        }
        return instance && cacheContext(workInProgress2, unmaskedContext, context), context;
      }
    }
    function hasContextChanged() {
      return didPerformWorkStackCursor.current;
    }
    function isContextProvider(type) {
      {
        var childContextTypes = type.childContextTypes;
        return childContextTypes != null;
      }
    }
    function popContext(fiber) {
      pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
    }
    function popTopLevelContextObject(fiber) {
      pop(didPerformWorkStackCursor, fiber), pop(contextStackCursor, fiber);
    }
    function pushTopLevelContextObject(fiber, context, didChange) {
      {
        if (contextStackCursor.current !== emptyContextObject)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        push(contextStackCursor, context, fiber), push(didPerformWorkStackCursor, didChange, fiber);
      }
    }
    function processChildContext(fiber, type, parentContext) {
      {
        var instance = fiber.stateNode, childContextTypes = type.childContextTypes;
        if (typeof instance.getChildContext != "function") {
          {
            var componentName = getComponentNameFromFiber(fiber) || "Unknown";
            warnedAboutMissingGetChildContext[componentName] || (warnedAboutMissingGetChildContext[componentName] = !0, error("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", componentName, componentName));
          }
          return parentContext;
        }
        var childContext = instance.getChildContext();
        for (var contextKey in childContext)
          if (!(contextKey in childContextTypes))
            throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
        {
          var name2 = getComponentNameFromFiber(fiber) || "Unknown";
          checkPropTypes(childContextTypes, childContext, "child context", name2);
        }
        return assign2({}, parentContext, childContext);
      }
    }
    function pushContextProvider(workInProgress2) {
      {
        var instance = workInProgress2.stateNode, memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
        return previousContext = contextStackCursor.current, push(contextStackCursor, memoizedMergedChildContext, workInProgress2), push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2), !0;
      }
    }
    function invalidateContextProvider(workInProgress2, type, didChange) {
      {
        var instance = workInProgress2.stateNode;
        if (!instance)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (didChange) {
          var mergedContext = processChildContext(workInProgress2, type, previousContext);
          instance.__reactInternalMemoizedMergedChildContext = mergedContext, pop(didPerformWorkStackCursor, workInProgress2), pop(contextStackCursor, workInProgress2), push(contextStackCursor, mergedContext, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
        } else
          pop(didPerformWorkStackCursor, workInProgress2), push(didPerformWorkStackCursor, didChange, workInProgress2);
      }
    }
    function findCurrentUnmaskedContext(fiber) {
      {
        if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var node2 = fiber;
        do {
          switch (node2.tag) {
            case HostRoot:
              return node2.stateNode.context;
            case ClassComponent: {
              var Component = node2.type;
              if (isContextProvider(Component))
                return node2.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          node2 = node2.return;
        } while (node2 !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var LegacyRoot = 0, ConcurrentRoot = 1, syncQueue = null, includesLegacySyncCallbacks = !1, isFlushingSyncQueue = !1;
    function scheduleSyncCallback(callback) {
      syncQueue === null ? syncQueue = [callback] : syncQueue.push(callback);
    }
    function scheduleLegacySyncCallback(callback) {
      includesLegacySyncCallbacks = !0, scheduleSyncCallback(callback);
    }
    function flushSyncCallbacksOnlyInLegacyMode() {
      includesLegacySyncCallbacks && flushSyncCallbacks();
    }
    function flushSyncCallbacks() {
      if (!isFlushingSyncQueue && syncQueue !== null) {
        isFlushingSyncQueue = !0;
        var i = 0, previousUpdatePriority = getCurrentUpdatePriority();
        try {
          var isSync = !0, queue = syncQueue;
          for (setCurrentUpdatePriority(DiscreteEventPriority); i < queue.length; i++) {
            var callback = queue[i];
            do
              callback = callback(isSync);
            while (callback !== null);
          }
          syncQueue = null, includesLegacySyncCallbacks = !1;
        } catch (error2) {
          throw syncQueue !== null && (syncQueue = syncQueue.slice(i + 1)), scheduleCallback(ImmediatePriority, flushSyncCallbacks), error2;
        } finally {
          setCurrentUpdatePriority(previousUpdatePriority), isFlushingSyncQueue = !1;
        }
      }
      return null;
    }
    var forkStack = [], forkStackIndex = 0, treeForkProvider = null, treeForkCount = 0, idStack = [], idStackIndex = 0, treeContextProvider = null, treeContextId = 1, treeContextOverflow = "";
    function isForkedChild(workInProgress2) {
      return warnIfNotHydrating(), (workInProgress2.flags & Forked) !== NoFlags;
    }
    function getForksAtLevel(workInProgress2) {
      return warnIfNotHydrating(), treeForkCount;
    }
    function getTreeId() {
      var overflow = treeContextOverflow, idWithLeadingBit = treeContextId, id2 = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
      return id2.toString(32) + overflow;
    }
    function pushTreeFork(workInProgress2, totalChildren) {
      warnIfNotHydrating(), forkStack[forkStackIndex++] = treeForkCount, forkStack[forkStackIndex++] = treeForkProvider, treeForkProvider = workInProgress2, treeForkCount = totalChildren;
    }
    function pushTreeId(workInProgress2, totalChildren, index3) {
      warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextProvider = workInProgress2;
      var baseIdWithLeadingBit = treeContextId, baseOverflow = treeContextOverflow, baseLength = getBitLength(baseIdWithLeadingBit) - 1, baseId = baseIdWithLeadingBit & ~(1 << baseLength), slot = index3 + 1, length2 = getBitLength(totalChildren) + baseLength;
      if (length2 > 30) {
        var numberOfOverflowBits = baseLength - baseLength % 5, newOverflowBits = (1 << numberOfOverflowBits) - 1, newOverflow = (baseId & newOverflowBits).toString(32), restOfBaseId = baseId >> numberOfOverflowBits, restOfBaseLength = baseLength - numberOfOverflowBits, restOfLength = getBitLength(totalChildren) + restOfBaseLength, restOfNewBits = slot << restOfBaseLength, id2 = restOfNewBits | restOfBaseId, overflow = newOverflow + baseOverflow;
        treeContextId = 1 << restOfLength | id2, treeContextOverflow = overflow;
      } else {
        var newBits = slot << baseLength, _id = newBits | baseId, _overflow = baseOverflow;
        treeContextId = 1 << length2 | _id, treeContextOverflow = _overflow;
      }
    }
    function pushMaterializedTreeId(workInProgress2) {
      warnIfNotHydrating();
      var returnFiber = workInProgress2.return;
      if (returnFiber !== null) {
        var numberOfForks = 1, slotIndex = 0;
        pushTreeFork(workInProgress2, numberOfForks), pushTreeId(workInProgress2, numberOfForks, slotIndex);
      }
    }
    function getBitLength(number2) {
      return 32 - clz32(number2);
    }
    function getLeadingBit(id2) {
      return 1 << getBitLength(id2) - 1;
    }
    function popTreeContext(workInProgress2) {
      for (; workInProgress2 === treeForkProvider; )
        treeForkProvider = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null, treeForkCount = forkStack[--forkStackIndex], forkStack[forkStackIndex] = null;
      for (; workInProgress2 === treeContextProvider; )
        treeContextProvider = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextOverflow = idStack[--idStackIndex], idStack[idStackIndex] = null, treeContextId = idStack[--idStackIndex], idStack[idStackIndex] = null;
    }
    function getSuspendedTreeContext() {
      return warnIfNotHydrating(), treeContextProvider !== null ? {
        id: treeContextId,
        overflow: treeContextOverflow
      } : null;
    }
    function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
      warnIfNotHydrating(), idStack[idStackIndex++] = treeContextId, idStack[idStackIndex++] = treeContextOverflow, idStack[idStackIndex++] = treeContextProvider, treeContextId = suspendedContext.id, treeContextOverflow = suspendedContext.overflow, treeContextProvider = workInProgress2;
    }
    function warnIfNotHydrating() {
      getIsHydrating() || error("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1, hydrationErrors = null;
    function warnIfHydrating() {
      isHydrating && error("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function markDidThrowWhileHydratingDEV() {
      didSuspendOrErrorDEV = !0;
    }
    function didSuspendOrErrorWhileHydratingDEV() {
      return didSuspendOrErrorDEV;
    }
    function enterHydrationState(fiber) {
      var parentInstance = fiber.stateNode.containerInfo;
      return nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance), hydrationParentFiber = fiber, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, !0;
    }
    function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
      return nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance), hydrationParentFiber = fiber, isHydrating = !0, hydrationErrors = null, didSuspendOrErrorDEV = !1, treeContext !== null && restoreSuspendedTreeContext(fiber, treeContext), !0;
    }
    function warnUnhydratedInstance(returnFiber, instance) {
      switch (returnFiber.tag) {
        case HostRoot: {
          didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
          break;
        }
        case HostComponent: {
          var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
          didNotHydrateInstance(
            returnFiber.type,
            returnFiber.memoizedProps,
            returnFiber.stateNode,
            instance,
            // TODO: Delete this argument when we remove the legacy root API.
            isConcurrentMode
          );
          break;
        }
        case SuspenseComponent: {
          var suspenseState = returnFiber.memoizedState;
          suspenseState.dehydrated !== null && didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
          break;
        }
      }
    }
    function deleteHydratableInstance(returnFiber, instance) {
      warnUnhydratedInstance(returnFiber, instance);
      var childToDelete = createFiberFromHostInstanceForDeletion();
      childToDelete.stateNode = instance, childToDelete.return = returnFiber;
      var deletions = returnFiber.deletions;
      deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= ChildDeletion) : deletions.push(childToDelete);
    }
    function warnNonhydratedInstance(returnFiber, fiber) {
      {
        if (didSuspendOrErrorDEV)
          return;
        switch (returnFiber.tag) {
          case HostRoot: {
            var parentContainer = returnFiber.stateNode.containerInfo;
            switch (fiber.tag) {
              case HostComponent:
                var type = fiber.type;
                didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                break;
              case HostText:
                var text = fiber.pendingProps;
                didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                break;
            }
            break;
          }
          case HostComponent: {
            var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode;
            switch (fiber.tag) {
              case HostComponent: {
                var _type = fiber.type, _props = fiber.pendingProps, isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotFindHydratableInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  _type,
                  _props,
                  // TODO: Delete this argument when we remove the legacy root API.
                  isConcurrentMode
                );
                break;
              }
              case HostText: {
                var _text = fiber.pendingProps, _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotFindHydratableTextInstance(
                  parentType,
                  parentProps,
                  parentInstance,
                  _text,
                  // TODO: Delete this argument when we remove the legacy root API.
                  _isConcurrentMode
                );
                break;
              }
            }
            break;
          }
          case SuspenseComponent: {
            var suspenseState = returnFiber.memoizedState, _parentInstance = suspenseState.dehydrated;
            if (_parentInstance !== null) switch (fiber.tag) {
              case HostComponent:
                var _type2 = fiber.type;
                didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                break;
              case HostText:
                var _text2 = fiber.pendingProps;
                didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function insertNonHydratedInstance(returnFiber, fiber) {
      fiber.flags = fiber.flags & ~Hydrating | Placement, warnNonhydratedInstance(returnFiber, fiber);
    }
    function tryHydrate(fiber, nextInstance) {
      switch (fiber.tag) {
        case HostComponent: {
          var type = fiber.type, instance = canHydrateInstance(nextInstance, type);
          return instance !== null ? (fiber.stateNode = instance, hydrationParentFiber = fiber, nextHydratableInstance = getFirstHydratableChild(instance), !0) : !1;
        }
        case HostText: {
          var text = fiber.pendingProps, textInstance = canHydrateTextInstance(nextInstance, text);
          return textInstance !== null ? (fiber.stateNode = textInstance, hydrationParentFiber = fiber, nextHydratableInstance = null, !0) : !1;
        }
        case SuspenseComponent: {
          var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
          if (suspenseInstance !== null) {
            var suspenseState = {
              dehydrated: suspenseInstance,
              treeContext: getSuspendedTreeContext(),
              retryLane: OffscreenLane
            };
            fiber.memoizedState = suspenseState;
            var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
            return dehydratedFragment.return = fiber, fiber.child = dehydratedFragment, hydrationParentFiber = fiber, nextHydratableInstance = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function shouldClientRenderOnMismatch(fiber) {
      return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
    }
    function throwOnHydrationMismatch(fiber) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function tryToClaimNextHydratableInstance(fiber) {
      if (isHydrating) {
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
          shouldClientRenderOnMismatch(fiber) && (warnNonhydratedInstance(hydrationParentFiber, fiber), throwOnHydrationMismatch()), insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
          return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          shouldClientRenderOnMismatch(fiber) && (warnNonhydratedInstance(hydrationParentFiber, fiber), throwOnHydrationMismatch()), nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          var prevHydrationParentFiber = hydrationParentFiber;
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber), isHydrating = !1, hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
        }
      }
    }
    function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
      var instance = fiber.stateNode, shouldWarnIfMismatchDev = !didSuspendOrErrorDEV, updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
      return fiber.updateQueue = updatePayload, updatePayload !== null;
    }
    function prepareToHydrateHostTextInstance(fiber) {
      var textInstance = fiber.stateNode, textContent = fiber.memoizedProps, shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
      if (shouldUpdate) {
        var returnFiber = hydrationParentFiber;
        if (returnFiber !== null)
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo, isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotMatchHydratedContainerTextInstance(
                parentContainer,
                textInstance,
                textContent,
                // TODO: Delete this argument when we remove the legacy root API.
                isConcurrentMode
              );
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type, parentProps = returnFiber.memoizedProps, parentInstance = returnFiber.stateNode, _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotMatchHydratedTextInstance(
                parentType,
                parentProps,
                parentInstance,
                textInstance,
                textContent,
                // TODO: Delete this argument when we remove the legacy root API.
                _isConcurrentMode2
              );
              break;
            }
          }
      }
      return shouldUpdate;
    }
    function prepareToHydrateHostSuspenseInstance(fiber) {
      var suspenseState = fiber.memoizedState, suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
      if (!suspenseInstance)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      hydrateSuspenseInstance(suspenseInstance, fiber);
    }
    function skipPastDehydratedSuspenseInstance(fiber) {
      var suspenseState = fiber.memoizedState, suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
      if (!suspenseInstance)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
    }
    function popToNextHostParent(fiber) {
      for (var parent = fiber.return; parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent; )
        parent = parent.return;
      hydrationParentFiber = parent;
    }
    function popHydrationState(fiber) {
      if (fiber !== hydrationParentFiber)
        return !1;
      if (!isHydrating)
        return popToNextHostParent(fiber), isHydrating = !0, !1;
      if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
        var nextInstance = nextHydratableInstance;
        if (nextInstance)
          if (shouldClientRenderOnMismatch(fiber))
            warnIfUnhydratedTailNodes(fiber), throwOnHydrationMismatch();
          else
            for (; nextInstance; )
              deleteHydratableInstance(fiber, nextInstance), nextInstance = getNextHydratableSibling(nextInstance);
      }
      return popToNextHostParent(fiber), fiber.tag === SuspenseComponent ? nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber) : nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null, !0;
    }
    function hasUnhydratedTailNodes() {
      return isHydrating && nextHydratableInstance !== null;
    }
    function warnIfUnhydratedTailNodes(fiber) {
      for (var nextInstance = nextHydratableInstance; nextInstance; )
        warnUnhydratedInstance(fiber, nextInstance), nextInstance = getNextHydratableSibling(nextInstance);
    }
    function resetHydrationState() {
      hydrationParentFiber = null, nextHydratableInstance = null, isHydrating = !1, didSuspendOrErrorDEV = !1;
    }
    function upgradeHydrationErrorsToRecoverable() {
      hydrationErrors !== null && (queueRecoverableErrors(hydrationErrors), hydrationErrors = null);
    }
    function getIsHydrating() {
      return isHydrating;
    }
    function queueHydrationError(error2) {
      hydrationErrors === null ? hydrationErrors = [error2] : hydrationErrors.push(error2);
    }
    var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig, NoTransition = null;
    function requestCurrentTransition() {
      return ReactCurrentBatchConfig$1.transition;
    }
    var ReactStrictModeWarnings = {
      recordUnsafeLifecycleWarnings: function(fiber, instance) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(fiber, instance) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var findStrictRoot = function(fiber) {
        for (var maybeStrictRoot = null, node2 = fiber; node2 !== null; )
          node2.mode & StrictLegacyMode && (maybeStrictRoot = node2), node2 = node2.return;
        return maybeStrictRoot;
      }, setToSortedString = function(set2) {
        var array = [];
        return set2.forEach(function(value) {
          array.push(value);
        }), array.sort().join(", ");
      }, pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], didWarnAboutUnsafeLifecycles = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
        didWarnAboutUnsafeLifecycles.has(fiber.type) || (typeof instance.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        instance.componentWillMount.__suppressDeprecationWarning !== !0 && pendingComponentWillMountWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount == "function" && pendingUNSAFE_ComponentWillMountWarnings.push(fiber), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && pendingComponentWillReceivePropsWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps == "function" && pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 && pendingComponentWillUpdateWarnings.push(fiber), fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate == "function" && pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber));
      }, ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
        var componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        pendingComponentWillMountWarnings.length > 0 && (pendingComponentWillMountWarnings.forEach(function(fiber) {
          componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillMountWarnings = []);
        var UNSAFE_componentWillMountUniqueNames = /* @__PURE__ */ new Set();
        pendingUNSAFE_ComponentWillMountWarnings.length > 0 && (pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
          UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillMountWarnings = []);
        var componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        pendingComponentWillReceivePropsWarnings.length > 0 && (pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
          componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillReceivePropsWarnings = []);
        var UNSAFE_componentWillReceivePropsUniqueNames = /* @__PURE__ */ new Set();
        pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0 && (pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
          UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillReceivePropsWarnings = []);
        var componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        pendingComponentWillUpdateWarnings.length > 0 && (pendingComponentWillUpdateWarnings.forEach(function(fiber) {
          componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingComponentWillUpdateWarnings = []);
        var UNSAFE_componentWillUpdateUniqueNames = /* @__PURE__ */ new Set();
        if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0 && (pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
          UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutUnsafeLifecycles.add(fiber.type);
        }), pendingUNSAFE_ComponentWillUpdateWarnings = []), UNSAFE_componentWillMountUniqueNames.size > 0) {
          var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
          error(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, sortedNames);
        }
        if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
          var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
          error(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, _sortedNames);
        }
        if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
          var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
          error(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, _sortedNames2);
        }
        if (componentWillMountUniqueNames.size > 0) {
          var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
          warn(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames3);
        }
        if (componentWillReceivePropsUniqueNames.size > 0) {
          var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
          warn(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames4);
        }
        if (componentWillUpdateUniqueNames.size > 0) {
          var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
          warn(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, _sortedNames5);
        }
      };
      var pendingLegacyContextWarning = /* @__PURE__ */ new Map(), didWarnAboutLegacyContext = /* @__PURE__ */ new Set();
      ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
        var strictRoot = findStrictRoot(fiber);
        if (strictRoot === null) {
          error("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!didWarnAboutLegacyContext.has(fiber.type)) {
          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
          (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext == "function") && (warningsForRoot === void 0 && (warningsForRoot = [], pendingLegacyContextWarning.set(strictRoot, warningsForRoot)), warningsForRoot.push(fiber));
        }
      }, ReactStrictModeWarnings.flushLegacyContextWarning = function() {
        pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
          if (fiberArray.length !== 0) {
            var firstFiber = fiberArray[0], uniqueNames = /* @__PURE__ */ new Set();
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component"), didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
              setCurrentFiber(firstFiber), error(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, sortedNames);
            } finally {
              resetCurrentFiber();
            }
          }
        });
      }, ReactStrictModeWarnings.discardPendingWarnings = function() {
        pendingComponentWillMountWarnings = [], pendingUNSAFE_ComponentWillMountWarnings = [], pendingComponentWillReceivePropsWarnings = [], pendingUNSAFE_ComponentWillReceivePropsWarnings = [], pendingComponentWillUpdateWarnings = [], pendingUNSAFE_ComponentWillUpdateWarnings = [], pendingLegacyContextWarning = /* @__PURE__ */ new Map();
      };
    }
    var didWarnAboutMaps, didWarnAboutGenerators, didWarnAboutStringRefs, ownerHasKeyUseWarning, ownerHasFunctionTypeWarning, warnForMissingKey = function(child, returnFiber) {
    };
    didWarnAboutMaps = !1, didWarnAboutGenerators = !1, didWarnAboutStringRefs = {}, ownerHasKeyUseWarning = {}, ownerHasFunctionTypeWarning = {}, warnForMissingKey = function(child, returnFiber) {
      if (!(child === null || typeof child != "object") && !(!child._store || child._store.validated || child.key != null)) {
        if (typeof child._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        child._store.validated = !0;
        var componentName = getComponentNameFromFiber(returnFiber) || "Component";
        ownerHasKeyUseWarning[componentName] || (ownerHasKeyUseWarning[componentName] = !0, error('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function isReactClass(type) {
      return type.prototype && type.prototype.isReactComponent;
    }
    function coerceRef(returnFiber, current2, element) {
      var mixedRef = element.ref;
      if (mixedRef !== null && typeof mixedRef != "function" && typeof mixedRef != "object") {
        if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(element._owner && element._self && element._owner.stateNode !== element._self) && // Will already throw with "Function components cannot have string refs"
        !(element._owner && element._owner.tag !== ClassComponent) && // Will already warn with "Function components cannot be given refs"
        !(typeof element.type == "function" && !isReactClass(element.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        element._owner) {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          didWarnAboutStringRefs[componentName] || (error('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', componentName, mixedRef), didWarnAboutStringRefs[componentName] = !0);
        }
        if (element._owner) {
          var owner = element._owner, inst;
          if (owner) {
            var ownerFiber = owner;
            if (ownerFiber.tag !== ClassComponent)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            inst = ownerFiber.stateNode;
          }
          if (!inst)
            throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a bug in React. Please file an issue.");
          var resolvedInst = inst;
          checkPropStringCoercion(mixedRef, "ref");
          var stringRef = "" + mixedRef;
          if (current2 !== null && current2.ref !== null && typeof current2.ref == "function" && current2.ref._stringRef === stringRef)
            return current2.ref;
          var ref = function(value) {
            var refs = resolvedInst.refs;
            value === null ? delete refs[stringRef] : refs[stringRef] = value;
          };
          return ref._stringRef = stringRef, ref;
        } else {
          if (typeof mixedRef != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!element._owner)
            throw new Error("Element ref was specified as a string (" + mixedRef + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return mixedRef;
    }
    function throwOnInvalidObjectType(returnFiber, newChild) {
      var childString = Object.prototype.toString.call(newChild);
      throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). If you meant to render a collection of children, use an array instead.");
    }
    function warnOnFunctionType(returnFiber) {
      {
        var componentName = getComponentNameFromFiber(returnFiber) || "Component";
        if (ownerHasFunctionTypeWarning[componentName])
          return;
        ownerHasFunctionTypeWarning[componentName] = !0, error("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function resolveLazy(lazyType) {
      var payload = lazyType._payload, init = lazyType._init;
      return init(payload);
    }
    function ChildReconciler(shouldTrackSideEffects) {
      function deleteChild(returnFiber, childToDelete) {
        if (shouldTrackSideEffects) {
          var deletions = returnFiber.deletions;
          deletions === null ? (returnFiber.deletions = [childToDelete], returnFiber.flags |= ChildDeletion) : deletions.push(childToDelete);
        }
      }
      function deleteRemainingChildren(returnFiber, currentFirstChild) {
        if (!shouldTrackSideEffects)
          return null;
        for (var childToDelete = currentFirstChild; childToDelete !== null; )
          deleteChild(returnFiber, childToDelete), childToDelete = childToDelete.sibling;
        return null;
      }
      function mapRemainingChildren(returnFiber, currentFirstChild) {
        for (var existingChildren = /* @__PURE__ */ new Map(), existingChild = currentFirstChild; existingChild !== null; )
          existingChild.key !== null ? existingChildren.set(existingChild.key, existingChild) : existingChildren.set(existingChild.index, existingChild), existingChild = existingChild.sibling;
        return existingChildren;
      }
      function useFiber(fiber, pendingProps) {
        var clone = createWorkInProgress(fiber, pendingProps);
        return clone.index = 0, clone.sibling = null, clone;
      }
      function placeChild(newFiber, lastPlacedIndex, newIndex) {
        if (newFiber.index = newIndex, !shouldTrackSideEffects)
          return newFiber.flags |= Forked, lastPlacedIndex;
        var current2 = newFiber.alternate;
        if (current2 !== null) {
          var oldIndex = current2.index;
          return oldIndex < lastPlacedIndex ? (newFiber.flags |= Placement, lastPlacedIndex) : oldIndex;
        } else
          return newFiber.flags |= Placement, lastPlacedIndex;
      }
      function placeSingleChild(newFiber) {
        return shouldTrackSideEffects && newFiber.alternate === null && (newFiber.flags |= Placement), newFiber;
      }
      function updateTextNode(returnFiber, current2, textContent, lanes) {
        if (current2 === null || current2.tag !== HostText) {
          var created = createFiberFromText(textContent, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        } else {
          var existing = useFiber(current2, textContent);
          return existing.return = returnFiber, existing;
        }
      }
      function updateElement(returnFiber, current2, element, lanes) {
        var elementType = element.type;
        if (elementType === REACT_FRAGMENT_TYPE)
          return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
        if (current2 !== null && (current2.elementType === elementType || // Keep this check inline so it only runs on the false path:
        isCompatibleFamilyForHotReloading(current2, element) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof elementType == "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type)) {
          var existing = useFiber(current2, element.props);
          return existing.ref = coerceRef(returnFiber, current2, element), existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
        }
        var created = createFiberFromElement(element, returnFiber.mode, lanes);
        return created.ref = coerceRef(returnFiber, current2, element), created.return = returnFiber, created;
      }
      function updatePortal(returnFiber, current2, portal, lanes) {
        if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        } else {
          var existing = useFiber(current2, portal.children || []);
          return existing.return = returnFiber, existing;
        }
      }
      function updateFragment2(returnFiber, current2, fragment, lanes, key2) {
        if (current2 === null || current2.tag !== Fragment2) {
          var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key2);
          return created.return = returnFiber, created;
        } else {
          var existing = useFiber(current2, fragment);
          return existing.return = returnFiber, existing;
        }
      }
      function createChild(returnFiber, newChild, lanes) {
        if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number") {
          var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
          return created.return = returnFiber, created;
        }
        if (typeof newChild == "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
              return _created.ref = coerceRef(returnFiber, null, newChild), _created.return = returnFiber, _created;
            }
            case REACT_PORTAL_TYPE: {
              var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
              return _created2.return = returnFiber, _created2;
            }
            case REACT_LAZY_TYPE: {
              var payload = newChild._payload, init = newChild._init;
              return createChild(returnFiber, init(payload), lanes);
            }
          }
          if (isArray(newChild) || getIteratorFn(newChild)) {
            var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
            return _created3.return = returnFiber, _created3;
          }
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
      }
      function updateSlot(returnFiber, oldFiber, newChild, lanes) {
        var key2 = oldFiber !== null ? oldFiber.key : null;
        if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number")
          return key2 !== null ? null : updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
        if (typeof newChild == "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return newChild.key === key2 ? updateElement(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_PORTAL_TYPE:
              return newChild.key === key2 ? updatePortal(returnFiber, oldFiber, newChild, lanes) : null;
            case REACT_LAZY_TYPE: {
              var payload = newChild._payload, init = newChild._init;
              return updateSlot(returnFiber, oldFiber, init(payload), lanes);
            }
          }
          if (isArray(newChild) || getIteratorFn(newChild))
            return key2 !== null ? null : updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
      }
      function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
        if (typeof newChild == "string" && newChild !== "" || typeof newChild == "number") {
          var matchedFiber = existingChildren.get(newIdx) || null;
          return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
        }
        if (typeof newChild == "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE: {
              var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
              return updateElement(returnFiber, _matchedFiber, newChild, lanes);
            }
            case REACT_PORTAL_TYPE: {
              var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
              return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
            }
            case REACT_LAZY_TYPE:
              var payload = newChild._payload, init = newChild._init;
              return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
          }
          if (isArray(newChild) || getIteratorFn(newChild)) {
            var _matchedFiber3 = existingChildren.get(newIdx) || null;
            return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
          }
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return typeof newChild == "function" && warnOnFunctionType(returnFiber), null;
      }
      function warnOnInvalidKey(child, knownKeys, returnFiber) {
        {
          if (typeof child != "object" || child === null)
            return knownKeys;
          switch (child.$$typeof) {
            case REACT_ELEMENT_TYPE:
            case REACT_PORTAL_TYPE:
              warnForMissingKey(child, returnFiber);
              var key2 = child.key;
              if (typeof key2 != "string")
                break;
              if (knownKeys === null) {
                knownKeys = /* @__PURE__ */ new Set(), knownKeys.add(key2);
                break;
              }
              if (!knownKeys.has(key2)) {
                knownKeys.add(key2);
                break;
              }
              error("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted \u2014 the behavior is unsupported and could change in a future version.", key2);
              break;
            case REACT_LAZY_TYPE:
              var payload = child._payload, init = child._init;
              warnOnInvalidKey(init(payload), knownKeys, returnFiber);
              break;
          }
        }
        return knownKeys;
      }
      function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
        for (var knownKeys = null, i = 0; i < newChildren.length; i++) {
          var child = newChildren[i];
          knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
        }
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null; oldFiber !== null && newIdx < newChildren.length; newIdx++) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
        }
        if (newIdx === newChildren.length) {
          if (deleteRemainingChildren(returnFiber, oldFiber), getIsHydrating()) {
            var numberOfForks = newIdx;
            pushTreeFork(returnFiber, numberOfForks);
          }
          return resultingFirstChild;
        }
        if (oldFiber === null) {
          for (; newIdx < newChildren.length; newIdx++) {
            var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
            _newFiber !== null && (lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber : previousNewFiber.sibling = _newFiber, previousNewFiber = _newFiber);
          }
          if (getIsHydrating()) {
            var _numberOfForks = newIdx;
            pushTreeFork(returnFiber, _numberOfForks);
          }
          return resultingFirstChild;
        }
        for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); newIdx < newChildren.length; newIdx++) {
          var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
          _newFiber2 !== null && (shouldTrackSideEffects && _newFiber2.alternate !== null && existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key), lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber2 : previousNewFiber.sibling = _newFiber2, previousNewFiber = _newFiber2);
        }
        if (shouldTrackSideEffects && existingChildren.forEach(function(child2) {
          return deleteChild(returnFiber, child2);
        }), getIsHydrating()) {
          var _numberOfForks2 = newIdx;
          pushTreeFork(returnFiber, _numberOfForks2);
        }
        return resultingFirstChild;
      }
      function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
        var iteratorFn = getIteratorFn(newChildrenIterable);
        if (typeof iteratorFn != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          newChildrenIterable[Symbol.toStringTag] === "Generator" && (didWarnAboutGenerators || error("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), didWarnAboutGenerators = !0), newChildrenIterable.entries === iteratorFn && (didWarnAboutMaps || error("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), didWarnAboutMaps = !0);
          var _newChildren = iteratorFn.call(newChildrenIterable);
          if (_newChildren)
            for (var knownKeys = null, _step = _newChildren.next(); !_step.done; _step = _newChildren.next()) {
              var child = _step.value;
              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
        }
        var newChildren = iteratorFn.call(newChildrenIterable);
        if (newChildren == null)
          throw new Error("An iterable object provided no iterator.");
        for (var resultingFirstChild = null, previousNewFiber = null, oldFiber = currentFirstChild, lastPlacedIndex = 0, newIdx = 0, nextOldFiber = null, step = newChildren.next(); oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
          oldFiber.index > newIdx ? (nextOldFiber = oldFiber, oldFiber = null) : nextOldFiber = oldFiber.sibling;
          var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
          if (newFiber === null) {
            oldFiber === null && (oldFiber = nextOldFiber);
            break;
          }
          shouldTrackSideEffects && oldFiber && newFiber.alternate === null && deleteChild(returnFiber, oldFiber), lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = newFiber : previousNewFiber.sibling = newFiber, previousNewFiber = newFiber, oldFiber = nextOldFiber;
        }
        if (step.done) {
          if (deleteRemainingChildren(returnFiber, oldFiber), getIsHydrating()) {
            var numberOfForks = newIdx;
            pushTreeFork(returnFiber, numberOfForks);
          }
          return resultingFirstChild;
        }
        if (oldFiber === null) {
          for (; !step.done; newIdx++, step = newChildren.next()) {
            var _newFiber3 = createChild(returnFiber, step.value, lanes);
            _newFiber3 !== null && (lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber3 : previousNewFiber.sibling = _newFiber3, previousNewFiber = _newFiber3);
          }
          if (getIsHydrating()) {
            var _numberOfForks3 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks3);
          }
          return resultingFirstChild;
        }
        for (var existingChildren = mapRemainingChildren(returnFiber, oldFiber); !step.done; newIdx++, step = newChildren.next()) {
          var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
          _newFiber4 !== null && (shouldTrackSideEffects && _newFiber4.alternate !== null && existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key), lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx), previousNewFiber === null ? resultingFirstChild = _newFiber4 : previousNewFiber.sibling = _newFiber4, previousNewFiber = _newFiber4);
        }
        if (shouldTrackSideEffects && existingChildren.forEach(function(child2) {
          return deleteChild(returnFiber, child2);
        }), getIsHydrating()) {
          var _numberOfForks4 = newIdx;
          pushTreeFork(returnFiber, _numberOfForks4);
        }
        return resultingFirstChild;
      }
      function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
        if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
          deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
          var existing = useFiber(currentFirstChild, textContent);
          return existing.return = returnFiber, existing;
        }
        deleteRemainingChildren(returnFiber, currentFirstChild);
        var created = createFiberFromText(textContent, returnFiber.mode, lanes);
        return created.return = returnFiber, created;
      }
      function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
        for (var key2 = element.key, child = currentFirstChild; child !== null; ) {
          if (child.key === key2) {
            var elementType = element.type;
            if (elementType === REACT_FRAGMENT_TYPE) {
              if (child.tag === Fragment2) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, element.props.children);
                return existing.return = returnFiber, existing._debugSource = element._source, existing._debugOwner = element._owner, existing;
              }
            } else if (child.elementType === elementType || // Keep this check inline so it only runs on the false path:
            isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof elementType == "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var _existing = useFiber(child, element.props);
              return _existing.ref = coerceRef(returnFiber, child, element), _existing.return = returnFiber, _existing._debugSource = element._source, _existing._debugOwner = element._owner, _existing;
            }
            deleteRemainingChildren(returnFiber, child);
            break;
          } else
            deleteChild(returnFiber, child);
          child = child.sibling;
        }
        if (element.type === REACT_FRAGMENT_TYPE) {
          var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
          return created.return = returnFiber, created;
        } else {
          var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
          return _created4.ref = coerceRef(returnFiber, currentFirstChild, element), _created4.return = returnFiber, _created4;
        }
      }
      function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
        for (var key2 = portal.key, child = currentFirstChild; child !== null; ) {
          if (child.key === key2)
            if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
              deleteRemainingChildren(returnFiber, child.sibling);
              var existing = useFiber(child, portal.children || []);
              return existing.return = returnFiber, existing;
            } else {
              deleteRemainingChildren(returnFiber, child);
              break;
            }
          else
            deleteChild(returnFiber, child);
          child = child.sibling;
        }
        var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
        return created.return = returnFiber, created;
      }
      function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
        var isUnkeyedTopLevelFragment = typeof newChild == "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
        if (isUnkeyedTopLevelFragment && (newChild = newChild.props.children), typeof newChild == "object" && newChild !== null) {
          switch (newChild.$$typeof) {
            case REACT_ELEMENT_TYPE:
              return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
            case REACT_PORTAL_TYPE:
              return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
            case REACT_LAZY_TYPE:
              var payload = newChild._payload, init = newChild._init;
              return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
          }
          if (isArray(newChild))
            return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
          if (getIteratorFn(newChild))
            return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
          throwOnInvalidObjectType(returnFiber, newChild);
        }
        return typeof newChild == "string" && newChild !== "" || typeof newChild == "number" ? placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes)) : (typeof newChild == "function" && warnOnFunctionType(returnFiber), deleteRemainingChildren(returnFiber, currentFirstChild));
      }
      return reconcileChildFibers2;
    }
    var reconcileChildFibers = ChildReconciler(!0), mountChildFibers = ChildReconciler(!1);
    function cloneChildFibers(current2, workInProgress2) {
      if (current2 !== null && workInProgress2.child !== current2.child)
        throw new Error("Resuming work not yet implemented.");
      if (workInProgress2.child !== null) {
        var currentChild = workInProgress2.child, newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        for (workInProgress2.child = newChild, newChild.return = workInProgress2; currentChild.sibling !== null; )
          currentChild = currentChild.sibling, newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps), newChild.return = workInProgress2;
        newChild.sibling = null;
      }
    }
    function resetChildFibers(workInProgress2, lanes) {
      for (var child = workInProgress2.child; child !== null; )
        resetWorkInProgress(child, lanes), child = child.sibling;
    }
    var valueCursor = createCursor(null), rendererSigil;
    rendererSigil = {};
    var currentlyRenderingFiber = null, lastContextDependency = null, lastFullyObservedContext = null, isDisallowedContextReadInDEV = !1;
    function resetContextDependencies() {
      currentlyRenderingFiber = null, lastContextDependency = null, lastFullyObservedContext = null, isDisallowedContextReadInDEV = !1;
    }
    function enterDisallowedContextReadInDEV() {
      isDisallowedContextReadInDEV = !0;
    }
    function exitDisallowedContextReadInDEV() {
      isDisallowedContextReadInDEV = !1;
    }
    function pushProvider(providerFiber, context, nextValue) {
      push(valueCursor, context._currentValue, providerFiber), context._currentValue = nextValue, context._currentRenderer !== void 0 && context._currentRenderer !== null && context._currentRenderer !== rendererSigil && error("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), context._currentRenderer = rendererSigil;
    }
    function popProvider(context, providerFiber) {
      var currentValue = valueCursor.current;
      pop(valueCursor, providerFiber), context._currentValue = currentValue;
    }
    function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
      for (var node2 = parent; node2 !== null; ) {
        var alternate = node2.alternate;
        if (isSubsetOfLanes(node2.childLanes, renderLanes2) ? alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2) && (alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2)) : (node2.childLanes = mergeLanes(node2.childLanes, renderLanes2), alternate !== null && (alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2))), node2 === propagationRoot)
          break;
        node2 = node2.return;
      }
      node2 !== propagationRoot && error("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function propagateContextChange(workInProgress2, context, renderLanes2) {
      propagateContextChange_eager(workInProgress2, context, renderLanes2);
    }
    function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
      var fiber = workInProgress2.child;
      for (fiber !== null && (fiber.return = workInProgress2); fiber !== null; ) {
        var nextFiber = void 0, list = fiber.dependencies;
        if (list !== null) {
          nextFiber = fiber.child;
          for (var dependency = list.firstContext; dependency !== null; ) {
            if (dependency.context === context) {
              if (fiber.tag === ClassComponent) {
                var lane = pickArbitraryLane(renderLanes2), update = createUpdate(NoTimestamp, lane);
                update.tag = ForceUpdate;
                var updateQueue = fiber.updateQueue;
                if (updateQueue !== null) {
                  var sharedQueue = updateQueue.shared, pending = sharedQueue.pending;
                  pending === null ? update.next = update : (update.next = pending.next, pending.next = update), sharedQueue.pending = update;
                }
              }
              fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
              var alternate = fiber.alternate;
              alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2), list.lanes = mergeLanes(list.lanes, renderLanes2);
              break;
            }
            dependency = dependency.next;
          }
        } else if (fiber.tag === ContextProvider)
          nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
        else if (fiber.tag === DehydratedFragment) {
          var parentSuspense = fiber.return;
          if (parentSuspense === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
          var _alternate = parentSuspense.alternate;
          _alternate !== null && (_alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2), nextFiber = fiber.sibling;
        } else
          nextFiber = fiber.child;
        if (nextFiber !== null)
          nextFiber.return = fiber;
        else
          for (nextFiber = fiber; nextFiber !== null; ) {
            if (nextFiber === workInProgress2) {
              nextFiber = null;
              break;
            }
            var sibling = nextFiber.sibling;
            if (sibling !== null) {
              sibling.return = nextFiber.return, nextFiber = sibling;
              break;
            }
            nextFiber = nextFiber.return;
          }
        fiber = nextFiber;
      }
    }
    function prepareToReadContext(workInProgress2, renderLanes2) {
      currentlyRenderingFiber = workInProgress2, lastContextDependency = null, lastFullyObservedContext = null;
      var dependencies = workInProgress2.dependencies;
      if (dependencies !== null) {
        var firstContext = dependencies.firstContext;
        firstContext !== null && (includesSomeLane(dependencies.lanes, renderLanes2) && markWorkInProgressReceivedUpdate(), dependencies.firstContext = null);
      }
    }
    function readContext(context) {
      isDisallowedContextReadInDEV && error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var value = context._currentValue;
      if (lastFullyObservedContext !== context) {
        var contextItem = {
          context,
          memoizedValue: value,
          next: null
        };
        if (lastContextDependency === null) {
          if (currentlyRenderingFiber === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          lastContextDependency = contextItem, currentlyRenderingFiber.dependencies = {
            lanes: NoLanes,
            firstContext: contextItem
          };
        } else
          lastContextDependency = lastContextDependency.next = contextItem;
      }
      return value;
    }
    var concurrentQueues = null;
    function pushConcurrentUpdateQueue(queue) {
      concurrentQueues === null ? concurrentQueues = [queue] : concurrentQueues.push(queue);
    }
    function finishQueueingConcurrentUpdates() {
      if (concurrentQueues !== null) {
        for (var i = 0; i < concurrentQueues.length; i++) {
          var queue = concurrentQueues[i], lastInterleavedUpdate = queue.interleaved;
          if (lastInterleavedUpdate !== null) {
            queue.interleaved = null;
            var firstInterleavedUpdate = lastInterleavedUpdate.next, lastPendingUpdate = queue.pending;
            if (lastPendingUpdate !== null) {
              var firstPendingUpdate = lastPendingUpdate.next;
              lastPendingUpdate.next = firstInterleavedUpdate, lastInterleavedUpdate.next = firstPendingUpdate;
            }
            queue.pending = lastInterleavedUpdate;
          }
        }
        concurrentQueues = null;
      }
    }
    function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
      var interleaved = queue.interleaved;
      return interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update, markUpdateLaneFromFiberToRoot(fiber, lane);
    }
    function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
      var interleaved = queue.interleaved;
      interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update;
    }
    function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
      var interleaved = queue.interleaved;
      return interleaved === null ? (update.next = update, pushConcurrentUpdateQueue(queue)) : (update.next = interleaved.next, interleaved.next = update), queue.interleaved = update, markUpdateLaneFromFiberToRoot(fiber, lane);
    }
    function enqueueConcurrentRenderForLane(fiber, lane) {
      return markUpdateLaneFromFiberToRoot(fiber, lane);
    }
    var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
    function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
      sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
      var alternate = sourceFiber.alternate;
      alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, lane)), alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
      for (var node2 = sourceFiber, parent = sourceFiber.return; parent !== null; )
        parent.childLanes = mergeLanes(parent.childLanes, lane), alternate = parent.alternate, alternate !== null ? alternate.childLanes = mergeLanes(alternate.childLanes, lane) : (parent.flags & (Placement | Hydrating)) !== NoFlags && warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber), node2 = parent, parent = parent.return;
      if (node2.tag === HostRoot) {
        var root2 = node2.stateNode;
        return root2;
      } else
        return null;
    }
    var UpdateState = 0, ReplaceState = 1, ForceUpdate = 2, CaptureUpdate = 3, hasForceUpdate = !1, didWarnUpdateInsideUpdate, currentlyProcessingQueue;
    didWarnUpdateInsideUpdate = !1, currentlyProcessingQueue = null;
    function initializeUpdateQueue(fiber) {
      var queue = {
        baseState: fiber.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: NoLanes
        },
        effects: null
      };
      fiber.updateQueue = queue;
    }
    function cloneUpdateQueue(current2, workInProgress2) {
      var queue = workInProgress2.updateQueue, currentQueue = current2.updateQueue;
      if (queue === currentQueue) {
        var clone = {
          baseState: currentQueue.baseState,
          firstBaseUpdate: currentQueue.firstBaseUpdate,
          lastBaseUpdate: currentQueue.lastBaseUpdate,
          shared: currentQueue.shared,
          effects: currentQueue.effects
        };
        workInProgress2.updateQueue = clone;
      }
    }
    function createUpdate(eventTime, lane) {
      var update = {
        eventTime,
        lane,
        tag: UpdateState,
        payload: null,
        callback: null,
        next: null
      };
      return update;
    }
    function enqueueUpdate(fiber, update, lane) {
      var updateQueue = fiber.updateQueue;
      if (updateQueue === null)
        return null;
      var sharedQueue = updateQueue.shared;
      if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate && (error("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), didWarnUpdateInsideUpdate = !0), isUnsafeClassRenderPhaseUpdate()) {
        var pending = sharedQueue.pending;
        return pending === null ? update.next = update : (update.next = pending.next, pending.next = update), sharedQueue.pending = update, unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
      } else
        return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
    }
    function entangleTransitions(root2, fiber, lane) {
      var updateQueue = fiber.updateQueue;
      if (updateQueue !== null) {
        var sharedQueue = updateQueue.shared;
        if (isTransitionLane(lane)) {
          var queueLanes = sharedQueue.lanes;
          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          sharedQueue.lanes = newQueueLanes, markRootEntangled(root2, newQueueLanes);
        }
      }
    }
    function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
      var queue = workInProgress2.updateQueue, current2 = workInProgress2.alternate;
      if (current2 !== null) {
        var currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
          var newFirst = null, newLast = null, firstBaseUpdate = queue.firstBaseUpdate;
          if (firstBaseUpdate !== null) {
            var update = firstBaseUpdate;
            do {
              var clone = {
                eventTime: update.eventTime,
                lane: update.lane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              newLast === null ? newFirst = newLast = clone : (newLast.next = clone, newLast = clone), update = update.next;
            } while (update !== null);
            newLast === null ? newFirst = newLast = capturedUpdate : (newLast.next = capturedUpdate, newLast = capturedUpdate);
          } else
            newFirst = newLast = capturedUpdate;
          queue = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: newFirst,
            lastBaseUpdate: newLast,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          }, workInProgress2.updateQueue = queue;
          return;
        }
      }
      var lastBaseUpdate = queue.lastBaseUpdate;
      lastBaseUpdate === null ? queue.firstBaseUpdate = capturedUpdate : lastBaseUpdate.next = capturedUpdate, queue.lastBaseUpdate = capturedUpdate;
    }
    function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
      switch (update.tag) {
        case ReplaceState: {
          var payload = update.payload;
          if (typeof payload == "function") {
            enterDisallowedContextReadInDEV();
            var nextState = payload.call(instance, prevState, nextProps);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(!0);
                try {
                  payload.call(instance, prevState, nextProps);
                } finally {
                  setIsStrictModeForDevtools(!1);
                }
              }
              exitDisallowedContextReadInDEV();
            }
            return nextState;
          }
          return payload;
        }
        case CaptureUpdate:
          workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
        case UpdateState: {
          var _payload = update.payload, partialState;
          if (typeof _payload == "function") {
            enterDisallowedContextReadInDEV(), partialState = _payload.call(instance, prevState, nextProps);
            {
              if (workInProgress2.mode & StrictLegacyMode) {
                setIsStrictModeForDevtools(!0);
                try {
                  _payload.call(instance, prevState, nextProps);
                } finally {
                  setIsStrictModeForDevtools(!1);
                }
              }
              exitDisallowedContextReadInDEV();
            }
          } else
            partialState = _payload;
          return partialState == null ? prevState : assign2({}, prevState, partialState);
        }
        case ForceUpdate:
          return hasForceUpdate = !0, prevState;
      }
      return prevState;
    }
    function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
      var queue = workInProgress2.updateQueue;
      hasForceUpdate = !1, currentlyProcessingQueue = queue.shared;
      var firstBaseUpdate = queue.firstBaseUpdate, lastBaseUpdate = queue.lastBaseUpdate, pendingQueue = queue.shared.pending;
      if (pendingQueue !== null) {
        queue.shared.pending = null;
        var lastPendingUpdate = pendingQueue, firstPendingUpdate = lastPendingUpdate.next;
        lastPendingUpdate.next = null, lastBaseUpdate === null ? firstBaseUpdate = firstPendingUpdate : lastBaseUpdate.next = firstPendingUpdate, lastBaseUpdate = lastPendingUpdate;
        var current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue = current2.updateQueue, currentLastBaseUpdate = currentQueue.lastBaseUpdate;
          currentLastBaseUpdate !== lastBaseUpdate && (currentLastBaseUpdate === null ? currentQueue.firstBaseUpdate = firstPendingUpdate : currentLastBaseUpdate.next = firstPendingUpdate, currentQueue.lastBaseUpdate = lastPendingUpdate);
        }
      }
      if (firstBaseUpdate !== null) {
        var newState = queue.baseState, newLanes = NoLanes, newBaseState = null, newFirstBaseUpdate = null, newLastBaseUpdate = null, update = firstBaseUpdate;
        do {
          var updateLane = update.lane, updateEventTime = update.eventTime;
          if (isSubsetOfLanes(renderLanes2, updateLane)) {
            if (newLastBaseUpdate !== null) {
              var _clone = {
                eventTime: updateEventTime,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: NoLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              newLastBaseUpdate = newLastBaseUpdate.next = _clone;
            }
            newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
            var callback = update.callback;
            if (callback !== null && // If the update was already committed, we should not queue its
            // callback again.
            update.lane !== NoLane) {
              workInProgress2.flags |= Callback;
              var effects = queue.effects;
              effects === null ? queue.effects = [update] : effects.push(update);
            }
          } else {
            var clone = {
              eventTime: updateEventTime,
              lane: updateLane,
              tag: update.tag,
              payload: update.payload,
              callback: update.callback,
              next: null
            };
            newLastBaseUpdate === null ? (newFirstBaseUpdate = newLastBaseUpdate = clone, newBaseState = newState) : newLastBaseUpdate = newLastBaseUpdate.next = clone, newLanes = mergeLanes(newLanes, updateLane);
          }
          if (update = update.next, update === null) {
            if (pendingQueue = queue.shared.pending, pendingQueue === null)
              break;
            var _lastPendingUpdate = pendingQueue, _firstPendingUpdate = _lastPendingUpdate.next;
            _lastPendingUpdate.next = null, update = _firstPendingUpdate, queue.lastBaseUpdate = _lastPendingUpdate, queue.shared.pending = null;
          }
        } while (!0);
        newLastBaseUpdate === null && (newBaseState = newState), queue.baseState = newBaseState, queue.firstBaseUpdate = newFirstBaseUpdate, queue.lastBaseUpdate = newLastBaseUpdate;
        var lastInterleaved = queue.shared.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do
            newLanes = mergeLanes(newLanes, interleaved.lane), interleaved = interleaved.next;
          while (interleaved !== lastInterleaved);
        } else firstBaseUpdate === null && (queue.shared.lanes = NoLanes);
        markSkippedUpdateLanes(newLanes), workInProgress2.lanes = newLanes, workInProgress2.memoizedState = newState;
      }
      currentlyProcessingQueue = null;
    }
    function callCallback(callback, context) {
      if (typeof callback != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
      callback.call(context);
    }
    function resetHasForceUpdateBeforeProcessing() {
      hasForceUpdate = !1;
    }
    function checkHasForceUpdateAfterProcessing() {
      return hasForceUpdate;
    }
    function commitUpdateQueue(finishedWork, finishedQueue, instance) {
      var effects = finishedQueue.effects;
      if (finishedQueue.effects = null, effects !== null)
        for (var i = 0; i < effects.length; i++) {
          var effect = effects[i], callback = effect.callback;
          callback !== null && (effect.callback = null, callCallback(callback, instance));
        }
    }
    var NO_CONTEXT = {}, contextStackCursor$1 = createCursor(NO_CONTEXT), contextFiberStackCursor = createCursor(NO_CONTEXT), rootInstanceStackCursor = createCursor(NO_CONTEXT);
    function requiredContext(c) {
      if (c === NO_CONTEXT)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return c;
    }
    function getRootHostContainer() {
      var rootInstance = requiredContext(rootInstanceStackCursor.current);
      return rootInstance;
    }
    function pushHostContainer(fiber, nextRootInstance) {
      push(rootInstanceStackCursor, nextRootInstance, fiber), push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, NO_CONTEXT, fiber);
      var nextRootContext = getRootHostContext(nextRootInstance);
      pop(contextStackCursor$1, fiber), push(contextStackCursor$1, nextRootContext, fiber);
    }
    function popHostContainer(fiber) {
      pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber), pop(rootInstanceStackCursor, fiber);
    }
    function getHostContext() {
      var context = requiredContext(contextStackCursor$1.current);
      return context;
    }
    function pushHostContext(fiber) {
      requiredContext(rootInstanceStackCursor.current);
      var context = requiredContext(contextStackCursor$1.current), nextContext = getChildHostContext(context, fiber.type);
      context !== nextContext && (push(contextFiberStackCursor, fiber, fiber), push(contextStackCursor$1, nextContext, fiber));
    }
    function popHostContext(fiber) {
      contextFiberStackCursor.current === fiber && (pop(contextStackCursor$1, fiber), pop(contextFiberStackCursor, fiber));
    }
    var DefaultSuspenseContext = 0, SubtreeSuspenseContextMask = 1, InvisibleParentSuspenseContext = 1, ForceSuspenseFallback = 2, suspenseStackCursor = createCursor(DefaultSuspenseContext);
    function hasSuspenseContext(parentContext, flag) {
      return (parentContext & flag) !== 0;
    }
    function setDefaultShallowSuspenseContext(parentContext) {
      return parentContext & SubtreeSuspenseContextMask;
    }
    function setShallowSuspenseContext(parentContext, shallowContext) {
      return parentContext & SubtreeSuspenseContextMask | shallowContext;
    }
    function addSubtreeSuspenseContext(parentContext, subtreeContext) {
      return parentContext | subtreeContext;
    }
    function pushSuspenseContext(fiber, newContext) {
      push(suspenseStackCursor, newContext, fiber);
    }
    function popSuspenseContext(fiber) {
      pop(suspenseStackCursor, fiber);
    }
    function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
      var nextState = workInProgress2.memoizedState;
      return nextState !== null ? nextState.dehydrated !== null : !0;
    }
    function findFirstSuspended(row) {
      for (var node2 = row; node2 !== null; ) {
        if (node2.tag === SuspenseComponent) {
          var state = node2.memoizedState;
          if (state !== null) {
            var dehydrated = state.dehydrated;
            if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated))
              return node2;
          }
        } else if (node2.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        node2.memoizedProps.revealOrder !== void 0) {
          var didSuspend = (node2.flags & DidCapture) !== NoFlags;
          if (didSuspend)
            return node2;
        } else if (node2.child !== null) {
          node2.child.return = node2, node2 = node2.child;
          continue;
        }
        if (node2 === row)
          return null;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === row)
            return null;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return, node2 = node2.sibling;
      }
      return null;
    }
    var NoFlags$1 = (
      /*   */
      0
    ), HasEffect = (
      /* */
      1
    ), Insertion = (
      /*  */
      2
    ), Layout = (
      /*    */
      4
    ), Passive$1 = (
      /*   */
      8
    ), workInProgressSources = [];
    function resetWorkInProgressVersions() {
      for (var i = 0; i < workInProgressSources.length; i++) {
        var mutableSource = workInProgressSources[i];
        mutableSource._workInProgressVersionPrimary = null;
      }
      workInProgressSources.length = 0;
    }
    function registerMutableSourceForHydration(root2, mutableSource) {
      var getVersion = mutableSource._getVersion, version = getVersion(mutableSource._source);
      root2.mutableSourceEagerHydrationData == null ? root2.mutableSourceEagerHydrationData = [mutableSource, version] : root2.mutableSourceEagerHydrationData.push(mutableSource, version);
    }
    var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentBatchConfig$2 = ReactSharedInternals.ReactCurrentBatchConfig, didWarnAboutMismatchedHooksForComponent, didWarnUncachedGetSnapshot;
    didWarnAboutMismatchedHooksForComponent = /* @__PURE__ */ new Set();
    var renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, didScheduleRenderPhaseUpdate = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0, globalClientIdCounter = 0, RE_RENDER_LIMIT = 25, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = !1;
    function mountHookTypesDev() {
      {
        var hookName = currentHookNameInDev;
        hookTypesDev === null ? hookTypesDev = [hookName] : hookTypesDev.push(hookName);
      }
    }
    function updateHookTypesDev() {
      {
        var hookName = currentHookNameInDev;
        hookTypesDev !== null && (hookTypesUpdateIndexDev++, hookTypesDev[hookTypesUpdateIndexDev] !== hookName && warnOnHookMismatchInDev(hookName));
      }
    }
    function checkDepsAreArrayDev(deps) {
      deps != null && !isArray(deps) && error("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
    }
    function warnOnHookMismatchInDev(currentHookName) {
      {
        var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
        if (!didWarnAboutMismatchedHooksForComponent.has(componentName) && (didWarnAboutMismatchedHooksForComponent.add(componentName), hookTypesDev !== null)) {
          for (var table = "", secondColumnStart = 30, i = 0; i <= hookTypesUpdateIndexDev; i++) {
            for (var oldHookName = hookTypesDev[i], newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName, row = i + 1 + ". " + oldHookName; row.length < secondColumnStart; )
              row += " ";
            row += newHookName + `
`, table += row;
          }
          error(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName, table);
        }
      }
    }
    function throwInvalidHookError() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function areHookInputsEqual(nextDeps, prevDeps) {
      if (ignorePreviousDependencies)
        return !1;
      if (prevDeps === null)
        return error("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev), !1;
      nextDeps.length !== prevDeps.length && error(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
      for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)
        if (!objectIs(nextDeps[i], prevDeps[i]))
          return !1;
      return !0;
    }
    function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
      renderLanes = nextRenderLanes, currentlyRenderingFiber$1 = workInProgress2, hookTypesDev = current2 !== null ? current2._debugHookTypes : null, hookTypesUpdateIndexDev = -1, ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.lanes = NoLanes, current2 !== null && current2.memoizedState !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV : hookTypesDev !== null ? ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV : ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
      var children = Component(props, secondArg);
      if (didScheduleRenderPhaseUpdateDuringThisPass) {
        var numberOfReRenders = 0;
        do {
          if (didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0, numberOfReRenders >= RE_RENDER_LIMIT)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          numberOfReRenders += 1, ignorePreviousDependencies = !1, currentHook = null, workInProgressHook = null, workInProgress2.updateQueue = null, hookTypesUpdateIndexDev = -1, ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV, children = Component(props, secondArg);
        } while (didScheduleRenderPhaseUpdateDuringThisPass);
      }
      ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, workInProgress2._debugHookTypes = hookTypesDev;
      var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
      if (renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, currentHookNameInDev = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (current2.mode & ConcurrentMode) !== NoMode && error("Internal React error: Expected static flag was missing. Please notify the React team."), didScheduleRenderPhaseUpdate = !1, didRenderTooFewHooks)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return children;
    }
    function checkDidRenderIdHook() {
      var didRenderIdHook = localIdCounter !== 0;
      return localIdCounter = 0, didRenderIdHook;
    }
    function bailoutHooks(current2, workInProgress2, lanes) {
      workInProgress2.updateQueue = current2.updateQueue, (workInProgress2.mode & StrictEffectsMode) !== NoMode ? workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update) : workInProgress2.flags &= ~(Passive | Update), current2.lanes = removeLanes(current2.lanes, lanes);
    }
    function resetHooksAfterThrow() {
      if (ReactCurrentDispatcher$1.current = ContextOnlyDispatcher, didScheduleRenderPhaseUpdate) {
        for (var hook = currentlyRenderingFiber$1.memoizedState; hook !== null; ) {
          var queue = hook.queue;
          queue !== null && (queue.pending = null), hook = hook.next;
        }
        didScheduleRenderPhaseUpdate = !1;
      }
      renderLanes = NoLanes, currentlyRenderingFiber$1 = null, currentHook = null, workInProgressHook = null, hookTypesDev = null, hookTypesUpdateIndexDev = -1, currentHookNameInDev = null, isUpdatingOpaqueValueInRenderPhase = !1, didScheduleRenderPhaseUpdateDuringThisPass = !1, localIdCounter = 0;
    }
    function mountWorkInProgressHook() {
      var hook = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook : workInProgressHook = workInProgressHook.next = hook, workInProgressHook;
    }
    function updateWorkInProgressHook() {
      var nextCurrentHook;
      if (currentHook === null) {
        var current2 = currentlyRenderingFiber$1.alternate;
        current2 !== null ? nextCurrentHook = current2.memoizedState : nextCurrentHook = null;
      } else
        nextCurrentHook = currentHook.next;
      var nextWorkInProgressHook;
      if (workInProgressHook === null ? nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState : nextWorkInProgressHook = workInProgressHook.next, nextWorkInProgressHook !== null)
        workInProgressHook = nextWorkInProgressHook, nextWorkInProgressHook = workInProgressHook.next, currentHook = nextCurrentHook;
      else {
        if (nextCurrentHook === null)
          throw new Error("Rendered more hooks than during the previous render.");
        currentHook = nextCurrentHook;
        var newHook = {
          memoizedState: currentHook.memoizedState,
          baseState: currentHook.baseState,
          baseQueue: currentHook.baseQueue,
          queue: currentHook.queue,
          next: null
        };
        workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook : workInProgressHook = workInProgressHook.next = newHook;
      }
      return workInProgressHook;
    }
    function createFunctionComponentUpdateQueue() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function basicStateReducer(state, action) {
      return typeof action == "function" ? action(state) : action;
    }
    function mountReducer(reducer, initialArg, init) {
      var hook = mountWorkInProgressHook(), initialState;
      init !== void 0 ? initialState = init(initialArg) : initialState = initialArg, hook.memoizedState = hook.baseState = initialState;
      var queue = {
        pending: null,
        interleaved: null,
        lanes: NoLanes,
        dispatch: null,
        lastRenderedReducer: reducer,
        lastRenderedState: initialState
      };
      hook.queue = queue;
      var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
      return [hook.memoizedState, dispatch];
    }
    function updateReducer(reducer, initialArg, init) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      queue.lastRenderedReducer = reducer;
      var current2 = currentHook, baseQueue = current2.baseQueue, pendingQueue = queue.pending;
      if (pendingQueue !== null) {
        if (baseQueue !== null) {
          var baseFirst = baseQueue.next, pendingFirst = pendingQueue.next;
          baseQueue.next = pendingFirst, pendingQueue.next = baseFirst;
        }
        current2.baseQueue !== baseQueue && error("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), current2.baseQueue = baseQueue = pendingQueue, queue.pending = null;
      }
      if (baseQueue !== null) {
        var first = baseQueue.next, newState = current2.baseState, newBaseState = null, newBaseQueueFirst = null, newBaseQueueLast = null, update = first;
        do {
          var updateLane = update.lane;
          if (isSubsetOfLanes(renderLanes, updateLane)) {
            if (newBaseQueueLast !== null) {
              var _clone = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: NoLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              newBaseQueueLast = newBaseQueueLast.next = _clone;
            }
            if (update.hasEagerState)
              newState = update.eagerState;
            else {
              var action = update.action;
              newState = reducer(newState, action);
            }
          } else {
            var clone = {
              lane: updateLane,
              action: update.action,
              hasEagerState: update.hasEagerState,
              eagerState: update.eagerState,
              next: null
            };
            newBaseQueueLast === null ? (newBaseQueueFirst = newBaseQueueLast = clone, newBaseState = newState) : newBaseQueueLast = newBaseQueueLast.next = clone, currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane), markSkippedUpdateLanes(updateLane);
          }
          update = update.next;
        } while (update !== null && update !== first);
        newBaseQueueLast === null ? newBaseState = newState : newBaseQueueLast.next = newBaseQueueFirst, objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseState = newBaseState, hook.baseQueue = newBaseQueueLast, queue.lastRenderedState = newState;
      }
      var lastInterleaved = queue.interleaved;
      if (lastInterleaved !== null) {
        var interleaved = lastInterleaved;
        do {
          var interleavedLane = interleaved.lane;
          currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane), markSkippedUpdateLanes(interleavedLane), interleaved = interleaved.next;
        } while (interleaved !== lastInterleaved);
      } else baseQueue === null && (queue.lanes = NoLanes);
      var dispatch = queue.dispatch;
      return [hook.memoizedState, dispatch];
    }
    function rerenderReducer(reducer, initialArg, init) {
      var hook = updateWorkInProgressHook(), queue = hook.queue;
      if (queue === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      queue.lastRenderedReducer = reducer;
      var dispatch = queue.dispatch, lastRenderPhaseUpdate = queue.pending, newState = hook.memoizedState;
      if (lastRenderPhaseUpdate !== null) {
        queue.pending = null;
        var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next, update = firstRenderPhaseUpdate;
        do {
          var action = update.action;
          newState = reducer(newState, action), update = update.next;
        } while (update !== firstRenderPhaseUpdate);
        objectIs(newState, hook.memoizedState) || markWorkInProgressReceivedUpdate(), hook.memoizedState = newState, hook.baseQueue === null && (hook.baseState = newState), queue.lastRenderedState = newState;
      }
      return [newState, dispatch];
    }
    function mountMutableSource(source, getSnapshot, subscribe) {
    }
    function updateMutableSource(source, getSnapshot, subscribe) {
    }
    function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot2) {
      var fiber = currentlyRenderingFiber$1, hook = mountWorkInProgressHook(), nextSnapshot, isHydrating2 = getIsHydrating();
      if (isHydrating2) {
        if (getServerSnapshot2 === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        nextSnapshot = getServerSnapshot2(), didWarnUncachedGetSnapshot || nextSnapshot !== getServerSnapshot2() && (error("The result of getServerSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      } else {
        if (nextSnapshot = getSnapshot(), !didWarnUncachedGetSnapshot) {
          var cachedSnapshot = getSnapshot();
          objectIs(nextSnapshot, cachedSnapshot) || (error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
        }
        var root2 = getWorkInProgressRoot();
        if (root2 === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        includesBlockingLane(root2, renderLanes) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      hook.memoizedState = nextSnapshot;
      var inst = {
        value: nextSnapshot,
        getSnapshot
      };
      return hook.queue = inst, mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]), fiber.flags |= Passive, pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null), nextSnapshot;
    }
    function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot2) {
      var fiber = currentlyRenderingFiber$1, hook = updateWorkInProgressHook(), nextSnapshot = getSnapshot();
      if (!didWarnUncachedGetSnapshot) {
        var cachedSnapshot = getSnapshot();
        objectIs(nextSnapshot, cachedSnapshot) || (error("The result of getSnapshot should be cached to avoid an infinite loop"), didWarnUncachedGetSnapshot = !0);
      }
      var prevSnapshot = hook.memoizedState, snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
      snapshotChanged && (hook.memoizedState = nextSnapshot, markWorkInProgressReceivedUpdate());
      var inst = hook.queue;
      if (updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]), inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
        fiber.flags |= Passive, pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), void 0, null);
        var root2 = getWorkInProgressRoot();
        if (root2 === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        includesBlockingLane(root2, renderLanes) || pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
      }
      return nextSnapshot;
    }
    function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
      fiber.flags |= StoreConsistency;
      var check2 = {
        getSnapshot,
        value: renderedSnapshot
      }, componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
      if (componentUpdateQueue === null)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = componentUpdateQueue, componentUpdateQueue.stores = [check2];
      else {
        var stores = componentUpdateQueue.stores;
        stores === null ? componentUpdateQueue.stores = [check2] : stores.push(check2);
      }
    }
    function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
      inst.value = nextSnapshot, inst.getSnapshot = getSnapshot, checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
    }
    function subscribeToStore(fiber, inst, subscribe) {
      var handleStoreChange = function() {
        checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);
      };
      return subscribe(handleStoreChange);
    }
    function checkIfSnapshotChanged(inst) {
      var latestGetSnapshot = inst.getSnapshot, prevValue = inst.value;
      try {
        var nextValue = latestGetSnapshot();
        return !objectIs(prevValue, nextValue);
      } catch {
        return !0;
      }
    }
    function forceStoreRerender(fiber) {
      var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
      root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
    }
    function mountState(initialState) {
      var hook = mountWorkInProgressHook();
      typeof initialState == "function" && (initialState = initialState()), hook.memoizedState = hook.baseState = initialState;
      var queue = {
        pending: null,
        interleaved: null,
        lanes: NoLanes,
        dispatch: null,
        lastRenderedReducer: basicStateReducer,
        lastRenderedState: initialState
      };
      hook.queue = queue;
      var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
      return [hook.memoizedState, dispatch];
    }
    function updateState(initialState) {
      return updateReducer(basicStateReducer);
    }
    function rerenderState(initialState) {
      return rerenderReducer(basicStateReducer);
    }
    function pushEffect(tag, create2, destroy, deps) {
      var effect = {
        tag,
        create: create2,
        destroy,
        deps,
        // Circular
        next: null
      }, componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
      if (componentUpdateQueue === null)
        componentUpdateQueue = createFunctionComponentUpdateQueue(), currentlyRenderingFiber$1.updateQueue = componentUpdateQueue, componentUpdateQueue.lastEffect = effect.next = effect;
      else {
        var lastEffect = componentUpdateQueue.lastEffect;
        if (lastEffect === null)
          componentUpdateQueue.lastEffect = effect.next = effect;
        else {
          var firstEffect = lastEffect.next;
          lastEffect.next = effect, effect.next = firstEffect, componentUpdateQueue.lastEffect = effect;
        }
      }
      return effect;
    }
    function mountRef(initialValue) {
      var hook = mountWorkInProgressHook();
      {
        var _ref2 = {
          current: initialValue
        };
        return hook.memoizedState = _ref2, _ref2;
      }
    }
    function updateRef(initialValue) {
      var hook = updateWorkInProgressHook();
      return hook.memoizedState;
    }
    function mountEffectImpl(fiberFlags, hookFlags, create2, deps) {
      var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
      currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, void 0, nextDeps);
    }
    function updateEffectImpl(fiberFlags, hookFlags, create2, deps) {
      var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, destroy = void 0;
      if (currentHook !== null) {
        var prevEffect = currentHook.memoizedState;
        if (destroy = prevEffect.destroy, nextDeps !== null) {
          var prevDeps = prevEffect.deps;
          if (areHookInputsEqual(nextDeps, prevDeps)) {
            hook.memoizedState = pushEffect(hookFlags, create2, destroy, nextDeps);
            return;
          }
        }
      }
      currentlyRenderingFiber$1.flags |= fiberFlags, hook.memoizedState = pushEffect(HasEffect | hookFlags, create2, destroy, nextDeps);
    }
    function mountEffect(create2, deps) {
      return (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode ? mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create2, deps) : mountEffectImpl(Passive | PassiveStatic, Passive$1, create2, deps);
    }
    function updateEffect(create2, deps) {
      return updateEffectImpl(Passive, Passive$1, create2, deps);
    }
    function mountInsertionEffect(create2, deps) {
      return mountEffectImpl(Update, Insertion, create2, deps);
    }
    function updateInsertionEffect(create2, deps) {
      return updateEffectImpl(Update, Insertion, create2, deps);
    }
    function mountLayoutEffect(create2, deps) {
      var fiberFlags = Update;
      return fiberFlags |= LayoutStatic, (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), mountEffectImpl(fiberFlags, Layout, create2, deps);
    }
    function updateLayoutEffect(create2, deps) {
      return updateEffectImpl(Update, Layout, create2, deps);
    }
    function imperativeHandleEffect(create2, ref) {
      if (typeof ref == "function") {
        var refCallback = ref, _inst = create2();
        return refCallback(_inst), function() {
          refCallback(null);
        };
      } else if (ref != null) {
        var refObject = ref;
        refObject.hasOwnProperty("current") || error("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
        var _inst2 = create2();
        return refObject.current = _inst2, function() {
          refObject.current = null;
        };
      }
    }
    function mountImperativeHandle(ref, create2, deps) {
      typeof create2 != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
      var effectDeps = deps != null ? deps.concat([ref]) : null, fiberFlags = Update;
      return fiberFlags |= LayoutStatic, (currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
    }
    function updateImperativeHandle(ref, create2, deps) {
      typeof create2 != "function" && error("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", create2 !== null ? typeof create2 : "null");
      var effectDeps = deps != null ? deps.concat([ref]) : null;
      return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create2, ref), effectDeps);
    }
    function mountDebugValue(value, formatterFn) {
    }
    var updateDebugValue = mountDebugValue;
    function mountCallback(callback, deps) {
      var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps;
      return hook.memoizedState = [callback, nextDeps], callback;
    }
    function updateCallback(callback, deps) {
      var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
      if (prevState !== null && nextDeps !== null) {
        var prevDeps = prevState[1];
        if (areHookInputsEqual(nextDeps, prevDeps))
          return prevState[0];
      }
      return hook.memoizedState = [callback, nextDeps], callback;
    }
    function mountMemo(nextCreate, deps) {
      var hook = mountWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, nextValue = nextCreate();
      return hook.memoizedState = [nextValue, nextDeps], nextValue;
    }
    function updateMemo(nextCreate, deps) {
      var hook = updateWorkInProgressHook(), nextDeps = deps === void 0 ? null : deps, prevState = hook.memoizedState;
      if (prevState !== null && nextDeps !== null) {
        var prevDeps = prevState[1];
        if (areHookInputsEqual(nextDeps, prevDeps))
          return prevState[0];
      }
      var nextValue = nextCreate();
      return hook.memoizedState = [nextValue, nextDeps], nextValue;
    }
    function mountDeferredValue(value) {
      var hook = mountWorkInProgressHook();
      return hook.memoizedState = value, value;
    }
    function updateDeferredValue(value) {
      var hook = updateWorkInProgressHook(), resolvedCurrentHook = currentHook, prevValue = resolvedCurrentHook.memoizedState;
      return updateDeferredValueImpl(hook, prevValue, value);
    }
    function rerenderDeferredValue(value) {
      var hook = updateWorkInProgressHook();
      if (currentHook === null)
        return hook.memoizedState = value, value;
      var prevValue = currentHook.memoizedState;
      return updateDeferredValueImpl(hook, prevValue, value);
    }
    function updateDeferredValueImpl(hook, prevValue, value) {
      var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
      if (shouldDeferValue) {
        if (!objectIs(value, prevValue)) {
          var deferredLane = claimNextTransitionLane();
          currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane), markSkippedUpdateLanes(deferredLane), hook.baseState = !0;
        }
        return prevValue;
      } else
        return hook.baseState && (hook.baseState = !1, markWorkInProgressReceivedUpdate()), hook.memoizedState = value, value;
    }
    function startTransition(setPending, callback, options2) {
      var previousPriority = getCurrentUpdatePriority();
      setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority)), setPending(!0);
      var prevTransition = ReactCurrentBatchConfig$2.transition;
      ReactCurrentBatchConfig$2.transition = {};
      var currentTransition = ReactCurrentBatchConfig$2.transition;
      ReactCurrentBatchConfig$2.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        setPending(!1), callback();
      } finally {
        if (setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$2.transition = prevTransition, prevTransition === null && currentTransition._updatedFibers) {
          var updatedFibersCount = currentTransition._updatedFibers.size;
          updatedFibersCount > 10 && warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), currentTransition._updatedFibers.clear();
        }
      }
    }
    function mountTransition() {
      var _mountState = mountState(!1), isPending = _mountState[0], setPending = _mountState[1], start = startTransition.bind(null, setPending), hook = mountWorkInProgressHook();
      return hook.memoizedState = start, [isPending, start];
    }
    function updateTransition() {
      var _updateState = updateState(), isPending = _updateState[0], hook = updateWorkInProgressHook(), start = hook.memoizedState;
      return [isPending, start];
    }
    function rerenderTransition() {
      var _rerenderState = rerenderState(), isPending = _rerenderState[0], hook = updateWorkInProgressHook(), start = hook.memoizedState;
      return [isPending, start];
    }
    var isUpdatingOpaqueValueInRenderPhase = !1;
    function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
      return isUpdatingOpaqueValueInRenderPhase;
    }
    function mountId() {
      var hook = mountWorkInProgressHook(), root2 = getWorkInProgressRoot(), identifierPrefix = root2.identifierPrefix, id2;
      if (getIsHydrating()) {
        var treeId = getTreeId();
        id2 = ":" + identifierPrefix + "R" + treeId;
        var localId = localIdCounter++;
        localId > 0 && (id2 += "H" + localId.toString(32)), id2 += ":";
      } else {
        var globalClientId = globalClientIdCounter++;
        id2 = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
      }
      return hook.memoizedState = id2, id2;
    }
    function updateId() {
      var hook = updateWorkInProgressHook(), id2 = hook.memoizedState;
      return id2;
    }
    function dispatchReducerAction(fiber, queue, action) {
      typeof arguments[3] == "function" && error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var lane = requestUpdateLane(fiber), update = {
        lane,
        action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime), entangleTransitionUpdate(root2, queue, lane);
        }
      }
      markUpdateInDevTools(fiber, lane);
    }
    function dispatchSetState(fiber, queue, action) {
      typeof arguments[3] == "function" && error("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var lane = requestUpdateLane(fiber), update = {
        lane,
        action,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (isRenderPhaseUpdate(fiber))
        enqueueRenderPhaseUpdate(queue, update);
      else {
        var alternate = fiber.alternate;
        if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
          var lastRenderedReducer = queue.lastRenderedReducer;
          if (lastRenderedReducer !== null) {
            var prevDispatcher;
            prevDispatcher = ReactCurrentDispatcher$1.current, ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              var currentState = queue.lastRenderedState, eagerState = lastRenderedReducer(currentState, action);
              if (update.hasEagerState = !0, update.eagerState = eagerState, objectIs(eagerState, currentState)) {
                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                return;
              }
            } catch {
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          }
        }
        var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime), entangleTransitionUpdate(root2, queue, lane);
        }
      }
      markUpdateInDevTools(fiber, lane);
    }
    function isRenderPhaseUpdate(fiber) {
      var alternate = fiber.alternate;
      return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
    }
    function enqueueRenderPhaseUpdate(queue, update) {
      didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = !0;
      var pending = queue.pending;
      pending === null ? update.next = update : (update.next = pending.next, pending.next = update), queue.pending = update;
    }
    function entangleTransitionUpdate(root2, queue, lane) {
      if (isTransitionLane(lane)) {
        var queueLanes = queue.lanes;
        queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
        var newQueueLanes = mergeLanes(queueLanes, lane);
        queue.lanes = newQueueLanes, markRootEntangled(root2, newQueueLanes);
      }
    }
    function markUpdateInDevTools(fiber, lane, action) {
      markStateUpdateScheduled(fiber, lane);
    }
    var ContextOnlyDispatcher = {
      readContext,
      useCallback: throwInvalidHookError,
      useContext: throwInvalidHookError,
      useEffect: throwInvalidHookError,
      useImperativeHandle: throwInvalidHookError,
      useInsertionEffect: throwInvalidHookError,
      useLayoutEffect: throwInvalidHookError,
      useMemo: throwInvalidHookError,
      useReducer: throwInvalidHookError,
      useRef: throwInvalidHookError,
      useState: throwInvalidHookError,
      useDebugValue: throwInvalidHookError,
      useDeferredValue: throwInvalidHookError,
      useTransition: throwInvalidHookError,
      useMutableSource: throwInvalidHookError,
      useSyncExternalStore: throwInvalidHookError,
      useId: throwInvalidHookError,
      unstable_isNewReconciler: enableNewReconciler
    }, HooksDispatcherOnMountInDEV = null, HooksDispatcherOnMountWithHookTypesInDEV = null, HooksDispatcherOnUpdateInDEV = null, HooksDispatcherOnRerenderInDEV = null, InvalidNestedHooksDispatcherOnMountInDEV = null, InvalidNestedHooksDispatcherOnUpdateInDEV = null, InvalidNestedHooksDispatcherOnRerenderInDEV = null;
    {
      var warnInvalidContextAccess = function() {
        error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, warnInvalidHookAccess = function() {
        error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      HooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", mountHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", mountHookTypesDev(), checkDepsAreArrayDev(deps), mountLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", mountHookTypesDev(), checkDepsAreArrayDev(deps);
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", mountHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", mountHookTypesDev(), mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", mountHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", mountHookTypesDev(), void 0;
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", mountHookTypesDev(), mountDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", mountHookTypesDev(), mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", mountHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", mountHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot2);
        },
        useId: function() {
          return currentHookNameInDev = "useId", mountHookTypesDev(), mountId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, HooksDispatcherOnMountWithHookTypesInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", updateHookTypesDev(), mountCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", updateHookTypesDev(), mountEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), mountImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), mountInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), mountLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", updateHookTypesDev(), mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), void 0;
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), mountDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", updateHookTypesDev(), mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot2);
        },
        useId: function() {
          return currentHookNameInDev = "useId", updateHookTypesDev(), mountId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, HooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), updateInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), updateDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", updateHookTypesDev(), updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
        },
        useId: function() {
          return currentHookNameInDev = "useId", updateHookTypesDev(), updateId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, HooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          return readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", updateHookTypesDev(), updateCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", updateHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", updateHookTypesDev(), updateEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", updateHookTypesDev(), updateInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", updateHookTypesDev(), updateLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return updateMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", updateHookTypesDev(), updateRef();
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
          try {
            return rerenderState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", updateHookTypesDev(), updateDebugValue();
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", updateHookTypesDev(), rerenderDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", updateHookTypesDev(), rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", updateHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
        },
        useId: function() {
          return currentHookNameInDev = "useId", updateHookTypesDev(), updateId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, InvalidNestedHooksDispatcherOnMountInDEV = {
        readContext: function(context) {
          return warnInvalidContextAccess(), readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), mountHookTypesDev(), mountCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", warnInvalidHookAccess(), mountHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), mountHookTypesDev(), mountImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), mountHookTypesDev(), mountLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", warnInvalidHookAccess(), mountHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", warnInvalidHookAccess(), mountHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", warnInvalidHookAccess(), mountHookTypesDev(), mountRef(initialValue);
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", warnInvalidHookAccess(), mountHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
          try {
            return mountState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), mountHookTypesDev(), void 0;
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), mountHookTypesDev(), mountDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), mountHookTypesDev(), mountTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), mountHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), mountHookTypesDev(), mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot2);
        },
        useId: function() {
          return currentHookNameInDev = "useId", warnInvalidHookAccess(), mountHookTypesDev(), mountId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, InvalidNestedHooksDispatcherOnUpdateInDEV = {
        readContext: function(context) {
          return warnInvalidContextAccess(), readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), updateTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
        },
        useId: function() {
          return currentHookNameInDev = "useId", warnInvalidHookAccess(), updateHookTypesDev(), updateId();
        },
        unstable_isNewReconciler: enableNewReconciler
      }, InvalidNestedHooksDispatcherOnRerenderInDEV = {
        readContext: function(context) {
          return warnInvalidContextAccess(), readContext(context);
        },
        useCallback: function(callback, deps) {
          return currentHookNameInDev = "useCallback", warnInvalidHookAccess(), updateHookTypesDev(), updateCallback(callback, deps);
        },
        useContext: function(context) {
          return currentHookNameInDev = "useContext", warnInvalidHookAccess(), updateHookTypesDev(), readContext(context);
        },
        useEffect: function(create2, deps) {
          return currentHookNameInDev = "useEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateEffect(create2, deps);
        },
        useImperativeHandle: function(ref, create2, deps) {
          return currentHookNameInDev = "useImperativeHandle", warnInvalidHookAccess(), updateHookTypesDev(), updateImperativeHandle(ref, create2, deps);
        },
        useInsertionEffect: function(create2, deps) {
          return currentHookNameInDev = "useInsertionEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateInsertionEffect(create2, deps);
        },
        useLayoutEffect: function(create2, deps) {
          return currentHookNameInDev = "useLayoutEffect", warnInvalidHookAccess(), updateHookTypesDev(), updateLayoutEffect(create2, deps);
        },
        useMemo: function(create2, deps) {
          currentHookNameInDev = "useMemo", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return updateMemo(create2, deps);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useReducer: function(reducer, initialArg, init) {
          currentHookNameInDev = "useReducer", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderReducer(reducer, initialArg, init);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useRef: function(initialValue) {
          return currentHookNameInDev = "useRef", warnInvalidHookAccess(), updateHookTypesDev(), updateRef();
        },
        useState: function(initialState) {
          currentHookNameInDev = "useState", warnInvalidHookAccess(), updateHookTypesDev();
          var prevDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
          try {
            return rerenderState(initialState);
          } finally {
            ReactCurrentDispatcher$1.current = prevDispatcher;
          }
        },
        useDebugValue: function(value, formatterFn) {
          return currentHookNameInDev = "useDebugValue", warnInvalidHookAccess(), updateHookTypesDev(), updateDebugValue();
        },
        useDeferredValue: function(value) {
          return currentHookNameInDev = "useDeferredValue", warnInvalidHookAccess(), updateHookTypesDev(), rerenderDeferredValue(value);
        },
        useTransition: function() {
          return currentHookNameInDev = "useTransition", warnInvalidHookAccess(), updateHookTypesDev(), rerenderTransition();
        },
        useMutableSource: function(source, getSnapshot, subscribe) {
          return currentHookNameInDev = "useMutableSource", warnInvalidHookAccess(), updateHookTypesDev(), void 0;
        },
        useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot2) {
          return currentHookNameInDev = "useSyncExternalStore", warnInvalidHookAccess(), updateHookTypesDev(), updateSyncExternalStore(subscribe, getSnapshot);
        },
        useId: function() {
          return currentHookNameInDev = "useId", warnInvalidHookAccess(), updateHookTypesDev(), updateId();
        },
        unstable_isNewReconciler: enableNewReconciler
      };
    }
    var now$1 = Scheduler2.unstable_now, commitTime = 0, layoutEffectStartTime = -1, profilerStartTime = -1, passiveEffectStartTime = -1, currentUpdateIsNested = !1, nestedUpdateScheduled = !1;
    function isCurrentUpdateNested() {
      return currentUpdateIsNested;
    }
    function markNestedUpdateScheduled() {
      nestedUpdateScheduled = !0;
    }
    function resetNestedUpdateFlag() {
      currentUpdateIsNested = !1, nestedUpdateScheduled = !1;
    }
    function syncNestedUpdateFlag() {
      currentUpdateIsNested = nestedUpdateScheduled, nestedUpdateScheduled = !1;
    }
    function getCommitTime() {
      return commitTime;
    }
    function recordCommitTime() {
      commitTime = now$1();
    }
    function startProfilerTimer(fiber) {
      profilerStartTime = now$1(), fiber.actualStartTime < 0 && (fiber.actualStartTime = now$1());
    }
    function stopProfilerTimerIfRunning(fiber) {
      profilerStartTime = -1;
    }
    function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
      if (profilerStartTime >= 0) {
        var elapsedTime = now$1() - profilerStartTime;
        fiber.actualDuration += elapsedTime, overrideBaseTime && (fiber.selfBaseDuration = elapsedTime), profilerStartTime = -1;
      }
    }
    function recordLayoutEffectDuration(fiber) {
      if (layoutEffectStartTime >= 0) {
        var elapsedTime = now$1() - layoutEffectStartTime;
        layoutEffectStartTime = -1;
        for (var parentFiber = fiber.return; parentFiber !== null; ) {
          switch (parentFiber.tag) {
            case HostRoot:
              var root2 = parentFiber.stateNode;
              root2.effectDuration += elapsedTime;
              return;
            case Profiler:
              var parentStateNode = parentFiber.stateNode;
              parentStateNode.effectDuration += elapsedTime;
              return;
          }
          parentFiber = parentFiber.return;
        }
      }
    }
    function recordPassiveEffectDuration(fiber) {
      if (passiveEffectStartTime >= 0) {
        var elapsedTime = now$1() - passiveEffectStartTime;
        passiveEffectStartTime = -1;
        for (var parentFiber = fiber.return; parentFiber !== null; ) {
          switch (parentFiber.tag) {
            case HostRoot:
              var root2 = parentFiber.stateNode;
              root2 !== null && (root2.passiveEffectDuration += elapsedTime);
              return;
            case Profiler:
              var parentStateNode = parentFiber.stateNode;
              parentStateNode !== null && (parentStateNode.passiveEffectDuration += elapsedTime);
              return;
          }
          parentFiber = parentFiber.return;
        }
      }
    }
    function startLayoutEffectTimer() {
      layoutEffectStartTime = now$1();
    }
    function startPassiveEffectTimer() {
      passiveEffectStartTime = now$1();
    }
    function transferActualDuration(fiber) {
      for (var child = fiber.child; child; )
        fiber.actualDuration += child.actualDuration, child = child.sibling;
    }
    function resolveDefaultProps(Component, baseProps) {
      if (Component && Component.defaultProps) {
        var props = assign2({}, baseProps), defaultProps = Component.defaultProps;
        for (var propName in defaultProps)
          props[propName] === void 0 && (props[propName] = defaultProps[propName]);
        return props;
      }
      return baseProps;
    }
    var fakeInternalInstance = {}, didWarnAboutStateAssignmentForComponent, didWarnAboutUninitializedState, didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate, didWarnAboutLegacyLifecyclesAndDerivedState, didWarnAboutUndefinedDerivedState, warnOnUndefinedDerivedState, warnOnInvalidCallback, didWarnAboutDirectlyAssigningPropsToState, didWarnAboutContextTypeAndContextTypes, didWarnAboutInvalidateContextType, didWarnAboutLegacyContext$1;
    {
      didWarnAboutStateAssignmentForComponent = /* @__PURE__ */ new Set(), didWarnAboutUninitializedState = /* @__PURE__ */ new Set(), didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = /* @__PURE__ */ new Set(), didWarnAboutLegacyLifecyclesAndDerivedState = /* @__PURE__ */ new Set(), didWarnAboutDirectlyAssigningPropsToState = /* @__PURE__ */ new Set(), didWarnAboutUndefinedDerivedState = /* @__PURE__ */ new Set(), didWarnAboutContextTypeAndContextTypes = /* @__PURE__ */ new Set(), didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set(), didWarnAboutLegacyContext$1 = /* @__PURE__ */ new Set();
      var didWarnOnInvalidCallback = /* @__PURE__ */ new Set();
      warnOnInvalidCallback = function(callback, callerName) {
        if (!(callback === null || typeof callback == "function")) {
          var key2 = callerName + "_" + callback;
          didWarnOnInvalidCallback.has(key2) || (didWarnOnInvalidCallback.add(key2), error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback));
        }
      }, warnOnUndefinedDerivedState = function(type, partialState) {
        if (partialState === void 0) {
          var componentName = getComponentNameFromType(type) || "Component";
          didWarnAboutUndefinedDerivedState.has(componentName) || (didWarnAboutUndefinedDerivedState.add(componentName), error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", componentName));
        }
      }, Object.defineProperty(fakeInternalInstance, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(fakeInternalInstance);
    }
    function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
      var prevState = workInProgress2.memoizedState, partialState = getDerivedStateFromProps(nextProps, prevState);
      {
        if (workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            partialState = getDerivedStateFromProps(nextProps, prevState);
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        warnOnUndefinedDerivedState(ctor, partialState);
      }
      var memoizedState = partialState == null ? prevState : assign2({}, prevState, partialState);
      if (workInProgress2.memoizedState = memoizedState, workInProgress2.lanes === NoLanes) {
        var updateQueue = workInProgress2.updateQueue;
        updateQueue.baseState = memoizedState;
      }
    }
    var classComponentUpdater = {
      isMounted,
      enqueueSetState: function(inst, payload, callback) {
        var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
        update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "setState"), update.callback = callback);
        var root2 = enqueueUpdate(fiber, update, lane);
        root2 !== null && (scheduleUpdateOnFiber(root2, fiber, lane, eventTime), entangleTransitions(root2, fiber, lane)), markStateUpdateScheduled(fiber, lane);
      },
      enqueueReplaceState: function(inst, payload, callback) {
        var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
        update.tag = ReplaceState, update.payload = payload, callback != null && (warnOnInvalidCallback(callback, "replaceState"), update.callback = callback);
        var root2 = enqueueUpdate(fiber, update, lane);
        root2 !== null && (scheduleUpdateOnFiber(root2, fiber, lane, eventTime), entangleTransitions(root2, fiber, lane)), markStateUpdateScheduled(fiber, lane);
      },
      enqueueForceUpdate: function(inst, callback) {
        var fiber = get(inst), eventTime = requestEventTime(), lane = requestUpdateLane(fiber), update = createUpdate(eventTime, lane);
        update.tag = ForceUpdate, callback != null && (warnOnInvalidCallback(callback, "forceUpdate"), update.callback = callback);
        var root2 = enqueueUpdate(fiber, update, lane);
        root2 !== null && (scheduleUpdateOnFiber(root2, fiber, lane, eventTime), entangleTransitions(root2, fiber, lane)), markForceUpdateScheduled(fiber, lane);
      }
    };
    function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
      var instance = workInProgress2.stateNode;
      if (typeof instance.shouldComponentUpdate == "function") {
        var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          shouldUpdate === void 0 && error("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
        }
        return shouldUpdate;
      }
      return ctor.prototype && ctor.prototype.isPureReactComponent ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState) : !0;
    }
    function checkClassInstance(workInProgress2, ctor, newProps) {
      var instance = workInProgress2.stateNode;
      {
        var name2 = getComponentNameFromType(ctor) || "Component", renderPresent = instance.render;
        renderPresent || (ctor.prototype && typeof ctor.prototype.render == "function" ? error("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", name2) : error("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", name2)), instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state && error("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", name2), instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved && error("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", name2), instance.propTypes && error("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", name2), instance.contextType && error("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", name2), ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (workInProgress2.mode & StrictLegacyMode) === NoMode && (didWarnAboutLegacyContext$1.add(ctor), error(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, name2)), ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (workInProgress2.mode & StrictLegacyMode) === NoMode && (didWarnAboutLegacyContext$1.add(ctor), error(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, name2)), instance.contextTypes && error("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", name2), ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor) && (didWarnAboutContextTypeAndContextTypes.add(ctor), error("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", name2)), typeof instance.componentShouldUpdate == "function" && error("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", name2), ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate < "u" && error("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component"), typeof instance.componentDidUnmount == "function" && error("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", name2), typeof instance.componentDidReceiveProps == "function" && error("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name2), typeof instance.componentWillRecieveProps == "function" && error("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name2), typeof instance.UNSAFE_componentWillRecieveProps == "function" && error("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name2);
        var hasMutatedProps = instance.props !== newProps;
        instance.props !== void 0 && hasMutatedProps && error("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", name2, name2), instance.defaultProps && error("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", name2, name2), typeof instance.getSnapshotBeforeUpdate == "function" && typeof instance.componentDidUpdate != "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor) && (didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor), error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor))), typeof instance.getDerivedStateFromProps == "function" && error("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2), typeof instance.getDerivedStateFromError == "function" && error("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", name2), typeof ctor.getSnapshotBeforeUpdate == "function" && error("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", name2);
        var _state = instance.state;
        _state && (typeof _state != "object" || isArray(_state)) && error("%s.state: must be set to an object or null", name2), typeof instance.getChildContext == "function" && typeof ctor.childContextTypes != "object" && error("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", name2);
      }
    }
    function adoptClassInstance(workInProgress2, instance) {
      instance.updater = classComponentUpdater, workInProgress2.stateNode = instance, set(instance, workInProgress2), instance._reactInternalInstance = fakeInternalInstance;
    }
    function constructClassInstance(workInProgress2, ctor, props) {
      var isLegacyContextConsumer = !1, unmaskedContext = emptyContextObject, context = emptyContextObject, contextType = ctor.contextType;
      if ("contextType" in ctor) {
        var isValid = (
          // Allow null for conditional declaration
          contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
        );
        if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
          didWarnAboutInvalidateContextType.add(ctor);
          var addendum = "";
          contextType === void 0 ? addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof contextType != "object" ? addendum = " However, it is set to a " + typeof contextType + "." : contextType.$$typeof === REACT_PROVIDER_TYPE ? addendum = " Did you accidentally pass the Context.Provider instead?" : contextType._context !== void 0 ? addendum = " Did you accidentally pass the Context.Consumer instead?" : addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.", error("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
        }
      }
      if (typeof contextType == "object" && contextType !== null)
        context = readContext(contextType);
      else {
        unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
        var contextTypes = ctor.contextTypes;
        isLegacyContextConsumer = contextTypes != null, context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
      }
      var instance = new ctor(props, context);
      if (workInProgress2.mode & StrictLegacyMode) {
        setIsStrictModeForDevtools(!0);
        try {
          instance = new ctor(props, context);
        } finally {
          setIsStrictModeForDevtools(!1);
        }
      }
      var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== void 0 ? instance.state : null;
      adoptClassInstance(workInProgress2, instance);
      {
        if (typeof ctor.getDerivedStateFromProps == "function" && state === null) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutUninitializedState.has(componentName) || (didWarnAboutUninitializedState.add(componentName), error("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName));
        }
        if (typeof ctor.getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function") {
          var foundWillMountName = null, foundWillReceivePropsName = null, foundWillUpdateName = null;
          if (typeof instance.componentWillMount == "function" && instance.componentWillMount.__suppressDeprecationWarning !== !0 ? foundWillMountName = "componentWillMount" : typeof instance.UNSAFE_componentWillMount == "function" && (foundWillMountName = "UNSAFE_componentWillMount"), typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? foundWillReceivePropsName = "componentWillReceiveProps" : typeof instance.UNSAFE_componentWillReceiveProps == "function" && (foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps"), typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== !0 ? foundWillUpdateName = "componentWillUpdate" : typeof instance.UNSAFE_componentWillUpdate == "function" && (foundWillUpdateName = "UNSAFE_componentWillUpdate"), foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
            var _componentName = getComponentNameFromType(ctor) || "Component", newApiName = typeof ctor.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName) || (didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName), error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : ""));
          }
        }
      }
      return isLegacyContextConsumer && cacheContext(workInProgress2, unmaskedContext, context), instance;
    }
    function callComponentWillMount(workInProgress2, instance) {
      var oldState = instance.state;
      typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount(), oldState !== instance.state && (error("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component"), classComponentUpdater.enqueueReplaceState(instance, instance.state, null));
    }
    function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
      var oldState = instance.state;
      if (typeof instance.componentWillReceiveProps == "function" && instance.componentWillReceiveProps(newProps, nextContext), typeof instance.UNSAFE_componentWillReceiveProps == "function" && instance.UNSAFE_componentWillReceiveProps(newProps, nextContext), instance.state !== oldState) {
        {
          var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
          didWarnAboutStateAssignmentForComponent.has(componentName) || (didWarnAboutStateAssignmentForComponent.add(componentName), error("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", componentName));
        }
        classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
      }
    }
    function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
      checkClassInstance(workInProgress2, ctor, newProps);
      var instance = workInProgress2.stateNode;
      instance.props = newProps, instance.state = workInProgress2.memoizedState, instance.refs = {}, initializeUpdateQueue(workInProgress2);
      var contextType = ctor.contextType;
      if (typeof contextType == "object" && contextType !== null)
        instance.context = readContext(contextType);
      else {
        var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
        instance.context = getMaskedContext(workInProgress2, unmaskedContext);
      }
      {
        if (instance.state === newProps) {
          var componentName = getComponentNameFromType(ctor) || "Component";
          didWarnAboutDirectlyAssigningPropsToState.has(componentName) || (didWarnAboutDirectlyAssigningPropsToState.add(componentName), error("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", componentName));
        }
        workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance), ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
      }
      instance.state = workInProgress2.memoizedState;
      var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
      if (typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), instance.state = workInProgress2.memoizedState), typeof ctor.getDerivedStateFromProps != "function" && typeof instance.getSnapshotBeforeUpdate != "function" && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (callComponentWillMount(workInProgress2, instance), processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), instance.state = workInProgress2.memoizedState), typeof instance.componentDidMount == "function") {
        var fiberFlags = Update;
        fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), workInProgress2.flags |= fiberFlags;
      }
    }
    function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
      var instance = workInProgress2.stateNode, oldProps = workInProgress2.memoizedProps;
      instance.props = oldProps;
      var oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
      if (typeof contextType == "object" && contextType !== null)
        nextContext = readContext(contextType);
      else {
        var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
        nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
      }
      var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
      !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (oldProps !== newProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
      var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
      if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
        if (typeof instance.componentDidMount == "function") {
          var fiberFlags = Update;
          fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (fiberFlags |= MountLayoutDev), workInProgress2.flags |= fiberFlags;
        }
        return !1;
      }
      typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
      if (shouldUpdate) {
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount == "function" || typeof instance.componentWillMount == "function") && (typeof instance.componentWillMount == "function" && instance.componentWillMount(), typeof instance.UNSAFE_componentWillMount == "function" && instance.UNSAFE_componentWillMount()), typeof instance.componentDidMount == "function") {
          var _fiberFlags = Update;
          _fiberFlags |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (_fiberFlags |= MountLayoutDev), workInProgress2.flags |= _fiberFlags;
        }
      } else {
        if (typeof instance.componentDidMount == "function") {
          var _fiberFlags2 = Update;
          _fiberFlags2 |= LayoutStatic, (workInProgress2.mode & StrictEffectsMode) !== NoMode && (_fiberFlags2 |= MountLayoutDev), workInProgress2.flags |= _fiberFlags2;
        }
        workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState;
      }
      return instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
    }
    function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
      var instance = workInProgress2.stateNode;
      cloneUpdateQueue(current2, workInProgress2);
      var unresolvedOldProps = workInProgress2.memoizedProps, oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
      instance.props = oldProps;
      var unresolvedNewProps = workInProgress2.pendingProps, oldContext = instance.context, contextType = ctor.contextType, nextContext = emptyContextObject;
      if (typeof contextType == "object" && contextType !== null)
        nextContext = readContext(contextType);
      else {
        var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, !0);
        nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
      }
      var getDerivedStateFromProps = ctor.getDerivedStateFromProps, hasNewLifecycles = typeof getDerivedStateFromProps == "function" || typeof instance.getSnapshotBeforeUpdate == "function";
      !hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps == "function" || typeof instance.componentWillReceiveProps == "function") && (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) && callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext), resetHasForceUpdateBeforeProcessing();
      var oldState = workInProgress2.memoizedState, newState = instance.state = oldState;
      if (processUpdateQueue(workInProgress2, newProps, instance, renderLanes2), newState = workInProgress2.memoizedState, unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation)
        return typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), !1;
      typeof getDerivedStateFromProps == "function" && (applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps), newState = workInProgress2.memoizedState);
      var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      enableLazyContextPropagation;
      return shouldUpdate ? (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate == "function" || typeof instance.componentWillUpdate == "function") && (typeof instance.componentWillUpdate == "function" && instance.componentWillUpdate(newProps, newState, nextContext), typeof instance.UNSAFE_componentWillUpdate == "function" && instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext)), typeof instance.componentDidUpdate == "function" && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (workInProgress2.flags |= Snapshot)) : (typeof instance.componentDidUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Update), typeof instance.getSnapshotBeforeUpdate == "function" && (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) && (workInProgress2.flags |= Snapshot), workInProgress2.memoizedProps = newProps, workInProgress2.memoizedState = newState), instance.props = newProps, instance.state = newState, instance.context = nextContext, shouldUpdate;
    }
    function createCapturedValueAtFiber(value, source) {
      return {
        value,
        source,
        stack: getStackByFiberInDevAndProd(source),
        digest: null
      };
    }
    function createCapturedValue(value, digest, stack) {
      return {
        value,
        source: null,
        stack: stack ?? null,
        digest: digest ?? null
      };
    }
    function showErrorDialog(boundary, errorInfo) {
      return !0;
    }
    function logCapturedError(boundary, errorInfo) {
      try {
        var logError = showErrorDialog(boundary, errorInfo);
        if (logError === !1)
          return;
        var error2 = errorInfo.value, source = errorInfo.source, stack = errorInfo.stack, componentStack = stack !== null ? stack : "";
        if (error2 != null && error2._suppressLogging) {
          if (boundary.tag === ClassComponent)
            return;
          console.error(error2);
        }
        var componentName = source ? getComponentNameFromFiber(source) : null, componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:", errorBoundaryMessage;
        if (boundary.tag === HostRoot)
          errorBoundaryMessage = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
          errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
        }
        var combinedMessage = componentNameMessage + `
` + componentStack + `

` + ("" + errorBoundaryMessage);
        console.error(combinedMessage);
      } catch (e) {
        setTimeout(function() {
          throw e;
        });
      }
    }
    var PossiblyWeakMap$1 = typeof WeakMap == "function" ? WeakMap : Map;
    function createRootErrorUpdate(fiber, errorInfo, lane) {
      var update = createUpdate(NoTimestamp, lane);
      update.tag = CaptureUpdate, update.payload = {
        element: null
      };
      var error2 = errorInfo.value;
      return update.callback = function() {
        onUncaughtError(error2), logCapturedError(fiber, errorInfo);
      }, update;
    }
    function createClassErrorUpdate(fiber, errorInfo, lane) {
      var update = createUpdate(NoTimestamp, lane);
      update.tag = CaptureUpdate;
      var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
      if (typeof getDerivedStateFromError == "function") {
        var error$1 = errorInfo.value;
        update.payload = function() {
          return getDerivedStateFromError(error$1);
        }, update.callback = function() {
          markFailedErrorBoundaryForHotReloading(fiber), logCapturedError(fiber, errorInfo);
        };
      }
      var inst = fiber.stateNode;
      return inst !== null && typeof inst.componentDidCatch == "function" && (update.callback = function() {
        markFailedErrorBoundaryForHotReloading(fiber), logCapturedError(fiber, errorInfo), typeof getDerivedStateFromError != "function" && markLegacyErrorBoundaryAsFailed(this);
        var error$12 = errorInfo.value, stack = errorInfo.stack;
        this.componentDidCatch(error$12, {
          componentStack: stack !== null ? stack : ""
        }), typeof getDerivedStateFromError != "function" && (includesSomeLane(fiber.lanes, SyncLane) || error("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown"));
      }), update;
    }
    function attachPingListener(root2, wakeable, lanes) {
      var pingCache = root2.pingCache, threadIDs;
      if (pingCache === null ? (pingCache = root2.pingCache = new PossiblyWeakMap$1(), threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs)) : (threadIDs = pingCache.get(wakeable), threadIDs === void 0 && (threadIDs = /* @__PURE__ */ new Set(), pingCache.set(wakeable, threadIDs))), !threadIDs.has(lanes)) {
        threadIDs.add(lanes);
        var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
        isDevToolsPresent && restorePendingUpdaters(root2, lanes), wakeable.then(ping, ping);
      }
    }
    function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
      var wakeables = suspenseBoundary.updateQueue;
      if (wakeables === null) {
        var updateQueue = /* @__PURE__ */ new Set();
        updateQueue.add(wakeable), suspenseBoundary.updateQueue = updateQueue;
      } else
        wakeables.add(wakeable);
    }
    function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
      var tag = sourceFiber.tag;
      if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
        var currentSource = sourceFiber.alternate;
        currentSource ? (sourceFiber.updateQueue = currentSource.updateQueue, sourceFiber.memoizedState = currentSource.memoizedState, sourceFiber.lanes = currentSource.lanes) : (sourceFiber.updateQueue = null, sourceFiber.memoizedState = null);
      }
    }
    function getNearestSuspenseBoundaryToCapture(returnFiber) {
      var node2 = returnFiber;
      do {
        if (node2.tag === SuspenseComponent && shouldCaptureSuspense(node2))
          return node2;
        node2 = node2.return;
      } while (node2 !== null);
      return null;
    }
    function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
      if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
        if (suspenseBoundary === returnFiber)
          suspenseBoundary.flags |= ShouldCapture;
        else {
          if (suspenseBoundary.flags |= DidCapture, sourceFiber.flags |= ForceUpdateForLegacySuspense, sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete), sourceFiber.tag === ClassComponent) {
            var currentSourceFiber = sourceFiber.alternate;
            if (currentSourceFiber === null)
              sourceFiber.tag = IncompleteClassComponent;
            else {
              var update = createUpdate(NoTimestamp, SyncLane);
              update.tag = ForceUpdate, enqueueUpdate(sourceFiber, update, SyncLane);
            }
          }
          sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
        }
        return suspenseBoundary;
      }
      return suspenseBoundary.flags |= ShouldCapture, suspenseBoundary.lanes = rootRenderLanes, suspenseBoundary;
    }
    function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
      if (sourceFiber.flags |= Incomplete, isDevToolsPresent && restorePendingUpdaters(root2, rootRenderLanes), value !== null && typeof value == "object" && typeof value.then == "function") {
        var wakeable = value;
        resetSuspendedComponent(sourceFiber), getIsHydrating() && sourceFiber.mode & ConcurrentMode && markDidThrowWhileHydratingDEV();
        var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
        if (suspenseBoundary !== null) {
          suspenseBoundary.flags &= ~ForceClientRender, markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes), suspenseBoundary.mode & ConcurrentMode && attachPingListener(root2, wakeable, rootRenderLanes), attachRetryListener(suspenseBoundary, root2, wakeable);
          return;
        } else {
          if (!includesSyncLane(rootRenderLanes)) {
            attachPingListener(root2, wakeable, rootRenderLanes), renderDidSuspendDelayIfPossible();
            return;
          }
          var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          value = uncaughtSuspenseError;
        }
      } else if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
        markDidThrowWhileHydratingDEV();
        var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
        if (_suspenseBoundary !== null) {
          (_suspenseBoundary.flags & ShouldCapture) === NoFlags && (_suspenseBoundary.flags |= ForceClientRender), markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes), queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
          return;
        }
      }
      value = createCapturedValueAtFiber(value, sourceFiber), renderDidError(value);
      var workInProgress2 = returnFiber;
      do {
        switch (workInProgress2.tag) {
          case HostRoot: {
            var _errorInfo = value;
            workInProgress2.flags |= ShouldCapture;
            var lane = pickArbitraryLane(rootRenderLanes);
            workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
            var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
            enqueueCapturedUpdate(workInProgress2, update);
            return;
          }
          case ClassComponent:
            var errorInfo = value, ctor = workInProgress2.type, instance = workInProgress2.stateNode;
            if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError == "function" || instance !== null && typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
              workInProgress2.flags |= ShouldCapture;
              var _lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
              var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
              enqueueCapturedUpdate(workInProgress2, _update);
              return;
            }
            break;
        }
        workInProgress2 = workInProgress2.return;
      } while (workInProgress2 !== null);
    }
    function getSuspendedCache() {
      return null;
    }
    var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner, didReceiveUpdate = !1, didWarnAboutBadClass, didWarnAboutModulePatternComponent, didWarnAboutContextTypeOnFunctionComponent, didWarnAboutGetDerivedStateOnFunctionComponent, didWarnAboutFunctionRefs, didWarnAboutReassigningProps, didWarnAboutRevealOrder, didWarnAboutTailOptions, didWarnAboutDefaultPropsOnFunctionComponent;
    didWarnAboutBadClass = {}, didWarnAboutModulePatternComponent = {}, didWarnAboutContextTypeOnFunctionComponent = {}, didWarnAboutGetDerivedStateOnFunctionComponent = {}, didWarnAboutFunctionRefs = {}, didWarnAboutReassigningProps = !1, didWarnAboutRevealOrder = {}, didWarnAboutTailOptions = {}, didWarnAboutDefaultPropsOnFunctionComponent = {};
    function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
      current2 === null ? workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2) : workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
    }
    function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
      workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
    }
    function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (workInProgress2.type !== workInProgress2.elementType) {
        var innerPropTypes = Component.propTypes;
        innerPropTypes && checkPropTypes(
          innerPropTypes,
          nextProps,
          // Resolved props
          "prop",
          getComponentNameFromType(Component)
        );
      }
      var render2 = Component.render, ref = workInProgress2.ref, nextChildren, hasId;
      prepareToReadContext(workInProgress2, renderLanes2), markComponentRenderStarted(workInProgress2);
      {
        if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2), hasId = checkDidRenderIdHook(), workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2), hasId = checkDidRenderIdHook();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        setIsRendering(!1);
      }
      return markComponentRenderStopped(), current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
    }
    function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (current2 === null) {
        var type = Component.type;
        if (isSimpleFunctionComponent(type) && Component.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        Component.defaultProps === void 0) {
          var resolvedType = type;
          return resolvedType = resolveFunctionForHotReloading(type), workInProgress2.tag = SimpleMemoComponent, workInProgress2.type = resolvedType, validateFunctionComponentInDev(workInProgress2, type), updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
        }
        {
          var innerPropTypes = type.propTypes;
          if (innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            // Resolved props
            "prop",
            getComponentNameFromType(type)
          ), Component.defaultProps !== void 0) {
            var componentName = getComponentNameFromType(type) || "Unknown";
            didWarnAboutDefaultPropsOnFunctionComponent[componentName] || (error("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", componentName), didWarnAboutDefaultPropsOnFunctionComponent[componentName] = !0);
          }
        }
        var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
        return child.ref = workInProgress2.ref, child.return = workInProgress2, workInProgress2.child = child, child;
      }
      {
        var _type = Component.type, _innerPropTypes = _type.propTypes;
        _innerPropTypes && checkPropTypes(
          _innerPropTypes,
          nextProps,
          // Resolved props
          "prop",
          getComponentNameFromType(_type)
        );
      }
      var currentChild = current2.child, hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
      if (!hasScheduledUpdateOrContext) {
        var prevProps = currentChild.memoizedProps, compare = Component.compare;
        if (compare = compare !== null ? compare : shallowEqual, compare(prevProps, nextProps) && current2.ref === workInProgress2.ref)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      workInProgress2.flags |= PerformedWork;
      var newChild = createWorkInProgress(currentChild, nextProps);
      return newChild.ref = workInProgress2.ref, newChild.return = workInProgress2, workInProgress2.child = newChild, newChild;
    }
    function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (workInProgress2.type !== workInProgress2.elementType) {
        var outerMemoType = workInProgress2.elementType;
        if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
          var lazyComponent = outerMemoType, payload = lazyComponent._payload, init = lazyComponent._init;
          try {
            outerMemoType = init(payload);
          } catch {
            outerMemoType = null;
          }
          var outerPropTypes = outerMemoType && outerMemoType.propTypes;
          outerPropTypes && checkPropTypes(
            outerPropTypes,
            nextProps,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            getComponentNameFromType(outerMemoType)
          );
        }
      }
      if (current2 !== null) {
        var prevProps = current2.memoizedProps;
        if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && // Prevent bailout if the implementation changed due to hot reload.
        workInProgress2.type === current2.type)
          if (didReceiveUpdate = !1, workInProgress2.pendingProps = nextProps = prevProps, checkScheduledUpdateOrContext(current2, renderLanes2))
            (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags && (didReceiveUpdate = !0);
          else return workInProgress2.lanes = current2.lanes, bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
    }
    function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children, prevState = current2 !== null ? current2.memoizedState : null;
      if (nextProps.mode === "hidden" || enableLegacyHidden)
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          var nextState = {
            baseLanes: NoLanes,
            cachePool: null,
            transitions: null
          };
          workInProgress2.memoizedState = nextState, pushRenderLanes(workInProgress2, renderLanes2);
        } else if (includesSomeLane(renderLanes2, OffscreenLane)) {
          var _nextState2 = {
            baseLanes: NoLanes,
            cachePool: null,
            transitions: null
          };
          workInProgress2.memoizedState = _nextState2;
          var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
          pushRenderLanes(workInProgress2, subtreeRenderLanes2);
        } else {
          var spawnedCachePool = null, nextBaseLanes;
          if (prevState !== null) {
            var prevBaseLanes = prevState.baseLanes;
            nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
          } else
            nextBaseLanes = renderLanes2;
          workInProgress2.lanes = workInProgress2.childLanes = OffscreenLane;
          var _nextState = {
            baseLanes: nextBaseLanes,
            cachePool: spawnedCachePool,
            transitions: null
          };
          return workInProgress2.memoizedState = _nextState, workInProgress2.updateQueue = null, pushRenderLanes(workInProgress2, nextBaseLanes), null;
        }
      else {
        var _subtreeRenderLanes;
        prevState !== null ? (_subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2), workInProgress2.memoizedState = null) : _subtreeRenderLanes = renderLanes2, pushRenderLanes(workInProgress2, _subtreeRenderLanes);
      }
      return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function updateFragment(current2, workInProgress2, renderLanes2) {
      var nextChildren = workInProgress2.pendingProps;
      return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function updateMode(current2, workInProgress2, renderLanes2) {
      var nextChildren = workInProgress2.pendingProps.children;
      return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function updateProfiler(current2, workInProgress2, renderLanes2) {
      {
        workInProgress2.flags |= Update;
        {
          var stateNode = workInProgress2.stateNode;
          stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
        }
      }
      var nextProps = workInProgress2.pendingProps, nextChildren = nextProps.children;
      return reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function markRef(current2, workInProgress2) {
      var ref = workInProgress2.ref;
      (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) && (workInProgress2.flags |= Ref, workInProgress2.flags |= RefStatic);
    }
    function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      if (workInProgress2.type !== workInProgress2.elementType) {
        var innerPropTypes = Component.propTypes;
        innerPropTypes && checkPropTypes(
          innerPropTypes,
          nextProps,
          // Resolved props
          "prop",
          getComponentNameFromType(Component)
        );
      }
      var context;
      {
        var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !0);
        context = getMaskedContext(workInProgress2, unmaskedContext);
      }
      var nextChildren, hasId;
      prepareToReadContext(workInProgress2, renderLanes2), markComponentRenderStarted(workInProgress2);
      {
        if (ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2), hasId = checkDidRenderIdHook(), workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2), hasId = checkDidRenderIdHook();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        setIsRendering(!1);
      }
      return markComponentRenderStopped(), current2 !== null && !didReceiveUpdate ? (bailoutHooks(current2, workInProgress2, renderLanes2), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2)) : (getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child);
    }
    function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
      {
        switch (shouldError(workInProgress2)) {
          case !1: {
            var _instance = workInProgress2.stateNode, ctor = workInProgress2.type, tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context), state = tempInstance.state;
            _instance.updater.enqueueSetState(_instance, state, null);
            break;
          }
          case !0: {
            workInProgress2.flags |= DidCapture, workInProgress2.flags |= ShouldCapture;
            var error$1 = new Error("Simulated error coming from DevTools"), lane = pickArbitraryLane(renderLanes2);
            workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
            var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
            enqueueCapturedUpdate(workInProgress2, update);
            break;
          }
        }
        if (workInProgress2.type !== workInProgress2.elementType) {
          var innerPropTypes = Component.propTypes;
          innerPropTypes && checkPropTypes(
            innerPropTypes,
            nextProps,
            // Resolved props
            "prop",
            getComponentNameFromType(Component)
          );
        }
      }
      var hasContext;
      isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2);
      var instance = workInProgress2.stateNode, shouldUpdate;
      instance === null ? (resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), shouldUpdate = !0) : current2 === null ? shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2) : shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
      var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
      {
        var inst = workInProgress2.stateNode;
        shouldUpdate && inst.props !== nextProps && (didWarnAboutReassigningProps || error("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component"), didWarnAboutReassigningProps = !0);
      }
      return nextUnitOfWork;
    }
    function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
      markRef(current2, workInProgress2);
      var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
      if (!shouldUpdate && !didCaptureError)
        return hasContext && invalidateContextProvider(workInProgress2, Component, !1), bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      var instance = workInProgress2.stateNode;
      ReactCurrentOwner$1.current = workInProgress2;
      var nextChildren;
      if (didCaptureError && typeof Component.getDerivedStateFromError != "function")
        nextChildren = null, stopProfilerTimerIfRunning();
      else {
        markComponentRenderStarted(workInProgress2);
        {
          if (setIsRendering(!0), nextChildren = instance.render(), workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(!0);
            try {
              instance.render();
            } finally {
              setIsStrictModeForDevtools(!1);
            }
          }
          setIsRendering(!1);
        }
        markComponentRenderStopped();
      }
      return workInProgress2.flags |= PerformedWork, current2 !== null && didCaptureError ? forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.memoizedState = instance.state, hasContext && invalidateContextProvider(workInProgress2, Component, !0), workInProgress2.child;
    }
    function pushHostRootContext(workInProgress2) {
      var root2 = workInProgress2.stateNode;
      root2.pendingContext ? pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context) : root2.context && pushTopLevelContextObject(workInProgress2, root2.context, !1), pushHostContainer(workInProgress2, root2.containerInfo);
    }
    function updateHostRoot(current2, workInProgress2, renderLanes2) {
      if (pushHostRootContext(workInProgress2), current2 === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var nextProps = workInProgress2.pendingProps, prevState = workInProgress2.memoizedState, prevChildren = prevState.element;
      cloneUpdateQueue(current2, workInProgress2), processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
      var nextState = workInProgress2.memoizedState, nextChildren = nextState.element;
      if (prevState.isDehydrated) {
        var overrideState = {
          element: nextChildren,
          isDehydrated: !1,
          cache: nextState.cache,
          pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
          transitions: nextState.transitions
        }, updateQueue = workInProgress2.updateQueue;
        if (updateQueue.baseState = overrideState, workInProgress2.memoizedState = overrideState, workInProgress2.flags & ForceClientRender) {
          var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), workInProgress2);
          return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
        } else if (nextChildren !== prevChildren) {
          var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), workInProgress2);
          return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
        } else {
          enterHydrationState(workInProgress2);
          var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
          workInProgress2.child = child;
          for (var node2 = child; node2; )
            node2.flags = node2.flags & ~Placement | Hydrating, node2 = node2.sibling;
        }
      } else {
        if (resetHydrationState(), nextChildren === prevChildren)
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
      }
      return workInProgress2.child;
    }
    function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
      return resetHydrationState(), queueHydrationError(recoverableError), workInProgress2.flags |= ForceClientRender, reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function updateHostComponent(current2, workInProgress2, renderLanes2) {
      pushHostContext(workInProgress2), current2 === null && tryToClaimNextHydratableInstance(workInProgress2);
      var type = workInProgress2.type, nextProps = workInProgress2.pendingProps, prevProps = current2 !== null ? current2.memoizedProps : null, nextChildren = nextProps.children, isDirectTextChild = shouldSetTextContent(type, nextProps);
      return isDirectTextChild ? nextChildren = null : prevProps !== null && shouldSetTextContent(type, prevProps) && (workInProgress2.flags |= ContentReset), markRef(current2, workInProgress2), reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    function updateHostText(current2, workInProgress2) {
      return current2 === null && tryToClaimNextHydratableInstance(workInProgress2), null;
    }
    function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
      resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
      var props = workInProgress2.pendingProps, lazyComponent = elementType, payload = lazyComponent._payload, init = lazyComponent._init, Component = init(payload);
      workInProgress2.type = Component;
      var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component), resolvedProps = resolveDefaultProps(Component, props), child;
      switch (resolvedTag) {
        case FunctionComponent:
          return validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.type = Component = resolveFunctionForHotReloading(Component), child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
        case ClassComponent:
          return workInProgress2.type = Component = resolveClassForHotReloading(Component), child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
        case ForwardRef:
          return workInProgress2.type = Component = resolveForwardRefForHotReloading(Component), child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2), child;
        case MemoComponent: {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerPropTypes = Component.propTypes;
            outerPropTypes && checkPropTypes(
              outerPropTypes,
              resolvedProps,
              // Resolved for outer only
              "prop",
              getComponentNameFromType(Component)
            );
          }
          return child = updateMemoComponent(
            null,
            workInProgress2,
            Component,
            resolveDefaultProps(Component.type, resolvedProps),
            // The inner type can have defaults too
            renderLanes2
          ), child;
        }
      }
      var hint = "";
      throw Component !== null && typeof Component == "object" && Component.$$typeof === REACT_LAZY_TYPE && (hint = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
    }
    function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
      resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2), workInProgress2.tag = ClassComponent;
      var hasContext;
      return isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, prepareToReadContext(workInProgress2, renderLanes2), constructClassInstance(workInProgress2, Component, nextProps), mountClassInstance(workInProgress2, Component, nextProps, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
    }
    function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
      resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
      var props = workInProgress2.pendingProps, context;
      {
        var unmaskedContext = getUnmaskedContext(workInProgress2, Component, !1);
        context = getMaskedContext(workInProgress2, unmaskedContext);
      }
      prepareToReadContext(workInProgress2, renderLanes2);
      var value, hasId;
      markComponentRenderStarted(workInProgress2);
      {
        if (Component.prototype && typeof Component.prototype.render == "function") {
          var componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutBadClass[componentName] || (error("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName), didWarnAboutBadClass[componentName] = !0);
        }
        workInProgress2.mode & StrictLegacyMode && ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null), setIsRendering(!0), ReactCurrentOwner$1.current = workInProgress2, value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2), hasId = checkDidRenderIdHook(), setIsRendering(!1);
      }
      if (markComponentRenderStopped(), workInProgress2.flags |= PerformedWork, typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0) {
        var _componentName = getComponentNameFromType(Component) || "Unknown";
        didWarnAboutModulePatternComponent[_componentName] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName, _componentName, _componentName), didWarnAboutModulePatternComponent[_componentName] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof value == "object" && value !== null && typeof value.render == "function" && value.$$typeof === void 0
      ) {
        {
          var _componentName2 = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutModulePatternComponent[_componentName2] || (error("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2), didWarnAboutModulePatternComponent[_componentName2] = !0);
        }
        workInProgress2.tag = ClassComponent, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null;
        var hasContext = !1;
        return isContextProvider(Component) ? (hasContext = !0, pushContextProvider(workInProgress2)) : hasContext = !1, workInProgress2.memoizedState = value.state !== null && value.state !== void 0 ? value.state : null, initializeUpdateQueue(workInProgress2), adoptClassInstance(workInProgress2, value), mountClassInstance(workInProgress2, Component, props, renderLanes2), finishClassComponent(null, workInProgress2, Component, !0, hasContext, renderLanes2);
      } else {
        if (workInProgress2.tag = FunctionComponent, workInProgress2.mode & StrictLegacyMode) {
          setIsStrictModeForDevtools(!0);
          try {
            value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2), hasId = checkDidRenderIdHook();
          } finally {
            setIsStrictModeForDevtools(!1);
          }
        }
        return getIsHydrating() && hasId && pushMaterializedTreeId(workInProgress2), reconcileChildren(null, workInProgress2, value, renderLanes2), validateFunctionComponentInDev(workInProgress2, Component), workInProgress2.child;
      }
    }
    function validateFunctionComponentInDev(workInProgress2, Component) {
      {
        if (Component && Component.childContextTypes && error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component"), workInProgress2.ref !== null) {
          var info2 = "", ownerName = getCurrentFiberOwnerNameInDevOrNull();
          ownerName && (info2 += `

Check the render method of \`` + ownerName + "`.");
          var warningKey = ownerName || "", debugSource = workInProgress2._debugSource;
          debugSource && (warningKey = debugSource.fileName + ":" + debugSource.lineNumber), didWarnAboutFunctionRefs[warningKey] || (didWarnAboutFunctionRefs[warningKey] = !0, error("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", info2));
        }
        if (Component.defaultProps !== void 0) {
          var componentName = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutDefaultPropsOnFunctionComponent[componentName] || (error("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", componentName), didWarnAboutDefaultPropsOnFunctionComponent[componentName] = !0);
        }
        if (typeof Component.getDerivedStateFromProps == "function") {
          var _componentName3 = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] || (error("%s: Function components do not support getDerivedStateFromProps.", _componentName3), didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = !0);
        }
        if (typeof Component.contextType == "object" && Component.contextType !== null) {
          var _componentName4 = getComponentNameFromType(Component) || "Unknown";
          didWarnAboutContextTypeOnFunctionComponent[_componentName4] || (error("%s: Function components do not support contextType.", _componentName4), didWarnAboutContextTypeOnFunctionComponent[_componentName4] = !0);
        }
      }
    }
    var SUSPENDED_MARKER = {
      dehydrated: null,
      treeContext: null,
      retryLane: NoLane
    };
    function mountSuspenseOffscreenState(renderLanes2) {
      return {
        baseLanes: renderLanes2,
        cachePool: getSuspendedCache(),
        transitions: null
      };
    }
    function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
      var cachePool = null;
      return {
        baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
        cachePool,
        transitions: prevOffscreenState.transitions
      };
    }
    function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
      if (current2 !== null) {
        var suspenseState = current2.memoizedState;
        if (suspenseState === null)
          return !1;
      }
      return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
    }
    function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
      return removeLanes(current2.childLanes, renderLanes2);
    }
    function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps;
      shouldSuspend(workInProgress2) && (workInProgress2.flags |= DidCapture);
      var suspenseContext = suspenseStackCursor.current, showFallback = !1, didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
      if (didSuspend || shouldRemainOnFallback(suspenseContext, current2) ? (showFallback = !0, workInProgress2.flags &= ~DidCapture) : (current2 === null || current2.memoizedState !== null) && (suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext)), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), current2 === null) {
        tryToClaimNextHydratableInstance(workInProgress2);
        var suspenseState = workInProgress2.memoizedState;
        if (suspenseState !== null) {
          var dehydrated = suspenseState.dehydrated;
          if (dehydrated !== null)
            return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
        }
        var nextPrimaryChildren = nextProps.children, nextFallbackChildren = nextProps.fallback;
        if (showFallback) {
          var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), primaryChildFragment = workInProgress2.child;
          return primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackFragment;
        } else
          return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
      } else {
        var prevState = current2.memoizedState;
        if (prevState !== null) {
          var _dehydrated = prevState.dehydrated;
          if (_dehydrated !== null)
            return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
        }
        if (showFallback) {
          var _nextFallbackChildren = nextProps.fallback, _nextPrimaryChildren = nextProps.children, fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2), _primaryChildFragment2 = workInProgress2.child, prevOffscreenState = current2.child.memoizedState;
          return _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2), _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackChildFragment;
        } else {
          var _nextPrimaryChildren2 = nextProps.children, _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
          return workInProgress2.memoizedState = null, _primaryChildFragment3;
        }
      }
    }
    function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
      var mode = workInProgress2.mode, primaryChildProps = {
        mode: "visible",
        children: primaryChildren
      }, primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
      return primaryChildFragment.return = workInProgress2, workInProgress2.child = primaryChildFragment, primaryChildFragment;
    }
    function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
      var mode = workInProgress2.mode, progressedPrimaryFragment = workInProgress2.child, primaryChildProps = {
        mode: "hidden",
        children: primaryChildren
      }, primaryChildFragment, fallbackChildFragment;
      return (mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null ? (primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = 0, primaryChildFragment.treeBaseDuration = 0), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)) : (primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode), fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null)), primaryChildFragment.return = workInProgress2, fallbackChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
    }
    function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
      return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
    }
    function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
      return createWorkInProgress(current2, offscreenProps);
    }
    function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
      var currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
        mode: "visible",
        children: primaryChildren
      });
      if ((workInProgress2.mode & ConcurrentMode) === NoMode && (primaryChildFragment.lanes = renderLanes2), primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = null, currentFallbackChildFragment !== null) {
        var deletions = workInProgress2.deletions;
        deletions === null ? (workInProgress2.deletions = [currentFallbackChildFragment], workInProgress2.flags |= ChildDeletion) : deletions.push(currentFallbackChildFragment);
      }
      return workInProgress2.child = primaryChildFragment, primaryChildFragment;
    }
    function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
      var mode = workInProgress2.mode, currentPrimaryChildFragment = current2.child, currentFallbackChildFragment = currentPrimaryChildFragment.sibling, primaryChildProps = {
        mode: "hidden",
        children: primaryChildren
      }, primaryChildFragment;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (mode & ConcurrentMode) === NoMode && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        workInProgress2.child !== currentPrimaryChildFragment
      ) {
        var progressedPrimaryFragment = workInProgress2.child;
        primaryChildFragment = progressedPrimaryFragment, primaryChildFragment.childLanes = NoLanes, primaryChildFragment.pendingProps = primaryChildProps, workInProgress2.mode & ProfileMode && (primaryChildFragment.actualDuration = 0, primaryChildFragment.actualStartTime = -1, primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration, primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration), workInProgress2.deletions = null;
      } else
        primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps), primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
      var fallbackChildFragment;
      return currentFallbackChildFragment !== null ? fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren) : (fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null), fallbackChildFragment.flags |= Placement), fallbackChildFragment.return = workInProgress2, primaryChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, fallbackChildFragment;
    }
    function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
      recoverableError !== null && queueHydrationError(recoverableError), reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
      var nextProps = workInProgress2.pendingProps, primaryChildren = nextProps.children, primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
      return primaryChildFragment.flags |= Placement, workInProgress2.memoizedState = null, primaryChildFragment;
    }
    function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
      var fiberMode = workInProgress2.mode, primaryChildProps = {
        mode: "visible",
        children: primaryChildren
      }, primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode), fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
      return fallbackChildFragment.flags |= Placement, primaryChildFragment.return = workInProgress2, fallbackChildFragment.return = workInProgress2, primaryChildFragment.sibling = fallbackChildFragment, workInProgress2.child = primaryChildFragment, (workInProgress2.mode & ConcurrentMode) !== NoMode && reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2), fallbackChildFragment;
    }
    function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
      return (workInProgress2.mode & ConcurrentMode) === NoMode ? (error("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), workInProgress2.lanes = SyncLane) : isSuspenseInstanceFallback(suspenseInstance) ? workInProgress2.lanes = DefaultHydrationLane : workInProgress2.lanes = OffscreenLane, null;
    }
    function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
      if (didSuspend)
        if (workInProgress2.flags & ForceClientRender) {
          workInProgress2.flags &= ~ForceClientRender;
          var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
        } else {
          if (workInProgress2.memoizedState !== null)
            return workInProgress2.child = current2.child, workInProgress2.flags |= DidCapture, null;
          var nextPrimaryChildren = nextProps.children, nextFallbackChildren = nextProps.fallback, fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2), _primaryChildFragment4 = workInProgress2.child;
          return _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2), workInProgress2.memoizedState = SUSPENDED_MARKER, fallbackChildFragment;
        }
      else {
        if (warnIfHydrating(), (workInProgress2.mode & ConcurrentMode) === NoMode)
          return retrySuspenseComponentWithoutHydrating(
            current2,
            workInProgress2,
            renderLanes2,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (isSuspenseInstanceFallback(suspenseInstance)) {
          var digest, message, stack;
          {
            var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
            digest = _getSuspenseInstanceF.digest, message = _getSuspenseInstanceF.message, stack = _getSuspenseInstanceF.stack;
          }
          var error2;
          message ? error2 = new Error(message) : error2 = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var capturedValue = createCapturedValue(error2, digest, stack);
          return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
        }
        var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
        if (didReceiveUpdate || hasContextChanged2) {
          var root2 = getWorkInProgressRoot();
          if (root2 !== null) {
            var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
            if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
              suspenseState.retryLane = attemptHydrationAtLane;
              var eventTime = NoTimestamp;
              enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane), scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
            }
          }
          renderDidSuspendDelayIfPossible();
          var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
        } else if (isSuspenseInstancePending(suspenseInstance)) {
          workInProgress2.flags |= DidCapture, workInProgress2.child = current2.child;
          var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
          return registerSuspenseInstanceRetry(suspenseInstance, retry), null;
        } else {
          reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
          var primaryChildren = nextProps.children, primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
          return primaryChildFragment.flags |= Hydrating, primaryChildFragment;
        }
      }
    }
    function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
      fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
      var alternate = fiber.alternate;
      alternate !== null && (alternate.lanes = mergeLanes(alternate.lanes, renderLanes2)), scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
    }
    function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
      for (var node2 = firstChild; node2 !== null; ) {
        if (node2.tag === SuspenseComponent) {
          var state = node2.memoizedState;
          state !== null && scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
        } else if (node2.tag === SuspenseListComponent)
          scheduleSuspenseWorkOnFiber(node2, renderLanes2, workInProgress2);
        else if (node2.child !== null) {
          node2.child.return = node2, node2 = node2.child;
          continue;
        }
        if (node2 === workInProgress2)
          return;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === workInProgress2)
            return;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return, node2 = node2.sibling;
      }
    }
    function findLastContentRow(firstChild) {
      for (var row = firstChild, lastContentRow = null; row !== null; ) {
        var currentRow = row.alternate;
        currentRow !== null && findFirstSuspended(currentRow) === null && (lastContentRow = row), row = row.sibling;
      }
      return lastContentRow;
    }
    function validateRevealOrder(revealOrder) {
      if (revealOrder !== void 0 && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder])
        if (didWarnAboutRevealOrder[revealOrder] = !0, typeof revealOrder == "string")
          switch (revealOrder.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              error('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
              break;
            }
            default:
              error('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
              break;
          }
        else
          error('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', revealOrder);
    }
    function validateTailOptions(tailMode, revealOrder) {
      tailMode !== void 0 && !didWarnAboutTailOptions[tailMode] && (tailMode !== "collapsed" && tailMode !== "hidden" ? (didWarnAboutTailOptions[tailMode] = !0, error('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', tailMode)) : revealOrder !== "forwards" && revealOrder !== "backwards" && (didWarnAboutTailOptions[tailMode] = !0, error('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', tailMode)));
    }
    function validateSuspenseListNestedChild(childSlot, index3) {
      {
        var isAnArray = isArray(childSlot), isIterable = !isAnArray && typeof getIteratorFn(childSlot) == "function";
        if (isAnArray || isIterable) {
          var type = isAnArray ? "array" : "iterable";
          return error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", type, index3, type), !1;
        }
      }
      return !0;
    }
    function validateSuspenseListChildren(children, revealOrder) {
      if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== void 0 && children !== null && children !== !1)
        if (isArray(children)) {
          for (var i = 0; i < children.length; i++)
            if (!validateSuspenseListNestedChild(children[i], i))
              return;
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn == "function") {
            var childrenIterator = iteratorFn.call(children);
            if (childrenIterator)
              for (var step = childrenIterator.next(), _i = 0; !step.done; step = childrenIterator.next()) {
                if (!validateSuspenseListNestedChild(step.value, _i))
                  return;
                _i++;
              }
          } else
            error('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', revealOrder);
        }
    }
    function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
      var renderState = workInProgress2.memoizedState;
      renderState === null ? workInProgress2.memoizedState = {
        isBackwards,
        rendering: null,
        renderingStartTime: 0,
        last: lastContentRow,
        tail,
        tailMode
      } : (renderState.isBackwards = isBackwards, renderState.rendering = null, renderState.renderingStartTime = 0, renderState.last = lastContentRow, renderState.tail = tail, renderState.tailMode = tailMode);
    }
    function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
      var nextProps = workInProgress2.pendingProps, revealOrder = nextProps.revealOrder, tailMode = nextProps.tail, newChildren = nextProps.children;
      validateRevealOrder(revealOrder), validateTailOptions(tailMode, revealOrder), validateSuspenseListChildren(newChildren, revealOrder), reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
      var suspenseContext = suspenseStackCursor.current, shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      if (shouldForceFallback)
        suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback), workInProgress2.flags |= DidCapture;
      else {
        var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
        didSuspendBefore && propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2), suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
      }
      if (pushSuspenseContext(workInProgress2, suspenseContext), (workInProgress2.mode & ConcurrentMode) === NoMode)
        workInProgress2.memoizedState = null;
      else
        switch (revealOrder) {
          case "forwards": {
            var lastContentRow = findLastContentRow(workInProgress2.child), tail;
            lastContentRow === null ? (tail = workInProgress2.child, workInProgress2.child = null) : (tail = lastContentRow.sibling, lastContentRow.sibling = null), initSuspenseListRenderState(
              workInProgress2,
              !1,
              // isBackwards
              tail,
              lastContentRow,
              tailMode
            );
            break;
          }
          case "backwards": {
            var _tail = null, row = workInProgress2.child;
            for (workInProgress2.child = null; row !== null; ) {
              var currentRow = row.alternate;
              if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                workInProgress2.child = row;
                break;
              }
              var nextRow = row.sibling;
              row.sibling = _tail, _tail = row, row = nextRow;
            }
            initSuspenseListRenderState(
              workInProgress2,
              !0,
              // isBackwards
              _tail,
              null,
              // last
              tailMode
            );
            break;
          }
          case "together": {
            initSuspenseListRenderState(
              workInProgress2,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            workInProgress2.memoizedState = null;
        }
      return workInProgress2.child;
    }
    function updatePortalComponent(current2, workInProgress2, renderLanes2) {
      pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
      var nextChildren = workInProgress2.pendingProps;
      return current2 === null ? workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2) : reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2), workInProgress2.child;
    }
    var hasWarnedAboutUsingNoValuePropOnContextProvider = !1;
    function updateContextProvider(current2, workInProgress2, renderLanes2) {
      var providerType = workInProgress2.type, context = providerType._context, newProps = workInProgress2.pendingProps, oldProps = workInProgress2.memoizedProps, newValue = newProps.value;
      {
        "value" in newProps || hasWarnedAboutUsingNoValuePropOnContextProvider || (hasWarnedAboutUsingNoValuePropOnContextProvider = !0, error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var providerPropTypes = workInProgress2.type.propTypes;
        providerPropTypes && checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
      }
      if (pushProvider(workInProgress2, context, newValue), oldProps !== null) {
        var oldValue = oldProps.value;
        if (objectIs(oldValue, newValue)) {
          if (oldProps.children === newProps.children && !hasContextChanged())
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        } else
          propagateContextChange(workInProgress2, context, renderLanes2);
      }
      var newChildren = newProps.children;
      return reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
    }
    var hasWarnedAboutUsingContextAsConsumer = !1;
    function updateContextConsumer(current2, workInProgress2, renderLanes2) {
      var context = workInProgress2.type;
      context._context === void 0 ? context !== context.Consumer && (hasWarnedAboutUsingContextAsConsumer || (hasWarnedAboutUsingContextAsConsumer = !0, error("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : context = context._context;
      var newProps = workInProgress2.pendingProps, render2 = newProps.children;
      typeof render2 != "function" && error("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), prepareToReadContext(workInProgress2, renderLanes2);
      var newValue = readContext(context);
      markComponentRenderStarted(workInProgress2);
      var newChildren;
      return ReactCurrentOwner$1.current = workInProgress2, setIsRendering(!0), newChildren = render2(newValue), setIsRendering(!1), markComponentRenderStopped(), workInProgress2.flags |= PerformedWork, reconcileChildren(current2, workInProgress2, newChildren, renderLanes2), workInProgress2.child;
    }
    function markWorkInProgressReceivedUpdate() {
      didReceiveUpdate = !0;
    }
    function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
      (workInProgress2.mode & ConcurrentMode) === NoMode && current2 !== null && (current2.alternate = null, workInProgress2.alternate = null, workInProgress2.flags |= Placement);
    }
    function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
      return current2 !== null && (workInProgress2.dependencies = current2.dependencies), stopProfilerTimerIfRunning(), markSkippedUpdateLanes(workInProgress2.lanes), includesSomeLane(renderLanes2, workInProgress2.childLanes) ? (cloneChildFibers(current2, workInProgress2), workInProgress2.child) : null;
    }
    function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
      {
        var returnFiber = oldWorkInProgress.return;
        if (returnFiber === null)
          throw new Error("Cannot swap the root fiber.");
        if (current2.alternate = null, oldWorkInProgress.alternate = null, newWorkInProgress.index = oldWorkInProgress.index, newWorkInProgress.sibling = oldWorkInProgress.sibling, newWorkInProgress.return = oldWorkInProgress.return, newWorkInProgress.ref = oldWorkInProgress.ref, oldWorkInProgress === returnFiber.child)
          returnFiber.child = newWorkInProgress;
        else {
          var prevSibling = returnFiber.child;
          if (prevSibling === null)
            throw new Error("Expected parent to have a child.");
          for (; prevSibling.sibling !== oldWorkInProgress; )
            if (prevSibling = prevSibling.sibling, prevSibling === null)
              throw new Error("Expected to find the previous sibling.");
          prevSibling.sibling = newWorkInProgress;
        }
        var deletions = returnFiber.deletions;
        return deletions === null ? (returnFiber.deletions = [current2], returnFiber.flags |= ChildDeletion) : deletions.push(current2), newWorkInProgress.flags |= Placement, newWorkInProgress;
      }
    }
    function checkScheduledUpdateOrContext(current2, renderLanes2) {
      var updateLanes = current2.lanes;
      return !!includesSomeLane(updateLanes, renderLanes2);
    }
    function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
      switch (workInProgress2.tag) {
        case HostRoot:
          pushHostRootContext(workInProgress2), resetHydrationState();
          break;
        case HostComponent:
          pushHostContext(workInProgress2);
          break;
        case ClassComponent: {
          var Component = workInProgress2.type;
          isContextProvider(Component) && pushContextProvider(workInProgress2);
          break;
        }
        case HostPortal:
          pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
          break;
        case ContextProvider: {
          var newValue = workInProgress2.memoizedProps.value, context = workInProgress2.type._context;
          pushProvider(workInProgress2, context, newValue);
          break;
        }
        case Profiler:
          {
            var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            hasChildWork && (workInProgress2.flags |= Update);
            {
              var stateNode = workInProgress2.stateNode;
              stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
            }
          }
          break;
        case SuspenseComponent: {
          var state = workInProgress2.memoizedState;
          if (state !== null) {
            if (state.dehydrated !== null)
              return pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current)), workInProgress2.flags |= DidCapture, null;
            var primaryChildFragment = workInProgress2.child, primaryChildLanes = primaryChildFragment.childLanes;
            if (includesSomeLane(renderLanes2, primaryChildLanes))
              return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
            pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            return child !== null ? child.sibling : null;
          } else
            pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
          break;
        }
        case SuspenseListComponent: {
          var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags, _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
          if (didSuspendBefore) {
            if (_hasChildWork)
              return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
            workInProgress2.flags |= DidCapture;
          }
          var renderState = workInProgress2.memoizedState;
          if (renderState !== null && (renderState.rendering = null, renderState.tail = null, renderState.lastEffect = null), pushSuspenseContext(workInProgress2, suspenseStackCursor.current), _hasChildWork)
            break;
          return null;
        }
        case OffscreenComponent:
        case LegacyHiddenComponent:
          return workInProgress2.lanes = NoLanes, updateOffscreenComponent(current2, workInProgress2, renderLanes2);
      }
      return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
    }
    function beginWork(current2, workInProgress2, renderLanes2) {
      if (workInProgress2._debugNeedsRemount && current2 !== null)
        return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
      if (current2 !== null) {
        var oldProps = current2.memoizedProps, newProps = workInProgress2.pendingProps;
        if (oldProps !== newProps || hasContextChanged() || // Force a re-render if the implementation changed due to hot reload:
        workInProgress2.type !== current2.type)
          didReceiveUpdate = !0;
        else {
          var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
          if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (workInProgress2.flags & DidCapture) === NoFlags)
            return didReceiveUpdate = !1, attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
          (current2.flags & ForceUpdateForLegacySuspense) !== NoFlags ? didReceiveUpdate = !0 : didReceiveUpdate = !1;
        }
      } else if (didReceiveUpdate = !1, getIsHydrating() && isForkedChild(workInProgress2)) {
        var slotIndex = workInProgress2.index, numberOfForks = getForksAtLevel();
        pushTreeId(workInProgress2, numberOfForks, slotIndex);
      }
      switch (workInProgress2.lanes = NoLanes, workInProgress2.tag) {
        case IndeterminateComponent:
          return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
        case LazyComponent: {
          var elementType = workInProgress2.elementType;
          return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
        }
        case FunctionComponent: {
          var Component = workInProgress2.type, unresolvedProps = workInProgress2.pendingProps, resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
          return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
        }
        case ClassComponent: {
          var _Component = workInProgress2.type, _unresolvedProps = workInProgress2.pendingProps, _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
          return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
        }
        case HostRoot:
          return updateHostRoot(current2, workInProgress2, renderLanes2);
        case HostComponent:
          return updateHostComponent(current2, workInProgress2, renderLanes2);
        case HostText:
          return updateHostText(current2, workInProgress2);
        case SuspenseComponent:
          return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
        case HostPortal:
          return updatePortalComponent(current2, workInProgress2, renderLanes2);
        case ForwardRef: {
          var type = workInProgress2.type, _unresolvedProps2 = workInProgress2.pendingProps, _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
          return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
        }
        case Fragment2:
          return updateFragment(current2, workInProgress2, renderLanes2);
        case Mode:
          return updateMode(current2, workInProgress2, renderLanes2);
        case Profiler:
          return updateProfiler(current2, workInProgress2, renderLanes2);
        case ContextProvider:
          return updateContextProvider(current2, workInProgress2, renderLanes2);
        case ContextConsumer:
          return updateContextConsumer(current2, workInProgress2, renderLanes2);
        case MemoComponent: {
          var _type2 = workInProgress2.type, _unresolvedProps3 = workInProgress2.pendingProps, _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerPropTypes = _type2.propTypes;
            outerPropTypes && checkPropTypes(
              outerPropTypes,
              _resolvedProps3,
              // Resolved for outer only
              "prop",
              getComponentNameFromType(_type2)
            );
          }
          return _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3), updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
        }
        case SimpleMemoComponent:
          return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
        case IncompleteClassComponent: {
          var _Component2 = workInProgress2.type, _unresolvedProps4 = workInProgress2.pendingProps, _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
          return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
        }
        case SuspenseListComponent:
          return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
        case ScopeComponent:
          break;
        case OffscreenComponent:
          return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
      }
      throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function markUpdate(workInProgress2) {
      workInProgress2.flags |= Update;
    }
    function markRef$1(workInProgress2) {
      workInProgress2.flags |= Ref, workInProgress2.flags |= RefStatic;
    }
    var appendAllChildren, updateHostContainer, updateHostComponent$1, updateHostText$1;
    appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden2) {
      for (var node2 = workInProgress2.child; node2 !== null; ) {
        if (node2.tag === HostComponent || node2.tag === HostText)
          appendInitialChild(parent, node2.stateNode);
        else if (node2.tag !== HostPortal) {
          if (node2.child !== null) {
            node2.child.return = node2, node2 = node2.child;
            continue;
          }
        }
        if (node2 === workInProgress2)
          return;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === workInProgress2)
            return;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return, node2 = node2.sibling;
      }
    }, updateHostContainer = function(current2, workInProgress2) {
    }, updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
      var oldProps = current2.memoizedProps;
      if (oldProps !== newProps) {
        var instance = workInProgress2.stateNode, currentHostContext = getHostContext(), updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
        workInProgress2.updateQueue = updatePayload, updatePayload && markUpdate(workInProgress2);
      }
    }, updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
      oldText !== newText && markUpdate(workInProgress2);
    };
    function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
      if (!getIsHydrating())
        switch (renderState.tailMode) {
          case "hidden": {
            for (var tailNode = renderState.tail, lastTailNode = null; tailNode !== null; )
              tailNode.alternate !== null && (lastTailNode = tailNode), tailNode = tailNode.sibling;
            lastTailNode === null ? renderState.tail = null : lastTailNode.sibling = null;
            break;
          }
          case "collapsed": {
            for (var _tailNode = renderState.tail, _lastTailNode = null; _tailNode !== null; )
              _tailNode.alternate !== null && (_lastTailNode = _tailNode), _tailNode = _tailNode.sibling;
            _lastTailNode === null ? !hasRenderedATailFallback && renderState.tail !== null ? renderState.tail.sibling = null : renderState.tail = null : _lastTailNode.sibling = null;
            break;
          }
        }
    }
    function bubbleProperties(completedWork) {
      var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child, newChildLanes = NoLanes, subtreeFlags = NoFlags;
      if (didBailout) {
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (var _treeBaseDuration = completedWork.selfBaseDuration, _child2 = completedWork.child; _child2 !== null; )
            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)), subtreeFlags |= _child2.subtreeFlags & StaticMask, subtreeFlags |= _child2.flags & StaticMask, _treeBaseDuration += _child2.treeBaseDuration, _child2 = _child2.sibling;
          completedWork.treeBaseDuration = _treeBaseDuration;
        } else
          for (var _child3 = completedWork.child; _child3 !== null; )
            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)), subtreeFlags |= _child3.subtreeFlags & StaticMask, subtreeFlags |= _child3.flags & StaticMask, _child3.return = completedWork, _child3 = _child3.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
      } else {
        if ((completedWork.mode & ProfileMode) !== NoMode) {
          for (var actualDuration = completedWork.actualDuration, treeBaseDuration = completedWork.selfBaseDuration, child = completedWork.child; child !== null; )
            newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes)), subtreeFlags |= child.subtreeFlags, subtreeFlags |= child.flags, actualDuration += child.actualDuration, treeBaseDuration += child.treeBaseDuration, child = child.sibling;
          completedWork.actualDuration = actualDuration, completedWork.treeBaseDuration = treeBaseDuration;
        } else
          for (var _child = completedWork.child; _child !== null; )
            newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes)), subtreeFlags |= _child.subtreeFlags, subtreeFlags |= _child.flags, _child.return = completedWork, _child = _child.sibling;
        completedWork.subtreeFlags |= subtreeFlags;
      }
      return completedWork.childLanes = newChildLanes, didBailout;
    }
    function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
      if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags)
        return warnIfUnhydratedTailNodes(workInProgress2), resetHydrationState(), workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture, !1;
      var wasHydrated = popHydrationState(workInProgress2);
      if (nextState !== null && nextState.dehydrated !== null)
        if (current2 === null) {
          if (!wasHydrated)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (prepareToHydrateHostSuspenseInstance(workInProgress2), bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode) {
            var isTimedOutSuspense = nextState !== null;
            if (isTimedOutSuspense) {
              var primaryChildFragment = workInProgress2.child;
              primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (resetHydrationState(), (workInProgress2.flags & DidCapture) === NoFlags && (workInProgress2.memoizedState = null), workInProgress2.flags |= Update, bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode) {
            var _isTimedOutSuspense = nextState !== null;
            if (_isTimedOutSuspense) {
              var _primaryChildFragment = workInProgress2.child;
              _primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return upgradeHydrationErrorsToRecoverable(), !0;
    }
    function completeWork(current2, workInProgress2, renderLanes2) {
      var newProps = workInProgress2.pendingProps;
      switch (popTreeContext(workInProgress2), workInProgress2.tag) {
        case IndeterminateComponent:
        case LazyComponent:
        case SimpleMemoComponent:
        case FunctionComponent:
        case ForwardRef:
        case Fragment2:
        case Mode:
        case Profiler:
        case ContextConsumer:
        case MemoComponent:
          return bubbleProperties(workInProgress2), null;
        case ClassComponent: {
          var Component = workInProgress2.type;
          return isContextProvider(Component) && popContext(workInProgress2), bubbleProperties(workInProgress2), null;
        }
        case HostRoot: {
          var fiberRoot = workInProgress2.stateNode;
          if (popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions(), fiberRoot.pendingContext && (fiberRoot.context = fiberRoot.pendingContext, fiberRoot.pendingContext = null), current2 === null || current2.child === null) {
            var wasHydrated = popHydrationState(workInProgress2);
            if (wasHydrated)
              markUpdate(workInProgress2);
            else if (current2 !== null) {
              var prevState = current2.memoizedState;
              // Check if this is a client root
              (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (workInProgress2.flags & ForceClientRender) !== NoFlags) && (workInProgress2.flags |= Snapshot, upgradeHydrationErrorsToRecoverable());
            }
          }
          return updateHostContainer(current2, workInProgress2), bubbleProperties(workInProgress2), null;
        }
        case HostComponent: {
          popHostContext(workInProgress2);
          var rootContainerInstance = getRootHostContainer(), type = workInProgress2.type;
          if (current2 !== null && workInProgress2.stateNode != null)
            updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance), current2.ref !== workInProgress2.ref && markRef$1(workInProgress2);
          else {
            if (!newProps) {
              if (workInProgress2.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return bubbleProperties(workInProgress2), null;
            }
            var currentHostContext = getHostContext(), _wasHydrated = popHydrationState(workInProgress2);
            if (_wasHydrated)
              prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext) && markUpdate(workInProgress2);
            else {
              var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
              appendAllChildren(instance, workInProgress2, !1, !1), workInProgress2.stateNode = instance, finalizeInitialChildren(instance, type, newProps, rootContainerInstance) && markUpdate(workInProgress2);
            }
            workInProgress2.ref !== null && markRef$1(workInProgress2);
          }
          return bubbleProperties(workInProgress2), null;
        }
        case HostText: {
          var newText = newProps;
          if (current2 && workInProgress2.stateNode != null) {
            var oldText = current2.memoizedProps;
            updateHostText$1(current2, workInProgress2, oldText, newText);
          } else {
            if (typeof newText != "string" && workInProgress2.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var _rootContainerInstance = getRootHostContainer(), _currentHostContext = getHostContext(), _wasHydrated2 = popHydrationState(workInProgress2);
            _wasHydrated2 ? prepareToHydrateHostTextInstance(workInProgress2) && markUpdate(workInProgress2) : workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
          }
          return bubbleProperties(workInProgress2), null;
        }
        case SuspenseComponent: {
          popSuspenseContext(workInProgress2);
          var nextState = workInProgress2.memoizedState;
          if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
            if (!fallthroughToNormalSuspensePath)
              return workInProgress2.flags & ShouldCapture ? workInProgress2 : null;
          }
          if ((workInProgress2.flags & DidCapture) !== NoFlags)
            return workInProgress2.lanes = renderLanes2, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2;
          var nextDidTimeout = nextState !== null, prevDidTimeout = current2 !== null && current2.memoizedState !== null;
          if (nextDidTimeout !== prevDidTimeout && nextDidTimeout) {
            var _offscreenFiber2 = workInProgress2.child;
            if (_offscreenFiber2.flags |= Visibility, (workInProgress2.mode & ConcurrentMode) !== NoMode) {
              var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== !0 || !enableSuspenseAvoidThisFallback);
              hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext) ? renderDidSuspend() : renderDidSuspendDelayIfPossible();
            }
          }
          var wakeables = workInProgress2.updateQueue;
          if (wakeables !== null && (workInProgress2.flags |= Update), bubbleProperties(workInProgress2), (workInProgress2.mode & ProfileMode) !== NoMode && nextDidTimeout) {
            var primaryChildFragment = workInProgress2.child;
            primaryChildFragment !== null && (workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration);
          }
          return null;
        }
        case HostPortal:
          return popHostContainer(workInProgress2), updateHostContainer(current2, workInProgress2), current2 === null && preparePortalMount(workInProgress2.stateNode.containerInfo), bubbleProperties(workInProgress2), null;
        case ContextProvider:
          var context = workInProgress2.type._context;
          return popProvider(context, workInProgress2), bubbleProperties(workInProgress2), null;
        case IncompleteClassComponent: {
          var _Component = workInProgress2.type;
          return isContextProvider(_Component) && popContext(workInProgress2), bubbleProperties(workInProgress2), null;
        }
        case SuspenseListComponent: {
          popSuspenseContext(workInProgress2);
          var renderState = workInProgress2.memoizedState;
          if (renderState === null)
            return bubbleProperties(workInProgress2), null;
          var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags, renderedTail = renderState.rendering;
          if (renderedTail === null)
            if (didSuspendAlready)
              cutOffTailIfNeeded(renderState, !1);
            else {
              var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
              if (!cannotBeSuspended)
                for (var row = workInProgress2.child; row !== null; ) {
                  var suspended = findFirstSuspended(row);
                  if (suspended !== null) {
                    didSuspendAlready = !0, workInProgress2.flags |= DidCapture, cutOffTailIfNeeded(renderState, !1);
                    var newThenables = suspended.updateQueue;
                    return newThenables !== null && (workInProgress2.updateQueue = newThenables, workInProgress2.flags |= Update), workInProgress2.subtreeFlags = NoFlags, resetChildFibers(workInProgress2, renderLanes2), pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback)), workInProgress2.child;
                  }
                  row = row.sibling;
                }
              renderState.tail !== null && now2() > getRenderTargetTime() && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane);
            }
          else {
            if (!didSuspendAlready) {
              var _suspended = findFirstSuspended(renderedTail);
              if (_suspended !== null) {
                workInProgress2.flags |= DidCapture, didSuspendAlready = !0;
                var _newThenables = _suspended.updateQueue;
                if (_newThenables !== null && (workInProgress2.updateQueue = _newThenables, workInProgress2.flags |= Update), cutOffTailIfNeeded(renderState, !0), renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating())
                  return bubbleProperties(workInProgress2), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              now2() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane && (workInProgress2.flags |= DidCapture, didSuspendAlready = !0, cutOffTailIfNeeded(renderState, !1), workInProgress2.lanes = SomeRetryLane);
            }
            if (renderState.isBackwards)
              renderedTail.sibling = workInProgress2.child, workInProgress2.child = renderedTail;
            else {
              var previousSibling = renderState.last;
              previousSibling !== null ? previousSibling.sibling = renderedTail : workInProgress2.child = renderedTail, renderState.last = renderedTail;
            }
          }
          if (renderState.tail !== null) {
            var next2 = renderState.tail;
            renderState.rendering = next2, renderState.tail = next2.sibling, renderState.renderingStartTime = now2(), next2.sibling = null;
            var suspenseContext = suspenseStackCursor.current;
            return didSuspendAlready ? suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback) : suspenseContext = setDefaultShallowSuspenseContext(suspenseContext), pushSuspenseContext(workInProgress2, suspenseContext), next2;
          }
          return bubbleProperties(workInProgress2), null;
        }
        case ScopeComponent:
          break;
        case OffscreenComponent:
        case LegacyHiddenComponent: {
          popRenderLanes(workInProgress2);
          var _nextState = workInProgress2.memoizedState, nextIsHidden = _nextState !== null;
          if (current2 !== null) {
            var _prevState = current2.memoizedState, prevIsHidden = _prevState !== null;
            prevIsHidden !== nextIsHidden && // LegacyHidden doesn't do any hiding — it only pre-renders.
            !enableLegacyHidden && (workInProgress2.flags |= Visibility);
          }
          return !nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode ? bubbleProperties(workInProgress2) : includesSomeLane(subtreeRenderLanes, OffscreenLane) && (bubbleProperties(workInProgress2), workInProgress2.subtreeFlags & (Placement | Update) && (workInProgress2.flags |= Visibility)), null;
        }
        case CacheComponent:
          return null;
        case TracingMarkerComponent:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function unwindWork(current2, workInProgress2, renderLanes2) {
      switch (popTreeContext(workInProgress2), workInProgress2.tag) {
        case ClassComponent: {
          var Component = workInProgress2.type;
          isContextProvider(Component) && popContext(workInProgress2);
          var flags = workInProgress2.flags;
          return flags & ShouldCapture ? (workInProgress2.flags = flags & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        }
        case HostRoot: {
          popHostContainer(workInProgress2), popTopLevelContextObject(workInProgress2), resetWorkInProgressVersions();
          var _flags = workInProgress2.flags;
          return (_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags ? (workInProgress2.flags = _flags & ~ShouldCapture | DidCapture, workInProgress2) : null;
        }
        case HostComponent:
          return popHostContext(workInProgress2), null;
        case SuspenseComponent: {
          popSuspenseContext(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null && suspenseState.dehydrated !== null) {
            if (workInProgress2.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            resetHydrationState();
          }
          var _flags2 = workInProgress2.flags;
          return _flags2 & ShouldCapture ? (workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture, (workInProgress2.mode & ProfileMode) !== NoMode && transferActualDuration(workInProgress2), workInProgress2) : null;
        }
        case SuspenseListComponent:
          return popSuspenseContext(workInProgress2), null;
        case HostPortal:
          return popHostContainer(workInProgress2), null;
        case ContextProvider:
          var context = workInProgress2.type._context;
          return popProvider(context, workInProgress2), null;
        case OffscreenComponent:
        case LegacyHiddenComponent:
          return popRenderLanes(workInProgress2), null;
        case CacheComponent:
          return null;
        default:
          return null;
      }
    }
    function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
      switch (popTreeContext(interruptedWork), interruptedWork.tag) {
        case ClassComponent: {
          var childContextTypes = interruptedWork.type.childContextTypes;
          childContextTypes != null && popContext(interruptedWork);
          break;
        }
        case HostRoot: {
          popHostContainer(interruptedWork), popTopLevelContextObject(interruptedWork), resetWorkInProgressVersions();
          break;
        }
        case HostComponent: {
          popHostContext(interruptedWork);
          break;
        }
        case HostPortal:
          popHostContainer(interruptedWork);
          break;
        case SuspenseComponent:
          popSuspenseContext(interruptedWork);
          break;
        case SuspenseListComponent:
          popSuspenseContext(interruptedWork);
          break;
        case ContextProvider:
          var context = interruptedWork.type._context;
          popProvider(context, interruptedWork);
          break;
        case OffscreenComponent:
        case LegacyHiddenComponent:
          popRenderLanes(interruptedWork);
          break;
      }
    }
    var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
    didWarnAboutUndefinedSnapshotBeforeUpdate = /* @__PURE__ */ new Set();
    var offscreenSubtreeIsHidden = !1, offscreenSubtreeWasHidden = !1, PossiblyWeakSet = typeof WeakSet == "function" ? WeakSet : Set, nextEffect = null, inProgressLanes = null, inProgressRoot = null;
    function reportUncaughtErrorInDEV(error2) {
      invokeGuardedCallback(null, function() {
        throw error2;
      }), clearCaughtError();
    }
    var callComponentWillUnmountWithTimer = function(current2, instance) {
      if (instance.props = current2.memoizedProps, instance.state = current2.memoizedState, current2.mode & ProfileMode)
        try {
          startLayoutEffectTimer(), instance.componentWillUnmount();
        } finally {
          recordLayoutEffectDuration(current2);
        }
      else
        instance.componentWillUnmount();
    };
    function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
      try {
        commitHookEffectListMount(Layout, current2);
      } catch (error2) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
      }
    }
    function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
      try {
        callComponentWillUnmountWithTimer(current2, instance);
      } catch (error2) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
      }
    }
    function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
      try {
        instance.componentDidMount();
      } catch (error2) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
      }
    }
    function safelyAttachRef(current2, nearestMountedAncestor) {
      try {
        commitAttachRef(current2);
      } catch (error2) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
      }
    }
    function safelyDetachRef(current2, nearestMountedAncestor) {
      var ref = current2.ref;
      if (ref !== null)
        if (typeof ref == "function") {
          var retVal;
          try {
            if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode)
              try {
                startLayoutEffectTimer(), retVal = ref(null);
              } finally {
                recordLayoutEffectDuration(current2);
              }
            else
              retVal = ref(null);
          } catch (error2) {
            captureCommitPhaseError(current2, nearestMountedAncestor, error2);
          }
          typeof retVal == "function" && error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(current2));
        } else
          ref.current = null;
    }
    function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
      try {
        destroy();
      } catch (error2) {
        captureCommitPhaseError(current2, nearestMountedAncestor, error2);
      }
    }
    var shouldFireAfterActiveInstanceBlur = !1;
    function commitBeforeMutationEffects(root2, firstChild) {
      prepareForCommit(), nextEffect = firstChild, commitBeforeMutationEffects_begin();
      var shouldFire = shouldFireAfterActiveInstanceBlur;
      return shouldFireAfterActiveInstanceBlur = !1, shouldFire;
    }
    function commitBeforeMutationEffects_begin() {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, child = fiber.child;
        (fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null ? (child.return = fiber, nextEffect = child) : commitBeforeMutationEffects_complete();
      }
    }
    function commitBeforeMutationEffects_complete() {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        setCurrentFiber(fiber);
        try {
          commitBeforeMutationEffectsOnFiber(fiber);
        } catch (error2) {
          captureCommitPhaseError(fiber, fiber.return, error2);
        }
        resetCurrentFiber();
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function commitBeforeMutationEffectsOnFiber(finishedWork) {
      var current2 = finishedWork.alternate, flags = finishedWork.flags;
      if ((flags & Snapshot) !== NoFlags) {
        switch (setCurrentFiber(finishedWork), finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent:
            break;
          case ClassComponent: {
            if (current2 !== null) {
              var prevProps = current2.memoizedProps, prevState = current2.memoizedState, instance = finishedWork.stateNode;
              finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"));
              var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
              {
                var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                snapshot === void 0 && !didWarnSet.has(finishedWork.type) && (didWarnSet.add(finishedWork.type), error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork)));
              }
              instance.__reactInternalSnapshotBeforeUpdate = snapshot;
            }
            break;
          }
          case HostRoot: {
            {
              var root2 = finishedWork.stateNode;
              clearContainer(root2.containerInfo);
            }
            break;
          }
          case HostComponent:
          case HostText:
          case HostPortal:
          case IncompleteClassComponent:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        resetCurrentFiber();
      }
    }
    function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
      var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
      if (lastEffect !== null) {
        var firstEffect = lastEffect.next, effect = firstEffect;
        do {
          if ((effect.tag & flags) === flags) {
            var destroy = effect.destroy;
            effect.destroy = void 0, destroy !== void 0 && ((flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectUnmountStarted(finishedWork) : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectUnmountStarted(finishedWork), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!0), safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!1), (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectUnmountStopped() : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectUnmountStopped());
          }
          effect = effect.next;
        } while (effect !== firstEffect);
      }
    }
    function commitHookEffectListMount(flags, finishedWork) {
      var updateQueue = finishedWork.updateQueue, lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
      if (lastEffect !== null) {
        var firstEffect = lastEffect.next, effect = firstEffect;
        do {
          if ((effect.tag & flags) === flags) {
            (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectMountStarted(finishedWork) : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectMountStarted(finishedWork);
            var create2 = effect.create;
            (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!0), effect.destroy = create2(), (flags & Insertion) !== NoFlags$1 && setIsRunningInsertionEffect(!1), (flags & Passive$1) !== NoFlags$1 ? markComponentPassiveEffectMountStopped() : (flags & Layout) !== NoFlags$1 && markComponentLayoutEffectMountStopped();
            {
              var destroy = effect.destroy;
              if (destroy !== void 0 && typeof destroy != "function") {
                var hookName = void 0;
                (effect.tag & Layout) !== NoFlags ? hookName = "useLayoutEffect" : (effect.tag & Insertion) !== NoFlags ? hookName = "useInsertionEffect" : hookName = "useEffect";
                var addendum = void 0;
                destroy === null ? addendum = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof destroy.then == "function" ? addendum = `

It looks like you wrote ` + hookName + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + hookName + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : addendum = " You returned: " + destroy, error("%s must not return anything besides a function, which is used for clean-up.%s", hookName, addendum);
              }
            }
          }
          effect = effect.next;
        } while (effect !== firstEffect);
      }
    }
    function commitPassiveEffectDurations(finishedRoot, finishedWork) {
      if ((finishedWork.flags & Update) !== NoFlags)
        switch (finishedWork.tag) {
          case Profiler: {
            var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration, _finishedWork$memoize = finishedWork.memoizedProps, id2 = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit, commitTime2 = getCommitTime(), phase = finishedWork.alternate === null ? "mount" : "update";
            isCurrentUpdateNested() && (phase = "nested-update"), typeof onPostCommit == "function" && onPostCommit(id2, phase, passiveEffectDuration, commitTime2);
            var parentFiber = finishedWork.return;
            outer: for (; parentFiber !== null; ) {
              switch (parentFiber.tag) {
                case HostRoot:
                  var root2 = parentFiber.stateNode;
                  root2.passiveEffectDuration += passiveEffectDuration;
                  break outer;
                case Profiler:
                  var parentStateNode = parentFiber.stateNode;
                  parentStateNode.passiveEffectDuration += passiveEffectDuration;
                  break outer;
              }
              parentFiber = parentFiber.return;
            }
            break;
          }
        }
    }
    function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
      if ((finishedWork.flags & LayoutMask) !== NoFlags)
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden)
              if (finishedWork.mode & ProfileMode)
                try {
                  startLayoutEffectTimer(), commitHookEffectListMount(Layout | HasEffect, finishedWork);
                } finally {
                  recordLayoutEffectDuration(finishedWork);
                }
              else
                commitHookEffectListMount(Layout | HasEffect, finishedWork);
            break;
          }
          case ClassComponent: {
            var instance = finishedWork.stateNode;
            if (finishedWork.flags & Update && !offscreenSubtreeWasHidden)
              if (current2 === null)
                if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), finishedWork.mode & ProfileMode)
                  try {
                    startLayoutEffectTimer(), instance.componentDidMount();
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                else
                  instance.componentDidMount();
              else {
                var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps), prevState = current2.memoizedState;
                if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), finishedWork.mode & ProfileMode)
                  try {
                    startLayoutEffectTimer(), instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                else
                  instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
              }
            var updateQueue = finishedWork.updateQueue;
            updateQueue !== null && (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps && (instance.props !== finishedWork.memoizedProps && error("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance"), instance.state !== finishedWork.memoizedState && error("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance")), commitUpdateQueue(finishedWork, updateQueue, instance));
            break;
          }
          case HostRoot: {
            var _updateQueue = finishedWork.updateQueue;
            if (_updateQueue !== null) {
              var _instance = null;
              if (finishedWork.child !== null)
                switch (finishedWork.child.tag) {
                  case HostComponent:
                    _instance = finishedWork.child.stateNode;
                    break;
                  case ClassComponent:
                    _instance = finishedWork.child.stateNode;
                    break;
                }
              commitUpdateQueue(finishedWork, _updateQueue, _instance);
            }
            break;
          }
          case HostComponent: {
            var _instance2 = finishedWork.stateNode;
            if (current2 === null && finishedWork.flags & Update) {
              var type = finishedWork.type, props = finishedWork.memoizedProps;
              commitMount(_instance2, type, props);
            }
            break;
          }
          case HostText:
            break;
          case HostPortal:
            break;
          case Profiler: {
            {
              var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender, effectDuration = finishedWork.stateNode.effectDuration, commitTime2 = getCommitTime(), phase = current2 === null ? "mount" : "update";
              isCurrentUpdateNested() && (phase = "nested-update"), typeof onRender == "function" && onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
              {
                typeof onCommit == "function" && onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2), enqueuePendingPassiveProfilerEffect(finishedWork);
                var parentFiber = finishedWork.return;
                outer: for (; parentFiber !== null; ) {
                  switch (parentFiber.tag) {
                    case HostRoot:
                      var root2 = parentFiber.stateNode;
                      root2.effectDuration += effectDuration;
                      break outer;
                    case Profiler:
                      var parentStateNode = parentFiber.stateNode;
                      parentStateNode.effectDuration += effectDuration;
                      break outer;
                  }
                  parentFiber = parentFiber.return;
                }
              }
            }
            break;
          }
          case SuspenseComponent: {
            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
            break;
          }
          case SuspenseListComponent:
          case IncompleteClassComponent:
          case ScopeComponent:
          case OffscreenComponent:
          case LegacyHiddenComponent:
          case TracingMarkerComponent:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      offscreenSubtreeWasHidden || finishedWork.flags & Ref && commitAttachRef(finishedWork);
    }
    function reappearLayoutEffectsOnFiber(node2) {
      switch (node2.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          if (node2.mode & ProfileMode)
            try {
              startLayoutEffectTimer(), safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
            } finally {
              recordLayoutEffectDuration(node2);
            }
          else
            safelyCallCommitHookLayoutEffectListMount(node2, node2.return);
          break;
        }
        case ClassComponent: {
          var instance = node2.stateNode;
          typeof instance.componentDidMount == "function" && safelyCallComponentDidMount(node2, node2.return, instance), safelyAttachRef(node2, node2.return);
          break;
        }
        case HostComponent: {
          safelyAttachRef(node2, node2.return);
          break;
        }
      }
    }
    function hideOrUnhideAllChildren(finishedWork, isHidden2) {
      for (var hostSubtreeRoot = null, node2 = finishedWork; ; ) {
        if (node2.tag === HostComponent) {
          if (hostSubtreeRoot === null) {
            hostSubtreeRoot = node2;
            try {
              var instance = node2.stateNode;
              isHidden2 ? hideInstance(instance) : unhideInstance(node2.stateNode, node2.memoizedProps);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
          }
        } else if (node2.tag === HostText) {
          if (hostSubtreeRoot === null)
            try {
              var _instance3 = node2.stateNode;
              isHidden2 ? hideTextInstance(_instance3) : unhideTextInstance(_instance3, node2.memoizedProps);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
        } else if (!((node2.tag === OffscreenComponent || node2.tag === LegacyHiddenComponent) && node2.memoizedState !== null && node2 !== finishedWork)) {
          if (node2.child !== null) {
            node2.child.return = node2, node2 = node2.child;
            continue;
          }
        }
        if (node2 === finishedWork)
          return;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === finishedWork)
            return;
          hostSubtreeRoot === node2 && (hostSubtreeRoot = null), node2 = node2.return;
        }
        hostSubtreeRoot === node2 && (hostSubtreeRoot = null), node2.sibling.return = node2.return, node2 = node2.sibling;
      }
    }
    function commitAttachRef(finishedWork) {
      var ref = finishedWork.ref;
      if (ref !== null) {
        var instance = finishedWork.stateNode, instanceToUse;
        switch (finishedWork.tag) {
          case HostComponent:
            instanceToUse = instance;
            break;
          default:
            instanceToUse = instance;
        }
        if (typeof ref == "function") {
          var retVal;
          if (finishedWork.mode & ProfileMode)
            try {
              startLayoutEffectTimer(), retVal = ref(instanceToUse);
            } finally {
              recordLayoutEffectDuration(finishedWork);
            }
          else
            retVal = ref(instanceToUse);
          typeof retVal == "function" && error("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
        } else
          ref.hasOwnProperty("current") || error("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork)), ref.current = instanceToUse;
      }
    }
    function detachFiberMutation(fiber) {
      var alternate = fiber.alternate;
      alternate !== null && (alternate.return = null), fiber.return = null;
    }
    function detachFiberAfterEffects(fiber) {
      var alternate = fiber.alternate;
      alternate !== null && (fiber.alternate = null, detachFiberAfterEffects(alternate));
      {
        if (fiber.child = null, fiber.deletions = null, fiber.sibling = null, fiber.tag === HostComponent) {
          var hostInstance = fiber.stateNode;
          hostInstance !== null && detachDeletedInstance(hostInstance);
        }
        fiber.stateNode = null, fiber._debugOwner = null, fiber.return = null, fiber.dependencies = null, fiber.memoizedProps = null, fiber.memoizedState = null, fiber.pendingProps = null, fiber.stateNode = null, fiber.updateQueue = null;
      }
    }
    function getHostParentFiber(fiber) {
      for (var parent = fiber.return; parent !== null; ) {
        if (isHostParent(parent))
          return parent;
        parent = parent.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function isHostParent(fiber) {
      return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
    }
    function getHostSibling(fiber) {
      var node2 = fiber;
      siblings: for (; ; ) {
        for (; node2.sibling === null; ) {
          if (node2.return === null || isHostParent(node2.return))
            return null;
          node2 = node2.return;
        }
        for (node2.sibling.return = node2.return, node2 = node2.sibling; node2.tag !== HostComponent && node2.tag !== HostText && node2.tag !== DehydratedFragment; ) {
          if (node2.flags & Placement || node2.child === null || node2.tag === HostPortal)
            continue siblings;
          node2.child.return = node2, node2 = node2.child;
        }
        if (!(node2.flags & Placement))
          return node2.stateNode;
      }
    }
    function commitPlacement(finishedWork) {
      var parentFiber = getHostParentFiber(finishedWork);
      switch (parentFiber.tag) {
        case HostComponent: {
          var parent = parentFiber.stateNode;
          parentFiber.flags & ContentReset && (resetTextContent(parent), parentFiber.flags &= ~ContentReset);
          var before = getHostSibling(finishedWork);
          insertOrAppendPlacementNode(finishedWork, before, parent);
          break;
        }
        case HostRoot:
        case HostPortal: {
          var _parent = parentFiber.stateNode.containerInfo, _before = getHostSibling(finishedWork);
          insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
          break;
        }
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function insertOrAppendPlacementNodeIntoContainer(node2, before, parent) {
      var tag = node2.tag, isHost = tag === HostComponent || tag === HostText;
      if (isHost) {
        var stateNode = node2.stateNode;
        before ? insertInContainerBefore(parent, stateNode, before) : appendChildToContainer(parent, stateNode);
      } else if (tag !== HostPortal) {
        var child = node2.child;
        if (child !== null) {
          insertOrAppendPlacementNodeIntoContainer(child, before, parent);
          for (var sibling = child.sibling; sibling !== null; )
            insertOrAppendPlacementNodeIntoContainer(sibling, before, parent), sibling = sibling.sibling;
        }
      }
    }
    function insertOrAppendPlacementNode(node2, before, parent) {
      var tag = node2.tag, isHost = tag === HostComponent || tag === HostText;
      if (isHost) {
        var stateNode = node2.stateNode;
        before ? insertBefore(parent, stateNode, before) : appendChild(parent, stateNode);
      } else if (tag !== HostPortal) {
        var child = node2.child;
        if (child !== null) {
          insertOrAppendPlacementNode(child, before, parent);
          for (var sibling = child.sibling; sibling !== null; )
            insertOrAppendPlacementNode(sibling, before, parent), sibling = sibling.sibling;
        }
      }
    }
    var hostParent = null, hostParentIsContainer = !1;
    function commitDeletionEffects(root2, returnFiber, deletedFiber) {
      {
        var parent = returnFiber;
        findParent: for (; parent !== null; ) {
          switch (parent.tag) {
            case HostComponent: {
              hostParent = parent.stateNode, hostParentIsContainer = !1;
              break findParent;
            }
            case HostRoot: {
              hostParent = parent.stateNode.containerInfo, hostParentIsContainer = !0;
              break findParent;
            }
            case HostPortal: {
              hostParent = parent.stateNode.containerInfo, hostParentIsContainer = !0;
              break findParent;
            }
          }
          parent = parent.return;
        }
        if (hostParent === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber), hostParent = null, hostParentIsContainer = !1;
      }
      detachFiberMutation(deletedFiber);
    }
    function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
      for (var child = parent.child; child !== null; )
        commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child), child = child.sibling;
    }
    function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
      switch (onCommitUnmount(deletedFiber), deletedFiber.tag) {
        case HostComponent:
          offscreenSubtreeWasHidden || safelyDetachRef(deletedFiber, nearestMountedAncestor);
        case HostText: {
          {
            var prevHostParent = hostParent, prevHostParentIsContainer = hostParentIsContainer;
            hostParent = null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = prevHostParent, hostParentIsContainer = prevHostParentIsContainer, hostParent !== null && (hostParentIsContainer ? removeChildFromContainer(hostParent, deletedFiber.stateNode) : removeChild(hostParent, deletedFiber.stateNode));
          }
          return;
        }
        case DehydratedFragment: {
          hostParent !== null && (hostParentIsContainer ? clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode) : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));
          return;
        }
        case HostPortal: {
          {
            var _prevHostParent = hostParent, _prevHostParentIsContainer = hostParentIsContainer;
            hostParent = deletedFiber.stateNode.containerInfo, hostParentIsContainer = !0, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), hostParent = _prevHostParent, hostParentIsContainer = _prevHostParentIsContainer;
          }
          return;
        }
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent: {
          if (!offscreenSubtreeWasHidden) {
            var updateQueue = deletedFiber.updateQueue;
            if (updateQueue !== null) {
              var lastEffect = updateQueue.lastEffect;
              if (lastEffect !== null) {
                var firstEffect = lastEffect.next, effect = firstEffect;
                do {
                  var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                  destroy !== void 0 && ((tag & Insertion) !== NoFlags$1 ? safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy) : (tag & Layout) !== NoFlags$1 && (markComponentLayoutEffectUnmountStarted(deletedFiber), deletedFiber.mode & ProfileMode ? (startLayoutEffectTimer(), safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy), recordLayoutEffectDuration(deletedFiber)) : safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy), markComponentLayoutEffectUnmountStopped())), effect = effect.next;
                } while (effect !== firstEffect);
              }
            }
          }
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          return;
        }
        case ClassComponent: {
          if (!offscreenSubtreeWasHidden) {
            safelyDetachRef(deletedFiber, nearestMountedAncestor);
            var instance = deletedFiber.stateNode;
            typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
          }
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          return;
        }
        case ScopeComponent: {
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          return;
        }
        case OffscreenComponent: {
          if (
            // TODO: Remove this dead flag
            deletedFiber.mode & ConcurrentMode
          ) {
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null, recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber), offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          } else
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          break;
        }
        default: {
          recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
          return;
        }
      }
    }
    function commitSuspenseCallback(finishedWork) {
    }
    function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
      var newState = finishedWork.memoizedState;
      if (newState === null) {
        var current2 = finishedWork.alternate;
        if (current2 !== null) {
          var prevState = current2.memoizedState;
          if (prevState !== null) {
            var suspenseInstance = prevState.dehydrated;
            suspenseInstance !== null && commitHydratedSuspenseInstance(suspenseInstance);
          }
        }
      }
    }
    function attachSuspenseRetryListeners(finishedWork) {
      var wakeables = finishedWork.updateQueue;
      if (wakeables !== null) {
        finishedWork.updateQueue = null;
        var retryCache = finishedWork.stateNode;
        retryCache === null && (retryCache = finishedWork.stateNode = new PossiblyWeakSet()), wakeables.forEach(function(wakeable) {
          var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
          if (!retryCache.has(wakeable)) {
            if (retryCache.add(wakeable), isDevToolsPresent)
              if (inProgressLanes !== null && inProgressRoot !== null)
                restorePendingUpdaters(inProgressRoot, inProgressLanes);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            wakeable.then(retry, retry);
          }
        });
      }
    }
    function commitMutationEffects(root2, finishedWork, committedLanes) {
      inProgressLanes = committedLanes, inProgressRoot = root2, setCurrentFiber(finishedWork), commitMutationEffectsOnFiber(finishedWork, root2), setCurrentFiber(finishedWork), inProgressLanes = null, inProgressRoot = null;
    }
    function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
      var deletions = parentFiber.deletions;
      if (deletions !== null)
        for (var i = 0; i < deletions.length; i++) {
          var childToDelete = deletions[i];
          try {
            commitDeletionEffects(root2, parentFiber, childToDelete);
          } catch (error2) {
            captureCommitPhaseError(childToDelete, parentFiber, error2);
          }
        }
      var prevDebugFiber = getCurrentFiber();
      if (parentFiber.subtreeFlags & MutationMask)
        for (var child = parentFiber.child; child !== null; )
          setCurrentFiber(child), commitMutationEffectsOnFiber(child, root2), child = child.sibling;
      setCurrentFiber(prevDebugFiber);
    }
    function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
      var current2 = finishedWork.alternate, flags = finishedWork.flags;
      switch (finishedWork.tag) {
        case FunctionComponent:
        case ForwardRef:
        case MemoComponent:
        case SimpleMemoComponent: {
          if (recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Update) {
            try {
              commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return), commitHookEffectListMount(Insertion | HasEffect, finishedWork);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
            if (finishedWork.mode & ProfileMode) {
              try {
                startLayoutEffectTimer(), commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              recordLayoutEffectDuration(finishedWork);
            } else
              try {
                commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
          }
          return;
        }
        case ClassComponent: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Ref && current2 !== null && safelyDetachRef(current2, current2.return);
          return;
        }
        case HostComponent: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Ref && current2 !== null && safelyDetachRef(current2, current2.return);
          {
            if (finishedWork.flags & ContentReset) {
              var instance = finishedWork.stateNode;
              try {
                resetTextContent(instance);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
            }
            if (flags & Update) {
              var _instance4 = finishedWork.stateNode;
              if (_instance4 != null) {
                var newProps = finishedWork.memoizedProps, oldProps = current2 !== null ? current2.memoizedProps : newProps, type = finishedWork.type, updatePayload = finishedWork.updateQueue;
                if (finishedWork.updateQueue = null, updatePayload !== null)
                  try {
                    commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                  } catch (error2) {
                    captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                  }
              }
            }
          }
          return;
        }
        case HostText: {
          if (recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Update) {
            if (finishedWork.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var textInstance = finishedWork.stateNode, newText = finishedWork.memoizedProps, oldText = current2 !== null ? current2.memoizedProps : newText;
            try {
              commitTextUpdate(textInstance, oldText, newText);
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
          }
          return;
        }
        case HostRoot: {
          if (recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Update && current2 !== null) {
            var prevRootState = current2.memoizedState;
            if (prevRootState.isDehydrated)
              try {
                commitHydratedContainer(root2.containerInfo);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
          }
          return;
        }
        case HostPortal: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          return;
        }
        case SuspenseComponent: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          var offscreenFiber = finishedWork.child;
          if (offscreenFiber.flags & Visibility) {
            var offscreenInstance = offscreenFiber.stateNode, newState = offscreenFiber.memoizedState, isHidden2 = newState !== null;
            if (offscreenInstance.isHidden = isHidden2, isHidden2) {
              var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
              wasHidden || markCommitTimeOfFallback();
            }
          }
          if (flags & Update) {
            try {
            } catch (error2) {
              captureCommitPhaseError(finishedWork, finishedWork.return, error2);
            }
            attachSuspenseRetryListeners(finishedWork);
          }
          return;
        }
        case OffscreenComponent: {
          var _wasHidden = current2 !== null && current2.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            finishedWork.mode & ConcurrentMode
          ) {
            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden, recursivelyTraverseMutationEffects(root2, finishedWork), offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
          } else
            recursivelyTraverseMutationEffects(root2, finishedWork);
          if (commitReconciliationEffects(finishedWork), flags & Visibility) {
            var _offscreenInstance = finishedWork.stateNode, _newState = finishedWork.memoizedState, _isHidden = _newState !== null, offscreenBoundary = finishedWork;
            if (_offscreenInstance.isHidden = _isHidden, _isHidden && !_wasHidden && (offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
              nextEffect = offscreenBoundary;
              for (var offscreenChild = offscreenBoundary.child; offscreenChild !== null; )
                nextEffect = offscreenChild, disappearLayoutEffects_begin(offscreenChild), offscreenChild = offscreenChild.sibling;
            }
            hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
          }
          return;
        }
        case SuspenseListComponent: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork), flags & Update && attachSuspenseRetryListeners(finishedWork);
          return;
        }
        case ScopeComponent:
          return;
        default: {
          recursivelyTraverseMutationEffects(root2, finishedWork), commitReconciliationEffects(finishedWork);
          return;
        }
      }
    }
    function commitReconciliationEffects(finishedWork) {
      var flags = finishedWork.flags;
      if (flags & Placement) {
        try {
          commitPlacement(finishedWork);
        } catch (error2) {
          captureCommitPhaseError(finishedWork, finishedWork.return, error2);
        }
        finishedWork.flags &= ~Placement;
      }
      flags & Hydrating && (finishedWork.flags &= ~Hydrating);
    }
    function commitLayoutEffects(finishedWork, root2, committedLanes) {
      inProgressLanes = committedLanes, inProgressRoot = root2, nextEffect = finishedWork, commitLayoutEffects_begin(finishedWork, root2, committedLanes), inProgressLanes = null, inProgressRoot = null;
    }
    function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
      for (var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode; nextEffect !== null; ) {
        var fiber = nextEffect, firstChild = fiber.child;
        if (fiber.tag === OffscreenComponent && isModernRoot) {
          var isHidden2 = fiber.memoizedState !== null, newOffscreenSubtreeIsHidden = isHidden2 || offscreenSubtreeIsHidden;
          if (newOffscreenSubtreeIsHidden) {
            commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            continue;
          } else {
            var current2 = fiber.alternate, wasHidden = current2 !== null && current2.memoizedState !== null, newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden, prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden, prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
            offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden, offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden, offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden && (nextEffect = fiber, reappearLayoutEffects_begin(fiber));
            for (var child = firstChild; child !== null; )
              nextEffect = child, commitLayoutEffects_begin(
                child,
                // New root; bubble back up to here and stop.
                root2,
                committedLanes
              ), child = child.sibling;
            nextEffect = fiber, offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden, offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden, commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
            continue;
          }
        }
        (fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
      }
    }
    function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        if ((fiber.flags & LayoutMask) !== NoFlags) {
          var current2 = fiber.alternate;
          setCurrentFiber(fiber);
          try {
            commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
        }
        if (fiber === subtreeRoot) {
          nextEffect = null;
          return;
        }
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function disappearLayoutEffects_begin(subtreeRoot) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, firstChild = fiber.child;
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (fiber.mode & ProfileMode)
              try {
                startLayoutEffectTimer(), commitHookEffectListUnmount(Layout, fiber, fiber.return);
              } finally {
                recordLayoutEffectDuration(fiber);
              }
            else
              commitHookEffectListUnmount(Layout, fiber, fiber.return);
            break;
          }
          case ClassComponent: {
            safelyDetachRef(fiber, fiber.return);
            var instance = fiber.stateNode;
            typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(fiber, fiber.return, instance);
            break;
          }
          case HostComponent: {
            safelyDetachRef(fiber, fiber.return);
            break;
          }
          case OffscreenComponent: {
            var isHidden2 = fiber.memoizedState !== null;
            if (isHidden2) {
              disappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
            break;
          }
        }
        firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : disappearLayoutEffects_complete(subtreeRoot);
      }
    }
    function disappearLayoutEffects_complete(subtreeRoot) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        if (fiber === subtreeRoot) {
          nextEffect = null;
          return;
        }
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function reappearLayoutEffects_begin(subtreeRoot) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, firstChild = fiber.child;
        if (fiber.tag === OffscreenComponent) {
          var isHidden2 = fiber.memoizedState !== null;
          if (isHidden2) {
            reappearLayoutEffects_complete(subtreeRoot);
            continue;
          }
        }
        firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : reappearLayoutEffects_complete(subtreeRoot);
      }
    }
    function reappearLayoutEffects_complete(subtreeRoot) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        setCurrentFiber(fiber);
        try {
          reappearLayoutEffectsOnFiber(fiber);
        } catch (error2) {
          captureCommitPhaseError(fiber, fiber.return, error2);
        }
        if (resetCurrentFiber(), fiber === subtreeRoot) {
          nextEffect = null;
          return;
        }
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
      nextEffect = finishedWork, commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
    }
    function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, firstChild = fiber.child;
        (fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null ? (firstChild.return = fiber, nextEffect = firstChild) : commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
      }
    }
    function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        if ((fiber.flags & Passive) !== NoFlags) {
          setCurrentFiber(fiber);
          try {
            commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
        }
        if (fiber === subtreeRoot) {
          nextEffect = null;
          return;
        }
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
      switch (finishedWork.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          if (finishedWork.mode & ProfileMode) {
            startPassiveEffectTimer();
            try {
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            } finally {
              recordPassiveEffectDuration(finishedWork);
            }
          } else
            commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
          break;
        }
      }
    }
    function commitPassiveUnmountEffects(firstChild) {
      nextEffect = firstChild, commitPassiveUnmountEffects_begin();
    }
    function commitPassiveUnmountEffects_begin() {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, child = fiber.child;
        if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
          var deletions = fiber.deletions;
          if (deletions !== null) {
            for (var i = 0; i < deletions.length; i++) {
              var fiberToDelete = deletions[i];
              nextEffect = fiberToDelete, commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
            }
            {
              var previousFiber = fiber.alternate;
              if (previousFiber !== null) {
                var detachedChild = previousFiber.child;
                if (detachedChild !== null) {
                  previousFiber.child = null;
                  do {
                    var detachedSibling = detachedChild.sibling;
                    detachedChild.sibling = null, detachedChild = detachedSibling;
                  } while (detachedChild !== null);
                }
              }
            }
            nextEffect = fiber;
          }
        }
        (fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null ? (child.return = fiber, nextEffect = child) : commitPassiveUnmountEffects_complete();
      }
    }
    function commitPassiveUnmountEffects_complete() {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        (fiber.flags & Passive) !== NoFlags && (setCurrentFiber(fiber), commitPassiveUnmountOnFiber(fiber), resetCurrentFiber());
        var sibling = fiber.sibling;
        if (sibling !== null) {
          sibling.return = fiber.return, nextEffect = sibling;
          return;
        }
        nextEffect = fiber.return;
      }
    }
    function commitPassiveUnmountOnFiber(finishedWork) {
      switch (finishedWork.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          finishedWork.mode & ProfileMode ? (startPassiveEffectTimer(), commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return), recordPassiveEffectDuration(finishedWork)) : commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
          break;
        }
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect;
        setCurrentFiber(fiber), commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor), resetCurrentFiber();
        var child = fiber.child;
        child !== null ? (child.return = fiber, nextEffect = child) : commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
      }
    }
    function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
      for (; nextEffect !== null; ) {
        var fiber = nextEffect, sibling = fiber.sibling, returnFiber = fiber.return;
        if (detachFiberAfterEffects(fiber), fiber === deletedSubtreeRoot) {
          nextEffect = null;
          return;
        }
        if (sibling !== null) {
          sibling.return = returnFiber, nextEffect = sibling;
          return;
        }
        nextEffect = returnFiber;
      }
    }
    function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
      switch (current2.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          current2.mode & ProfileMode ? (startPassiveEffectTimer(), commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor), recordPassiveEffectDuration(current2)) : commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
          break;
        }
      }
    }
    function invokeLayoutEffectMountInDEV(fiber) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          try {
            commitHookEffectListMount(Layout | HasEffect, fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          break;
        }
        case ClassComponent: {
          var instance = fiber.stateNode;
          try {
            instance.componentDidMount();
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          break;
        }
      }
    }
    function invokePassiveEffectMountInDEV(fiber) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          try {
            commitHookEffectListMount(Passive$1 | HasEffect, fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          break;
        }
      }
    }
    function invokeLayoutEffectUnmountInDEV(fiber) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent: {
          try {
            commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          break;
        }
        case ClassComponent: {
          var instance = fiber.stateNode;
          typeof instance.componentWillUnmount == "function" && safelyCallComponentWillUnmount(fiber, fiber.return, instance);
          break;
        }
      }
    }
    function invokePassiveEffectUnmountInDEV(fiber) {
      switch (fiber.tag) {
        case FunctionComponent:
        case ForwardRef:
        case SimpleMemoComponent:
          try {
            commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var symbolFor = Symbol.for;
      symbolFor("selector.component"), symbolFor("selector.has_pseudo_class"), symbolFor("selector.role"), symbolFor("selector.test_id"), symbolFor("selector.text");
    }
    var commitHooks = [];
    function onCommitRoot$1() {
      commitHooks.forEach(function(commitHook) {
        return commitHook();
      });
    }
    var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
    function isLegacyActEnvironment(fiber) {
      {
        var isReactActEnvironmentGlobal = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), jestIsDefined = typeof jest < "u";
        return jestIsDefined && isReactActEnvironmentGlobal !== !1;
      }
    }
    function isConcurrentActEnvironment() {
      {
        var isReactActEnvironmentGlobal = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null && error("The current testing environment is not configured to support act(...)"), isReactActEnvironmentGlobal;
      }
    }
    var ceil = Math.ceil, ReactCurrentDispatcher$2 = ReactSharedInternals.ReactCurrentDispatcher, ReactCurrentOwner$2 = ReactSharedInternals.ReactCurrentOwner, ReactCurrentBatchConfig$3 = ReactSharedInternals.ReactCurrentBatchConfig, ReactCurrentActQueue$1 = ReactSharedInternals.ReactCurrentActQueue, NoContext = (
      /*             */
      0
    ), BatchedContext = (
      /*               */
      1
    ), RenderContext = (
      /*                */
      2
    ), CommitContext = (
      /*                */
      4
    ), RootInProgress = 0, RootFatalErrored = 1, RootErrored = 2, RootSuspended = 3, RootSuspendedWithDelay = 4, RootCompleted = 5, RootDidNotComplete = 6, executionContext = NoContext, workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes, subtreeRenderLanes = NoLanes, subtreeRenderLanesCursor = createCursor(NoLanes), workInProgressRootExitStatus = RootInProgress, workInProgressRootFatalError = null, workInProgressRootSkippedLanes = NoLanes, workInProgressRootInterleavedUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, globalMostRecentFallbackTime = 0, FALLBACK_THROTTLE_MS = 500, workInProgressRootRenderTargetTime = 1 / 0, RENDER_TIMEOUT_MS = 500, workInProgressTransitions = null;
    function resetRenderTimer() {
      workInProgressRootRenderTargetTime = now2() + RENDER_TIMEOUT_MS;
    }
    function getRenderTargetTime() {
      return workInProgressRootRenderTargetTime;
    }
    var hasUncaughtError = !1, firstUncaughtError = null, legacyErrorBoundariesThatAlreadyFailed = null, rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = NoLanes, pendingPassiveProfilerEffects = [], pendingPassiveTransitions = null, NESTED_UPDATE_LIMIT = 50, nestedUpdateCount = 0, rootWithNestedUpdates = null, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, NESTED_PASSIVE_UPDATE_LIMIT = 50, nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, currentEventTime = NoTimestamp, currentEventTransitionLane = NoLanes, isRunningInsertionEffect = !1;
    function getWorkInProgressRoot() {
      return workInProgressRoot;
    }
    function requestEventTime() {
      return (executionContext & (RenderContext | CommitContext)) !== NoContext ? now2() : (currentEventTime !== NoTimestamp || (currentEventTime = now2()), currentEventTime);
    }
    function requestUpdateLane(fiber) {
      var mode = fiber.mode;
      if ((mode & ConcurrentMode) === NoMode)
        return SyncLane;
      if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes)
        return pickArbitraryLane(workInProgressRootRenderLanes);
      var isTransition = requestCurrentTransition() !== NoTransition;
      if (isTransition) {
        if (ReactCurrentBatchConfig$3.transition !== null) {
          var transition = ReactCurrentBatchConfig$3.transition;
          transition._updatedFibers || (transition._updatedFibers = /* @__PURE__ */ new Set()), transition._updatedFibers.add(fiber);
        }
        return currentEventTransitionLane === NoLane && (currentEventTransitionLane = claimNextTransitionLane()), currentEventTransitionLane;
      }
      var updateLane = getCurrentUpdatePriority();
      if (updateLane !== NoLane)
        return updateLane;
      var eventLane = getCurrentEventPriority();
      return eventLane;
    }
    function requestRetryLane(fiber) {
      var mode = fiber.mode;
      return (mode & ConcurrentMode) === NoMode ? SyncLane : claimNextRetryLane();
    }
    function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
      checkForNestedUpdates(), isRunningInsertionEffect && error("useInsertionEffect must not schedule updates."), isFlushingPassiveEffects && (didScheduleUpdateDuringPassiveEffects = !0), markRootUpdated(root2, lane, eventTime), (executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot ? warnAboutRenderPhaseUpdatesInDEV(fiber) : (isDevToolsPresent && addFiberToLanesMap(root2, fiber, lane), warnIfUpdatesNotWrappedWithActDEV(fiber), root2 === workInProgressRoot && ((executionContext & RenderContext) === NoContext && (workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane)), workInProgressRootExitStatus === RootSuspendedWithDelay && markRootSuspended$1(root2, workInProgressRootRenderLanes)), ensureRootIsScheduled(root2, eventTime), lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !ReactCurrentActQueue$1.isBatchingLegacy && (resetRenderTimer(), flushSyncCallbacksOnlyInLegacyMode()));
    }
    function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
      var current2 = root2.current;
      current2.lanes = lane, markRootUpdated(root2, lane, eventTime), ensureRootIsScheduled(root2, eventTime);
    }
    function isUnsafeClassRenderPhaseUpdate(fiber) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (executionContext & RenderContext) !== NoContext
      );
    }
    function ensureRootIsScheduled(root2, currentTime) {
      var existingCallbackNode = root2.callbackNode;
      markStarvedLanesAsExpired(root2, currentTime);
      var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
      if (nextLanes === NoLanes) {
        existingCallbackNode !== null && cancelCallback$1(existingCallbackNode), root2.callbackNode = null, root2.callbackPriority = NoLane;
        return;
      }
      var newCallbackPriority = getHighestPriorityLane(nextLanes), existingCallbackPriority = root2.callbackPriority;
      if (existingCallbackPriority === newCallbackPriority && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
        existingCallbackNode == null && existingCallbackPriority !== SyncLane && error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      existingCallbackNode != null && cancelCallback$1(existingCallbackNode);
      var newCallbackNode;
      if (newCallbackPriority === SyncLane)
        root2.tag === LegacyRoot ? (ReactCurrentActQueue$1.isBatchingLegacy !== null && (ReactCurrentActQueue$1.didScheduleLegacyUpdate = !0), scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2))) : scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2)), ReactCurrentActQueue$1.current !== null ? ReactCurrentActQueue$1.current.push(flushSyncCallbacks) : scheduleMicrotask(function() {
          (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncCallbacks();
        }), newCallbackNode = null;
      else {
        var schedulerPriorityLevel;
        switch (lanesToEventPriority(nextLanes)) {
          case DiscreteEventPriority:
            schedulerPriorityLevel = ImmediatePriority;
            break;
          case ContinuousEventPriority:
            schedulerPriorityLevel = UserBlockingPriority;
            break;
          case DefaultEventPriority:
            schedulerPriorityLevel = NormalPriority;
            break;
          case IdleEventPriority:
            schedulerPriorityLevel = IdlePriority;
            break;
          default:
            schedulerPriorityLevel = NormalPriority;
            break;
        }
        newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
      }
      root2.callbackPriority = newCallbackPriority, root2.callbackNode = newCallbackNode;
    }
    function performConcurrentWorkOnRoot(root2, didTimeout) {
      if (resetNestedUpdateFlag(), currentEventTime = NoTimestamp, currentEventTransitionLane = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Should not already be working.");
      var originalCallbackNode = root2.callbackNode, didFlushPassiveEffects = flushPassiveEffects();
      if (didFlushPassiveEffects && root2.callbackNode !== originalCallbackNode)
        return null;
      var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
      if (lanes === NoLanes)
        return null;
      var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout, exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
      if (exitStatus !== RootInProgress) {
        if (exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
          errorRetryLanes !== NoLanes && (lanes = errorRetryLanes, exitStatus = recoverFromConcurrentError(root2, errorRetryLanes));
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          throw prepareFreshStack(root2, NoLanes), markRootSuspended$1(root2, lanes), ensureRootIsScheduled(root2, now2()), fatalError;
        }
        if (exitStatus === RootDidNotComplete)
          markRootSuspended$1(root2, lanes);
        else {
          var renderWasConcurrent = !includesBlockingLane(root2, lanes), finishedWork = root2.current.alternate;
          if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
            if (exitStatus = renderRootSync(root2, lanes), exitStatus === RootErrored) {
              var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
              _errorRetryLanes !== NoLanes && (lanes = _errorRetryLanes, exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes));
            }
            if (exitStatus === RootFatalErrored) {
              var _fatalError = workInProgressRootFatalError;
              throw prepareFreshStack(root2, NoLanes), markRootSuspended$1(root2, lanes), ensureRootIsScheduled(root2, now2()), _fatalError;
            }
          }
          root2.finishedWork = finishedWork, root2.finishedLanes = lanes, finishConcurrentRender(root2, exitStatus, lanes);
        }
      }
      return ensureRootIsScheduled(root2, now2()), root2.callbackNode === originalCallbackNode ? performConcurrentWorkOnRoot.bind(null, root2) : null;
    }
    function recoverFromConcurrentError(root2, errorRetryLanes) {
      var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
      if (isRootDehydrated(root2)) {
        var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
        rootWorkInProgress.flags |= ForceClientRender, errorHydratingContainer(root2.containerInfo);
      }
      var exitStatus = renderRootSync(root2, errorRetryLanes);
      if (exitStatus !== RootErrored) {
        var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
        workInProgressRootRecoverableErrors = errorsFromFirstAttempt, errorsFromSecondAttempt !== null && queueRecoverableErrors(errorsFromSecondAttempt);
      }
      return exitStatus;
    }
    function queueRecoverableErrors(errors) {
      workInProgressRootRecoverableErrors === null ? workInProgressRootRecoverableErrors = errors : workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
    }
    function finishConcurrentRender(root2, exitStatus, lanes) {
      switch (exitStatus) {
        case RootInProgress:
        case RootFatalErrored:
          throw new Error("Root did not complete. This is a bug in React.");
        case RootErrored: {
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          break;
        }
        case RootSuspended: {
          if (markRootSuspended$1(root2, lanes), includesOnlyRetries(lanes) && // do not delay if we're inside an act() scope
          !shouldForceFlushFallbacksInDEV()) {
            var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now2();
            if (msUntilTimeout > 10) {
              var nextLanes = getNextLanes(root2, NoLanes);
              if (nextLanes !== NoLanes)
                break;
              var suspendedLanes = root2.suspendedLanes;
              if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                requestEventTime(), markRootPinged(root2, suspendedLanes);
                break;
              }
              root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
              break;
            }
          }
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          break;
        }
        case RootSuspendedWithDelay: {
          if (markRootSuspended$1(root2, lanes), includesOnlyTransitions(lanes))
            break;
          if (!shouldForceFlushFallbacksInDEV()) {
            var mostRecentEventTime = getMostRecentEventTime(root2, lanes), eventTimeMs = mostRecentEventTime, timeElapsedMs = now2() - eventTimeMs, _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
            if (_msUntilTimeout > 10) {
              root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
              break;
            }
          }
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          break;
        }
        case RootCompleted: {
          commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function isRenderConsistentWithExternalStores(finishedWork) {
      for (var node2 = finishedWork; ; ) {
        if (node2.flags & StoreConsistency) {
          var updateQueue = node2.updateQueue;
          if (updateQueue !== null) {
            var checks2 = updateQueue.stores;
            if (checks2 !== null)
              for (var i = 0; i < checks2.length; i++) {
                var check2 = checks2[i], getSnapshot = check2.getSnapshot, renderedValue = check2.value;
                try {
                  if (!objectIs(getSnapshot(), renderedValue))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var child = node2.child;
        if (node2.subtreeFlags & StoreConsistency && child !== null) {
          child.return = node2, node2 = child;
          continue;
        }
        if (node2 === finishedWork)
          return !0;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === finishedWork)
            return !0;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return, node2 = node2.sibling;
      }
      return !0;
    }
    function markRootSuspended$1(root2, suspendedLanes) {
      suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes), suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes), markRootSuspended(root2, suspendedLanes);
    }
    function performSyncWorkOnRoot(root2) {
      if (syncNestedUpdateFlag(), (executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Should not already be working.");
      flushPassiveEffects();
      var lanes = getNextLanes(root2, NoLanes);
      if (!includesSomeLane(lanes, SyncLane))
        return ensureRootIsScheduled(root2, now2()), null;
      var exitStatus = renderRootSync(root2, lanes);
      if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
        var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
        errorRetryLanes !== NoLanes && (lanes = errorRetryLanes, exitStatus = recoverFromConcurrentError(root2, errorRetryLanes));
      }
      if (exitStatus === RootFatalErrored) {
        var fatalError = workInProgressRootFatalError;
        throw prepareFreshStack(root2, NoLanes), markRootSuspended$1(root2, lanes), ensureRootIsScheduled(root2, now2()), fatalError;
      }
      if (exitStatus === RootDidNotComplete)
        throw new Error("Root did not complete. This is a bug in React.");
      var finishedWork = root2.current.alternate;
      return root2.finishedWork = finishedWork, root2.finishedLanes = lanes, commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions), ensureRootIsScheduled(root2, now2()), null;
    }
    function flushRoot(root2, lanes) {
      lanes !== NoLanes && (markRootEntangled(root2, mergeLanes(lanes, SyncLane)), ensureRootIsScheduled(root2, now2()), (executionContext & (RenderContext | CommitContext)) === NoContext && (resetRenderTimer(), flushSyncCallbacks()));
    }
    function batchedUpdates$1(fn, a) {
      var prevExecutionContext = executionContext;
      executionContext |= BatchedContext;
      try {
        return fn(a);
      } finally {
        executionContext = prevExecutionContext, executionContext === NoContext && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !ReactCurrentActQueue$1.isBatchingLegacy && (resetRenderTimer(), flushSyncCallbacksOnlyInLegacyMode());
      }
    }
    function discreteUpdates(fn, a, b, c, d) {
      var previousPriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig$3.transition;
      try {
        return ReactCurrentBatchConfig$3.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), fn(a, b, c, d);
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$3.transition = prevTransition, executionContext === NoContext && resetRenderTimer();
      }
    }
    function flushSync(fn) {
      rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext && flushPassiveEffects();
      var prevExecutionContext = executionContext;
      executionContext |= BatchedContext;
      var prevTransition = ReactCurrentBatchConfig$3.transition, previousPriority = getCurrentUpdatePriority();
      try {
        return ReactCurrentBatchConfig$3.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), fn ? fn() : void 0;
      } finally {
        setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$3.transition = prevTransition, executionContext = prevExecutionContext, (executionContext & (RenderContext | CommitContext)) === NoContext && flushSyncCallbacks();
      }
    }
    function isAlreadyRendering() {
      return (executionContext & (RenderContext | CommitContext)) !== NoContext;
    }
    function pushRenderLanes(fiber, lanes) {
      push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber), subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
    }
    function popRenderLanes(fiber) {
      subtreeRenderLanes = subtreeRenderLanesCursor.current, pop(subtreeRenderLanesCursor, fiber);
    }
    function prepareFreshStack(root2, lanes) {
      root2.finishedWork = null, root2.finishedLanes = NoLanes;
      var timeoutHandle = root2.timeoutHandle;
      if (timeoutHandle !== noTimeout && (root2.timeoutHandle = noTimeout, cancelTimeout(timeoutHandle)), workInProgress !== null)
        for (var interruptedWork = workInProgress.return; interruptedWork !== null; ) {
          var current2 = interruptedWork.alternate;
          unwindInterruptedWork(current2, interruptedWork), interruptedWork = interruptedWork.return;
        }
      workInProgressRoot = root2;
      var rootWorkInProgress = createWorkInProgress(root2.current, null);
      return workInProgress = rootWorkInProgress, workInProgressRootRenderLanes = subtreeRenderLanes = lanes, workInProgressRootExitStatus = RootInProgress, workInProgressRootFatalError = null, workInProgressRootSkippedLanes = NoLanes, workInProgressRootInterleavedUpdatedLanes = NoLanes, workInProgressRootPingedLanes = NoLanes, workInProgressRootConcurrentErrors = null, workInProgressRootRecoverableErrors = null, finishQueueingConcurrentUpdates(), ReactStrictModeWarnings.discardPendingWarnings(), rootWorkInProgress;
    }
    function handleError(root2, thrownValue) {
      do {
        var erroredWork = workInProgress;
        try {
          if (resetContextDependencies(), resetHooksAfterThrow(), resetCurrentFiber(), ReactCurrentOwner$2.current = null, erroredWork === null || erroredWork.return === null) {
            workInProgressRootExitStatus = RootFatalErrored, workInProgressRootFatalError = thrownValue, workInProgress = null;
            return;
          }
          if (enableProfilerTimer && erroredWork.mode & ProfileMode && stopProfilerTimerIfRunningAndRecordDelta(erroredWork, !0), enableSchedulingProfiler)
            if (markComponentRenderStopped(), thrownValue !== null && typeof thrownValue == "object" && typeof thrownValue.then == "function") {
              var wakeable = thrownValue;
              markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
            } else
              markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
          throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes), completeUnitOfWork(erroredWork);
        } catch (yetAnotherThrownValue) {
          thrownValue = yetAnotherThrownValue, workInProgress === erroredWork && erroredWork !== null ? (erroredWork = erroredWork.return, workInProgress = erroredWork) : erroredWork = workInProgress;
          continue;
        }
        return;
      } while (!0);
    }
    function pushDispatcher() {
      var prevDispatcher = ReactCurrentDispatcher$2.current;
      return ReactCurrentDispatcher$2.current = ContextOnlyDispatcher, prevDispatcher === null ? ContextOnlyDispatcher : prevDispatcher;
    }
    function popDispatcher(prevDispatcher) {
      ReactCurrentDispatcher$2.current = prevDispatcher;
    }
    function markCommitTimeOfFallback() {
      globalMostRecentFallbackTime = now2();
    }
    function markSkippedUpdateLanes(lane) {
      workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
    }
    function renderDidSuspend() {
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootSuspended);
    }
    function renderDidSuspendDelayIfPossible() {
      (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) && (workInProgressRootExitStatus = RootSuspendedWithDelay), workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
    }
    function renderDidError(error2) {
      workInProgressRootExitStatus !== RootSuspendedWithDelay && (workInProgressRootExitStatus = RootErrored), workInProgressRootConcurrentErrors === null ? workInProgressRootConcurrentErrors = [error2] : workInProgressRootConcurrentErrors.push(error2);
    }
    function renderHasNotSuspendedYet() {
      return workInProgressRootExitStatus === RootInProgress;
    }
    function renderRootSync(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          memoizedUpdaters.size > 0 && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear()), movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = getTransitionsForLanes(), prepareFreshStack(root2, lanes);
      }
      markRenderStarted(lanes);
      do
        try {
          workLoopSync();
          break;
        } catch (thrownValue) {
          handleError(root2, thrownValue);
        }
      while (!0);
      if (resetContextDependencies(), executionContext = prevExecutionContext, popDispatcher(prevDispatcher), workInProgress !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return markRenderStopped(), workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus;
    }
    function workLoopSync() {
      for (; workInProgress !== null; )
        performUnitOfWork(workInProgress);
    }
    function renderRootConcurrent(root2, lanes) {
      var prevExecutionContext = executionContext;
      executionContext |= RenderContext;
      var prevDispatcher = pushDispatcher();
      if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
        if (isDevToolsPresent) {
          var memoizedUpdaters = root2.memoizedUpdaters;
          memoizedUpdaters.size > 0 && (restorePendingUpdaters(root2, workInProgressRootRenderLanes), memoizedUpdaters.clear()), movePendingFibersToMemoized(root2, lanes);
        }
        workInProgressTransitions = getTransitionsForLanes(), resetRenderTimer(), prepareFreshStack(root2, lanes);
      }
      markRenderStarted(lanes);
      do
        try {
          workLoopConcurrent();
          break;
        } catch (thrownValue) {
          handleError(root2, thrownValue);
        }
      while (!0);
      return resetContextDependencies(), popDispatcher(prevDispatcher), executionContext = prevExecutionContext, workInProgress !== null ? (markRenderYielded(), RootInProgress) : (markRenderStopped(), workInProgressRoot = null, workInProgressRootRenderLanes = NoLanes, workInProgressRootExitStatus);
    }
    function workLoopConcurrent() {
      for (; workInProgress !== null && !shouldYield(); )
        performUnitOfWork(workInProgress);
    }
    function performUnitOfWork(unitOfWork) {
      var current2 = unitOfWork.alternate;
      setCurrentFiber(unitOfWork);
      var next2;
      (unitOfWork.mode & ProfileMode) !== NoMode ? (startProfilerTimer(unitOfWork), next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, !0)) : next2 = beginWork$1(current2, unitOfWork, subtreeRenderLanes), resetCurrentFiber(), unitOfWork.memoizedProps = unitOfWork.pendingProps, next2 === null ? completeUnitOfWork(unitOfWork) : workInProgress = next2, ReactCurrentOwner$2.current = null;
    }
    function completeUnitOfWork(unitOfWork) {
      var completedWork = unitOfWork;
      do {
        var current2 = completedWork.alternate, returnFiber = completedWork.return;
        if ((completedWork.flags & Incomplete) === NoFlags) {
          setCurrentFiber(completedWork);
          var next2 = void 0;
          if ((completedWork.mode & ProfileMode) === NoMode ? next2 = completeWork(current2, completedWork, subtreeRenderLanes) : (startProfilerTimer(completedWork), next2 = completeWork(current2, completedWork, subtreeRenderLanes), stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1)), resetCurrentFiber(), next2 !== null) {
            workInProgress = next2;
            return;
          }
        } else {
          var _next = unwindWork(current2, completedWork);
          if (_next !== null) {
            _next.flags &= HostEffectMask, workInProgress = _next;
            return;
          }
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            stopProfilerTimerIfRunningAndRecordDelta(completedWork, !1);
            for (var actualDuration = completedWork.actualDuration, child = completedWork.child; child !== null; )
              actualDuration += child.actualDuration, child = child.sibling;
            completedWork.actualDuration = actualDuration;
          }
          if (returnFiber !== null)
            returnFiber.flags |= Incomplete, returnFiber.subtreeFlags = NoFlags, returnFiber.deletions = null;
          else {
            workInProgressRootExitStatus = RootDidNotComplete, workInProgress = null;
            return;
          }
        }
        var siblingFiber = completedWork.sibling;
        if (siblingFiber !== null) {
          workInProgress = siblingFiber;
          return;
        }
        completedWork = returnFiber, workInProgress = completedWork;
      } while (completedWork !== null);
      workInProgressRootExitStatus === RootInProgress && (workInProgressRootExitStatus = RootCompleted);
    }
    function commitRoot(root2, recoverableErrors, transitions) {
      var previousUpdateLanePriority = getCurrentUpdatePriority(), prevTransition = ReactCurrentBatchConfig$3.transition;
      try {
        ReactCurrentBatchConfig$3.transition = null, setCurrentUpdatePriority(DiscreteEventPriority), commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
      } finally {
        ReactCurrentBatchConfig$3.transition = prevTransition, setCurrentUpdatePriority(previousUpdateLanePriority);
      }
      return null;
    }
    function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
      do
        flushPassiveEffects();
      while (rootWithPendingPassiveEffects !== null);
      if (flushRenderPhaseStrictModeWarningsInDEV(), (executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Should not already be working.");
      var finishedWork = root2.finishedWork, lanes = root2.finishedLanes;
      if (markCommitStarted(lanes), finishedWork === null)
        return markCommitStopped(), null;
      if (lanes === NoLanes && error("root.finishedLanes should not be empty during a commit. This is a bug in React."), root2.finishedWork = null, root2.finishedLanes = NoLanes, finishedWork === root2.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      root2.callbackNode = null, root2.callbackPriority = NoLane;
      var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
      markRootFinished(root2, remainingLanes), root2 === workInProgressRoot && (workInProgressRoot = null, workInProgress = null, workInProgressRootRenderLanes = NoLanes), ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) && (rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, pendingPassiveTransitions = transitions, scheduleCallback$1(NormalPriority, function() {
        return flushPassiveEffects(), null;
      })));
      var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags, rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
      if (subtreeHasEffects || rootHasEffect) {
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        ReactCurrentBatchConfig$3.transition = null;
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(DiscreteEventPriority);
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext, ReactCurrentOwner$2.current = null, commitBeforeMutationEffects(root2, finishedWork), recordCommitTime(), commitMutationEffects(root2, finishedWork, lanes), resetAfterCommit(), root2.current = finishedWork, markLayoutEffectsStarted(lanes), commitLayoutEffects(finishedWork, root2, lanes), markLayoutEffectsStopped(), requestPaint(), executionContext = prevExecutionContext, setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$3.transition = prevTransition;
      } else
        root2.current = finishedWork, recordCommitTime();
      var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
      if (rootDoesHavePassiveEffects ? (rootDoesHavePassiveEffects = !1, rootWithPendingPassiveEffects = root2, pendingPassiveEffectsLanes = lanes) : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null), remainingLanes = root2.pendingLanes, remainingLanes === NoLanes && (legacyErrorBoundariesThatAlreadyFailed = null), rootDidHavePassiveEffects || commitDoubleInvokeEffectsInDEV(root2.current, !1), onCommitRoot(finishedWork.stateNode, renderPriorityLevel), isDevToolsPresent && root2.memoizedUpdaters.clear(), onCommitRoot$1(), ensureRootIsScheduled(root2, now2()), recoverableErrors !== null)
        for (var onRecoverableError = root2.onRecoverableError, i = 0; i < recoverableErrors.length; i++) {
          var recoverableError = recoverableErrors[i], componentStack = recoverableError.stack, digest = recoverableError.digest;
          onRecoverableError(recoverableError.value, {
            componentStack,
            digest
          });
        }
      if (hasUncaughtError) {
        hasUncaughtError = !1;
        var error$1 = firstUncaughtError;
        throw firstUncaughtError = null, error$1;
      }
      return includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot && flushPassiveEffects(), remainingLanes = root2.pendingLanes, includesSomeLane(remainingLanes, SyncLane) ? (markNestedUpdateScheduled(), root2 === rootWithNestedUpdates ? nestedUpdateCount++ : (nestedUpdateCount = 0, rootWithNestedUpdates = root2)) : nestedUpdateCount = 0, flushSyncCallbacks(), markCommitStopped(), null;
    }
    function flushPassiveEffects() {
      if (rootWithPendingPassiveEffects !== null) {
        var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes), priority = lowerEventPriority(DefaultEventPriority, renderPriority), prevTransition = ReactCurrentBatchConfig$3.transition, previousPriority = getCurrentUpdatePriority();
        try {
          return ReactCurrentBatchConfig$3.transition = null, setCurrentUpdatePriority(priority), flushPassiveEffectsImpl();
        } finally {
          setCurrentUpdatePriority(previousPriority), ReactCurrentBatchConfig$3.transition = prevTransition;
        }
      }
      return !1;
    }
    function enqueuePendingPassiveProfilerEffect(fiber) {
      pendingPassiveProfilerEffects.push(fiber), rootDoesHavePassiveEffects || (rootDoesHavePassiveEffects = !0, scheduleCallback$1(NormalPriority, function() {
        return flushPassiveEffects(), null;
      }));
    }
    function flushPassiveEffectsImpl() {
      if (rootWithPendingPassiveEffects === null)
        return !1;
      var transitions = pendingPassiveTransitions;
      pendingPassiveTransitions = null;
      var root2 = rootWithPendingPassiveEffects, lanes = pendingPassiveEffectsLanes;
      if (rootWithPendingPassiveEffects = null, pendingPassiveEffectsLanes = NoLanes, (executionContext & (RenderContext | CommitContext)) !== NoContext)
        throw new Error("Cannot flush passive effects while already rendering.");
      isFlushingPassiveEffects = !0, didScheduleUpdateDuringPassiveEffects = !1, markPassiveEffectsStarted(lanes);
      var prevExecutionContext = executionContext;
      executionContext |= CommitContext, commitPassiveUnmountEffects(root2.current), commitPassiveMountEffects(root2, root2.current, lanes, transitions);
      {
        var profilerEffects = pendingPassiveProfilerEffects;
        pendingPassiveProfilerEffects = [];
        for (var i = 0; i < profilerEffects.length; i++) {
          var _fiber = profilerEffects[i];
          commitPassiveEffectDurations(root2, _fiber);
        }
      }
      markPassiveEffectsStopped(), commitDoubleInvokeEffectsInDEV(root2.current, !0), executionContext = prevExecutionContext, flushSyncCallbacks(), didScheduleUpdateDuringPassiveEffects ? root2 === rootWithPassiveNestedUpdates ? nestedPassiveUpdateCount++ : (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = root2) : nestedPassiveUpdateCount = 0, isFlushingPassiveEffects = !1, didScheduleUpdateDuringPassiveEffects = !1, onPostCommitRoot(root2);
      {
        var stateNode = root2.current.stateNode;
        stateNode.effectDuration = 0, stateNode.passiveEffectDuration = 0;
      }
      return !0;
    }
    function isAlreadyFailedLegacyErrorBoundary(instance) {
      return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
    }
    function markLegacyErrorBoundaryAsFailed(instance) {
      legacyErrorBoundariesThatAlreadyFailed === null ? legacyErrorBoundariesThatAlreadyFailed = /* @__PURE__ */ new Set([instance]) : legacyErrorBoundariesThatAlreadyFailed.add(instance);
    }
    function prepareToThrowUncaughtError(error2) {
      hasUncaughtError || (hasUncaughtError = !0, firstUncaughtError = error2);
    }
    var onUncaughtError = prepareToThrowUncaughtError;
    function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
      var errorInfo = createCapturedValueAtFiber(error2, sourceFiber), update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane), root2 = enqueueUpdate(rootFiber, update, SyncLane), eventTime = requestEventTime();
      root2 !== null && (markRootUpdated(root2, SyncLane, eventTime), ensureRootIsScheduled(root2, eventTime));
    }
    function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
      if (reportUncaughtErrorInDEV(error$1), setIsRunningInsertionEffect(!1), sourceFiber.tag === HostRoot) {
        captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
        return;
      }
      var fiber = null;
      for (fiber = nearestMountedAncestor; fiber !== null; ) {
        if (fiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
          return;
        } else if (fiber.tag === ClassComponent) {
          var ctor = fiber.type, instance = fiber.stateNode;
          if (typeof ctor.getDerivedStateFromError == "function" || typeof instance.componentDidCatch == "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
            var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber), update = createClassErrorUpdate(fiber, errorInfo, SyncLane), root2 = enqueueUpdate(fiber, update, SyncLane), eventTime = requestEventTime();
            root2 !== null && (markRootUpdated(root2, SyncLane, eventTime), ensureRootIsScheduled(root2, eventTime));
            return;
          }
        }
        fiber = fiber.return;
      }
      error(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, error$1);
    }
    function pingSuspendedRoot(root2, wakeable, pingedLanes) {
      var pingCache = root2.pingCache;
      pingCache !== null && pingCache.delete(wakeable);
      var eventTime = requestEventTime();
      markRootPinged(root2, pingedLanes), warnIfSuspenseResolutionNotWrappedWithActDEV(root2), workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes) && (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now2() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS ? prepareFreshStack(root2, NoLanes) : workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes)), ensureRootIsScheduled(root2, eventTime);
    }
    function retryTimedOutBoundary(boundaryFiber, retryLane) {
      retryLane === NoLane && (retryLane = requestRetryLane(boundaryFiber));
      var eventTime = requestEventTime(), root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
      root2 !== null && (markRootUpdated(root2, retryLane, eventTime), ensureRootIsScheduled(root2, eventTime));
    }
    function retryDehydratedSuspenseBoundary(boundaryFiber) {
      var suspenseState = boundaryFiber.memoizedState, retryLane = NoLane;
      suspenseState !== null && (retryLane = suspenseState.retryLane), retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function resolveRetryWakeable(boundaryFiber, wakeable) {
      var retryLane = NoLane, retryCache;
      switch (boundaryFiber.tag) {
        case SuspenseComponent:
          retryCache = boundaryFiber.stateNode;
          var suspenseState = boundaryFiber.memoizedState;
          suspenseState !== null && (retryLane = suspenseState.retryLane);
          break;
        case SuspenseListComponent:
          retryCache = boundaryFiber.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      retryCache !== null && retryCache.delete(wakeable), retryTimedOutBoundary(boundaryFiber, retryLane);
    }
    function jnd(timeElapsed) {
      return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3e3 ? 3e3 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
    }
    function checkForNestedUpdates() {
      if (nestedUpdateCount > NESTED_UPDATE_LIMIT)
        throw nestedUpdateCount = 0, rootWithNestedUpdates = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT && (nestedPassiveUpdateCount = 0, rootWithPassiveNestedUpdates = null, error("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function flushRenderPhaseStrictModeWarningsInDEV() {
      ReactStrictModeWarnings.flushLegacyContextWarning(), ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
    }
    function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
      setCurrentFiber(fiber), invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV), hasPassiveEffects && invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV), invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV), hasPassiveEffects && invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV), resetCurrentFiber();
    }
    function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
      for (var current2 = firstChild, subtreeRoot = null; current2 !== null; ) {
        var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
        current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags ? current2 = current2.child : ((current2.flags & fiberFlags) !== NoFlags && invokeEffectFn(current2), current2.sibling !== null ? current2 = current2.sibling : current2 = subtreeRoot = current2.return);
      }
    }
    var didWarnStateUpdateForNotYetMountedComponent = null;
    function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
      {
        if ((executionContext & RenderContext) !== NoContext || !(fiber.mode & ConcurrentMode))
          return;
        var tag = fiber.tag;
        if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent)
          return;
        var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
        if (didWarnStateUpdateForNotYetMountedComponent !== null) {
          if (didWarnStateUpdateForNotYetMountedComponent.has(componentName))
            return;
          didWarnStateUpdateForNotYetMountedComponent.add(componentName);
        } else
          didWarnStateUpdateForNotYetMountedComponent = /* @__PURE__ */ new Set([componentName]);
        var previousFiber = current;
        try {
          setCurrentFiber(fiber), error("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
        }
      }
    }
    var beginWork$1;
    {
      var dummyFiber = null;
      beginWork$1 = function(current2, unitOfWork, lanes) {
        var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
        try {
          return beginWork(current2, unitOfWork, lanes);
        } catch (originalError) {
          if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError == "object" && typeof originalError.then == "function")
            throw originalError;
          if (resetContextDependencies(), resetHooksAfterThrow(), unwindInterruptedWork(current2, unitOfWork), assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy), unitOfWork.mode & ProfileMode && startProfilerTimer(unitOfWork), invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes), hasCaughtError()) {
            var replayError = clearCaughtError();
            typeof replayError == "object" && replayError !== null && replayError._suppressLogging && typeof originalError == "object" && originalError !== null && !originalError._suppressLogging && (originalError._suppressLogging = !0);
          }
          throw originalError;
        }
      };
    }
    var didWarnAboutUpdateInRender = !1, didWarnAboutUpdateInRenderForAnotherComponent;
    didWarnAboutUpdateInRenderForAnotherComponent = /* @__PURE__ */ new Set();
    function warnAboutRenderPhaseUpdatesInDEV(fiber) {
      if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV())
        switch (fiber.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown", dedupeKey = renderingComponentName;
            if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
              didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
              var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
              error("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
            }
            break;
          }
          case ClassComponent: {
            didWarnAboutUpdateInRender || (error("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), didWarnAboutUpdateInRender = !0);
            break;
          }
        }
    }
    function restorePendingUpdaters(root2, lanes) {
      if (isDevToolsPresent) {
        var memoizedUpdaters = root2.memoizedUpdaters;
        memoizedUpdaters.forEach(function(schedulingFiber) {
          addFiberToLanesMap(root2, schedulingFiber, lanes);
        });
      }
    }
    var fakeActCallbackNode = {};
    function scheduleCallback$1(priorityLevel, callback) {
      {
        var actQueue = ReactCurrentActQueue$1.current;
        return actQueue !== null ? (actQueue.push(callback), fakeActCallbackNode) : scheduleCallback(priorityLevel, callback);
      }
    }
    function cancelCallback$1(callbackNode) {
      if (callbackNode !== fakeActCallbackNode)
        return cancelCallback(callbackNode);
    }
    function shouldForceFlushFallbacksInDEV() {
      return ReactCurrentActQueue$1.current !== null;
    }
    function warnIfUpdatesNotWrappedWithActDEV(fiber) {
      {
        if (fiber.mode & ConcurrentMode) {
          if (!isConcurrentActEnvironment())
            return;
        } else if (!isLegacyActEnvironment() || executionContext !== NoContext || fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent)
          return;
        if (ReactCurrentActQueue$1.current === null) {
          var previousFiber = current;
          try {
            setCurrentFiber(fiber), error(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, getComponentNameFromFiber(fiber));
          } finally {
            previousFiber ? setCurrentFiber(fiber) : resetCurrentFiber();
          }
        }
      }
    }
    function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
      root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null && error(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function setIsRunningInsertionEffect(isRunning) {
      isRunningInsertionEffect = isRunning;
    }
    var resolveFamily = null, failedBoundaries = null, setRefreshHandler = function(handler) {
      resolveFamily = handler;
    };
    function resolveFunctionForHotReloading(type) {
      {
        if (resolveFamily === null)
          return type;
        var family = resolveFamily(type);
        return family === void 0 ? type : family.current;
      }
    }
    function resolveClassForHotReloading(type) {
      return resolveFunctionForHotReloading(type);
    }
    function resolveForwardRefForHotReloading(type) {
      {
        if (resolveFamily === null)
          return type;
        var family = resolveFamily(type);
        if (family === void 0) {
          if (type != null && typeof type.render == "function") {
            var currentRender = resolveFunctionForHotReloading(type.render);
            if (type.render !== currentRender) {
              var syntheticType = {
                $$typeof: REACT_FORWARD_REF_TYPE,
                render: currentRender
              };
              return type.displayName !== void 0 && (syntheticType.displayName = type.displayName), syntheticType;
            }
          }
          return type;
        }
        return family.current;
      }
    }
    function isCompatibleFamilyForHotReloading(fiber, element) {
      {
        if (resolveFamily === null)
          return !1;
        var prevType = fiber.elementType, nextType = element.type, needsCompareFamilies = !1, $$typeofNextType = typeof nextType == "object" && nextType !== null ? nextType.$$typeof : null;
        switch (fiber.tag) {
          case ClassComponent: {
            typeof nextType == "function" && (needsCompareFamilies = !0);
            break;
          }
          case FunctionComponent: {
            (typeof nextType == "function" || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
            break;
          }
          case ForwardRef: {
            ($$typeofNextType === REACT_FORWARD_REF_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
            break;
          }
          case MemoComponent:
          case SimpleMemoComponent: {
            ($$typeofNextType === REACT_MEMO_TYPE || $$typeofNextType === REACT_LAZY_TYPE) && (needsCompareFamilies = !0);
            break;
          }
          default:
            return !1;
        }
        if (needsCompareFamilies) {
          var prevFamily = resolveFamily(prevType);
          if (prevFamily !== void 0 && prevFamily === resolveFamily(nextType))
            return !0;
        }
        return !1;
      }
    }
    function markFailedErrorBoundaryForHotReloading(fiber) {
      {
        if (resolveFamily === null || typeof WeakSet != "function")
          return;
        failedBoundaries === null && (failedBoundaries = /* @__PURE__ */ new WeakSet()), failedBoundaries.add(fiber);
      }
    }
    var scheduleRefresh = function(root2, update) {
      {
        if (resolveFamily === null)
          return;
        var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;
        flushPassiveEffects(), flushSync(function() {
          scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
        });
      }
    }, scheduleRoot = function(root2, element) {
      {
        if (root2.context !== emptyContextObject)
          return;
        flushPassiveEffects(), flushSync(function() {
          updateContainer(element, root2, null, null);
        });
      }
    };
    function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
      {
        var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
        switch (tag) {
          case FunctionComponent:
          case SimpleMemoComponent:
          case ClassComponent:
            candidateType = type;
            break;
          case ForwardRef:
            candidateType = type.render;
            break;
        }
        if (resolveFamily === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var needsRender = !1, needsRemount = !1;
        if (candidateType !== null) {
          var family = resolveFamily(candidateType);
          family !== void 0 && (staleFamilies.has(family) ? needsRemount = !0 : updatedFamilies.has(family) && (tag === ClassComponent ? needsRemount = !0 : needsRender = !0));
        }
        if (failedBoundaries !== null && (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) && (needsRemount = !0), needsRemount && (fiber._debugNeedsRemount = !0), needsRemount || needsRender) {
          var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
          _root !== null && scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
        }
        child !== null && !needsRemount && scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies), sibling !== null && scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
      }
    }
    var findHostInstancesForRefresh = function(root2, families) {
      {
        var hostInstances = /* @__PURE__ */ new Set(), types2 = new Set(families.map(function(family) {
          return family.current;
        }));
        return findHostInstancesForMatchingFibersRecursively(root2.current, types2, hostInstances), hostInstances;
      }
    };
    function findHostInstancesForMatchingFibersRecursively(fiber, types2, hostInstances) {
      {
        var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type, candidateType = null;
        switch (tag) {
          case FunctionComponent:
          case SimpleMemoComponent:
          case ClassComponent:
            candidateType = type;
            break;
          case ForwardRef:
            candidateType = type.render;
            break;
        }
        var didMatch = !1;
        candidateType !== null && types2.has(candidateType) && (didMatch = !0), didMatch ? findHostInstancesForFiberShallowly(fiber, hostInstances) : child !== null && findHostInstancesForMatchingFibersRecursively(child, types2, hostInstances), sibling !== null && findHostInstancesForMatchingFibersRecursively(sibling, types2, hostInstances);
      }
    }
    function findHostInstancesForFiberShallowly(fiber, hostInstances) {
      {
        var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
        if (foundHostInstances)
          return;
        for (var node2 = fiber; ; ) {
          switch (node2.tag) {
            case HostComponent:
              hostInstances.add(node2.stateNode);
              return;
            case HostPortal:
              hostInstances.add(node2.stateNode.containerInfo);
              return;
            case HostRoot:
              hostInstances.add(node2.stateNode.containerInfo);
              return;
          }
          if (node2.return === null)
            throw new Error("Expected to reach root first.");
          node2 = node2.return;
        }
      }
    }
    function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
      for (var node2 = fiber, foundHostInstances = !1; ; ) {
        if (node2.tag === HostComponent)
          foundHostInstances = !0, hostInstances.add(node2.stateNode);
        else if (node2.child !== null) {
          node2.child.return = node2, node2 = node2.child;
          continue;
        }
        if (node2 === fiber)
          return foundHostInstances;
        for (; node2.sibling === null; ) {
          if (node2.return === null || node2.return === fiber)
            return foundHostInstances;
          node2 = node2.return;
        }
        node2.sibling.return = node2.return, node2 = node2.sibling;
      }
      return !1;
    }
    var hasBadMapPolyfill;
    {
      hasBadMapPolyfill = !1;
      try {
        var nonExtensibleObject = Object.preventExtensions({});
      } catch {
        hasBadMapPolyfill = !0;
      }
    }
    function FiberNode(tag, pendingProps, key2, mode) {
      this.tag = tag, this.key = key2, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = pendingProps, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = mode, this.flags = NoFlags, this.subtreeFlags = NoFlags, this.deletions = null, this.lanes = NoLanes, this.childLanes = NoLanes, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !hasBadMapPolyfill && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var createFiber = function(tag, pendingProps, key2, mode) {
      return new FiberNode(tag, pendingProps, key2, mode);
    };
    function shouldConstruct$1(Component) {
      var prototype = Component.prototype;
      return !!(prototype && prototype.isReactComponent);
    }
    function isSimpleFunctionComponent(type) {
      return typeof type == "function" && !shouldConstruct$1(type) && type.defaultProps === void 0;
    }
    function resolveLazyComponentTag(Component) {
      if (typeof Component == "function")
        return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
      if (Component != null) {
        var $$typeof = Component.$$typeof;
        if ($$typeof === REACT_FORWARD_REF_TYPE)
          return ForwardRef;
        if ($$typeof === REACT_MEMO_TYPE)
          return MemoComponent;
      }
      return IndeterminateComponent;
    }
    function createWorkInProgress(current2, pendingProps) {
      var workInProgress2 = current2.alternate;
      workInProgress2 === null ? (workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode), workInProgress2.elementType = current2.elementType, workInProgress2.type = current2.type, workInProgress2.stateNode = current2.stateNode, workInProgress2._debugSource = current2._debugSource, workInProgress2._debugOwner = current2._debugOwner, workInProgress2._debugHookTypes = current2._debugHookTypes, workInProgress2.alternate = current2, current2.alternate = workInProgress2) : (workInProgress2.pendingProps = pendingProps, workInProgress2.type = current2.type, workInProgress2.flags = NoFlags, workInProgress2.subtreeFlags = NoFlags, workInProgress2.deletions = null, workInProgress2.actualDuration = 0, workInProgress2.actualStartTime = -1), workInProgress2.flags = current2.flags & StaticMask, workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue;
      var currentDependencies = current2.dependencies;
      switch (workInProgress2.dependencies = currentDependencies === null ? null : {
        lanes: currentDependencies.lanes,
        firstContext: currentDependencies.firstContext
      }, workInProgress2.sibling = current2.sibling, workInProgress2.index = current2.index, workInProgress2.ref = current2.ref, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration, workInProgress2._debugNeedsRemount = current2._debugNeedsRemount, workInProgress2.tag) {
        case IndeterminateComponent:
        case FunctionComponent:
        case SimpleMemoComponent:
          workInProgress2.type = resolveFunctionForHotReloading(current2.type);
          break;
        case ClassComponent:
          workInProgress2.type = resolveClassForHotReloading(current2.type);
          break;
        case ForwardRef:
          workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
          break;
      }
      return workInProgress2;
    }
    function resetWorkInProgress(workInProgress2, renderLanes2) {
      workInProgress2.flags &= StaticMask | Placement;
      var current2 = workInProgress2.alternate;
      if (current2 === null)
        workInProgress2.childLanes = NoLanes, workInProgress2.lanes = renderLanes2, workInProgress2.child = null, workInProgress2.subtreeFlags = NoFlags, workInProgress2.memoizedProps = null, workInProgress2.memoizedState = null, workInProgress2.updateQueue = null, workInProgress2.dependencies = null, workInProgress2.stateNode = null, workInProgress2.selfBaseDuration = 0, workInProgress2.treeBaseDuration = 0;
      else {
        workInProgress2.childLanes = current2.childLanes, workInProgress2.lanes = current2.lanes, workInProgress2.child = current2.child, workInProgress2.subtreeFlags = NoFlags, workInProgress2.deletions = null, workInProgress2.memoizedProps = current2.memoizedProps, workInProgress2.memoizedState = current2.memoizedState, workInProgress2.updateQueue = current2.updateQueue, workInProgress2.type = current2.type;
        var currentDependencies = current2.dependencies;
        workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        }, workInProgress2.selfBaseDuration = current2.selfBaseDuration, workInProgress2.treeBaseDuration = current2.treeBaseDuration;
      }
      return workInProgress2;
    }
    function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
      var mode;
      return tag === ConcurrentRoot ? (mode = ConcurrentMode, isStrictMode === !0 && (mode |= StrictLegacyMode, mode |= StrictEffectsMode)) : mode = NoMode, isDevToolsPresent && (mode |= ProfileMode), createFiber(HostRoot, null, null, mode);
    }
    function createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes) {
      var fiberTag = IndeterminateComponent, resolvedType = type;
      if (typeof type == "function")
        shouldConstruct$1(type) ? (fiberTag = ClassComponent, resolvedType = resolveClassForHotReloading(resolvedType)) : resolvedType = resolveFunctionForHotReloading(resolvedType);
      else if (typeof type == "string")
        fiberTag = HostComponent;
      else
        getTag: switch (type) {
          case REACT_FRAGMENT_TYPE:
            return createFiberFromFragment(pendingProps.children, mode, lanes, key2);
          case REACT_STRICT_MODE_TYPE:
            fiberTag = Mode, mode |= StrictLegacyMode, (mode & ConcurrentMode) !== NoMode && (mode |= StrictEffectsMode);
            break;
          case REACT_PROFILER_TYPE:
            return createFiberFromProfiler(pendingProps, mode, lanes, key2);
          case REACT_SUSPENSE_TYPE:
            return createFiberFromSuspense(pendingProps, mode, lanes, key2);
          case REACT_SUSPENSE_LIST_TYPE:
            return createFiberFromSuspenseList(pendingProps, mode, lanes, key2);
          case REACT_OFFSCREEN_TYPE:
            return createFiberFromOffscreen(pendingProps, mode, lanes, key2);
          case REACT_LEGACY_HIDDEN_TYPE:
          case REACT_SCOPE_TYPE:
          case REACT_CACHE_TYPE:
          case REACT_TRACING_MARKER_TYPE:
          case REACT_DEBUG_TRACING_MODE_TYPE:
          default: {
            if (typeof type == "object" && type !== null)
              switch (type.$$typeof) {
                case REACT_PROVIDER_TYPE:
                  fiberTag = ContextProvider;
                  break getTag;
                case REACT_CONTEXT_TYPE:
                  fiberTag = ContextConsumer;
                  break getTag;
                case REACT_FORWARD_REF_TYPE:
                  fiberTag = ForwardRef, resolvedType = resolveForwardRefForHotReloading(resolvedType);
                  break getTag;
                case REACT_MEMO_TYPE:
                  fiberTag = MemoComponent;
                  break getTag;
                case REACT_LAZY_TYPE:
                  fiberTag = LazyComponent, resolvedType = null;
                  break getTag;
              }
            var info2 = "";
            {
              (type === void 0 || typeof type == "object" && type !== null && Object.keys(type).length === 0) && (info2 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var ownerName = owner ? getComponentNameFromFiber(owner) : null;
              ownerName && (info2 += `

Check the render method of \`` + ownerName + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info2));
          }
        }
      var fiber = createFiber(fiberTag, pendingProps, key2, mode);
      return fiber.elementType = type, fiber.type = resolvedType, fiber.lanes = lanes, fiber._debugOwner = owner, fiber;
    }
    function createFiberFromElement(element, mode, lanes) {
      var owner = null;
      owner = element._owner;
      var type = element.type, key2 = element.key, pendingProps = element.props, fiber = createFiberFromTypeAndProps(type, key2, pendingProps, owner, mode, lanes);
      return fiber._debugSource = element._source, fiber._debugOwner = element._owner, fiber;
    }
    function createFiberFromFragment(elements, mode, lanes, key2) {
      var fiber = createFiber(Fragment2, elements, key2, mode);
      return fiber.lanes = lanes, fiber;
    }
    function createFiberFromProfiler(pendingProps, mode, lanes, key2) {
      typeof pendingProps.id != "string" && error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
      var fiber = createFiber(Profiler, pendingProps, key2, mode | ProfileMode);
      return fiber.elementType = REACT_PROFILER_TYPE, fiber.lanes = lanes, fiber.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, fiber;
    }
    function createFiberFromSuspense(pendingProps, mode, lanes, key2) {
      var fiber = createFiber(SuspenseComponent, pendingProps, key2, mode);
      return fiber.elementType = REACT_SUSPENSE_TYPE, fiber.lanes = lanes, fiber;
    }
    function createFiberFromSuspenseList(pendingProps, mode, lanes, key2) {
      var fiber = createFiber(SuspenseListComponent, pendingProps, key2, mode);
      return fiber.elementType = REACT_SUSPENSE_LIST_TYPE, fiber.lanes = lanes, fiber;
    }
    function createFiberFromOffscreen(pendingProps, mode, lanes, key2) {
      var fiber = createFiber(OffscreenComponent, pendingProps, key2, mode);
      fiber.elementType = REACT_OFFSCREEN_TYPE, fiber.lanes = lanes;
      var primaryChildInstance = {
        isHidden: !1
      };
      return fiber.stateNode = primaryChildInstance, fiber;
    }
    function createFiberFromText(content, mode, lanes) {
      var fiber = createFiber(HostText, content, null, mode);
      return fiber.lanes = lanes, fiber;
    }
    function createFiberFromHostInstanceForDeletion() {
      var fiber = createFiber(HostComponent, null, null, NoMode);
      return fiber.elementType = "DELETED", fiber;
    }
    function createFiberFromDehydratedFragment(dehydratedNode) {
      var fiber = createFiber(DehydratedFragment, null, null, NoMode);
      return fiber.stateNode = dehydratedNode, fiber;
    }
    function createFiberFromPortal(portal, mode, lanes) {
      var pendingProps = portal.children !== null ? portal.children : [], fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
      return fiber.lanes = lanes, fiber.stateNode = {
        containerInfo: portal.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: portal.implementation
      }, fiber;
    }
    function assignFiberPropertiesInDEV(target2, source) {
      return target2 === null && (target2 = createFiber(IndeterminateComponent, null, null, NoMode)), target2.tag = source.tag, target2.key = source.key, target2.elementType = source.elementType, target2.type = source.type, target2.stateNode = source.stateNode, target2.return = source.return, target2.child = source.child, target2.sibling = source.sibling, target2.index = source.index, target2.ref = source.ref, target2.pendingProps = source.pendingProps, target2.memoizedProps = source.memoizedProps, target2.updateQueue = source.updateQueue, target2.memoizedState = source.memoizedState, target2.dependencies = source.dependencies, target2.mode = source.mode, target2.flags = source.flags, target2.subtreeFlags = source.subtreeFlags, target2.deletions = source.deletions, target2.lanes = source.lanes, target2.childLanes = source.childLanes, target2.alternate = source.alternate, target2.actualDuration = source.actualDuration, target2.actualStartTime = source.actualStartTime, target2.selfBaseDuration = source.selfBaseDuration, target2.treeBaseDuration = source.treeBaseDuration, target2._debugSource = source._debugSource, target2._debugOwner = source._debugOwner, target2._debugNeedsRemount = source._debugNeedsRemount, target2._debugHookTypes = source._debugHookTypes, target2;
    }
    function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
      this.tag = tag, this.containerInfo = containerInfo, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = noTimeout, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = NoLane, this.eventTimes = createLaneMap(NoLanes), this.expirationTimes = createLaneMap(NoTimestamp), this.pendingLanes = NoLanes, this.suspendedLanes = NoLanes, this.pingedLanes = NoLanes, this.expiredLanes = NoLanes, this.mutableReadLanes = NoLanes, this.finishedLanes = NoLanes, this.entangledLanes = NoLanes, this.entanglements = createLaneMap(NoLanes), this.identifierPrefix = identifierPrefix, this.onRecoverableError = onRecoverableError, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [], _i = 0; _i < TotalLanes; _i++)
          pendingUpdatersLaneMap.push(/* @__PURE__ */ new Set());
      }
      switch (tag) {
        case ConcurrentRoot:
          this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
          break;
        case LegacyRoot:
          this._debugRootType = hydrate2 ? "hydrate()" : "render()";
          break;
      }
    }
    function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
      var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError), uninitializedFiber = createHostRootFiber(tag, isStrictMode);
      root2.current = uninitializedFiber, uninitializedFiber.stateNode = root2;
      {
        var _initialState = {
          element: initialChildren,
          isDehydrated: hydrate2,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        uninitializedFiber.memoizedState = _initialState;
      }
      return initializeUpdateQueue(uninitializedFiber), root2;
    }
    var ReactVersion = "18.3.1";
    function createPortal(children, containerInfo, implementation) {
      var key2 = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return checkKeyStringCoercion(key2), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: REACT_PORTAL_TYPE,
        key: key2 == null ? null : "" + key2,
        children,
        containerInfo,
        implementation
      };
    }
    var didWarnAboutNestedUpdates, didWarnAboutFindNodeInStrictMode;
    didWarnAboutNestedUpdates = !1, didWarnAboutFindNodeInStrictMode = {};
    function getContextForSubtree(parentComponent) {
      if (!parentComponent)
        return emptyContextObject;
      var fiber = get(parentComponent), parentContext = findCurrentUnmaskedContext(fiber);
      if (fiber.tag === ClassComponent) {
        var Component = fiber.type;
        if (isContextProvider(Component))
          return processChildContext(fiber, Component, parentContext);
      }
      return parentContext;
    }
    function findHostInstanceWithWarning(component, methodName) {
      {
        var fiber = get(component);
        if (fiber === void 0) {
          if (typeof component.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var keys = Object.keys(component).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
        }
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null)
          return null;
        if (hostFiber.mode & StrictLegacyMode) {
          var componentName = getComponentNameFromFiber(fiber) || "Component";
          if (!didWarnAboutFindNodeInStrictMode[componentName]) {
            didWarnAboutFindNodeInStrictMode[componentName] = !0;
            var previousFiber = current;
            try {
              setCurrentFiber(hostFiber), fiber.mode & StrictLegacyMode ? error("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName) : error("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
            } finally {
              previousFiber ? setCurrentFiber(previousFiber) : resetCurrentFiber();
            }
          }
        }
        return hostFiber.stateNode;
      }
    }
    function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
      var hydrate2 = !1, initialChildren = null;
      return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
    }
    function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
      var hydrate2 = !0, root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      root2.context = getContextForSubtree(null);
      var current2 = root2.current, eventTime = requestEventTime(), lane = requestUpdateLane(current2), update = createUpdate(eventTime, lane);
      return update.callback = callback ?? null, enqueueUpdate(current2, update, lane), scheduleInitialHydrationOnRoot(root2, lane, eventTime), root2;
    }
    function updateContainer(element, container, parentComponent, callback) {
      onScheduleRoot(container, element);
      var current$1 = container.current, eventTime = requestEventTime(), lane = requestUpdateLane(current$1);
      markRenderScheduled(lane);
      var context = getContextForSubtree(parentComponent);
      container.context === null ? container.context = context : container.pendingContext = context, isRendering && current !== null && !didWarnAboutNestedUpdates && (didWarnAboutNestedUpdates = !0, error(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, getComponentNameFromFiber(current) || "Unknown"));
      var update = createUpdate(eventTime, lane);
      update.payload = {
        element
      }, callback = callback === void 0 ? null : callback, callback !== null && (typeof callback != "function" && error("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callback), update.callback = callback);
      var root2 = enqueueUpdate(current$1, update, lane);
      return root2 !== null && (scheduleUpdateOnFiber(root2, current$1, lane, eventTime), entangleTransitions(root2, current$1, lane)), lane;
    }
    function getPublicRootInstance(container) {
      var containerFiber = container.current;
      if (!containerFiber.child)
        return null;
      switch (containerFiber.child.tag) {
        case HostComponent:
          return containerFiber.child.stateNode;
        default:
          return containerFiber.child.stateNode;
      }
    }
    function attemptSynchronousHydration$1(fiber) {
      switch (fiber.tag) {
        case HostRoot: {
          var root2 = fiber.stateNode;
          if (isRootDehydrated(root2)) {
            var lanes = getHighestPriorityPendingLanes(root2);
            flushRoot(root2, lanes);
          }
          break;
        }
        case SuspenseComponent: {
          flushSync(function() {
            var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root3 !== null) {
              var eventTime = requestEventTime();
              scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
            }
          });
          var retryLane = SyncLane;
          markRetryLaneIfNotHydrated(fiber, retryLane);
          break;
        }
      }
    }
    function markRetryLaneImpl(fiber, retryLane) {
      var suspenseState = fiber.memoizedState;
      suspenseState !== null && suspenseState.dehydrated !== null && (suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane));
    }
    function markRetryLaneIfNotHydrated(fiber, retryLane) {
      markRetryLaneImpl(fiber, retryLane);
      var alternate = fiber.alternate;
      alternate && markRetryLaneImpl(alternate, retryLane);
    }
    function attemptContinuousHydration$1(fiber) {
      if (fiber.tag === SuspenseComponent) {
        var lane = SelectiveHydrationLane, root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    function attemptHydrationAtCurrentPriority$1(fiber) {
      if (fiber.tag === SuspenseComponent) {
        var lane = requestUpdateLane(fiber), root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
    }
    function findHostInstanceWithNoPortals(fiber) {
      var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
      return hostFiber === null ? null : hostFiber.stateNode;
    }
    var shouldErrorImpl = function(fiber) {
      return null;
    };
    function shouldError(fiber) {
      return shouldErrorImpl(fiber);
    }
    var shouldSuspendImpl = function(fiber) {
      return !1;
    };
    function shouldSuspend(fiber) {
      return shouldSuspendImpl(fiber);
    }
    var overrideHookState = null, overrideHookStateDeletePath = null, overrideHookStateRenamePath = null, overrideProps = null, overridePropsDeletePath = null, overridePropsRenamePath = null, scheduleUpdate = null, setErrorHandler = null, setSuspenseHandler = null;
    {
      var copyWithDeleteImpl = function(obj, path, index3) {
        var key2 = path[index3], updated = isArray(obj) ? obj.slice() : assign2({}, obj);
        return index3 + 1 === path.length ? (isArray(updated) ? updated.splice(key2, 1) : delete updated[key2], updated) : (updated[key2] = copyWithDeleteImpl(obj[key2], path, index3 + 1), updated);
      }, copyWithDelete = function(obj, path) {
        return copyWithDeleteImpl(obj, path, 0);
      }, copyWithRenameImpl = function(obj, oldPath, newPath, index3) {
        var oldKey = oldPath[index3], updated = isArray(obj) ? obj.slice() : assign2({}, obj);
        if (index3 + 1 === oldPath.length) {
          var newKey = newPath[index3];
          updated[newKey] = updated[oldKey], isArray(updated) ? updated.splice(oldKey, 1) : delete updated[oldKey];
        } else
          updated[oldKey] = copyWithRenameImpl(
            // $FlowFixMe number or string is fine here
            obj[oldKey],
            oldPath,
            newPath,
            index3 + 1
          );
        return updated;
      }, copyWithRename = function(obj, oldPath, newPath) {
        if (oldPath.length !== newPath.length) {
          warn("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var i = 0; i < newPath.length - 1; i++)
            if (oldPath[i] !== newPath[i]) {
              warn("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return copyWithRenameImpl(obj, oldPath, newPath, 0);
      }, copyWithSetImpl = function(obj, path, index3, value) {
        if (index3 >= path.length)
          return value;
        var key2 = path[index3], updated = isArray(obj) ? obj.slice() : assign2({}, obj);
        return updated[key2] = copyWithSetImpl(obj[key2], path, index3 + 1, value), updated;
      }, copyWithSet = function(obj, path, value) {
        return copyWithSetImpl(obj, path, 0, value);
      }, findHook = function(fiber, id2) {
        for (var currentHook2 = fiber.memoizedState; currentHook2 !== null && id2 > 0; )
          currentHook2 = currentHook2.next, id2--;
        return currentHook2;
      };
      overrideHookState = function(fiber, id2, path, value) {
        var hook = findHook(fiber, id2);
        if (hook !== null) {
          var newState = copyWithSet(hook.memoizedState, path, value);
          hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign2({}, fiber.memoizedProps);
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
        }
      }, overrideHookStateDeletePath = function(fiber, id2, path) {
        var hook = findHook(fiber, id2);
        if (hook !== null) {
          var newState = copyWithDelete(hook.memoizedState, path);
          hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign2({}, fiber.memoizedProps);
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
        }
      }, overrideHookStateRenamePath = function(fiber, id2, oldPath, newPath) {
        var hook = findHook(fiber, id2);
        if (hook !== null) {
          var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
          hook.memoizedState = newState, hook.baseState = newState, fiber.memoizedProps = assign2({}, fiber.memoizedProps);
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
        }
      }, overrideProps = function(fiber, path, value) {
        fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
      }, overridePropsDeletePath = function(fiber, path) {
        fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
      }, overridePropsRenamePath = function(fiber, oldPath, newPath) {
        fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath), fiber.alternate && (fiber.alternate.pendingProps = fiber.pendingProps);
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
      }, scheduleUpdate = function(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        root2 !== null && scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
      }, setErrorHandler = function(newShouldErrorImpl) {
        shouldErrorImpl = newShouldErrorImpl;
      }, setSuspenseHandler = function(newShouldSuspendImpl) {
        shouldSuspendImpl = newShouldSuspendImpl;
      };
    }
    function findHostInstanceByFiber(fiber) {
      var hostFiber = findCurrentHostFiber(fiber);
      return hostFiber === null ? null : hostFiber.stateNode;
    }
    function emptyFindFiberByHostInstance(instance) {
      return null;
    }
    function getCurrentFiberForDevTools() {
      return current;
    }
    function injectIntoDevTools(devToolsConfig) {
      var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance, ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
      return injectInternals({
        bundleType: devToolsConfig.bundleType,
        version: devToolsConfig.version,
        rendererPackageName: devToolsConfig.rendererPackageName,
        rendererConfig: devToolsConfig.rendererConfig,
        overrideHookState,
        overrideHookStateDeletePath,
        overrideHookStateRenamePath,
        overrideProps,
        overridePropsDeletePath,
        overridePropsRenamePath,
        setErrorHandler,
        setSuspenseHandler,
        scheduleUpdate,
        currentDispatcherRef: ReactCurrentDispatcher2,
        findHostInstanceByFiber,
        findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
        // React Refresh
        findHostInstancesForRefresh,
        scheduleRefresh,
        scheduleRoot,
        setRefreshHandler,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: getCurrentFiberForDevTools,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: ReactVersion
      });
    }
    var defaultOnRecoverableError = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(error2) {
      console.error(error2);
    };
    function ReactDOMRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
      var root2 = this._internalRoot;
      if (root2 === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? error("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : isValidContainer(arguments[1]) ? error("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && error("You passed a second argument to root.render(...) but it only accepts one argument.");
        var container = root2.containerInfo;
        if (container.nodeType !== COMMENT_NODE) {
          var hostInstance = findHostInstanceWithNoPortals(root2.current);
          hostInstance && hostInstance.parentNode !== container && error("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      updateContainer(children, root2, null, null);
    }, ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
      typeof arguments[0] == "function" && error("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var root2 = this._internalRoot;
      if (root2 !== null) {
        this._internalRoot = null;
        var container = root2.containerInfo;
        isAlreadyRendering() && error("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), flushSync(function() {
          updateContainer(null, root2, null, null);
        }), unmarkContainerAsRoot(container);
      }
    };
    function createRoot(container, options2) {
      if (!isValidContainer(container))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container);
      var isStrictMode = !1, concurrentUpdatesByDefaultOverride = !1, identifierPrefix = "", onRecoverableError = defaultOnRecoverableError;
      options2 != null && (options2.hydrate ? warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof options2 == "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE && error(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), options2.unstable_strictMode === !0 && (isStrictMode = !0), options2.identifierPrefix !== void 0 && (identifierPrefix = options2.identifierPrefix), options2.onRecoverableError !== void 0 && (onRecoverableError = options2.onRecoverableError));
      var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      markContainerAsRoot(root2.current, container);
      var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
      return listenToAllSupportedEvents(rootContainerElement), new ReactDOMRoot(root2);
    }
    function ReactDOMHydrationRoot(internalRoot) {
      this._internalRoot = internalRoot;
    }
    function scheduleHydration(target2) {
      target2 && queueExplicitHydrationTarget(target2);
    }
    ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
    function hydrateRoot(container, initialChildren, options2) {
      if (!isValidContainer(container))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      warnIfReactDOMContainerInDEV(container), initialChildren === void 0 && error("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var hydrationCallbacks = options2 ?? null, mutableSources = options2 != null && options2.hydratedSources || null, isStrictMode = !1, concurrentUpdatesByDefaultOverride = !1, identifierPrefix = "", onRecoverableError = defaultOnRecoverableError;
      options2 != null && (options2.unstable_strictMode === !0 && (isStrictMode = !0), options2.identifierPrefix !== void 0 && (identifierPrefix = options2.identifierPrefix), options2.onRecoverableError !== void 0 && (onRecoverableError = options2.onRecoverableError));
      var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      if (markContainerAsRoot(root2.current, container), listenToAllSupportedEvents(container), mutableSources)
        for (var i = 0; i < mutableSources.length; i++) {
          var mutableSource = mutableSources[i];
          registerMutableSourceForHydration(root2, mutableSource);
        }
      return new ReactDOMHydrationRoot(root2);
    }
    function isValidContainer(node2) {
      return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
    }
    function isValidContainerLegacy(node2) {
      return !!(node2 && (node2.nodeType === ELEMENT_NODE || node2.nodeType === DOCUMENT_NODE || node2.nodeType === DOCUMENT_FRAGMENT_NODE || node2.nodeType === COMMENT_NODE && node2.nodeValue === " react-mount-point-unstable "));
    }
    function warnIfReactDOMContainerInDEV(container) {
      container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY" && error("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), isContainerMarkedAsRoot(container) && (container._reactRootContainer ? error("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : error("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner, topLevelUpdateWarnings;
    topLevelUpdateWarnings = function(container) {
      if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
        var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
        hostInstance && hostInstance.parentNode !== container && error("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var isRootRenderedBySomeReact = !!container._reactRootContainer, rootEl = getReactRootElementInContainer(container), hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
      hasNonRootReactChild && !isRootRenderedBySomeReact && error("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY" && error("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function getReactRootElementInContainer(container) {
      return container ? container.nodeType === DOCUMENT_NODE ? container.documentElement : container.firstChild : null;
    }
    function noopOnRecoverableError() {
    }
    function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
      if (isHydrationContainer) {
        if (typeof callback == "function") {
          var originalCallback = callback;
          callback = function() {
            var instance = getPublicRootInstance(root2);
            originalCallback.call(instance);
          };
        }
        var root2 = createHydrationContainer(
          initialChildren,
          callback,
          container,
          LegacyRoot,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          noopOnRecoverableError
        );
        container._reactRootContainer = root2, markContainerAsRoot(root2.current, container);
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        return listenToAllSupportedEvents(rootContainerElement), flushSync(), root2;
      } else {
        for (var rootSibling; rootSibling = container.lastChild; )
          container.removeChild(rootSibling);
        if (typeof callback == "function") {
          var _originalCallback = callback;
          callback = function() {
            var instance = getPublicRootInstance(_root);
            _originalCallback.call(instance);
          };
        }
        var _root = createContainer(
          container,
          LegacyRoot,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          noopOnRecoverableError
        );
        container._reactRootContainer = _root, markContainerAsRoot(_root.current, container);
        var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        return listenToAllSupportedEvents(_rootContainerElement), flushSync(function() {
          updateContainer(initialChildren, _root, parentComponent, callback);
        }), _root;
      }
    }
    function warnOnInvalidCallback$1(callback, callerName) {
      callback !== null && typeof callback != "function" && error("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", callerName, callback);
    }
    function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
      topLevelUpdateWarnings(container), warnOnInvalidCallback$1(callback === void 0 ? null : callback, "render");
      var maybeRoot = container._reactRootContainer, root2;
      if (!maybeRoot)
        root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
      else {
        if (root2 = maybeRoot, typeof callback == "function") {
          var originalCallback = callback;
          callback = function() {
            var instance = getPublicRootInstance(root2);
            originalCallback.call(instance);
          };
        }
        updateContainer(children, root2, parentComponent, callback);
      }
      return getPublicRootInstance(root2);
    }
    var didWarnAboutFindDOMNode = !1;
    function findDOMNode(componentOrElement) {
      {
        didWarnAboutFindDOMNode || (didWarnAboutFindDOMNode = !0, error("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var owner = ReactCurrentOwner$3.current;
        if (owner !== null && owner.stateNode !== null) {
          var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
          warnedAboutRefsInRender || error("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component"), owner.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return componentOrElement == null ? null : componentOrElement.nodeType === ELEMENT_NODE ? componentOrElement : findHostInstanceWithWarning(componentOrElement, "findDOMNode");
    }
    function hydrate(element, container, callback) {
      if (error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !isValidContainerLegacy(container))
        throw new Error("Target container is not a DOM element.");
      {
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
        isModernRoot && error("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return legacyRenderSubtreeIntoContainer(null, element, container, !0, callback);
    }
    function render(element, container, callback) {
      if (error("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !isValidContainerLegacy(container))
        throw new Error("Target container is not a DOM element.");
      {
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
        isModernRoot && error("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return legacyRenderSubtreeIntoContainer(null, element, container, !1, callback);
    }
    function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
      if (error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !isValidContainerLegacy(containerNode))
        throw new Error("Target container is not a DOM element.");
      if (parentComponent == null || !has(parentComponent))
        throw new Error("parentComponent must be a valid React Component");
      return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, !1, callback);
    }
    var didWarnAboutUnmountComponentAtNode = !1;
    function unmountComponentAtNode(container) {
      if (didWarnAboutUnmountComponentAtNode || (didWarnAboutUnmountComponentAtNode = !0, error("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !isValidContainerLegacy(container))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === void 0;
        isModernRoot && error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (container._reactRootContainer) {
        {
          var rootEl = getReactRootElementInContainer(container), renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
          renderedByDifferentReact && error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return flushSync(function() {
          legacyRenderSubtreeIntoContainer(null, null, container, !1, function() {
            container._reactRootContainer = null, unmarkContainerAsRoot(container);
          });
        }), !0;
      } else {
        {
          var _rootEl = getReactRootElementInContainer(container), hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl)), isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
          hasNonRootReactChild && error("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    setAttemptSynchronousHydration(attemptSynchronousHydration$1), setAttemptContinuousHydration(attemptContinuousHydration$1), setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1), setGetCurrentUpdatePriority(getCurrentUpdatePriority), setAttemptHydrationAtPriority(runWithPriority), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && error("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), setRestoreImplementation(restoreControlledState$3), setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
    function createPortal$1(children, container) {
      var key2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!isValidContainer(container))
        throw new Error("Target container is not a DOM element.");
      return createPortal(children, container, null, key2);
    }
    function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
      return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
    }
    var Internals = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
    };
    function createRoot$1(container, options2) {
      return Internals.usingClientEntryPoint || error('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), createRoot(container, options2);
    }
    function hydrateRoot$1(container, initialChildren, options2) {
      return Internals.usingClientEntryPoint || error('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), hydrateRoot(container, initialChildren, options2);
    }
    function flushSync$1(fn) {
      return isAlreadyRendering() && error("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), flushSync(fn);
    }
    var foundDevTools = injectIntoDevTools({
      findFiberByHostInstance: getClosestInstanceFromNode,
      bundleType: 1,
      version: ReactVersion,
      rendererPackageName: "react-dom"
    });
    if (!foundDevTools && canUseDOM && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var protocol = window.location.protocol;
      /^(https?|file):$/.test(protocol) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (protocol === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    reactDom_development.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals, reactDom_development.createPortal = createPortal$1, reactDom_development.createRoot = createRoot$1, reactDom_development.findDOMNode = findDOMNode, reactDom_development.flushSync = flushSync$1, reactDom_development.hydrate = hydrate, reactDom_development.hydrateRoot = hydrateRoot$1, reactDom_development.render = render, reactDom_development.unmountComponentAtNode = unmountComponentAtNode, reactDom_development.unstable_batchedUpdates = batchedUpdates$1, reactDom_development.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer, reactDom_development.version = ReactVersion, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }()), reactDom_development;
}
function checkDCE() {
  if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("^_^");
    try {
      __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    } catch (err) {
      console.error(err);
    }
  }
}
process.env.NODE_ENV === "production" ? (checkDCE(), reactDom.exports = requireReactDom_production_min()) : reactDom.exports = requireReactDom_development();
var reactDomExports = reactDom.exports, index = typeof document < "u" ? useLayoutEffect : useEffect;
function deepEqual(a, b) {
  if (a === b)
    return !0;
  if (typeof a != typeof b)
    return !1;
  if (typeof a == "function" && a.toString() === b.toString())
    return !0;
  let length2, i, keys;
  if (a && b && typeof a == "object") {
    if (Array.isArray(a)) {
      if (length2 = a.length, length2 !== b.length) return !1;
      for (i = length2; i-- !== 0; )
        if (!deepEqual(a[i], b[i]))
          return !1;
      return !0;
    }
    if (keys = Object.keys(a), length2 = keys.length, length2 !== Object.keys(b).length)
      return !1;
    for (i = length2; i-- !== 0; )
      if (!{}.hasOwnProperty.call(b, keys[i]))
        return !1;
    for (i = length2; i-- !== 0; ) {
      const key2 = keys[i];
      if (!(key2 === "_owner" && a.$$typeof) && !deepEqual(a[key2], b[key2]))
        return !1;
    }
    return !0;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  return typeof window > "u" ? 1 : (element.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React$2.useRef(value);
  return index(() => {
    ref.current = value;
  }), ref;
}
function useFloating(options) {
  options === void 0 && (options = {});
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = !0,
    whileElementsMounted,
    open
  } = options, [data2, setData] = React$2.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: !1
  }), [latestMiddleware, setLatestMiddleware] = React$2.useState(middleware2);
  deepEqual(latestMiddleware, middleware2) || setLatestMiddleware(middleware2);
  const [_reference, _setReference] = React$2.useState(null), [_floating, _setFloating] = React$2.useState(null), setReference = React$2.useCallback((node2) => {
    node2 !== referenceRef.current && (referenceRef.current = node2, _setReference(node2));
  }, []), setFloating = React$2.useCallback((node2) => {
    node2 !== floatingRef.current && (floatingRef.current = node2, _setFloating(node2));
  }, []), referenceEl = externalReference || _reference, floatingEl = externalFloating || _floating, referenceRef = React$2.useRef(null), floatingRef = React$2.useRef(null), dataRef = React$2.useRef(data2), hasWhileElementsMounted = whileElementsMounted != null, whileElementsMountedRef = useLatestRef(whileElementsMounted), platformRef = useLatestRef(platform2), update = React$2.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current)
      return;
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    platformRef.current && (config.platform = platformRef.current), computePosition(referenceRef.current, floatingRef.current, config).then((data3) => {
      const fullData = {
        ...data3,
        isPositioned: !0
      };
      isMountedRef.current && !deepEqual(dataRef.current, fullData) && (dataRef.current = fullData, reactDomExports.flushSync(() => {
        setData(fullData);
      }));
    });
  }, [latestMiddleware, placement, strategy, platformRef]);
  index(() => {
    open === !1 && dataRef.current.isPositioned && (dataRef.current.isPositioned = !1, setData((data3) => ({
      ...data3,
      isPositioned: !1
    })));
  }, [open]);
  const isMountedRef = React$2.useRef(!1);
  index(() => (isMountedRef.current = !0, () => {
    isMountedRef.current = !1;
  }), []), index(() => {
    if (referenceEl && (referenceRef.current = referenceEl), floatingEl && (floatingRef.current = floatingEl), referenceEl && floatingEl) {
      if (whileElementsMountedRef.current)
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React$2.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]), elements = React$2.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]), floatingStyles = React$2.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating)
      return initialStyles;
    const x2 = roundByDPR(elements.floating, data2.x), y2 = roundByDPR(elements.floating, data2.y);
    return transform ? {
      ...initialStyles,
      transform: "translate(" + x2 + "px, " + y2 + "px)",
      ...getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data2.x, data2.y]);
  return React$2.useMemo(() => ({
    ...data2,
    update,
    refs,
    elements,
    floatingStyles
  }), [data2, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options == "function" ? options(state) : options;
      return element && isRef(element) ? element.current != null ? arrow$2({
        element: element.current,
        padding
      }).fn(state) : {} : element ? arrow$2({
        element,
        padding
      }).fn(state) : {};
    }
  };
}, offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
}), shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
}), flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
}), hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
}), arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
}), MotionConfigContext = createContext({
  transformPagePoint: (p) => p,
  isStatic: !1,
  reducedMotion: "never"
}), MotionContext = createContext({}), PresenceContext = createContext(null), isBrowser = typeof document < "u", useIsomorphicLayoutEffect = isBrowser ? useLayoutEffect : useEffect, LazyContext = createContext({ strict: !1 }), camelToDash = (str) => str.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase(), optimizedAppearDataId = "framerAppearId", optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId), MotionGlobalConfig = {
  skipAnimations: !1,
  useManualTiming: !1
};
class Queue {
  constructor() {
    this.order = [], this.scheduled = /* @__PURE__ */ new Set();
  }
  add(process2) {
    if (!this.scheduled.has(process2))
      return this.scheduled.add(process2), this.order.push(process2), !0;
  }
  remove(process2) {
    const index2 = this.order.indexOf(process2);
    index2 !== -1 && (this.order.splice(index2, 1), this.scheduled.delete(process2));
  }
  clear() {
    this.order.length = 0, this.scheduled.clear();
  }
}
function createRenderStep(runNextFrame) {
  let thisFrame = new Queue(), nextFrame = new Queue(), numToRun = 0, isProcessing = !1, flushNextFrame = !1;
  const toKeepAlive = /* @__PURE__ */ new WeakSet(), step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = !1, immediate = !1) => {
      const addToCurrentFrame = immediate && isProcessing, queue = addToCurrentFrame ? thisFrame : nextFrame;
      return keepAlive && toKeepAlive.add(callback), queue.add(callback) && addToCurrentFrame && isProcessing && (numToRun = thisFrame.order.length), callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.remove(callback), toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      if (isProcessing) {
        flushNextFrame = !0;
        return;
      }
      if (isProcessing = !0, [thisFrame, nextFrame] = [nextFrame, thisFrame], nextFrame.clear(), numToRun = thisFrame.order.length, numToRun)
        for (let i = 0; i < numToRun; i++) {
          const callback = thisFrame.order[i];
          toKeepAlive.has(callback) && (step.schedule(callback), runNextFrame()), callback(frameData2);
        }
      isProcessing = !1, flushNextFrame && (flushNextFrame = !1, step.process(frameData2));
    }
  };
  return step;
}
const stepsOrder = [
  "prepare",
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
], maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = !1, useDefaultElapsed = !0;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: !1
  }, steps2 = stepsOrder.reduce((acc, key2) => (acc[key2] = createRenderStep(() => runNextFrame = !0), acc), {}), processStep = (stepId) => {
    steps2[stepId].process(state);
  }, processBatch = () => {
    const timestamp = performance.now();
    runNextFrame = !1, state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1), state.timestamp = timestamp, state.isProcessing = !0, stepsOrder.forEach(processStep), state.isProcessing = !1, runNextFrame && allowKeepAlive && (useDefaultElapsed = !1, scheduleNextBatch(processBatch));
  }, wake = () => {
    runNextFrame = !0, useDefaultElapsed = !0, state.isProcessing || scheduleNextBatch(processBatch);
  };
  return { schedule: stepsOrder.reduce((acc, key2) => {
    const step = steps2[key2];
    return acc[key2] = (process2, keepAlive = !1, immediate = !1) => (runNextFrame || wake(), step.schedule(process2, keepAlive, immediate)), acc;
  }, {}), cancel: (process2) => stepsOrder.forEach((key2) => steps2[key2].cancel(process2)), state, steps: steps2 };
}
const { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, !1);
function useVisualElement(Component, visualState, props, createVisualElement) {
  const { visualElement: parent } = useContext(MotionContext), lazyContext = useContext(LazyContext), presenceContext = useContext(PresenceContext), reducedMotionConfig = useContext(MotionConfigContext).reducedMotion, visualElementRef = useRef();
  createVisualElement = createVisualElement || lazyContext.renderer, !visualElementRef.current && createVisualElement && (visualElementRef.current = createVisualElement(Component, {
    visualState,
    parent,
    props,
    presenceContext,
    blockInitialAnimation: presenceContext ? presenceContext.initial === !1 : !1,
    reducedMotionConfig
  }));
  const visualElement = visualElementRef.current;
  useInsertionEffect(() => {
    visualElement && visualElement.update(props, presenceContext);
  });
  const wantsHandoff = useRef(!!(props[optimizedAppearDataAttribute] && !window.HandoffComplete));
  return useIsomorphicLayoutEffect(() => {
    visualElement && (microtask.postRender(visualElement.render), wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges());
  }), useEffect(() => {
    visualElement && (visualElement.updateFeatures(), !wantsHandoff.current && visualElement.animationState && visualElement.animationState.animateChanges(), wantsHandoff.current && (wantsHandoff.current = !1, window.HandoffComplete = !0));
  }), visualElement;
}
function isRefObject(ref) {
  return ref && typeof ref == "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}
function useMotionRef(visualState, visualElement, externalRef) {
  return useCallback(
    (instance) => {
      instance && visualState.mount && visualState.mount(instance), visualElement && (instance ? visualElement.mount(instance) : visualElement.unmount()), externalRef && (typeof externalRef == "function" ? externalRef(instance) : isRefObject(externalRef) && (externalRef.current = instance));
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}
function isVariantLabel(v2) {
  return typeof v2 == "string" || Array.isArray(v2);
}
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 == "object" && typeof v2.start == "function";
}
const variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
], variantProps = ["initial", ...variantPriorityOrder];
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name2) => isVariantLabel(props[name2]));
}
function isVariantNode(props) {
  return !!(isControllingVariants(props) || props.variants);
}
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate } = props;
    return {
      initial: initial === !1 || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate) ? animate : void 0
    };
  }
  return props.inherit !== !1 ? context : {};
}
function useCreateMotionContext(props) {
  const { initial, animate } = getCurrentTreeVariants(props, useContext(MotionContext));
  return useMemo(() => ({ initial, animate }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop2) {
  return Array.isArray(prop2) ? prop2.join(" ") : prop2;
}
const featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
}, featureDefinitions = {};
for (const key2 in featureProps)
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name2) => !!props[name2])
  };
function loadFeatures(features) {
  for (const key2 in features)
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
}
const LayoutGroupContext = createContext({}), SwitchLayoutGroupContext = createContext({}), motionComponentSymbol = Symbol.for("motionComponentSymbol");
function createMotionComponent({ preloadedFeatures: preloadedFeatures2, createVisualElement, useRender, useVisualState, Component }) {
  preloadedFeatures2 && loadFeatures(preloadedFeatures2);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    }, { isStatic } = configAndProps, context = useCreateMotionContext(props), visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);
      const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext), isStrict = useContext(LazyContext).strict;
      context.visualElement && (MeasureLayout2 = context.visualElement.loadFeatures(
        // Note: Pass the full new combined props to correctly re-render dynamic feature components.
        configAndProps,
        isStrict,
        preloadedFeatures2,
        initialLayoutGroupConfig
      ));
    }
    return React$2.createElement(
      MotionContext.Provider,
      { value: context },
      MeasureLayout2 && context.visualElement ? React$2.createElement(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null,
      useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)
    );
  }
  const ForwardRefComponent = forwardRef(MotionComponent);
  return ForwardRefComponent[motionComponentSymbol] = Component, ForwardRefComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function createMotionProxy(createConfig) {
  function custom(Component, customMotionComponentConfig = {}) {
    return createMotionComponent(createConfig(Component, customMotionComponentConfig));
  }
  if (typeof Proxy > "u")
    return custom;
  const componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => (componentCache.has(key2) || componentCache.set(key2, custom(key2)), componentCache.get(key2))
  });
}
const lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];
function isSVGComponent(Component) {
  return (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component != "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-") ? !1 : (
      /**
       * If it's in our list of lowercase SVG tags, it's an SVG component
       */
      !!(lowercaseSVGElements.indexOf(Component) > -1 || /**
       * If it contains a capital letter, it's an SVG component
       */
      /[A-Z]/.test(Component))
    )
  );
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
const transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
], transformProps = new Set(transformPropOrder);
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}
const isMotionValue = (value) => !!(value && value.getVelocity), translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
}, numTransforms = transformPropOrder.length;
function buildTransform(transform, { enableHardwareAcceleration = !0, allowTransformNone = !0 }, transformIsDefault, transformTemplate) {
  let transformString = "";
  for (let i = 0; i < numTransforms; i++) {
    const key2 = transformPropOrder[i];
    if (transform[key2] !== void 0) {
      const transformName = translateAlias[key2] || key2;
      transformString += `${transformName}(${transform[key2]}) `;
    }
  }
  return enableHardwareAcceleration && !transform.z && (transformString += "translateZ(0)"), transformString = transformString.trim(), transformTemplate ? transformString = transformTemplate(transform, transformIsDefault ? "" : transformString) : allowTransformNone && transformIsDefault && (transformString = "none"), transformString;
}
const checkStringStartsWith = (token2) => (key2) => typeof key2 == "string" && key2.startsWith(token2), isCSSVariableName = checkStringStartsWith("--"), startsAsVariableToken = checkStringStartsWith("var(--"), isCSSVariableToken = (value) => startsAsVariableToken(value) ? singleCssVariableRegex.test(value.split("/*")[0].trim()) : !1, singleCssVariableRegex = /var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)$/i, getValueAsType = (value, type) => type && typeof value == "number" ? type.transform(value) : value, clamp$1 = (min2, max2, v2) => v2 > max2 ? max2 : v2 < min2 ? min2 : v2, number = {
  test: (v2) => typeof v2 == "number",
  parse: parseFloat,
  transform: (v2) => v2
}, alpha = {
  ...number,
  transform: (v2) => clamp$1(0, 1, v2)
}, scale = {
  ...number,
  default: 1
}, sanitize = (v2) => Math.round(v2 * 1e5) / 1e5, floatRegex = /(-)?([\d]*\.?[\d])+/g, colorRegex = /(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi, singleColorRegex = /^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;
function isString(v2) {
  return typeof v2 == "string";
}
const createUnitType = (unit) => ({
  test: (v2) => isString(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
}), degrees = createUnitType("deg"), percent = createUnitType("%"), px = createUnitType("px"), vh = createUnitType("vh"), vw = createUnitType("vw"), progressPercentage = {
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}, int = {
  ...number,
  transform: Math.round
}, numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  const { style: style2, vars, transform, transformOrigin } = state;
  let hasTransform2 = !1, hasTransformOrigin = !1, transformIsNone = !0;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    }
    const valueType = numberValueTypes[key2], valueAsType = getValueAsType(value, valueType);
    if (transformProps.has(key2)) {
      if (hasTransform2 = !0, transform[key2] = valueAsType, !transformIsNone)
        continue;
      value !== (valueType.default || 0) && (transformIsNone = !1);
    } else key2.startsWith("origin") ? (hasTransformOrigin = !0, transformOrigin[key2] = valueAsType) : style2[key2] = valueAsType;
  }
  if (latestValues.transform || (hasTransform2 || transformTemplate ? style2.transform = buildTransform(state.transform, options, transformIsNone, transformTemplate) : style2.transform && (style2.transform = "none")), hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style2.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
function copyRawValuesOnly(target2, source, props) {
  for (const key2 in source)
    !isMotionValue(source[key2]) && !isForcedMotionValue(key2, props) && (target2[key2] = source[key2]);
}
function useInitialMotionValues({ transformTemplate }, visualState, isStatic) {
  return useMemo(() => {
    const state = createHtmlRenderState();
    return buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate), Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  const styleProp = props.style || {}, style2 = {};
  return copyRawValuesOnly(style2, styleProp, props), Object.assign(style2, useInitialMotionValues(props, visualState, isStatic)), style2;
}
function useHTMLProps(props, visualState, isStatic) {
  const htmlProps = {}, style2 = useStyle(props, visualState, isStatic);
  return props.drag && props.dragListener !== !1 && (htmlProps.draggable = !1, style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none", style2.touchAction = props.drag === !0 ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`), props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap) && (htmlProps.tabIndex = 0), htmlProps.style = style2, htmlProps;
}
const validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || key2.startsWith("onLayout") || validMotionProps.has(key2);
}
let shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  isValidProp && (shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2));
}
try {
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props)
    key2 === "values" && typeof props.values == "object" || (shouldForward(key2) || forwardMotionProps === !0 && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props.draggable && key2.startsWith("onDrag")) && (filteredProps[key2] = props[key2]);
  return filteredProps;
}
function calcOrigin$1(origin2, offset2, size2) {
  return typeof origin2 == "string" ? origin2 : px.transform(offset2 + size2 * origin2);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width), pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
}, camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset2 = 0, useDashCase = !0) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset2);
  const pathLength = px.transform(length2), pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, options, isSVGTag2, transformTemplate) {
  if (buildHTMLStyles(state, latest, options, transformTemplate), isSVGTag2) {
    state.style.viewBox && (state.attrs.viewBox = state.style.viewBox);
    return;
  }
  state.attrs = state.style, state.style = {};
  const { attrs, style: style2, dimensions } = state;
  attrs.transform && (dimensions && (style2.transform = attrs.transform), delete attrs.transform), dimensions && (originX !== void 0 || originY !== void 0 || style2.transform) && (style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5)), attrX !== void 0 && (attrs.x = attrX), attrY !== void 0 && (attrs.y = attrY), attrScale !== void 0 && (attrs.scale = attrScale), pathLength !== void 0 && buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, !1);
}
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
}), isSVGTag = (tag) => typeof tag == "string" && tag.toLowerCase() === "svg";
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = useMemo(() => {
    const state = createSvgRenderState();
    return buildSVGAttrs(state, visualState, { enableHardwareAcceleration: !1 }, isSVGTag(Component), props.transformTemplate), {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props), visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = !1) {
  return (Component, props, ref, { latestValues }, isStatic) => {
    const visualProps = (isSVGComponent(Component) ? useSVGProps : useHTMLProps)(props, latestValues, isStatic, Component), filteredProps = filterProps(props, typeof Component == "string", forwardMotionProps), elementProps = Component !== Fragment ? { ...filteredProps, ...visualProps, ref } : {}, { children } = props, renderedChildren = useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
}
function renderHTML(element, { style: style2, vars }, styleProp, projection) {
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars)
    element.style.setProperty(key2, vars[key2]);
}
const camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs)
    element.setAttribute(camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), renderState.attrs[key2]);
}
function scrapeMotionValuesFromProps$1(props, prevProps) {
  const { style: style2 } = props, newValues = {};
  for (const key2 in style2)
    (isMotionValue(style2[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props)) && (newValues[key2] = style2[key2]);
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps);
  for (const key2 in props)
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  return newValues;
}
function resolveVariantFromProps(props, definition, custom, currentValues = {}, currentVelocity = {}) {
  return typeof definition == "function" && (definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)), typeof definition == "string" && (definition = props.variants && props.variants[definition]), typeof definition == "function" && (definition = definition(custom !== void 0 ? custom : props.custom, currentValues, currentVelocity)), definition;
}
function useConstant(init) {
  const ref = useRef(null);
  return ref.current === null && (ref.current = init()), ref.current;
}
const isKeyframesTarget = (v2) => Array.isArray(v2), isCustomValue = (v2) => !!(v2 && typeof v2 == "object" && v2.mix && v2.toValue), resolveFinalValueInKeyframes = (v2) => isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, createRenderState, onMount }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps2),
    renderState: createRenderState()
  };
  return onMount && (state.mount = (instance) => onMount(props, instance, state)), state;
}
const makeUseVisualState = (config) => (props, isStatic) => {
  const context = useContext(MotionContext), presenceContext = useContext(PresenceContext), make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {}, motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues)
    values[key2] = resolveMotionValue(motionValues[key2]);
  let { initial, animate } = props;
  const isControllingVariants$1 = isControllingVariants(props), isVariantNode$1 = isVariantNode(props);
  context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== !1 && (initial === void 0 && (initial = context.initial), animate === void 0 && (animate = context.animate));
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === !1 : !1;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === !1;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  return variantToSet && typeof variantToSet != "boolean" && !isAnimationControls(variantToSet) && (Array.isArray(variantToSet) ? variantToSet : [variantToSet]).forEach((definition) => {
    const resolved = resolveVariantFromProps(props, definition);
    if (!resolved)
      return;
    const { transitionEnd, transition, ...target2 } = resolved;
    for (const key2 in target2) {
      let valueTarget = target2[key2];
      if (Array.isArray(valueTarget)) {
        const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
        valueTarget = valueTarget[index2];
      }
      valueTarget !== null && (values[key2] = valueTarget);
    }
    for (const key2 in transitionEnd)
      values[key2] = transitionEnd[key2];
  }), values;
}
const noop = (any) => any, { schedule: frame, cancel: cancelFrame, state: frameData, steps } = createRenderBatcher(typeof requestAnimationFrame < "u" ? requestAnimationFrame : noop, !0), svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onMount: (props, instance, { renderState, latestValues }) => {
      frame.read(() => {
        try {
          renderState.dimensions = typeof instance.getBBox == "function" ? instance.getBBox() : instance.getBoundingClientRect();
        } catch {
          renderState.dimensions = {
            x: 0,
            y: 0,
            width: 0,
            height: 0
          };
        }
      }), frame.render(() => {
        buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: !1 }, isSVGTag(instance.tagName), props.transformTemplate), renderSVG(instance, renderState);
      });
    }
  })
}, htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function createDomMotionConfig(Component, { forwardMotionProps = !1 }, preloadedFeatures2, createVisualElement) {
  return {
    ...isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig,
    preloadedFeatures: preloadedFeatures2,
    useRender: createUseRender(forwardMotionProps),
    createVisualElement,
    Component
  };
}
function addDomEvent(target2, eventName, handler, options = { passive: !0 }) {
  return target2.addEventListener(eventName, handler, options), () => target2.removeEventListener(eventName, handler);
}
const isPrimaryPointer = (event) => event.pointerType === "mouse" ? typeof event.button != "number" || event.button <= 0 : event.isPrimary !== !1;
function extractEventInfo(event, pointType = "page") {
  return {
    point: {
      x: event[pointType + "X"],
      y: event[pointType + "Y"]
    }
  };
}
const addPointerInfo = (handler) => (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
function addPointerEvent(target2, eventName, handler, options) {
  return addDomEvent(target2, eventName, addPointerInfo(handler), options);
}
const combineFunctions = (a, b) => (v2) => b(a(v2)), pipe = (...transformers) => transformers.reduce(combineFunctions);
function createLock(name2) {
  let lock = null;
  return () => {
    const openLock = () => {
      lock = null;
    };
    return lock === null ? (lock = name2, openLock) : !1;
  };
}
const globalHorizontalLock = createLock("dragHorizontal"), globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  let lock = !1;
  if (drag2 === "y")
    lock = globalVerticalLock();
  else if (drag2 === "x")
    lock = globalHorizontalLock();
  else {
    const openHorizontal = globalHorizontalLock(), openVertical = globalVerticalLock();
    openHorizontal && openVertical ? lock = () => {
      openHorizontal(), openVertical();
    } : (openHorizontal && openHorizontal(), openVertical && openVertical());
  }
  return lock;
}
function isDragActive() {
  const openGestureLock = getGlobalLock(!0);
  return openGestureLock ? (openGestureLock(), !1) : !0;
}
class Feature {
  constructor(node2) {
    this.isMounted = !1, this.node = node2;
  }
  update() {
  }
}
function addHoverEvent(node2, isActive) {
  const eventName = "pointer" + (isActive ? "enter" : "leave"), callbackName = "onHover" + (isActive ? "Start" : "End"), handleEvent = (event, info2) => {
    if (event.pointerType === "touch" || isDragActive())
      return;
    const props = node2.getProps();
    node2.animationState && props.whileHover && node2.animationState.setActive("whileHover", isActive), props[callbackName] && frame.update(() => props[callbackName](event, info2));
  };
  return addPointerEvent(node2.current, eventName, handleEvent, {
    passive: !node2.getProps()[callbackName]
  });
}
class HoverGesture extends Feature {
  mount() {
    this.unmount = pipe(addHoverEvent(this.node, !0), addHoverEvent(this.node, !1));
  }
  unmount() {
  }
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments), this.isActive = !1;
  }
  onFocus() {
    let isFocusVisible = !1;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch {
      isFocusVisible = !0;
    }
    !isFocusVisible || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0);
  }
  onBlur() {
    !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1);
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
}
const isNodeOrChild = (parent, child) => child ? parent === child ? !0 : isNodeOrChild(parent, child.parentElement) : !1;
function fireSyntheticPointerEvent(name2, handler) {
  if (!handler)
    return;
  const syntheticPointerEvent = new PointerEvent("pointer" + name2);
  handler(syntheticPointerEvent, extractEventInfo(syntheticPointerEvent));
}
class PressGesture extends Feature {
  constructor() {
    super(...arguments), this.removeStartListeners = noop, this.removeEndListeners = noop, this.removeAccessibleListeners = noop, this.startPointerPress = (startEvent, startInfo) => {
      if (this.isPressing)
        return;
      this.removeEndListeners();
      const props = this.node.getProps(), removePointerUpListener = addPointerEvent(window, "pointerup", (endEvent, endInfo) => {
        if (!this.checkPressEnd())
          return;
        const { onTap, onTapCancel, globalTapTarget } = this.node.getProps();
        frame.update(() => {
          !globalTapTarget && !isNodeOrChild(this.node.current, endEvent.target) ? onTapCancel && onTapCancel(endEvent, endInfo) : onTap && onTap(endEvent, endInfo);
        });
      }, { passive: !(props.onTap || props.onPointerUp) }), removePointerCancelListener = addPointerEvent(window, "pointercancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo), { passive: !(props.onTapCancel || props.onPointerCancel) });
      this.removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener), this.startPress(startEvent, startInfo);
    }, this.startAccessiblePress = () => {
      const handleKeydown = (keydownEvent) => {
        if (keydownEvent.key !== "Enter" || this.isPressing)
          return;
        const handleKeyup = (keyupEvent) => {
          keyupEvent.key !== "Enter" || !this.checkPressEnd() || fireSyntheticPointerEvent("up", (event, info2) => {
            const { onTap } = this.node.getProps();
            onTap && frame.update(() => onTap(event, info2));
          });
        };
        this.removeEndListeners(), this.removeEndListeners = addDomEvent(this.node.current, "keyup", handleKeyup), fireSyntheticPointerEvent("down", (event, info2) => {
          this.startPress(event, info2);
        });
      }, removeKeydownListener = addDomEvent(this.node.current, "keydown", handleKeydown), handleBlur = () => {
        this.isPressing && fireSyntheticPointerEvent("cancel", (cancelEvent, cancelInfo) => this.cancelPress(cancelEvent, cancelInfo));
      }, removeBlurListener = addDomEvent(this.node.current, "blur", handleBlur);
      this.removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
    };
  }
  startPress(event, info2) {
    this.isPressing = !0;
    const { onTapStart, whileTap } = this.node.getProps();
    whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !0), onTapStart && frame.update(() => onTapStart(event, info2));
  }
  checkPressEnd() {
    return this.removeEndListeners(), this.isPressing = !1, this.node.getProps().whileTap && this.node.animationState && this.node.animationState.setActive("whileTap", !1), !isDragActive();
  }
  cancelPress(event, info2) {
    if (!this.checkPressEnd())
      return;
    const { onTapCancel } = this.node.getProps();
    onTapCancel && frame.update(() => onTapCancel(event, info2));
  }
  mount() {
    const props = this.node.getProps(), removePointerListener = addPointerEvent(props.globalTapTarget ? window : this.node.current, "pointerdown", this.startPointerPress, { passive: !(props.onTapStart || props.onPointerStart) }), removeFocusListener = addDomEvent(this.node.current, "focus", this.startAccessiblePress);
    this.removeStartListeners = pipe(removePointerListener, removeFocusListener);
  }
  unmount() {
    this.removeStartListeners(), this.removeEndListeners(), this.removeAccessibleListeners();
  }
}
const observerCallbacks = /* @__PURE__ */ new WeakMap(), observers = /* @__PURE__ */ new WeakMap(), fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
}, fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  observers.has(lookupRoot) || observers.set(lookupRoot, {});
  const rootObservers = observers.get(lookupRoot), key2 = JSON.stringify(options);
  return rootObservers[key2] || (rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options })), rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  return observerCallbacks.set(element, callback), rootInteresectionObserver.observe(element), () => {
    observerCallbacks.delete(element), rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps(), { root, margin: rootMargin, amount = "some", once } = viewport, options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount == "number" ? amount : thresholdNames[amount]
    }, onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting || (this.isInView = isIntersecting, once && !isIntersecting && this.hasEnteredView))
        return;
      isIntersecting && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", isIntersecting);
      const { onViewportEnter, onViewportLeave } = this.node.getProps(), callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver > "u")
      return;
    const { props, prevProps } = this.node;
    ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps)) && this.startObserver();
  }
  unmount() {
  }
}
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name2) => viewport[name2] !== prevViewport[name2];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return !1;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return !1;
  for (let i = 0; i < prevLength; i++)
    if (prev2[i] !== next2[i])
      return !1;
  return !0;
}
function getCurrent(visualElement) {
  const current = {};
  return visualElement.values.forEach((value, key2) => current[key2] = value.get()), current;
}
function getVelocity$1(visualElement) {
  const velocity = {};
  return visualElement.values.forEach((value, key2) => velocity[key2] = value.getVelocity()), velocity;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, getCurrent(visualElement), getVelocity$1(visualElement));
}
let warning = noop, invariant = noop;
process.env.NODE_ENV !== "production" && (warning = (check2, message) => {
  !check2 && typeof console < "u" && console.warn(message);
}, invariant = (check2, message) => {
  if (!check2)
    throw new Error(message);
});
const secondsToMilliseconds = (seconds) => seconds * 1e3, millisecondsToSeconds = (milliseconds) => milliseconds / 1e3, instantAnimationState = {
  current: !1
}, isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] == "number";
function isWaapiSupportedEasing(easing) {
  return !!(!easing || typeof easing == "string" && supportedWaapiEasing[easing] || isBezierDefinition(easing) || Array.isArray(easing) && easing.every(isWaapiSupportedEasing));
}
const cubicBezierAsString = ([a, b, c, d]) => `cubic-bezier(${a}, ${b}, ${c}, ${d})`, supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};
function mapEasingToNativeEasing(easing) {
  if (easing)
    return isBezierDefinition(easing) ? cubicBezierAsString(easing) : Array.isArray(easing) ? easing.map(mapEasingToNativeEasing) : supportedWaapiEasing[easing];
}
function animateStyle(element, valueName, keyframes2, { delay: delay2 = 0, duration, repeat = 0, repeatType = "loop", ease: ease2, times: times2 } = {}) {
  const keyframeOptions = { [valueName]: keyframes2 };
  times2 && (keyframeOptions.offset = times2);
  const easing = mapEasingToNativeEasing(ease2);
  return Array.isArray(easing) && (keyframeOptions.easing = easing), element.animate(keyframeOptions, {
    delay: delay2,
    duration,
    easing: Array.isArray(easing) ? "linear" : easing,
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }) {
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : keyframes2.length - 1;
  return keyframes2[index2];
}
const calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t, subdivisionPrecision = 1e-7, subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX, currentT, i = 0;
  do
    currentT = lowerBound + (upperBound - lowerBound) / 2, currentX = calcBezier(currentT, mX1, mX2) - x2, currentX > 0 ? upperBound = currentT : lowerBound = currentT;
  while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}
const easeIn = cubicBezier(0.42, 0, 1, 1), easeOut = cubicBezier(0, 0, 0.58, 1), easeInOut = cubicBezier(0.42, 0, 0.58, 1), isEasingArray = (ease2) => Array.isArray(ease2) && typeof ease2[0] != "number", mirrorEasing = (easing) => (p) => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2, reverseEasing = (easing) => (p) => 1 - easing(1 - p), circIn = (p) => 1 - Math.sin(Math.acos(p)), circOut = reverseEasing(circIn), circInOut = mirrorEasing(circIn), backOut = cubicBezier(0.33, 1.53, 0.69, 0.99), backIn = reverseEasing(backOut), backInOut = mirrorEasing(backIn), anticipate = (p) => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1))), easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
}, easingDefinitionToFunction = (definition) => {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition == "string")
    return invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`), easingLookup[definition];
  return definition;
}, progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
}, mixNumber$1 = (from2, to, progress2) => from2 + (to - from2) * progress2;
function hueToRgb(p, q2, t) {
  return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + (q2 - p) * 6 * t : t < 1 / 2 ? q2 : t < 2 / 3 ? p + (q2 - p) * (2 / 3 - t) * 6 : p;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360, saturation /= 100, lightness /= 100;
  let red2 = 0, green2 = 0, blue2 = 0;
  if (!saturation)
    red2 = green2 = blue2 = lightness;
  else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation, p = 2 * lightness - q2;
    red2 = hueToRgb(p, q2, hue + 1 / 3), green2 = hueToRgb(p, q2, hue), blue2 = hueToRgb(p, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}
const isColorString = (type, testProp) => (v2) => !!(isString(v2) && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp)), splitColor = (aName, bName, cName) => (v2) => {
  if (!isString(v2))
    return v2;
  const [a, b, c, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
}, clampRgbUnit = (v2) => clamp$1(0, 255, v2), rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
}, rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$12 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
};
function parseHex(v2) {
  let r = "", g2 = "", b = "", a = "";
  return v2.length > 5 ? (r = v2.substring(1, 3), g2 = v2.substring(3, 5), b = v2.substring(5, 7), a = v2.substring(7, 9)) : (r = v2.substring(1, 2), g2 = v2.substring(2, 3), b = v2.substring(3, 4), a = v2.substring(4, 5), r += r, g2 += g2, b += b, a += a), {
    red: parseInt(r, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
}, hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$12 = 1 }) => "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$12)) + ")"
}, mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2, expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
}, colorTypes = [hex, rgba, hsla], getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color2) {
  const type = getColorType(color2);
  invariant(!!type, `'${color2}' is not an animatable color. Use the equivalent color code instead.`);
  let model = type.parse(color2);
  return type === hsla && (model = hslaToRgba(model)), model;
}
const mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2), toRGBA = asRGBA(to), blended = { ...fromRGBA };
  return (v2) => (blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2), blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2), blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2), blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v2), rgba.transform(blended));
}, color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => rgba.test(v2) ? rgba.parse(v2) : hsla.test(v2) ? hsla.parse(v2) : hex.parse(v2),
  transform: (v2) => isString(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2)
};
function test(v2) {
  var _a, _b;
  return isNaN(v2) && isString(v2) && (((_a = v2.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const NUMBER_TOKEN = "number", COLOR_TOKEN = "color", VAR_TOKEN = "var", VAR_FUNCTION_TOKEN = "var(", SPLIT_TOKEN = "${}", complexRegex = /(var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\))|(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))|((-)?([\d]*\.?[\d])+)/gi;
function analyseComplexValue(value) {
  const originalValue = value.toString(), matchedValues = originalValue.match(complexRegex) || [], values = [], indexes = {
    color: [],
    number: [],
    var: []
  }, types2 = [];
  for (let i = 0; i < matchedValues.length; i++) {
    const parsedValue = matchedValues[i];
    color.test(parsedValue) ? (indexes.color.push(i), types2.push(COLOR_TOKEN), values.push(color.parse(parsedValue))) : parsedValue.startsWith(VAR_FUNCTION_TOKEN) ? (indexes.var.push(i), types2.push(VAR_TOKEN), values.push(parsedValue)) : (indexes.number.push(i), types2.push(NUMBER_TOKEN), values.push(parseFloat(parsedValue)));
  }
  const split = originalValue.replace(complexRegex, SPLIT_TOKEN).split(SPLIT_TOKEN);
  return { values, split, indexes, types: types2 };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types: types2 } = analyseComplexValue(source), numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i = 0; i < numSections; i++)
      if (output += split[i], v2[i] !== void 0) {
        const type = types2[i];
        type === NUMBER_TOKEN ? output += sanitize(v2[i]) : type === COLOR_TOKEN ? output += color.transform(v2[i]) : output += v2[i];
      }
    return output;
  };
}
const convertNumbersToZero = (v2) => typeof v2 == "number" ? 0 : v2;
function getAnimatableNone$1(v2) {
  const parsed = parseComplexValue(v2);
  return createTransformer(v2)(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};
function mixImmediate(a, b) {
  return (p) => p > 0 ? b : a;
}
function mixNumber(a, b) {
  return (p) => mixNumber$1(a, b, p);
}
function getMixer(a) {
  return typeof a == "number" ? mixNumber : typeof a == "string" ? isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex : Array.isArray(a) ? mixArray : typeof a == "object" ? color.test(a) ? mixColor : mixObject : mixImmediate;
}
function mixArray(a, b) {
  const output = [...a], numValues = output.length, blendValue = a.map((v2, i) => getMixer(v2)(v2, b[i]));
  return (p) => {
    for (let i = 0; i < numValues; i++)
      output[i] = blendValue[i](p);
    return output;
  };
}
function mixObject(a, b) {
  const output = { ...a, ...b }, blendValue = {};
  for (const key2 in output)
    a[key2] !== void 0 && b[key2] !== void 0 && (blendValue[key2] = getMixer(a[key2])(a[key2], b[key2]));
  return (v2) => {
    for (const key2 in blendValue)
      output[key2] = blendValue[key2](v2);
    return output;
  };
}
function matchOrder(origin2, target2) {
  var _a;
  const orderedOrigin = [], pointers = { color: 0, var: 0, number: 0 };
  for (let i = 0; i < target2.values.length; i++) {
    const type = target2.types[i], originIndex = origin2.indexes[type][pointers[type]], originValue = (_a = origin2.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i] = originValue, pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin2, target2) => {
  const template = complex.createTransformer(target2), originStats = analyseComplexValue(origin2), targetStats = analyseComplexValue(target2);
  return originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length ? pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template) : (warning(!0, `Complex values '${origin2}' and '${target2}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`), mixImmediate(origin2, target2));
};
function mix(from2, to, p) {
  return typeof from2 == "number" && typeof to == "number" && typeof p == "number" ? mixNumber$1(from2, to, p) : getMixer(from2)(from2, to);
}
function createMixers(output, ease2, customMixer) {
  const mixers = [], mixerFactory = customMixer || mix, numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = !0, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  if (invariant(inputLength === output.length, "Both input and output ranges must be the same length"), inputLength === 1)
    return () => output[0];
  input[0] > input[inputLength - 1] && (input = [...input].reverse(), output = [...output].reverse());
  const mixers = createMixers(output, ease2, mixer), numMixers = mixers.length, interpolator = (v2) => {
    let i = 0;
    if (numMixers > 1)
      for (; i < input.length - 2 && !(v2 < input[i + 1]); i++)
        ;
    const progressInRange = progress(input[i], input[i + 1], v2);
    return mixers[i](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp$1(input[0], input[inputLength - 1], v2)) : interpolator;
}
function fillOffset(offset2, remaining) {
  const min2 = offset2[offset2.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = progress(0, remaining, i);
    offset2.push(mixNumber$1(min2, 1, offsetProgress));
  }
}
function defaultOffset(arr) {
  const offset2 = [0];
  return fillOffset(offset2, arr.length - 1), offset2;
}
function convertOffsetToTimes(offset2, duration) {
  return offset2.map((o) => o * duration);
}
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times: times2, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2), state = {
    done: !1,
    value: keyframeValues[0]
  }, absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times2 && times2.length === keyframeValues.length ? times2 : defaultOffset(keyframeValues),
    duration
  ), mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t) => (state.value = mapTimeToKeyframe(t), state.done = t >= duration, state)
  };
}
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}
const velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
const safeMin = 1e-3, minDuration = 0.01, maxDuration$1 = 10, minDamping = 0.05, maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope, derivative;
  warning(duration <= secondsToMilliseconds(maxDuration$1), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp$1(minDamping, maxDamping, dampingRatio), duration = clamp$1(minDuration, maxDuration$1, millisecondsToSeconds(duration)), dampingRatio < 1 ? (envelope = (undampedFreq2) => {
    const exponentialDecay = undampedFreq2 * dampingRatio, delta2 = exponentialDecay * duration, a = exponentialDecay - velocity, b = calcAngularFreq(undampedFreq2, dampingRatio), c = Math.exp(-delta2);
    return safeMin - a / b * c;
  }, derivative = (undampedFreq2) => {
    const delta2 = undampedFreq2 * dampingRatio * duration, d = delta2 * velocity + velocity, e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration, f2 = Math.exp(-delta2), g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
    return (-envelope(undampedFreq2) + safeMin > 0 ? -1 : 1) * ((d - e) * f2) / g2;
  }) : (envelope = (undampedFreq2) => {
    const a = Math.exp(-undampedFreq2 * duration), b = (undampedFreq2 - velocity) * duration + 1;
    return -safeMin + a * b;
  }, derivative = (undampedFreq2) => {
    const a = Math.exp(-undampedFreq2 * duration), b = (velocity - undampedFreq2) * (duration * duration);
    return a * b;
  });
  const initialGuess = 5 / duration, undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  if (duration = secondsToMilliseconds(duration), isNaN(undampedFreq))
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++)
    result = result - envelope(result) / derivative(result);
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"], physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: 0,
    stiffness: 100,
    damping: 10,
    mass: 1,
    isResolvedFromDuration: !1,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = {
      ...springOptions,
      ...derived,
      mass: 1
    }, springOptions.isResolvedFromDuration = !0;
  }
  return springOptions;
}
function spring({ keyframes: keyframes2, restDelta, restSpeed, ...options }) {
  const origin2 = keyframes2[0], target2 = keyframes2[keyframes2.length - 1], state = { done: !1, value: origin2 }, { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  }), initialVelocity = velocity || 0, dampingRatio = damping / (2 * Math.sqrt(stiffness * mass)), initialDelta = target2 - origin2, undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass)), isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? 0.01 : 2), restDelta || (restDelta = isGranularScale ? 5e-3 : 0.5);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target2 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1)
    resolveSpring = (t) => target2 - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t), freqForT = Math.min(dampedAngularFreq * t, 300);
      return target2 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  return {
    calculatedDuration: isResolvedFromDuration && duration || null,
    next: (t) => {
      const current = resolveSpring(t);
      if (isResolvedFromDuration)
        state.done = t >= duration;
      else {
        let currentVelocity = initialVelocity;
        t !== 0 && (dampingRatio < 1 ? currentVelocity = calcGeneratorVelocity(resolveSpring, t, current) : currentVelocity = 0);
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed, isBelowDisplacementThreshold = Math.abs(target2 - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      }
      return state.value = state.done ? target2 : current, state;
    }
  };
}
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin2 = keyframes2[0], state = {
    done: !1,
    value: origin2
  }, isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2, nearestBoundary = (v2) => min2 === void 0 ? max2 : max2 === void 0 || Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  let amplitude = power * velocity;
  const ideal = origin2 + amplitude, target2 = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  target2 !== ideal && (amplitude = target2 - origin2);
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant), calcLatest = (t) => target2 + calcDelta(t), applyFriction = (t) => {
    const delta2 = calcDelta(t), latest = calcLatest(t);
    state.done = Math.abs(delta2) <= restDelta, state.value = state.done ? target2 : latest;
  };
  let timeReachedBoundary, spring$1;
  const checkCatchBoundary = (t) => {
    isOutOfBounds(state.value) && (timeReachedBoundary = t, spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    }));
  };
  return checkCatchBoundary(0), {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = !1;
      return !spring$1 && timeReachedBoundary === void 0 && (hasUpdatedFrame = !0, applyFriction(t), checkCatchBoundary(t)), timeReachedBoundary !== void 0 && t > timeReachedBoundary ? spring$1.next(t - timeReachedBoundary) : (!hasUpdatedFrame && applyFriction(t), state);
    }
  };
}
let now;
function clearTime() {
  now = void 0;
}
const time$1 = {
  now: () => (now === void 0 && time$1.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now()), now),
  set: (newTime) => {
    now = newTime, queueMicrotask(clearTime);
  }
}, frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, !0),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time$1.now()
  };
}, maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  for (; !state.done && duration < maxGeneratorDuration; )
    duration += timeStep, state = generator.next(duration);
  return duration >= maxGeneratorDuration ? 1 / 0 : duration;
}
const types = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
}, percentToProgress = (percent2) => percent2 / 100;
function animateValue({ autoplay = !0, delay: delay2 = 0, driver = frameloopDriver, keyframes: keyframes$1, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", onPlay, onStop, onComplete, onUpdate, ...options }) {
  let speed = 1, hasStopped = !1, resolveFinishedPromise, currentFinishedPromise;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let animationDriver;
  const generatorFactory = types[type] || keyframes;
  let mapNumbersToKeyframes;
  generatorFactory !== keyframes && typeof keyframes$1[0] != "number" && (process.env.NODE_ENV !== "production" && invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`), mapNumbersToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1])), keyframes$1 = [0, 100]);
  const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
  let mirroredGenerator;
  repeatType === "mirror" && (mirroredGenerator = generatorFactory({
    ...options,
    keyframes: [...keyframes$1].reverse(),
    velocity: -(options.velocity || 0)
  }));
  let playState = "idle", holdTime = null, startTime = null, cancelTime = null;
  generator.calculatedDuration === null && repeat && (generator.calculatedDuration = calcGeneratorDuration(generator));
  const { calculatedDuration } = generator;
  let resolvedDuration = 1 / 0, totalDuration = 1 / 0;
  calculatedDuration !== null && (resolvedDuration = calculatedDuration + repeatDelay, totalDuration = resolvedDuration * (repeat + 1) - repeatDelay);
  let currentTime = 0;
  const tick = (timestamp) => {
    if (startTime === null)
      return;
    speed > 0 && (startTime = Math.min(startTime, timestamp)), speed < 0 && (startTime = Math.min(timestamp - totalDuration / speed, startTime)), holdTime !== null ? currentTime = holdTime : currentTime = Math.round(timestamp - startTime) * speed;
    const timeWithoutDelay = currentTime - delay2 * (speed >= 0 ? 1 : -1), isInDelayPhase = speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    currentTime = Math.max(timeWithoutDelay, 0), playState === "finished" && holdTime === null && (currentTime = totalDuration);
    let elapsed = currentTime, frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2), iterationProgress = progress2 % 1;
      !iterationProgress && progress2 >= 1 && (iterationProgress = 1), iterationProgress === 1 && currentIteration--, currentIteration = Math.min(currentIteration, repeat + 1), !!(currentIteration % 2) && (repeatType === "reverse" ? (iterationProgress = 1 - iterationProgress, repeatDelay && (iterationProgress -= repeatDelay / resolvedDuration)) : repeatType === "mirror" && (frameGenerator = mirroredGenerator)), elapsed = clamp$1(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: !1, value: keyframes$1[0] } : frameGenerator.next(elapsed);
    mapNumbersToKeyframes && (state.value = mapNumbersToKeyframes(state.value));
    let { done } = state;
    !isInDelayPhase && calculatedDuration !== null && (done = speed >= 0 ? currentTime >= totalDuration : currentTime <= 0);
    const isAnimationFinished = holdTime === null && (playState === "finished" || playState === "running" && done);
    return onUpdate && onUpdate(state.value), isAnimationFinished && finish(), state;
  }, stopAnimationDriver = () => {
    animationDriver && animationDriver.stop(), animationDriver = void 0;
  }, cancel = () => {
    playState = "idle", stopAnimationDriver(), resolveFinishedPromise(), updateFinishedPromise(), startTime = cancelTime = null;
  }, finish = () => {
    playState = "finished", onComplete && onComplete(), stopAnimationDriver(), resolveFinishedPromise();
  }, play = () => {
    if (hasStopped)
      return;
    animationDriver || (animationDriver = driver(tick));
    const now2 = animationDriver.now();
    onPlay && onPlay(), holdTime !== null ? startTime = now2 - holdTime : (!startTime || playState === "finished") && (startTime = now2), playState === "finished" && updateFinishedPromise(), cancelTime = startTime, holdTime = null, playState = "running", animationDriver.start();
  };
  autoplay && play();
  const controls = {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    get time() {
      return millisecondsToSeconds(currentTime);
    },
    set time(newTime) {
      newTime = secondsToMilliseconds(newTime), currentTime = newTime, holdTime !== null || !animationDriver || speed === 0 ? holdTime = newTime : startTime = animationDriver.now() - newTime / speed;
    },
    get duration() {
      const duration = generator.calculatedDuration === null ? calcGeneratorDuration(generator) : generator.calculatedDuration;
      return millisecondsToSeconds(duration);
    },
    get speed() {
      return speed;
    },
    set speed(newSpeed) {
      newSpeed === speed || !animationDriver || (speed = newSpeed, controls.time = millisecondsToSeconds(currentTime));
    },
    get state() {
      return playState;
    },
    play,
    pause: () => {
      playState = "paused", holdTime = currentTime;
    },
    stop: () => {
      hasStopped = !0, playState !== "idle" && (playState = "idle", onStop && onStop(), cancel());
    },
    cancel: () => {
      cancelTime !== null && tick(cancelTime), cancel();
    },
    complete: () => {
      playState = "finished";
    },
    sample: (elapsed) => (startTime = 0, tick(elapsed))
  };
  return controls;
}
function memo(callback) {
  let result;
  return () => (result === void 0 && (result = callback()), result);
}
const supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate")), acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
]), sampleDelta = 10, maxDuration = 2e4, requiresPregeneratedKeyframes = (valueName, options) => options.type === "spring" || valueName === "backgroundColor" || !isWaapiSupportedEasing(options.ease);
function createAcceleratedAnimation(value, valueName, { onUpdate, onComplete, ...options }) {
  if (!(supportsWaapi() && acceleratedValues.has(valueName) && !options.repeatDelay && options.repeatType !== "mirror" && options.damping !== 0 && options.type !== "inertia"))
    return !1;
  let hasStopped = !1, resolveFinishedPromise, currentFinishedPromise, pendingCancel = !1;
  const updateFinishedPromise = () => {
    currentFinishedPromise = new Promise((resolve) => {
      resolveFinishedPromise = resolve;
    });
  };
  updateFinishedPromise();
  let { keyframes: keyframes2, duration = 300, ease: ease2, times: times2 } = options;
  if (requiresPregeneratedKeyframes(valueName, options)) {
    const sampleAnimation = animateValue({
      ...options,
      repeat: 0,
      delay: 0
    });
    let state = { done: !1, value: keyframes2[0] };
    const pregeneratedKeyframes = [];
    let t = 0;
    for (; !state.done && t < maxDuration; )
      state = sampleAnimation.sample(t), pregeneratedKeyframes.push(state.value), t += sampleDelta;
    times2 = void 0, keyframes2 = pregeneratedKeyframes, duration = t - sampleDelta, ease2 = "linear";
  }
  const animation2 = animateStyle(value.owner.current, valueName, keyframes2, {
    ...options,
    duration,
    /**
     * This function is currently not called if ease is provided
     * as a function so the cast is safe.
     *
     * However it would be possible for a future refinement to port
     * in easing pregeneration from Motion One for browsers that
     * support the upcoming `linear()` easing function.
     */
    ease: ease2,
    times: times2
  }), cancelAnimation = () => {
    pendingCancel = !1, animation2.cancel();
  }, safeCancel = () => {
    pendingCancel = !0, frame.update(cancelAnimation), resolveFinishedPromise(), updateFinishedPromise();
  };
  return animation2.onfinish = () => {
    pendingCancel || (value.set(getFinalKeyframe(keyframes2, options)), onComplete && onComplete(), safeCancel());
  }, {
    then(resolve, reject) {
      return currentFinishedPromise.then(resolve, reject);
    },
    attachTimeline(timeline) {
      return animation2.timeline = timeline, animation2.onfinish = null, noop;
    },
    get time() {
      return millisecondsToSeconds(animation2.currentTime || 0);
    },
    set time(newTime) {
      animation2.currentTime = secondsToMilliseconds(newTime);
    },
    get speed() {
      return animation2.playbackRate;
    },
    set speed(newSpeed) {
      animation2.playbackRate = newSpeed;
    },
    get duration() {
      return millisecondsToSeconds(duration);
    },
    play: () => {
      hasStopped || (animation2.play(), cancelFrame(cancelAnimation));
    },
    pause: () => animation2.pause(),
    stop: () => {
      if (hasStopped = !0, animation2.playState === "idle")
        return;
      const { currentTime } = animation2;
      if (currentTime) {
        const sampleAnimation = animateValue({
          ...options,
          autoplay: !1
        });
        value.setWithVelocity(sampleAnimation.sample(currentTime - sampleDelta).value, sampleAnimation.sample(currentTime).value, sampleDelta);
      }
      safeCancel();
    },
    complete: () => {
      pendingCancel || animation2.finish();
    },
    cancel: safeCancel
  };
}
function createInstantAnimation({ keyframes: keyframes2, delay: delay2, onUpdate, onComplete }) {
  const setValue = () => (onUpdate && onUpdate(keyframes2[keyframes2.length - 1]), onComplete && onComplete(), {
    time: 0,
    speed: 1,
    duration: 0,
    play: noop,
    pause: noop,
    stop: noop,
    then: (resolve) => (resolve(), Promise.resolve()),
    cancel: noop,
    complete: noop
  });
  return delay2 ? animateValue({
    keyframes: [0, 1],
    duration: 0,
    delay: delay2,
    onComplete: setValue
  }) : setValue();
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
}, criticallyDampedSpring = (target2) => ({
  type: "spring",
  stiffness: 550,
  damping: target2 === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
}), keyframesTransition = {
  type: "keyframes",
  duration: 0.8
}, ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
}, getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => keyframes2.length > 2 ? keyframesTransition : transformProps.has(valueKey) ? valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring : ease, isAnimatable = (key2, value) => key2 === "zIndex" ? !1 : !!(typeof value == "number" || Array.isArray(value) || typeof value == "string" && // It's animatable if we have a string
(complex.test(value) || value === "0") && // And it contains numbers and/or colors
!value.startsWith("url(")), maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name2, value] = v2.slice(0, -1).split("(");
  if (name2 === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name2) ? 1 : 0;
  return number2 !== value && (defaultValue *= 100), name2 + "(" + defaultValue + unit + ")";
}
const functionRegex = /([a-z-]*)\(.*?\)/g, filter = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
}, defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
}, getDefaultValueType = (key2) => defaultValueTypes[key2];
function getAnimatableNone(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  return defaultValueType !== filter && (defaultValueType = complex), defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}
const isZeroValueString = (v2) => /^0[^.\s]+$/.test(v2);
function isNone(value) {
  if (typeof value == "number")
    return value === 0;
  if (value !== null)
    return value === "none" || value === "0" || isZeroValueString(value);
}
function getKeyframes(value, valueName, target2, transition) {
  const isTargetAnimatable = isAnimatable(valueName, target2);
  let keyframes2;
  Array.isArray(target2) ? keyframes2 = [...target2] : keyframes2 = [null, target2];
  const defaultOrigin = transition.from !== void 0 ? transition.from : value.get();
  let animatableTemplateValue;
  const noneKeyframeIndexes = [];
  for (let i = 0; i < keyframes2.length; i++)
    keyframes2[i] === null && (keyframes2[i] = i === 0 ? defaultOrigin : keyframes2[i - 1]), isNone(keyframes2[i]) && noneKeyframeIndexes.push(i), typeof keyframes2[i] == "string" && keyframes2[i] !== "none" && keyframes2[i] !== "0" && (animatableTemplateValue = keyframes2[i]);
  if (isTargetAnimatable && noneKeyframeIndexes.length && animatableTemplateValue)
    for (let i = 0; i < noneKeyframeIndexes.length; i++) {
      const index2 = noneKeyframeIndexes[i];
      keyframes2[index2] = getAnimatableNone(valueName, animatableTemplateValue);
    }
  return keyframes2;
}
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}
function getValueTransition(transition, key2) {
  return transition[key2] || transition.default || transition;
}
const animateMotionValue = (valueName, value, target2, transition = {}) => (onComplete) => {
  const valueTransition = getValueTransition(transition, valueName) || {}, delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  const keyframes2 = getKeyframes(value, valueName, target2, valueTransition), originKeyframe = keyframes2[0], targetKeyframe = keyframes2[keyframes2.length - 1], isOriginAnimatable = isAnimatable(valueName, originKeyframe), isTargetAnimatable = isAnimatable(valueName, targetKeyframe);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${valueName} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  let options = {
    keyframes: keyframes2,
    velocity: value.getVelocity(),
    ease: "easeOut",
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2), valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete(), valueTransition.onComplete && valueTransition.onComplete();
    }
  };
  if (isTransitionDefined(valueTransition) || (options = {
    ...options,
    ...getDefaultTransition(valueName, options)
  }), options.duration && (options.duration = secondsToMilliseconds(options.duration)), options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay)), !isOriginAnimatable || !isTargetAnimatable || instantAnimationState.current || valueTransition.type === !1 || MotionGlobalConfig.skipAnimations)
    return createInstantAnimation(options);
  if (
    /**
     * If this is a handoff animation, the optimised animation will be running via
     * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
     * optimised animation.
     */
    !transition.isHandoff && value.owner && value.owner.current instanceof HTMLElement && /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !value.owner.getProps().onUpdate
  ) {
    const acceleratedAnimation = createAcceleratedAnimation(value, valueName, options);
    if (acceleratedAnimation)
      return acceleratedAnimation;
  }
  return animateValue(options);
};
function isWillChangeMotionValue(value) {
  return !!(isMotionValue(value) && value.add);
}
const isNumericalString = (v2) => /^\-?\d*\.?\d+$/.test(v2);
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  index2 > -1 && arr.splice(index2, 1);
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    return addUniqueItem(this.subscriptions, handler), () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (numSubscriptions)
      if (numSubscriptions === 1)
        this.subscriptions[0](a, b, c);
      else
        for (let i = 0; i < numSubscriptions; i++) {
          const handler = this.subscriptions[i];
          handler && handler(a, b, c);
        }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}
const warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  condition || warned.has(message) || (console.warn(message), warned.add(message));
}
const MAX_VELOCITY_DELTA = 30, isFloat = (value) => !isNaN(parseFloat(value));
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    this.version = "11.0.8", this.canTrackVelocity = !1, this.events = {}, this.updateAndNotify = (v2, render = !0) => {
      const currentTime = time$1.now();
      this.updatedAt !== currentTime && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(v2), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), render && this.events.renderRequest && this.events.renderRequest.notify(this.current);
    }, this.hasAnimated = !1, this.setCurrent(init), this.canTrackVelocity = isFloat(this.current), this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current, this.updatedAt = time$1.now();
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue, this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    return process.env.NODE_ENV !== "production" && warnOnce(!1, 'value.onChange(callback) is deprecated. Switch to value.on("change", callback).'), this.on("change", subscription);
  }
  on(eventName, callback) {
    this.events[eventName] || (this.events[eventName] = new SubscriptionManager());
    const unsubscribe = this.events[eventName].add(callback);
    return eventName === "change" ? () => {
      unsubscribe(), frame.read(() => {
        this.events.change.getSize() || this.stop();
      });
    } : unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events)
      this.events[eventManagers].clear();
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect, this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = !0) {
    !render || !this.passiveEffect ? this.updateAndNotify(v2, render) : this.passiveEffect(v2, this.updateAndNotify);
  }
  setWithVelocity(prev2, current, delta2) {
    this.set(current), this.prev = void 0, this.prevFrameValue = prev2, this.prevUpdatedAt = this.updatedAt - delta2;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2) {
    this.updateAndNotify(v2), this.prev = v2, this.prevUpdatedAt = this.prevFrameValue = void 0, this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time$1.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA)
      return 0;
    const delta2 = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta2);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    return this.stop(), new Promise((resolve) => {
      this.hasAnimated = !0, this.animation = startAnimation(resolve), this.events.animationStart && this.events.animationStart.notify();
    }).then(() => {
      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}
const testValueType = (v2) => (type) => type.test(v2), auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
}, dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto], findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2)), valueTypes = [...dimensionValueTypes, color, complex], findValueType = (v2) => valueTypes.find(testValueType(v2));
function setMotionValue(visualElement, key2, value) {
  visualElement.hasValue(key2) ? visualElement.getValue(key2).set(value) : visualElement.addValue(key2, motionValue(value));
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target2 } = resolved ? visualElement.makeTargetAnimatable(resolved, !1) : {};
  target2 = { ...target2, ...transitionEnd };
  for (const key2 in target2) {
    const value = resolveFinalValueInKeyframes(target2[key2]);
    setMotionValue(visualElement, key2, value);
  }
}
function checkTargetForNewValues(visualElement, target2, origin2) {
  var _a, _b;
  const newValueKeys = Object.keys(target2).filter((key2) => !visualElement.hasValue(key2)), numNewValues = newValueKeys.length;
  if (numNewValues)
    for (let i = 0; i < numNewValues; i++) {
      const key2 = newValueKeys[i], targetValue = target2[key2];
      let value = null;
      Array.isArray(targetValue) && (value = targetValue[0]), value === null && (value = (_b = (_a = origin2[key2]) !== null && _a !== void 0 ? _a : visualElement.readValue(key2)) !== null && _b !== void 0 ? _b : target2[key2]), value != null && (typeof value == "string" && (isNumericalString(value) || isZeroValueString(value)) ? value = parseFloat(value) : !findValueType(value) && complex.test(targetValue) && (value = getAnimatableNone(key2, targetValue)), visualElement.addValue(key2, motionValue(value, { owner: visualElement })), origin2[key2] === void 0 && (origin2[key2] = value), value !== null && visualElement.setBaseTarget(key2, value));
    }
}
function getOriginFromTransition(key2, transition) {
  return transition ? (transition[key2] || transition.default || transition).from : void 0;
}
function getOrigin(target2, transition, visualElement) {
  const origin2 = {};
  for (const key2 in target2) {
    const transitionOrigin = getOriginFromTransition(key2, transition);
    if (transitionOrigin !== void 0)
      origin2[key2] = transitionOrigin;
    else {
      const value = visualElement.getValue(key2);
      value && (origin2[key2] = value.get());
    }
  }
  return origin2;
}
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== !0;
  return needsAnimating[key2] = !1, shouldBlock;
}
function hasKeyframesChanged(value, target2) {
  const current = value.get();
  if (Array.isArray(target2)) {
    for (let i = 0; i < target2.length; i++)
      if (target2[i] !== current)
        return !0;
  } else
    return current !== target2;
}
function animateTarget(visualElement, definition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target2 } = visualElement.makeTargetAnimatable(definition);
  const willChange = visualElement.getValue("willChange");
  transitionOverride && (transition = transitionOverride);
  const animations2 = [], animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target2) {
    const value = visualElement.getValue(key2), valueTarget = target2[key2];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2))
      continue;
    const valueTransition = {
      delay: delay2,
      elapsed: 0,
      ...getValueTransition(transition || {}, key2)
    };
    if (window.HandoffAppearAnimations) {
      const appearId = visualElement.getProps()[optimizedAppearDataAttribute];
      if (appearId) {
        const elapsed = window.HandoffAppearAnimations(appearId, key2, value, frame);
        elapsed !== null && (valueTransition.elapsed = elapsed, valueTransition.isHandoff = !0);
      }
    }
    let canSkip = !valueTransition.isHandoff && !hasKeyframesChanged(value, valueTarget);
    if (valueTransition.type === "spring" && (value.getVelocity() || valueTransition.velocity) && (canSkip = !1), value.animation && (canSkip = !1), canSkip)
      continue;
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key2) ? { type: !1 } : valueTransition));
    const animation2 = value.animation;
    isWillChangeMotionValue(willChange) && (willChange.add(key2), animation2.then(() => willChange.remove(key2))), animations2.push(animation2);
  }
  return transitionEnd && Promise.all(animations2).then(() => {
    transitionEnd && setTarget(visualElement, transitionEnd);
  }), animations2;
}
function animateVariant(visualElement, variant, options = {}) {
  const resolved = resolveVariant(visualElement, variant, options.custom);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  options.transitionOverride && (transition = options.transitionOverride);
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve(), getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve(), { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [], maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren, generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  return Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant), animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  }), Promise.all(animations2);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation2;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation2 = Promise.all(animations2);
  } else if (typeof definition == "string")
    animation2 = animateVariant(visualElement, definition, options);
  else {
    const resolvedDefinition = typeof definition == "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation2 = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation2.then(() => visualElement.notify("AnimationComplete", definition));
}
const reversePriorityOrder = [...variantPriorityOrder].reverse(), numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation: animation2, options }) => animateVisualElement(visualElement, animation2, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  const state = createState();
  let isInitialRender = !0;
  const buildResolvedTypeValues = (acc, definition) => {
    const resolved = resolveVariant(visualElement, definition);
    if (resolved) {
      const { transition, transitionEnd, ...target2 } = resolved;
      acc = { ...acc, ...target2, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  function animateChanges(options, changedActiveType) {
    const props = visualElement.getProps(), context = visualElement.getVariantContext(!0) || {}, animations2 = [], removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {}, removedVariantIndex = 1 / 0;
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i], typeState = state[type], prop2 = props[type] !== void 0 ? props[type] : context[type], propIsVariant = isVariantLabel(prop2), activeDelta = type === changedActiveType ? typeState.isActive : null;
      activeDelta === !1 && (removedVariantIndex = i);
      let isInherited = prop2 === context[type] && prop2 !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount && (isInherited = !1), typeState.protectedKeys = { ...encounteredKeys }, // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
      !prop2 && !typeState.prevProp || // Or if the prop doesn't define an animation
      isAnimationControls(prop2) || typeof prop2 == "boolean")
        continue;
      let shouldAnimateType = checkVariantsDidChange(typeState.prevProp, prop2) || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant, handledRemovedValues = !1;
      const definitionList = Array.isArray(prop2) ? prop2 : [prop2];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      activeDelta === !1 && (resolvedValues = {});
      const { prevResolvedValues = {} } = typeState, allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      }, markToAnimate = (key2) => {
        shouldAnimateType = !0, removedKeys.has(key2) && (handledRemovedValues = !0, removedKeys.delete(key2)), typeState.needsAnimating[key2] = !0;
      };
      for (const key2 in allKeys) {
        const next2 = resolvedValues[key2], prev2 = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        let valueHasChanged = !1;
        isKeyframesTarget(next2) && isKeyframesTarget(prev2) ? valueHasChanged = !shallowCompare(next2, prev2) : valueHasChanged = next2 !== prev2, valueHasChanged ? next2 !== void 0 ? markToAnimate(key2) : removedKeys.add(key2) : next2 !== void 0 && removedKeys.has(key2) ? markToAnimate(key2) : typeState.protectedKeys[key2] = !0;
      }
      typeState.prevProp = prop2, typeState.prevResolvedValues = resolvedValues, typeState.isActive && (encounteredKeys = { ...encounteredKeys, ...resolvedValues }), isInitialRender && visualElement.blockInitialAnimation && (shouldAnimateType = !1), shouldAnimateType && (!isInherited || handledRemovedValues) && animations2.push(...definitionList.map((animation2) => ({
        animation: animation2,
        options: { type, ...options }
      })));
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        fallbackTarget !== void 0 && (fallbackAnimation[key2] = fallbackTarget);
      }), animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = !!animations2.length;
    return isInitialRender && (props.initial === !1 || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount && (shouldAnimate = !1), isInitialRender = !1, shouldAnimate ? animate(animations2) : Promise.resolve();
  }
  function setActive(type, isActive, options) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) === null || _a === void 0 || _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(type, isActive);
    }), state[type].isActive = isActive;
    const animations2 = animateChanges(options, type);
    for (const key2 in state)
      state[key2].protectedKeys = {};
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state
  };
}
function checkVariantsDidChange(prev2, next2) {
  return typeof next2 == "string" ? next2 !== prev2 : Array.isArray(next2) ? !shallowCompare(next2, prev2) : !1;
}
function createTypeState(isActive = !1) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(!0),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2), node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate } = this.node.getProps();
    this.unmount(), isAnimationControls(animate) && (this.unmount = animate.subscribe(this.node));
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate } = this.node.getProps(), { animate: prevAnimate } = this.node.prevProps || {};
    animate !== prevAnimate && this.updateAnimationControlsSubscription();
  }
  unmount() {
  }
}
let id$1 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments), this.id = id$1++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete, custom } = this.node.presenceContext, { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent)
      return;
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent, { custom: custom ?? this.node.getProps().custom });
    onExitComplete && !isPresent && exitAnimation.then(() => onExitComplete(this.id));
  }
  mount() {
    const { register: register2 } = this.node.presenceContext || {};
    register2 && (this.unmount = register2(this.id));
  }
  unmount() {
  }
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
}, distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  const xDelta = distance(a.x, b.x), yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
class PanSession {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = !1 } = {}) {
    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info3 = getPanInfo(this.lastMoveEventInfo, this.history), isPanStarted = this.startEvent !== null, isDistancePastThreshold = distance2D(info3.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info3, { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      isPanStarted || (onStart && onStart(this.lastMoveEvent, info3), this.startEvent = this.lastMoveEvent), onMove && onMove(this.lastMoveEvent, info3);
    }, this.handlePointerMove = (event2, info3) => {
      this.lastMoveEvent = event2, this.lastMoveEventInfo = transformPoint(info3, this.transformPagePoint), frame.update(this.updatePoint, !0);
    }, this.handlePointerUp = (event2, info3) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin && resumeAnimation && resumeAnimation(), !(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info3, this.transformPagePoint), this.history);
      this.startEvent && onEnd && onEnd(event2, panInfo), onSessionEnd && onSessionEnd(event2, panInfo);
    }, !isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin, this.handlers = handlers, this.transformPagePoint = transformPagePoint, this.contextWindow = contextWindow || window;
    const info2 = extractEventInfo(event), initialInfo = transformPoint(info2, this.transformPagePoint), { point } = initialInfo, { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history)), this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners(), cancelFrame(this.updatePoint);
  }
}
function transformPoint(info2, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info2.point) } : info2;
}
function subtractPoint(a, b) {
  return { x: a.x - b.x, y: a.y - b.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i = history.length - 1, timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  for (; i >= 0 && (timestampedPoint = history[i], !(lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta))); )
    i--;
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time2 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time2 === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  return currentVelocity.x === 1 / 0 && (currentVelocity.x = 0), currentVelocity.y === 1 / 0 && (currentVelocity.y = 0), currentVelocity;
}
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target2 = 0, maxDistance = 0.01) {
  return Math.abs(value - target2) <= maxDistance;
}
function calcAxisDelta(delta2, source, target2, origin2 = 0.5) {
  delta2.origin = origin2, delta2.originPoint = mixNumber$1(source.min, source.max, delta2.origin), delta2.scale = calcLength(target2) / calcLength(source), (isNear(delta2.scale, 1, 1e-4) || isNaN(delta2.scale)) && (delta2.scale = 1), delta2.translate = mixNumber$1(target2.min, target2.max, delta2.origin) - delta2.originPoint, (isNear(delta2.translate) || isNaN(delta2.translate)) && (delta2.translate = 0);
}
function calcBoxDelta(delta2, source, target2, origin2) {
  calcAxisDelta(delta2.x, source.x, target2.x, origin2 ? origin2.originX : void 0), calcAxisDelta(delta2.y, source.y, target2.y, origin2 ? origin2.originY : void 0);
}
function calcRelativeAxis(target2, relative, parent) {
  target2.min = parent.min + relative.min, target2.max = target2.min + calcLength(relative);
}
function calcRelativeBox(target2, relative, parent) {
  calcRelativeAxis(target2.x, relative.x, parent.x), calcRelativeAxis(target2.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target2, layout2, parent) {
  target2.min = layout2.min - parent.min, target2.max = target2.min + calcLength(layout2);
}
function calcRelativePosition(target2, layout2, parent) {
  calcRelativeAxisPosition(target2.x, layout2.x, parent.x), calcRelativeAxisPosition(target2.y, layout2.y, parent.y);
}
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  return min2 !== void 0 && point < min2 ? point = elastic ? mixNumber$1(min2, point, elastic.min) : Math.max(point, min2) : max2 !== void 0 && point > max2 && (point = elastic ? mixNumber$1(max2, point, elastic.max) : Math.min(point, max2)), point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top: top2, left, bottom: bottom2, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top2, bottom2)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min, max2 = constraintsAxis.max - layoutAxis.max;
  return constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min && ([min2, max2] = [max2, min2]), { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target2) {
  let origin2 = 0.5;
  const sourceLength = calcLength(source), targetLength = calcLength(target2);
  return targetLength > sourceLength ? origin2 = progress(target2.min, target2.max - sourceLength, source.min) : sourceLength > targetLength && (origin2 = progress(source.min, source.max - targetLength, target2.min)), clamp$1(0, 1, origin2);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  return constraints.min !== void 0 && (relativeConstraints.min = constraints.min - layout2.min), constraints.max !== void 0 && (relativeConstraints.max = constraints.max - layout2.min), relativeConstraints;
}
const defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  return dragElastic === !1 ? dragElastic = 0 : dragElastic === !0 && (dragElastic = defaultElastic), {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic == "number" ? dragElastic : dragElastic[label] || 0;
}
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
}), createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
}), createAxis = () => ({ min: 0, max: 0 }), createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}
function convertBoundingBoxToBox({ top: top2, left, right, bottom: bottom2 }) {
  return {
    x: { min: left, max: right },
    y: { min: top2, max: bottom2 }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top }), bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX, scaleY }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint, scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  return boxScale !== void 0 && (point = scalePoint(point, boxScale, originPoint)), scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint), applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = !1) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2, delta2;
  for (let i = 0; i < treeLength; i++) {
    node2 = treePath[i], delta2 = node2.projectionDelta;
    const instance = node2.instance;
    instance && instance.style && instance.style.display === "contents" || (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(box, {
      x: -node2.scroll.offset.x,
      y: -node2.scroll.offset.y
    }), delta2 && (treeScale.x *= delta2.x.scale, treeScale.y *= delta2.y.scale, applyBoxDelta(box, delta2)), isSharedTransition && hasTransform(node2.latestValues) && transformBox(box, node2.latestValues));
  }
  treeScale.x = snapToDefault(treeScale.x), treeScale.y = snapToDefault(treeScale.y);
}
function snapToDefault(scale2) {
  return Number.isInteger(scale2) || scale2 > 1.0000000000001 || scale2 < 0.999999999999 ? scale2 : 1;
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2, axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms, [key2, scaleKey, originKey]) {
  const axisOrigin = transforms[originKey] !== void 0 ? transforms[originKey] : 0.5, originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms[key2], transforms[scaleKey], originPoint, transforms.scale);
}
const xKeys$1 = ["x", "scaleX", "originX"], yKeys$1 = ["y", "scaleY", "originY"];
function transformBox(box, transform) {
  transformAxis(box.x, transform, xKeys$1), transformAxis(box.y, transform, yKeys$1);
}
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint), { scroll } = rootProjectionNode2;
  return scroll && (translateAxis(viewportBox.x, scroll.offset.x), translateAxis(viewportBox.y, scroll.offset.y)), viewportBox;
}
const getContextWindow = ({ current }) => current ? current.ownerDocument.defaultView : null, elementDragControls = /* @__PURE__ */ new WeakMap();
class VisualElementDragControls {
  constructor(visualElement) {
    this.openGlobalLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = createBox(), this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = !1 } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === !1)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation(), snapToCursor && this.snapToCursor(extractEventInfo(event, "page").point);
    }, onStart = (event, info2) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation && (this.openGlobalLock && this.openGlobalLock(), this.openGlobalLock = getGlobalLock(drag2), !this.openGlobalLock))
        return;
      this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            measuredAxis && (current = calcLength(measuredAxis) * (parseFloat(current) / 100));
          }
        }
        this.originPoint[axis] = current;
      }), onDragStart && frame.update(() => onDragStart(event, info2), !1, !0);
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", !0);
    }, onMove = (event, info2) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openGlobalLock)
        return;
      const { offset: offset2 } = info2;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset2), this.currentDirection !== null && onDirectionLock && onDirectionLock(this.currentDirection);
        return;
      }
      this.updateAxis("x", info2.point, offset2), this.updateAxis("y", info2.point, offset2), this.visualElement.render(), onDrag && onDrag(event, info2);
    }, onSessionEnd = (event, info2) => this.stop(event, info2), resumeAnimation = () => eachAxis((axis) => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
    }), { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info2) {
    const isDragging = this.isDragging;
    if (this.cancel(), !isDragging)
      return;
    const { velocity } = info2;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    onDragEnd && frame.update(() => onDragEnd(event, info2));
  }
  cancel() {
    this.isDragging = !1;
    const { projection, animationState } = this.visualElement;
    projection && (projection.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    !dragPropagation && this.openGlobalLock && (this.openGlobalLock(), this.openGlobalLock = null), animationState && animationState.setActive("whileDrag", !1);
  }
  updateAxis(axis, _point, offset2) {
    const { drag: drag2 } = this.getProps();
    if (!offset2 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset2[axis];
    this.constraints && this.constraints[axis] && (next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis])), axisValue.set(next2);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps(), layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout, prevConstraints = this.constraints;
    dragConstraints && isRefObject(dragConstraints) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : dragConstraints && layout2 ? this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints) : this.constraints = !1, this.elastic = resolveDragElastic(dragElastic), prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints && eachAxis((axis) => {
      this.getAxisMotionValue(axis) && (this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]));
    });
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return !1;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return !1;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints, userConstraints && (measuredConstraints = convertBoundingBoxToBox(userConstraints));
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps(), constraints = this.constraints || {}, momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      let transition = constraints && constraints[axis] || {};
      dragSnapToOrigin && (transition = { min: 0, max: 0 });
      const bounceStiffness = dragElastic ? 200 : 1e6, bounceDamping = dragElastic ? 40 : 1e7, inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = "_drag" + axis.toUpperCase(), props = this.visualElement.getProps(), externalMotionValue = props[dragKey];
    return externalMotionValue || this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement, axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps(), { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none", projection.root && projection.root.updateScroll(), projection.updateLayout(), this.resolveConstraints(), eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis), { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber$1(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current, stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = !0 } = this.getProps();
      drag2 && dragListener && this.start(event);
    }), measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      isRefObject(dragConstraints) && (this.constraints = this.resolveRefConstraints());
    }, { projection } = this.visualElement, stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    projection && !projection.layout && (projection.root && projection.root.updateScroll(), projection.updateLayout()), measureDragConstraints();
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints()), stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta: delta2, hasLayoutChanged }) => {
      this.isDragging && hasLayoutChanged && (eachAxis((axis) => {
        const motionValue2 = this.getAxisMotionValue(axis);
        motionValue2 && (this.originPoint[axis] += delta2[axis].translate, motionValue2.set(motionValue2.get() + delta2[axis].translate));
      }), this.visualElement.render());
    });
    return () => {
      stopResizeListener(), stopPointerListener(), stopMeasureLayoutListener(), stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps(), { drag: drag2 = !1, dragDirectionLock = !1, dragPropagation = !1, dragConstraints = !1, dragElastic = defaultElastic, dragMomentum = !0 } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === !0 || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset2, lockThreshold = 10) {
  let direction = null;
  return Math.abs(offset2.y) > lockThreshold ? direction = "y" : Math.abs(offset2.x) > lockThreshold && (direction = "x"), direction;
}
class DragGesture extends Feature {
  constructor(node2) {
    super(node2), this.removeGroupControls = noop, this.removeListeners = noop, this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    dragControls && (this.removeGroupControls = dragControls.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls(), this.removeListeners();
  }
}
const asyncHandler = (handler) => (event, info2) => {
  handler && frame.update(() => handler(event, info2));
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments), this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info2) => {
        delete this.session, onPanEnd && frame.update(() => onPanEnd(event, info2));
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener(), this.session && this.session.end();
  }
}
function usePresence() {
  const context = useContext(PresenceContext);
  if (context === null)
    return [!0, null];
  const { isPresent, onExitComplete, register: register2 } = context, id2 = useId();
  return useEffect(() => register2(id2), []), !isPresent && onExitComplete ? [!1, () => onExitComplete && onExitComplete(id2)] : [!0];
}
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: !0,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: !1
};
function pixelsToPercent(pixels, axis) {
  return axis.max === axis.min ? 0 : pixels / (axis.max - axis.min) * 100;
}
const correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest == "string")
      if (px.test(latest))
        latest = parseFloat(latest);
      else
        return latest;
    const x2 = pixelsToPercent(latest, node2.target.x), y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
}, correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest, shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest), offset2 = typeof shadow[0] != "number" ? 1 : 0, xScale = projectionDelta.x.scale * treeScale.x, yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset2] /= xScale, shadow[1 + offset2] /= yScale;
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    return typeof shadow[2 + offset2] == "number" && (shadow[2 + offset2] /= averageScale), typeof shadow[3 + offset2] == "number" && (shadow[3 + offset2] /= averageScale), template(shadow);
  }
};
class MeasureLayoutWithContext extends React__default.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props, { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors), projection && (layoutGroup.group && layoutGroup.group.add(projection), switchLayoutGroup && switchLayoutGroup.register && layoutId && switchLayoutGroup.register(projection), projection.root.didUpdate(), projection.addEventListener("animationComplete", () => {
      this.safeToRemove();
    }), projection.setOptions({
      ...projection.options,
      onExitComplete: () => this.safeToRemove()
    })), globalProjectionState.hasEverUpdated = !0;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props, projection = visualElement.projection;
    return projection && (projection.isPresent = isPresent, drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 ? projection.willUpdate() : this.safeToRemove(), prevProps.isPresent !== isPresent && (isPresent ? projection.promote() : projection.relegate() || frame.postRender(() => {
      const stack = projection.getStack();
      (!stack || !stack.members.length) && this.safeToRemove();
    }))), null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    projection && (projection.root.didUpdate(), microtask.postRender(() => {
      !projection.currentAnimation && projection.isLead() && this.safeToRemove();
    }));
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props, { projection } = visualElement;
    projection && (projection.scheduleCheckAfterUnmount(), layoutGroup && layoutGroup.group && layoutGroup.group.remove(projection), promoteContext && promoteContext.deregister && promoteContext.deregister(projection));
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence(), layoutGroup = useContext(LayoutGroupContext);
  return React__default.createElement(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: useContext(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
}, borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], numBorders = borders.length, asNumber = (value) => typeof value == "string" ? parseFloat(value) : value, isPx = (value) => typeof value == "number" || px.test(value);
function mixValues(target2, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  shouldCrossfadeOpacity ? (target2.opacity = mixNumber$1(
    0,
    // TODO Reinstate this if only child
    lead.opacity !== void 0 ? lead.opacity : 1,
    easeCrossfadeIn(progress2)
  ), target2.opacityExit = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, 0, easeCrossfadeOut(progress2))) : isOnlyMember && (target2.opacity = mixNumber$1(follow.opacity !== void 0 ? follow.opacity : 1, lead.opacity !== void 0 ? lead.opacity : 1, progress2));
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel), leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0), leadRadius || (leadRadius = 0), followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius) ? (target2[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress2), 0), (percent.test(leadRadius) || percent.test(followRadius)) && (target2[borderLabel] += "%")) : target2[borderLabel] = leadRadius;
  }
  (follow.rotate || lead.rotate) && (target2.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress2));
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
const easeCrossfadeIn = compress(0, 0.5, circOut), easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(min2, max2, easing) {
  return (p) => p < min2 ? 0 : p > max2 ? 1 : easing(progress(min2, max2, p));
}
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min, axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x), copyAxisInto(box.y, originBox.y);
}
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  return point -= translate, point = scalePoint(point, 1 / scale2, originPoint), boxScale !== void 0 && (point = scalePoint(point, 1 / boxScale, originPoint)), point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin2 = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate) && (translate = parseFloat(translate), translate = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100) - sourceAxis.min), typeof translate != "number")
    return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin2);
  axis === originAxis && (originPoint -= translate), axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale), axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin2, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin2, sourceAxis);
}
const xKeys = ["x", "scaleX", "originX"], yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0), removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}
function isAxisDeltaZero(delta2) {
  return delta2.translate === 0 && delta2.scale === 1;
}
function isDeltaZero(delta2) {
  return isAxisDeltaZero(delta2.x) && isAxisDeltaZero(delta2.y);
}
function boxEquals(a, b) {
  return a.x.min === b.x.min && a.x.max === b.x.max && a.y.min === b.y.min && a.y.max === b.y.max;
}
function boxEqualsRounded(a, b) {
  return Math.round(a.x.min) === Math.round(b.x.min) && Math.round(a.x.max) === Math.round(b.x.max) && Math.round(a.y.min) === Math.round(b.y.min) && Math.round(a.y.max) === Math.round(b.y.max);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2), node2.scheduleRender();
  }
  remove(node2) {
    if (removeItem(this.members, node2), node2 === this.prevLead && (this.prevLead = void 0), node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      prevLead && this.promote(prevLead);
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return !1;
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== !1) {
        prevLead = member;
        break;
      }
    }
    return prevLead ? (this.promote(prevLead), !0) : !1;
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 !== prevLead && (this.prevLead = prevLead, this.lead = node2, node2.show(), prevLead)) {
      prevLead.instance && prevLead.scheduleRender(), node2.scheduleRender(), node2.resumeFrom = prevLead, preserveFollowOpacity && (node2.resumeFrom.preserveOpacity = !0), prevLead.snapshot && (node2.snapshot = prevLead.snapshot, node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues), node2.root && node2.root.isUpdating && (node2.isLayoutDirty = !0);
      const { crossfade } = node2.options;
      crossfade === !1 && prevLead.hide();
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete(), resumingFrom && resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(!1);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);
  }
}
function buildProjectionTransform(delta2, treeScale, latestTransform) {
  let transform = "";
  const xTranslate = delta2.x.translate / treeScale.x, yTranslate = delta2.y.translate / treeScale.y;
  if ((xTranslate || yTranslate) && (transform = `translate3d(${xTranslate}px, ${yTranslate}px, 0) `), (treeScale.x !== 1 || treeScale.y !== 1) && (transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `), latestTransform) {
    const { rotate: rotate2, rotateX, rotateY } = latestTransform;
    rotate2 && (transform += `rotate(${rotate2}deg) `), rotateX && (transform += `rotateX(${rotateX}deg) `), rotateY && (transform += `rotateY(${rotateY}deg) `);
  }
  const elementScaleX = delta2.x.scale * treeScale.x, elementScaleY = delta2.y.scale * treeScale.y;
  return (elementScaleX !== 1 || elementScaleY !== 1) && (transform += `scale(${elementScaleX}, ${elementScaleY})`), transform || "none";
}
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [], this.isDirty = !1;
  }
  add(child) {
    addUniqueItem(this.children, child), this.isDirty = !0;
  }
  remove(child) {
    removeItem(this.children, child), this.isDirty = !0;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth), this.isDirty = !1, this.children.forEach(callback);
  }
}
function delay(callback, timeout) {
  const start = time$1.now(), checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    elapsed >= timeout && (cancelFrame(checkElapsed), callback(elapsed - timeout));
  };
  return frame.read(checkElapsed, !0), () => cancelFrame(checkElapsed);
}
function record(data2) {
  window.MotionDebug && window.MotionDebug.record(data2);
}
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  return motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options)), motionValue$1.animation;
}
const transformAxes = ["", "X", "Y", "Z"], hiddenVisibility = { visibility: "hidden" }, animationTarget = 1e3;
let id = 0;
const projectionFrameData = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class {
    constructor(latestValues = {}, parent = defaultParent?.()) {
      this.id = id++, this.animationId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.updateScheduled = !1, this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());
      }, this.updateProjection = () => {
        this.projectionUpdateScheduled = !1, projectionFrameData.totalNodes = projectionFrameData.resolvedTargetDeltas = projectionFrameData.recalculatedProjection = 0, this.nodes.forEach(propagateDirtyNodes), this.nodes.forEach(resolveTargetDelta), this.nodes.forEach(calcProjection), this.nodes.forEach(cleanDirtyNodes), record(projectionFrameData);
      }, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = latestValues, this.root = parent ? parent.root || parent : this, this.path = parent ? [...parent.path, parent] : [], this.parent = parent, this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++)
        this.path[i].shouldResetTransform = !0;
      this.root === this && (this.nodes = new FlatTree());
    }
    addEventListener(name2, handler) {
      return this.eventHandlers.has(name2) || this.eventHandlers.set(name2, new SubscriptionManager()), this.eventHandlers.get(name2).add(handler);
    }
    notifyListeners(name2, ...args) {
      const subscriptionManager = this.eventHandlers.get(name2);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name2) {
      return this.eventHandlers.has(name2);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance), this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current && visualElement.mount(instance), this.root.nodes.add(this), this.parent && this.parent.children.add(this), isLayoutDirty && (layout2 || layoutId) && (this.isLayoutDirty = !0), attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = !1;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = !0, cancelDelay && cancelDelay(), cancelDelay = delay(resizeUnblockUpdate, 250), globalProjectionState.hasAnimatedSinceResize && (globalProjectionState.hasAnimatedSinceResize = !1, this.nodes.forEach(finishAnimation));
        });
      }
      layoutId && this.root.registerSharedNode(layoutId, this), this.options.animate !== !1 && visualElement && (layoutId || layout2) && this.addEventListener("didUpdate", ({ delta: delta2, hasLayoutChanged, hasRelativeTargetChanged, layout: newLayout }) => {
        if (this.isTreeAnimationBlocked()) {
          this.target = void 0, this.relativeTarget = void 0;
          return;
        }
        const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition, { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps(), targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged, hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
        if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(delta2, hasOnlyRelativeTargetChanged);
          const animationOptions = {
            ...getValueTransition(layoutTransition, "layout"),
            onPlay: onLayoutAnimationStart,
            onComplete: onLayoutAnimationComplete
          };
          (visualElement.shouldReduceMotion || this.options.layoutRoot) && (animationOptions.delay = 0, animationOptions.type = !1), this.startAnimation(animationOptions);
        } else
          hasLayoutChanged || finishAnimation(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
        this.targetLayout = newLayout;
      });
    }
    unmount() {
      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = !0;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = !1;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;
    }
    // Note: currently only running on root node
    startUpdate() {
      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(resetRotation), this.animationId++);
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = !0) {
      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (!this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)
        return;
      this.isLayoutDirty = !0;
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        node2.shouldResetTransform = !0, node2.updateScroll("snapshot"), node2.options.layoutRoot && node2.willUpdate(!1);
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, this.updateSnapshot(), shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      if (this.updateScheduled = !1, this.isUpdateBlocked()) {
        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(clearMeasurements);
        return;
      }
      this.isUpdating || this.nodes.forEach(clearIsLayoutDirty), this.isUpdating = !1, window.HandoffCancelAllAnimations && window.HandoffCancelAllAnimations(), this.nodes.forEach(resetTransformStyle), this.nodes.forEach(updateLayout), this.nodes.forEach(notifyLayoutUpdate), this.clearAllSnapshots();
      const now2 = time$1.now();
      frameData.delta = clamp$1(0, 1e3 / 60, now2 - frameData.timestamp), frameData.timestamp = now2, frameData.isProcessing = !0, steps.update.process(frameData), steps.preRender.process(frameData), steps.render.process(frameData), frameData.isProcessing = !1;
    }
    didUpdate() {
      this.updateScheduled || (this.updateScheduled = !0, microtask.read(() => this.update()));
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot), this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, frame.preRender(this.updateProjection, !1, !0));
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      this.snapshot || !this.instance || (this.snapshot = this.measure());
    }
    updateLayout() {
      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))
        return;
      if (this.resumeFrom && !this.resumeFrom.instance)
        for (let i = 0; i < this.path.length; i++)
          this.path[i].updateScroll();
      const prevLayout = this.layout;
      this.layout = this.measure(!1), this.layoutCorrected = createBox(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = !!(this.options.layoutScroll && this.instance);
      this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase && (needsMeasurement = !1), needsMeasurement && (this.scroll = {
        animationId: this.root.animationId,
        phase,
        isRoot: checkIsScrollRoot(this.instance),
        offset: measureScroll(this.instance)
      });
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform, hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta), transformTemplate = this.getTransformTemplate(), transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0, transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged) && (resetTransform(this.instance, transformTemplateValue), this.shouldResetTransform = !1, this.scheduleRender());
    }
    measure(removeTransform = !0) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      return removeTransform && (layoutBox = this.removeTransform(layoutBox)), roundBox(layoutBox), {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox(), { scroll } = this.root;
      return scroll && (translateAxis(box.x, scroll.offset.x), translateAxis(box.y, scroll.offset.y)), box;
    }
    removeElementScroll(box) {
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i], { scroll, options } = node2;
        if (node2 !== this.root && scroll && options.layoutScroll) {
          if (scroll.isRoot) {
            copyBoxInto(boxWithoutScroll, box);
            const { scroll: rootScroll } = this.root;
            rootScroll && (translateAxis(boxWithoutScroll.x, -rootScroll.offset.x), translateAxis(boxWithoutScroll.y, -rootScroll.offset.y));
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x), translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = !1) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        !transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root && transformBox(withTransforms, {
          x: -node2.scroll.offset.x,
          y: -node2.scroll.offset.y
        }), hasTransform(node2.latestValues) && transformBox(withTransforms, node2.latestValues);
      }
      return hasTransform(this.latestValues) && transformBox(withTransforms, this.latestValues), withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node2 = this.path[i];
        if (!node2.instance || !hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox(), nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox), removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      return hasTransform(this.latestValues) && removeBoxTransforms(boxWithoutTransform, this.latestValues), boxWithoutTransform;
    }
    setTargetDelta(delta2) {
      this.targetDelta = delta2, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : !0
      };
    }
    clearMeasurements() {
      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;
    }
    forceRelativeParentToResolveTarget() {
      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp && this.relativeParent.resolveTargetDelta(!0);
    }
    resolveTargetDelta(forceRecalculation = !1) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = !!this.resumingFrom || this !== lead;
      if (!(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || !((_a = this.parent) === null || _a === void 0) && _a.isProjectionDirty || this.attemptToResolveRelativeTarget))
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!(!this.layout || !(layout2 || layoutId))) {
        if (this.resolvedRelativeTargetAt = frameData.timestamp, !this.targetDelta && !this.relativeTarget) {
          const relativeParent = this.getClosestProjectingParent();
          relativeParent && relativeParent.layout && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
        }
        if (!(!this.relativeTarget && !this.targetDelta)) {
          if (this.target || (this.target = createBox(), this.targetWithTransforms = createBox()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : copyBoxInto(this.target, this.layout.layoutBox), applyBoxDelta(this.target, this.targetDelta)) : copyBoxInto(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
            this.attemptToResolveRelativeTarget = !1;
            const relativeParent = this.getClosestProjectingParent();
            relativeParent && !!relativeParent.resumingFrom == !!this.resumingFrom && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1 ? (this.relativeParent = relativeParent, this.forceRelativeParentToResolveTarget(), this.relativeTarget = createBox(), this.relativeTargetOrigin = createBox(), calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target), copyBoxInto(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0;
          }
          projectionFrameData.resolvedTargetDeltas++;
        }
      }
    }
    getClosestProjectingParent() {
      if (!(!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)))
        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();
    }
    isProjecting() {
      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead(), isShared = !!this.resumingFrom || this !== lead;
      let canSkip = !0;
      if ((this.isProjectionDirty || !((_a = this.parent) === null || _a === void 0) && _a.isProjectionDirty) && (canSkip = !1), isShared && (this.isSharedProjectionDirty || this.isTransformDirty) && (canSkip = !1), this.resolvedRelativeTargetAt === frameData.timestamp && (canSkip = !1), canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x, prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared), lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (lead.target = lead.layout.layoutBox, lead.targetWithTransforms = createBox());
      const { target: target2 } = lead;
      if (!target2) {
        this.projectionTransform && (this.projectionDelta = createDelta(), this.projectionTransform = "none", this.scheduleRender());
        return;
      }
      this.projectionDelta || (this.projectionDelta = createDelta(), this.projectionDeltaWithTransform = createDelta());
      const prevProjectionTransform = this.projectionTransform;
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target2, this.latestValues), this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale), (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", target2)), projectionFrameData.recalculatedProjection++;
    }
    hide() {
      this.isVisible = !1;
    }
    show() {
      this.isVisible = !0;
    }
    scheduleRender(notifyAll = !0) {
      if (this.options.scheduleRender && this.options.scheduleRender(), notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);
    }
    setAnimationOrigin(delta2, hasOnlyRelativeTargetChanged = !1) {
      const snapshot = this.snapshot, snapshotLatestValues = snapshot ? snapshot.latestValues : {}, mixedValues = { ...this.latestValues }, targetDelta = createDelta();
      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox(), snapshotSource = snapshot ? snapshot.source : void 0, layoutSource = this.layout ? this.layout.source : void 0, isSharedLayoutAnimation = snapshotSource !== layoutSource, stack = this.getStack(), isOnlyMember = !stack || stack.members.length <= 1, shouldCrossfadeOpacity = !!(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === !0 && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta2.x, progress2), mixAxisDelta(targetDelta.y, delta2.y, progress2), this.setTargetDelta(targetDelta), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox), mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2), prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget) && (this.isProjectionDirty = !1), prevRelativeTarget || (prevRelativeTarget = createBox()), copyBoxInto(prevRelativeTarget, this.relativeTarget)), isSharedLayoutAnimation && (this.animationValues = mixedValues, mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = progress2;
      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (cancelFrame(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = !0, this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest), options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete(), this.completeAnimation();
          }
        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
      const stack = this.getStack();
      stack && stack.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(animationTarget), this.currentAnimation.stop()), this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target: target2, layout: layout2, latestValues } = lead;
      if (!(!targetWithTransforms || !target2 || !layout2)) {
        if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
          target2 = this.target || createBox();
          const xLength = calcLength(this.layout.layoutBox.x);
          target2.x.min = lead.target.x.min, target2.x.max = target2.x.min + xLength;
          const yLength = calcLength(this.layout.layoutBox.y);
          target2.y.min = lead.target.y.min, target2.y.max = target2.y.min + yLength;
        }
        copyBoxInto(targetWithTransforms, target2), transformBox(targetWithTransforms, latestValues), calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      }
    }
    registerSharedNode(layoutId, node2) {
      this.sharedNodes.has(layoutId) || this.sharedNodes.set(layoutId, new NodeStack()), this.sharedNodes.get(layoutId).add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : !0;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      stack && stack.promote(this, preserveFollowOpacity), needsReset && (this.projectionDelta = void 0, this.needsReset = !0), transition && this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      return stack ? stack.relegate(this) : !1;
    }
    resetRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasRotate = !1;
      const { latestValues } = visualElement;
      if ((latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ) && (hasRotate = !0), !hasRotate)
        return;
      const resetValues = {};
      for (let i = 0; i < transformAxes.length; i++) {
        const key2 = "rotate" + transformAxes[i];
        latestValues[key2] && (resetValues[key2] = latestValues[key2], visualElement.setStaticValue(key2, 0));
      }
      visualElement.render();
      for (const key2 in resetValues)
        visualElement.setStaticValue(key2, resetValues[key2]);
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a, _b;
      if (!this.instance || this.isSVG)
        return;
      if (!this.isVisible)
        return hiddenVisibility;
      const styles = {
        visibility: ""
      }, transformTemplate = this.getTransformTemplate();
      if (this.needsReset)
        return this.needsReset = !1, styles.opacity = "", styles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || "", styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none", styles;
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        return this.options.layoutId && (emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, emptyStyles.pointerEvents = resolveMotionValue(styleProp?.pointerEvents) || ""), this.hasProjected && !hasTransform(this.latestValues) && (emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none", this.hasProjected = !1), emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget(), styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender), transformTemplate && (styles.transform = transformTemplate(valuesToRender, styles.transform));
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`, lead.animationValues ? styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit : styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo } = scaleCorrectors[key2], corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num2 = applyTo.length;
          for (let i = 0; i < num2; i++)
            styles[applyTo[i]] = corrected;
        } else
          styles[key2] = corrected;
      }
      return this.options.layoutId && (styles.pointerEvents = lead === this ? resolveMotionValue(styleProp?.pointerEvents) || "" : "none"), styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a;
        return (_a = node2.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      }), this.root.nodes.forEach(clearMeasurements), this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a;
  const snapshot = ((_a = node2.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout, { animationType } = node2.options, isShared = snapshot.source !== node2.layout.source;
    animationType === "size" ? eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length2 = calcLength(axisSnapshot);
      axisSnapshot.min = layout2[axis].min, axisSnapshot.max = axisSnapshot.min + length2;
    }) : shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2) && eachAxis((axis) => {
      const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis], length2 = calcLength(layout2[axis]);
      axisSnapshot.max = axisSnapshot.min + length2, node2.relativeTarget && !node2.currentAnimation && (node2.isProjectionDirty = !0, node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2);
    });
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    isShared ? calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, !0), snapshot.measuredBox) : calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = !1;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox), boxEqualsRounded(relativeSnapshot, relativeLayout) || (hasRelativeTargetChanged = !0), relativeParent.options.layoutRoot && (node2.relativeTarget = relativeLayout, node2.relativeTargetOrigin = relativeSnapshot, node2.relativeParent = relativeParent);
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  projectionFrameData.totalNodes++, node2.parent && (node2.isProjecting() || (node2.isProjectionDirty = node2.parent.isProjectionDirty), node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = !!(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty)), node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty));
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = !1;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = !1;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  visualElement && visualElement.getProps().onBeforeLayoutMeasure && visualElement.notify("BeforeLayoutMeasure"), node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation(), node2.targetDelta = node2.relativeTarget = node2.target = void 0, node2.isProjectionDirty = !0;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetRotation(node2) {
  node2.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta2, p) {
  output.translate = mixNumber$1(delta2.translate, 0, p), output.scale = mixNumber$1(delta2.scale, 1, p), output.origin = delta2.origin, output.originPoint = delta2.originPoint;
}
function mixAxis(output, from2, to, p) {
  output.min = mixNumber$1(from2.min, to.min, p), output.max = mixNumber$1(from2.max, to.max, p);
}
function mixBox(output, from2, to, p) {
  mixAxis(output.x, from2.x, to.x, p), mixAxis(output.y, from2.y, to.y, p);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
}, userAgentContains = (string) => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string), roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min), axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x), roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
const DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => !0
}), rootProjectionNode = {
  current: void 0
}, HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window), documentNode.setOptions({ layoutScroll: !0 }), rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => window.getComputedStyle(instance).position === "fixed"
}), drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, splitCSSVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token2, fallback] = match2;
  return [token2, fallback];
}
const maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  } else return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}
function resolveCSSVariables(visualElement, { ...target2 }, transitionEnd) {
  const element = visualElement.current;
  if (!(element instanceof Element))
    return { target: target2, transitionEnd };
  transitionEnd && (transitionEnd = { ...transitionEnd }), visualElement.values.forEach((value) => {
    const current = value.get();
    if (!isCSSVariableToken(current))
      return;
    const resolved = getVariableValue(current, element);
    resolved && value.set(resolved);
  });
  for (const key2 in target2) {
    const current = target2[key2];
    if (!isCSSVariableToken(current))
      continue;
    const resolved = getVariableValue(current, element);
    resolved && (target2[key2] = resolved, transitionEnd || (transitionEnd = {}), transitionEnd[key2] === void 0 && (transitionEnd[key2] = current));
  }
  return { target: target2, transitionEnd };
}
const positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y",
  "translateX",
  "translateY"
]), isPositionalKey = (key2) => positionalKeys.has(key2), hasPositionalKey = (target2) => Object.keys(target2).some(isPositionalKey), isNumOrPxType = (v2) => v2 === number || v2 === px, getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]), getTranslateFromMatrix = (pos2, pos3) => (_bbox, { transform }) => {
  if (transform === "none" || !transform)
    return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/);
  if (matrix3d)
    return getPosFromMatrix(matrix3d[1], pos3);
  {
    const matrix = transform.match(/^matrix\((.+)\)$/);
    return matrix ? getPosFromMatrix(matrix[1], pos2) : 0;
  }
}, transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]), nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  return nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value !== void 0 && (removedTransforms.push([key2, value.get()]), value.set(key2.startsWith("scale") ? 1 : 0));
  }), removedTransforms.length && visualElement.render(), removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top: top2 }) => parseFloat(top2),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top: top2 }) => parseFloat(top2) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const convertChangedValueTypes = (target2, visualElement, changedKeys) => {
  const originBbox = visualElement.measureViewportBox(), element = visualElement.current, elementComputedStyle = getComputedStyle(element), { display } = elementComputedStyle, origin2 = {};
  display === "none" && visualElement.setStaticValue("display", target2.display || "block"), changedKeys.forEach((key2) => {
    origin2[key2] = positionalValues[key2](originBbox, elementComputedStyle);
  }), visualElement.render();
  const targetBbox = visualElement.measureViewportBox();
  return changedKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    value && value.jump(origin2[key2]), target2[key2] = positionalValues[key2](targetBbox, elementComputedStyle);
  }), target2;
}, checkAndConvertChangedValueTypes = (visualElement, target2, origin2 = {}, transitionEnd = {}) => {
  target2 = { ...target2 }, transitionEnd = { ...transitionEnd };
  const targetPositionalKeys = Object.keys(target2).filter(isPositionalKey);
  let removedTransformValues = [], hasAttemptedToRemoveTransformValues = !1;
  const changedValueTypeKeys = [];
  if (targetPositionalKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (!visualElement.hasValue(key2))
      return;
    let from2 = origin2[key2], fromType = findDimensionValueType(from2);
    const to = target2[key2];
    let toType;
    if (isKeyframesTarget(to)) {
      const numKeyframes = to.length, fromIndex = to[0] === null ? 1 : 0;
      from2 = to[fromIndex], fromType = findDimensionValueType(from2);
      for (let i = fromIndex; i < numKeyframes && to[i] !== null; i++)
        toType ? invariant(findDimensionValueType(to[i]) === toType, "All keyframes must be of the same type") : (toType = findDimensionValueType(to[i]), invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value"));
    } else
      toType = findDimensionValueType(to);
    if (fromType !== toType)
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        const current = value.get();
        typeof current == "string" && value.set(parseFloat(current)), typeof to == "string" ? target2[key2] = parseFloat(to) : Array.isArray(to) && toType === px && (target2[key2] = to.map(parseFloat));
      } else fromType?.transform && toType?.transform && (from2 === 0 || to === 0) ? from2 === 0 ? value.set(toType.transform(from2)) : target2[key2] = fromType.transform(to) : (hasAttemptedToRemoveTransformValues || (removedTransformValues = removeNonTranslationalTransform(visualElement), hasAttemptedToRemoveTransformValues = !0), changedValueTypeKeys.push(key2), transitionEnd[key2] = transitionEnd[key2] !== void 0 ? transitionEnd[key2] : target2[key2], value.jump(to));
  }), changedValueTypeKeys.length) {
    const scrollY = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null, convertedTarget = convertChangedValueTypes(target2, visualElement, changedValueTypeKeys);
    return removedTransformValues.length && removedTransformValues.forEach(([key2, value]) => {
      visualElement.getValue(key2).set(value);
    }), visualElement.render(), isBrowser && scrollY !== null && window.scrollTo({ top: scrollY }), { target: convertedTarget, transitionEnd };
  } else
    return { target: target2, transitionEnd };
};
function unitConversion(visualElement, target2, origin2, transitionEnd) {
  return hasPositionalKey(target2) ? checkAndConvertChangedValueTypes(visualElement, target2, origin2, transitionEnd) : { target: target2, transitionEnd };
}
const parseDomVariant = (visualElement, target2, origin2, transitionEnd) => {
  const resolved = resolveCSSVariables(visualElement, target2, transitionEnd);
  return target2 = resolved.target, transitionEnd = resolved.transitionEnd, unitConversion(visualElement, target2, origin2, transitionEnd);
}, prefersReducedMotion = { current: null }, hasReducedMotionListener = { current: !1 };
function initPrefersReducedMotion() {
  if (hasReducedMotionListener.current = !0, !!isBrowser)
    if (window.matchMedia) {
      const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)"), setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
      motionMediaQuery.addListener(setReducedMotionPreferences), setReducedMotionPreferences();
    } else
      prefersReducedMotion.current = !1;
}
function updateMotionValuesFromProps(element, next2, prev2) {
  const { willChange } = next2;
  for (const key2 in next2) {
    const nextValue = next2[key2], prevValue = prev2[key2];
    if (isMotionValue(nextValue))
      element.addValue(key2, nextValue), isWillChangeMotionValue(willChange) && willChange.add(key2), process.env.NODE_ENV === "development" && warnOnce(nextValue.version === "11.0.8", `Attempting to mix Framer Motion versions ${nextValue.version} with 11.0.8 may not work as expected.`);
    else if (isMotionValue(prevValue))
      element.addValue(key2, motionValue(nextValue, { owner: element })), isWillChangeMotionValue(willChange) && willChange.remove(key2);
    else if (prevValue !== nextValue)
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
  }
  for (const key2 in prev2)
    next2[key2] === void 0 && element.removeValue(key2);
  return next2;
}
const visualElementStore = /* @__PURE__ */ new WeakMap(), featureNames = Object.keys(featureDefinitions), numFeatures = featureNames.length, propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
], numVariantProps = variantProps.length;
class VisualElement {
  constructor({ parent, props, presenceContext, reducedMotionConfig, visualState }, options = {}) {
    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));
    }, this.scheduleRender = () => frame.render(this.render, !1, !0);
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues, this.baseTarget = { ...latestValues }, this.initialValues = props.initial ? { ...latestValues } : {}, this.renderState = renderState, this.parent = parent, this.props = props, this.presenceContext = presenceContext, this.depth = parent ? parent.depth + 1 : 0, this.reducedMotionConfig = reducedMotionConfig, this.options = options, this.isControllingVariants = isControllingVariants(props), this.isVariantNode = isVariantNode(props), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {});
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      latestValues[key2] !== void 0 && isMotionValue(value) && (value.set(latestValues[key2], !1), isWillChangeMotionValue(willChange) && willChange.add(key2));
    }
  }
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps) {
    return {};
  }
  mount(instance) {
    this.current = instance, visualElementStore.set(instance, this), this.projection && !this.projection.instance && this.projection.mount(instance), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((value, key2) => this.bindToMotionValue(key2, value)), hasReducedMotionListener.current || initPrefersReducedMotion(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : prefersReducedMotion.current, process.env.NODE_ENV !== "production" && warnOnce(this.shouldReduceMotion !== !0, "You have Reduced Motion enabled on your device. Animations may not appear as expected."), this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current), this.projection && this.projection.unmount(), cancelFrame(this.notifyUpdate), cancelFrame(this.render), this.valueSubscriptions.forEach((remove) => remove()), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
    for (const key2 in this.events)
      this.events[key2].clear();
    for (const key2 in this.features)
      this.features[key2].unmount();
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    const valueIsTransform = transformProps.has(key2), removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue, this.props.onUpdate && frame.update(this.notifyUpdate, !1, !0), valueIsTransform && this.projection && (this.projection.isTransformDirty = !0);
    }), removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    this.valueSubscriptions.set(key2, () => {
      removeOnChange(), removeOnRenderRequest();
    });
  }
  sortNodePosition(other) {
    return !this.current || !this.sortInstanceNodePosition || this.type !== other.type ? 0 : this.sortInstanceNodePosition(this.current, other.current);
  }
  loadFeatures({ children, ...renderedProps }, isStrict, preloadedFeatures2, initialLayoutGroupConfig) {
    let ProjectionNodeConstructor, MeasureLayout2;
    if (process.env.NODE_ENV !== "production" && preloadedFeatures2 && isStrict) {
      const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
      renderedProps.ignoreStrict ? warning(!1, strictMessage) : invariant(!1, strictMessage);
    }
    for (let i = 0; i < numFeatures; i++) {
      const name2 = featureNames[i], { isEnabled, Feature: FeatureConstructor, ProjectionNode, MeasureLayout: MeasureLayoutComponent } = featureDefinitions[name2];
      ProjectionNode && (ProjectionNodeConstructor = ProjectionNode), isEnabled(renderedProps) && (!this.features[name2] && FeatureConstructor && (this.features[name2] = new FeatureConstructor(this)), MeasureLayoutComponent && (MeasureLayout2 = MeasureLayoutComponent));
    }
    if ((this.type === "html" || this.type === "svg") && !this.projection && ProjectionNodeConstructor) {
      this.projection = new ProjectionNodeConstructor(this.latestValues, this.parent && this.parent.projection);
      const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot } = renderedProps;
      this.projection.setOptions({
        layoutId,
        layout: layout2,
        alwaysMeasureLayout: !!drag2 || dragConstraints && isRefObject(dragConstraints),
        visualElement: this,
        scheduleRender: () => this.scheduleRender(),
        /**
         * TODO: Update options in an effect. This could be tricky as it'll be too late
         * to update by the time layout animations run.
         * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
         * ensuring it gets called if there's no potential layout animations.
         *
         */
        animationType: typeof layout2 == "string" ? layout2 : "both",
        initialPromotionConfig: initialLayoutGroupConfig,
        layoutScroll,
        layoutRoot
      });
    }
    return MeasureLayout2;
  }
  updateFeatures() {
    for (const key2 in this.features) {
      const feature = this.features[key2];
      feature.isMounted ? feature.update() : (feature.mount(), feature.isMounted = !0);
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.options, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Make a target animatable by Popmotion. For instance, if we're
   * trying to animate width from 100px to 100vw we need to measure 100vw
   * in pixels to determine what we really need to animate to. This is also
   * pluggable to support Framer's custom value types like Color,
   * and CSS variables.
   */
  makeTargetAnimatable(target2, canMutate = !0) {
    return this.makeTargetAnimatableFromInstance(target2, canMutate);
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    (props.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = props, this.prevPresenceContext = this.presenceContext, this.presenceContext = presenceContext;
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key2 = propEventHandlers[i];
      this.propEventSubscriptions[key2] && (this.propEventSubscriptions[key2](), delete this.propEventSubscriptions[key2]);
      const listener = props["on" + key2];
      listener && (this.propEventSubscriptions[key2] = this.on(key2, listener));
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name2) {
    return this.props.variants ? this.props.variants[name2] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  getVariantContext(startAtParent = !1) {
    if (startAtParent)
      return this.parent ? this.parent.getVariantContext() : void 0;
    if (!this.isControllingVariants) {
      const context2 = this.parent ? this.parent.getVariantContext() || {} : {};
      return this.props.initial !== void 0 && (context2.initial = this.props.initial), context2;
    }
    const context = {};
    for (let i = 0; i < numVariantProps; i++) {
      const name2 = variantProps[i], prop2 = this.props[name2];
      (isVariantLabel(prop2) || prop2 === !1) && (context[name2] = prop2);
    }
    return context;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode)
      return closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child), () => closestVariantNode.variantChildren.delete(child);
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    value !== this.values.get(key2) && (this.removeValue(key2), this.bindToMotionValue(key2, value)), this.values.set(key2, value), this.latestValues[key2] = value.get();
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    unsubscribe && (unsubscribe(), this.valueSubscriptions.delete(key2)), delete this.latestValues[key2], this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2])
      return this.props.values[key2];
    let value = this.values.get(key2);
    return value === void 0 && defaultValue !== void 0 && (value = motionValue(defaultValue, { owner: this }), this.addValue(key2, value)), value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2) {
    var _a;
    return this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : (_a = this.getBaseTargetFromProps(this.props, key2)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key2, this.options);
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a;
    const { initial } = this.props, valueFromInitial = typeof initial == "string" || typeof initial == "object" ? (_a = resolveVariantFromProps(this.props, initial)) === null || _a === void 0 ? void 0 : _a[key2] : void 0;
    if (initial && valueFromInitial !== void 0)
      return valueFromInitial;
    const target2 = this.getBaseTargetFromProps(this.props, key2);
    return target2 !== void 0 && !isMotionValue(target2) ? target2 : this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    return this.events[eventName] || (this.events[eventName] = new SubscriptionManager()), this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    this.events[eventName] && this.events[eventName].notify(...args);
  }
}
class DOMVisualElement extends VisualElement {
  sortInstanceNodePosition(a, b) {
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style: style2 }) {
    delete vars[key2], delete style2[key2];
  }
  makeTargetAnimatableFromInstance({ transition, transitionEnd, ...target2 }, isMounted) {
    const origin2 = getOrigin(target2, transition || {}, this);
    if (isMounted) {
      checkTargetForNewValues(this, target2, origin2);
      const parsed = parseDomVariant(this, target2, origin2, transitionEnd);
      transitionEnd = parsed.transitionEnd, target2 = parsed.target;
    }
    return {
      transition,
      transitionEnd,
      ...target2
    };
  }
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "html";
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    } else {
      const computedStyle = getComputedStyle$1(instance), value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value == "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, options, props) {
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps$1(props, prevProps);
  }
  handleChildMotionValue() {
    this.childSubscription && (this.childSubscription(), delete this.childSubscription);
    const { children } = this.props;
    isMotionValue(children) && (this.childSubscription = children.on("change", (latest) => {
      this.current && (this.current.textContent = `${latest}`);
    }));
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderHTML(instance, renderState, styleProp, projection);
  }
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments), this.type = "svg", this.isSVGTag = !1;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType && defaultType.default || 0;
    }
    return key2 = camelCaseAttributes.has(key2) ? key2 : camelToDash(key2), instance.getAttribute(key2);
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  scrapeMotionValuesFromProps(props, prevProps) {
    return scrapeMotionValuesFromProps(props, prevProps);
  }
  build(renderState, latestValues, options, props) {
    buildSVGAttrs(renderState, latestValues, options, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName), super.mount(instance);
  }
}
const createDomVisualElement = (Component, options) => isSVGComponent(Component) ? new SVGVisualElement(options, { enableHardwareAcceleration: !1 }) : new HTMLVisualElement(options, { enableHardwareAcceleration: !0 }), layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
}, preloadedFeatures = {
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, motion = /* @__PURE__ */ createMotionProxy((Component, config) => createDomMotionConfig(Component, config, preloadedFeatures, createDomVisualElement));
function useIsMounted() {
  const isMounted = useRef(!1);
  return useIsomorphicLayoutEffect(() => (isMounted.current = !0, () => {
    isMounted.current = !1;
  }), []), isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted(), [forcedRenderCount, setForcedRenderCount] = useState(0), forceRender = useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  return [useCallback(() => frame.postRender(forceRender), [forceRender]), forcedRenderCount];
}
class PopChildMeasure extends React$2.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size2 = this.props.sizeRef.current;
      size2.height = element.offsetHeight || 0, size2.width = element.offsetWidth || 0, size2.top = element.offsetTop, size2.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
}
function PopChild({ children, isPresent }) {
  const id2 = useId(), ref = useRef(null), size2 = useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  return useInsertionEffect(() => {
    const { width, height, top: top2, left } = size2.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    ref.current.dataset.motionPopId = id2;
    const style2 = document.createElement("style");
    return document.head.appendChild(style2), style2.sheet && style2.sheet.insertRule(`
          [data-motion-pop-id="${id2}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top2}px !important;
            left: ${left}px !important;
          }
        `), () => {
      document.head.removeChild(style2);
    };
  }, [isPresent]), React$2.createElement(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size2 }, React$2.cloneElement(children, { ref }));
}
const PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode }) => {
  const presenceChildren = useConstant(newChildrenMap), id2 = useId(), context = useMemo(
    () => ({
      id: id2,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, !0);
        for (const isComplete of presenceChildren.values())
          if (!isComplete)
            return;
        onExitComplete && onExitComplete();
      },
      register: (childId) => (presenceChildren.set(childId, !1), () => presenceChildren.delete(childId))
    }),
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent]
  );
  return useMemo(() => {
    presenceChildren.forEach((_2, key2) => presenceChildren.set(key2, !1));
  }, [isPresent]), React$2.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]), mode === "popLayout" && (children = React$2.createElement(PopChild, { isPresent }, children)), React$2.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}
function useUnmountEffect(callback) {
  return useEffect(() => () => callback(), []);
}
const getChildKey = (child) => child.key || "";
function updateChildLookup(children, allChildren) {
  children.forEach((child) => {
    const key2 = getChildKey(child);
    allChildren.set(key2, child);
  });
}
function onlyElements(children) {
  const filtered = [];
  return Children.forEach(children, (child) => {
    isValidElement(child) && filtered.push(child);
  }), filtered;
}
const AnimatePresence = ({ children, custom, initial = !0, onExitComplete, exitBeforeEnter, presenceAffectsLayout = !0, mode = "sync" }) => {
  invariant(!exitBeforeEnter, "Replace exitBeforeEnter with mode='wait'");
  const forceRender = useContext(LayoutGroupContext).forceRender || useForceUpdate()[0], isMounted = useIsMounted(), filteredChildren = onlyElements(children);
  let childrenToRender = filteredChildren;
  const exitingChildren = useRef(/* @__PURE__ */ new Map()).current, presentChildren = useRef(childrenToRender), allChildren = useRef(/* @__PURE__ */ new Map()).current, isInitialRender = useRef(!0);
  if (useIsomorphicLayoutEffect(() => {
    isInitialRender.current = !1, updateChildLookup(filteredChildren, allChildren), presentChildren.current = childrenToRender;
  }), useUnmountEffect(() => {
    isInitialRender.current = !0, allChildren.clear(), exitingChildren.clear();
  }), isInitialRender.current)
    return React$2.createElement(React$2.Fragment, null, childrenToRender.map((child) => React$2.createElement(PresenceChild, { key: getChildKey(child), isPresent: !0, initial: initial ? void 0 : !1, presenceAffectsLayout, mode }, child)));
  childrenToRender = [...childrenToRender];
  const presentKeys = presentChildren.current.map(getChildKey), targetKeys = filteredChildren.map(getChildKey), numPresent = presentKeys.length;
  for (let i = 0; i < numPresent; i++) {
    const key2 = presentKeys[i];
    targetKeys.indexOf(key2) === -1 && !exitingChildren.has(key2) && exitingChildren.set(key2, void 0);
  }
  return mode === "wait" && exitingChildren.size && (childrenToRender = []), exitingChildren.forEach((component, key2) => {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    const child = allChildren.get(key2);
    if (!child)
      return;
    const insertionIndex = presentKeys.indexOf(key2);
    let exitingComponent = component;
    if (!exitingComponent) {
      const onExit = () => {
        exitingChildren.delete(key2);
        const leftOverKeys = Array.from(allChildren.keys()).filter((childKey) => !targetKeys.includes(childKey));
        if (leftOverKeys.forEach((leftOverKey) => allChildren.delete(leftOverKey)), presentChildren.current = filteredChildren.filter((presentChild) => {
          const presentChildKey = getChildKey(presentChild);
          return (
            // filter out the node exiting
            presentChildKey === key2 || // filter out the leftover children
            leftOverKeys.includes(presentChildKey)
          );
        }), !exitingChildren.size) {
          if (isMounted.current === !1)
            return;
          forceRender(), onExitComplete && onExitComplete();
        }
      };
      exitingComponent = React$2.createElement(PresenceChild, { key: getChildKey(child), isPresent: !1, onExitComplete: onExit, custom, presenceAffectsLayout, mode }, child), exitingChildren.set(key2, exitingComponent);
    }
    childrenToRender.splice(insertionIndex, 0, exitingComponent);
  }), childrenToRender = childrenToRender.map((child) => {
    const key2 = child.key;
    return exitingChildren.has(key2) ? child : React$2.createElement(PresenceChild, { key: getChildKey(child), isPresent: !0, presenceAffectsLayout, mode }, child);
  }), process.env.NODE_ENV !== "production" && mode === "wait" && childrenToRender.length > 1 && console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`), React$2.createElement(React$2.Fragment, null, exitingChildren.size ? childrenToRender : childrenToRender.map((child) => cloneElement(child)));
};
function useEffectEvent(fn) {
  const ref = useRef(null);
  return useInsertionEffect(() => {
    ref.current = fn;
  }, [fn]), useCallback((...args) => {
    const latestFn = ref.current;
    return latestFn(...args);
  }, []);
}
buildTheme();
const EMPTY_ARRAY = [], EMPTY_RECORD = {}, POPOVER_MOTION_CONTENT_OPACITY_PROPERTY = "--motion-content-opacity", POPOVER_MOTION_PROPS = {
  initial: {
    opacity: 0.5,
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
    scale: 0.97,
    willChange: "transform"
  },
  animate: {
    opacity: [null, 1, 1],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, null, 1],
    scale: 1
  },
  exit: {
    // @ts-expect-error -- passing null a second time is valid: https://github.com/framer/motion/blob/b9ce4c42914c3916ea523609c5b032dfc72718bb/packages/framer-motion/src/animation/utils/keyframes.ts#L34C22-L34C22
    opacity: [null, null, 0],
    [POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [null, 0, 0],
    scale: 0.97
  },
  transition: { duration: 0.4, type: "spring" }
};
function _fillCSSObject(keys, value) {
  return keys.reduce((style2, key2) => (style2[key2] = value, style2), {});
}
function rem(pixelValue) {
  return pixelValue === 0 ? 0 : `${pixelValue / 16}rem`;
}
function _responsive(media, values, callback) {
  return (values?.map(callback) || []).map((statement, mediaIndex) => mediaIndex === 0 ? statement : { [`@media screen and (min-width: ${media[mediaIndex - 1]}px)`]: statement });
}
function _getArrayProp(val, defaultVal) {
  return val === void 0 ? defaultVal || EMPTY_ARRAY : Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props, spaceIndexes = EMPTY_ARRAY) {
  if (!Array.isArray(spaceIndexes))
    throw new Error("the property must be array of numbers");
  if (spaceIndexes.length === 0)
    return null;
  const { media, space: space2 } = getTheme_v2(theme);
  return _responsive(
    media,
    spaceIndexes,
    (spaceIndex) => _fillCSSObject(props, rem(space2[spaceIndex]))
  );
}
function responsiveFont(fontKey, props) {
  const { $size, $weight } = props, { font, media } = getTheme_v2(props.theme), { family, sizes, weights } = font[fontKey], fontWeight = $weight && weights[$weight] || weights.regular, defaultSize = sizes[2], base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size)
    return responsiveFont.warned || (console.warn("No size specified for responsive font", { fontKey, $size, props, base }), responsiveFont.warned = !0), [base];
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size2) {
  const { ascenderHeight, descenderHeight, fontSize: fontSize2, iconSize, letterSpacing, lineHeight } = size2, negHeight = ascenderHeight + descenderHeight, capHeight = lineHeight - negHeight, iconOffset = (capHeight - iconSize) / 2, customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1, customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: `calc(${lineHeight} / ${fontSize2})`,
    letterSpacing: rem(letterSpacing),
    transform: `translateY(${rem(descenderHeight)})`,
    "&:before": {
      marginTop: `calc(${rem(0 - negHeight)} - 1px)`
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: `calc(${customIconSize} / 16 * 1rem)`,
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: `calc(${iconSize} / 16 * 1rem)`,
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (textAlign) => ({ textAlign }));
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const __perf_hash__ = useMemo(() => JSON.stringify(val ?? defaultVal), [defaultVal, val]);
  return useMemo(
    () => _getArrayProp(val, defaultVal),
    // Improve performance: Keep object identify for a given hash of the value
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [__perf_hash__]
  );
}
function useClickOutsideEvent(listener, elementsArg = () => EMPTY_ARRAY, boundaryElement) {
  const onEvent = useEffectEvent((evt) => {
    if (!listener)
      return;
    const target2 = evt.target;
    if (!(target2 instanceof Node))
      return;
    const elements = elementsArg().flat();
    for (const el2 of elements)
      if (el2 && (target2 === el2 || el2.contains(target2)))
        return;
    listener(evt);
  }), hasListener = !!listener;
  useEffect(() => {
    if (!hasListener) return;
    const handleEvent = (evt) => onEvent(evt);
    return document.addEventListener("mousedown", handleEvent), () => {
      document.removeEventListener("mousedown", handleEvent);
    };
  }, [hasListener, onEvent]), useDebugValue(listener ? "MouseDown On" : "MouseDown Off");
}
function useCustomValidity(ref, customValidity) {
  useEffect(() => {
    var _a;
    (_a = ref.current) == null || _a.setCustomValidity(customValidity || "");
  }, [customValidity, ref]);
}
var resizeObservers = [], hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
}, hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
}, msg = "ResizeObserver loop completed with undelivered notifications.", deliverResizeLoopError = function() {
  var event;
  typeof ErrorEvent == "function" ? event = new ErrorEvent("error", {
    message: msg
  }) : (event = document.createEvent("Event"), event.initEvent("error", !1, !1), event.message = msg), window.dispatchEvent(event);
}, ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2.BORDER_BOX = "border-box", ResizeObserverBoxOptions2.CONTENT_BOX = "content-box", ResizeObserverBoxOptions2.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
var freeze = function(obj) {
  return Object.freeze(obj);
}, ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize, this.blockSize = blockSize, freeze(this);
  }
  return ResizeObserverSize2;
}(), DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x2, y2, width, height) {
    return this.x = x2, this.y = y2, this.width = width, this.height = height, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, freeze(this);
  }
  return DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x2 = _a.x, y2 = _a.y, top2 = _a.top, right = _a.right, bottom2 = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x: x2, y: y2, top: top2, right, bottom: bottom2, left, width, height };
  }, DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  }, DOMRectReadOnly2;
}(), isSVG = function(target2) {
  return target2 instanceof SVGElement && "getBBox" in target2;
}, isHidden = function(target2) {
  if (isSVG(target2)) {
    var _a = target2.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target2, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target2.getClientRects().length);
}, isElement = function(obj) {
  var _a;
  if (obj instanceof Element)
    return !0;
  var scope = (_a = obj?.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
}, isReplacedElement = function(target2) {
  switch (target2.tagName) {
    case "INPUT":
      if (target2.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, global$1 = typeof window < "u" ? window : {}, cache = /* @__PURE__ */ new WeakMap(), scrollRegexp = /auto|scroll/, verticalRegexp = /^tb|vertical/, IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent), parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
}, size$1 = function(inlineSize, blockSize, switchSizes) {
  return inlineSize === void 0 && (inlineSize = 0), blockSize === void 0 && (blockSize = 0), switchSizes === void 0 && (switchSizes = !1), new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
}, zeroBoxes = freeze({
  devicePixelContentBoxSize: size$1(),
  borderBoxSize: size$1(),
  contentBoxSize: size$1(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
}), calculateBoxSizes = function(target2, forceRecalculation) {
  if (forceRecalculation === void 0 && (forceRecalculation = !1), cache.has(target2) && !forceRecalculation)
    return cache.get(target2);
  if (isHidden(target2))
    return cache.set(target2, zeroBoxes), zeroBoxes;
  var cs = getComputedStyle(target2), svg = isSVG(target2) && target2.ownerSVGElement && target2.getBBox(), removePadding = !IE && cs.boxSizing === "border-box", switchSizes = verticalRegexp.test(cs.writingMode || ""), canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || ""), canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || ""), paddingTop = svg ? 0 : parseDimension(cs.paddingTop), paddingRight = svg ? 0 : parseDimension(cs.paddingRight), paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom), paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft), borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth), borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth), borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth), borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth), horizontalPadding = paddingLeft + paddingRight, verticalPadding = paddingTop + paddingBottom, horizontalBorderArea = borderLeft2 + borderRight2, verticalBorderArea = borderTop2 + borderBottom2, horizontalScrollbarThickness = canScrollHorizontally ? target2.offsetHeight - verticalBorderArea - target2.clientHeight : 0, verticalScrollbarThickness = canScrollVertically ? target2.offsetWidth - horizontalBorderArea - target2.clientWidth : 0, widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0, heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0, contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness, contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness, borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea, borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea, boxes = freeze({
    devicePixelContentBoxSize: size$1(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size$1(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size$1(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  return cache.set(target2, boxes), boxes;
}, calculateBoxSize = function(target2, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target2, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
}, ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target2) {
    var boxes = calculateBoxSizes(target2);
    this.target = target2, this.contentRect = boxes.contentRect, this.borderBoxSize = freeze([boxes.borderBoxSize]), this.contentBoxSize = freeze([boxes.contentBoxSize]), this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}(), calculateDepthForNode = function(node2) {
  if (isHidden(node2))
    return 1 / 0;
  for (var depth = 0, parent = node2.parentNode; parent; )
    depth += 1, parent = parent.parentNode;
  return depth;
}, broadcastActiveObservations = function() {
  var shallowestDepth = 1 / 0, callbacks2 = [];
  resizeObservers.forEach(function(ro) {
    if (ro.activeTargets.length !== 0) {
      var entries = [];
      ro.activeTargets.forEach(function(ot2) {
        var entry = new ResizeObserverEntry(ot2.target), targetDepth = calculateDepthForNode(ot2.target);
        entries.push(entry), ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox), targetDepth < shallowestDepth && (shallowestDepth = targetDepth);
      }), callbacks2.push(function() {
        ro.callback.call(ro.observer, entries, ro.observer);
      }), ro.activeTargets.splice(0, ro.activeTargets.length);
    }
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
}, gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length), ro.skippedTargets.splice(0, ro.skippedTargets.length), ro.observationTargets.forEach(function(ot2) {
      ot2.isActive() && (calculateDepthForNode(ot2.target) > depth ? ro.activeTargets.push(ot2) : ro.skippedTargets.push(ot2));
    });
  });
}, process$1 = function() {
  var depth = 0;
  for (gatherActiveObservationsAtDepth(depth); hasActiveObservations(); )
    depth = broadcastActiveObservations(), gatherActiveObservationsAtDepth(depth);
  return hasSkippedObservations() && deliverResizeLoopError(), depth > 0;
}, trigger, callbacks = [], notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
}, queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0, el_1 = document.createTextNode(""), config = { characterData: !0 };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config), trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback), trigger();
}, queueResizeObserver = function(cb) {
  queueMicroTask(function() {
    requestAnimationFrame(cb);
  });
}, watching = 0, isWatching = function() {
  return !!watching;
}, CATCH_PERIOD = 250, observerConfig = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], time = function(timeout) {
  return timeout === void 0 && (timeout = 0), Date.now() + timeout;
}, scheduled = !1, Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = !0, this.listener = function() {
      return _this.schedule();
    };
  }
  return Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0 && (timeout = CATCH_PERIOD), !scheduled) {
      scheduled = !0;
      var until = time(timeout);
      queueResizeObserver(function() {
        var elementsHaveResized = !1;
        try {
          elementsHaveResized = process$1();
        } finally {
          if (scheduled = !1, timeout = until - time(), !isWatching())
            return;
          elementsHaveResized ? _this.run(1e3) : timeout > 0 ? _this.run(timeout) : _this.start();
        }
      });
    }
  }, Scheduler2.prototype.schedule = function() {
    this.stop(), this.run();
  }, Scheduler2.prototype.observe = function() {
    var _this = this, cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
  }, Scheduler2.prototype.start = function() {
    var _this = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), events.forEach(function(name2) {
      return global$1.addEventListener(name2, _this.listener, !0);
    }));
  }, Scheduler2.prototype.stop = function() {
    var _this = this;
    this.stopped || (this.observer && this.observer.disconnect(), events.forEach(function(name2) {
      return global$1.removeEventListener(name2, _this.listener, !0);
    }), this.stopped = !0);
  }, Scheduler2;
}(), scheduler = new Scheduler(), updateCount = function(n) {
  !watching && n > 0 && scheduler.start(), watching += n, !watching && scheduler.stop();
}, skipNotifyOnElement = function(target2) {
  return !isSVG(target2) && !isReplacedElement(target2) && getComputedStyle(target2).display === "inline";
}, ResizeObservation = function() {
  function ResizeObservation2(target2, observedBox) {
    this.target = target2, this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return ResizeObservation2.prototype.isActive = function() {
    var size2 = calculateBoxSize(this.target, this.observedBox, !0);
    return skipNotifyOnElement(this.target) && (this.lastReportedSize = size2), this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize;
  }, ResizeObservation2;
}(), ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = resizeObserver, this.callback = callback;
  }
  return ResizeObserverDetail2;
}(), observerMap = /* @__PURE__ */ new WeakMap(), getObservationIndex = function(observationTargets, target2) {
  for (var i = 0; i < observationTargets.length; i += 1)
    if (observationTargets[i].target === target2)
      return i;
  return -1;
}, ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  return ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  }, ResizeObserverController2.observe = function(resizeObserver, target2, options) {
    var detail = observerMap.get(resizeObserver), firstObservation = detail.observationTargets.length === 0;
    getObservationIndex(detail.observationTargets, target2) < 0 && (firstObservation && resizeObservers.push(detail), detail.observationTargets.push(new ResizeObservation(target2, options && options.box)), updateCount(1), scheduler.schedule());
  }, ResizeObserverController2.unobserve = function(resizeObserver, target2) {
    var detail = observerMap.get(resizeObserver), index2 = getObservationIndex(detail.observationTargets, target2), lastObservation = detail.observationTargets.length === 1;
    index2 >= 0 && (lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1), detail.observationTargets.splice(index2, 1), updateCount(-1));
  }, ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this, detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot2) {
      return _this.unobserve(resizeObserver, ot2.target);
    }), detail.activeTargets.splice(0, detail.activeTargets.length);
  }, ResizeObserverController2;
}(), ResizeObserver$1 = function() {
  function ResizeObserver2(callback) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof callback != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    ResizeObserverController.connect(this, callback);
  }
  return ResizeObserver2.prototype.observe = function(target2, options) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target2))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.observe(this, target2, options);
  }, ResizeObserver2.prototype.unobserve = function(target2) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!isElement(target2))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    ResizeObserverController.unobserve(this, target2);
  }, ResizeObserver2.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  }, ResizeObserver2.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, ResizeObserver2;
}();
const _ResizeObserver = typeof document < "u" && typeof window < "u" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver$1, _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(([entry]) => {
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      return resizeObserver.observe(element), () => {
        resizeObserver.unobserve(element), resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap(), subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      return subscribersCache.has(element) || (subscribersCache.set(element, subscribers), dispose = _createElementRectValueListener().subscribe(element, (elementRect) => {
        for (const sub2 of subscribers)
          sub2(elementRect);
      })), subscribers.push(subscriber), () => {
        const idx = subscribers.indexOf(subscriber);
        idx > -1 && subscribers.splice(idx, 1), subscribers.length === 0 && dispose && dispose();
      };
    }
  };
}
function useElementSize(element) {
  const [size2, setSize] = useState(null);
  return useEffect(() => {
    if (element)
      return _elementSizeObserver.subscribe(element, setSize);
  }, [element]), size2;
}
function useGlobalKeyDown(onKeyDown) {
  return useEffect(() => (addEventListener("keydown", onKeyDown), () => removeEventListener("keydown", onKeyDown)), [onKeyDown]);
}
function useMatchMedia(mediaQueryString, getServerSnapshot2) {
  const { subscribe: subscribe2, getSnapshot } = useMemo(() => {
    let MEDIA_QUERY_CACHE;
    const getMatchMedia = () => (MEDIA_QUERY_CACHE || (MEDIA_QUERY_CACHE = window.matchMedia(mediaQueryString)), MEDIA_QUERY_CACHE);
    return {
      subscribe: (onStoreChange) => {
        const matchMedia = getMatchMedia();
        return matchMedia.addEventListener("change", onStoreChange), () => matchMedia.removeEventListener("change", onStoreChange);
      },
      getSnapshot: () => getMatchMedia().matches
    };
  }, [mediaQueryString]);
  return useDebugValue(mediaQueryString), useSyncExternalStore(subscribe2, getSnapshot, getServerSnapshot2);
}
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
const globalScope = getGlobalScope();
function createGlobalScopedContext(key2, defaultValue) {
  const symbol = Symbol.for(key2);
  return typeof document > "u" ? createContext(defaultValue) : (globalScope[symbol] = globalScope[symbol] || createContext(defaultValue), globalScope[symbol]);
}
const ThemeContext = createGlobalScopedContext(
  "@sanity/ui/context/theme",
  null
);
function ThemeProvider(props) {
  const parentTheme = useContext(ThemeContext), {
    children,
    scheme = parentTheme?.scheme || "light",
    theme: rootTheme = parentTheme?.theme || null,
    tone = parentTheme?.tone || "default"
  } = props, themeContext = useMemo(() => rootTheme ? {
    version: 0,
    theme: rootTheme,
    scheme,
    tone
  } : null, [rootTheme, scheme, tone]), theme = useMemo(() => rootTheme ? getScopedTheme(rootTheme, scheme, tone) : null, [scheme, rootTheme, tone]);
  return theme ? /* @__PURE__ */ jsx(ThemeContext.Provider, { value: themeContext, children: /* @__PURE__ */ jsx(rt, { theme, children }) }) : /* @__PURE__ */ jsx("pre", { children: 'ThemeProvider: no "theme" property provided' });
}
ThemeProvider.displayName = "ThemeProvider";
function useRootTheme() {
  const value = useContext(ThemeContext);
  if (!value)
    throw new Error("useRootTheme(): missing context value");
  return value;
}
function ThemeColorProvider(props) {
  const { children, scheme, tone } = props, root = useRootTheme();
  return /* @__PURE__ */ jsx(ThemeProvider, { scheme: scheme || root.scheme, theme: root.theme, tone, children });
}
ThemeColorProvider.displayName = "ThemeColorProvider";
function useTheme_v2() {
  return getTheme_v2(nt());
}
function _getMediaQuery(media, index2) {
  return index2 === 0 ? `screen and (max-width: ${media[index2] - 1}px)` : index2 === media.length ? `screen and (min-width: ${media[index2 - 1]}px)` : `screen and (min-width: ${media[index2 - 1]}px) and (max-width: ${media[index2] - 1}px)`;
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index2 = mediaLen; index2 > -1; index2 -= 1) {
        const mediaQuery = _getMediaQuery(media, index2);
        sizes.push({ index: index2, mq: window.matchMedia(mediaQuery) });
      }
    }
    return sizes;
  };
  return { getSnapshot: () => {
    for (const { index: index2, mq } of getSizes())
      if (mq.matches) return index2;
    return 0;
  }, subscribe: (onStoreChange) => {
    const disposeFns = [];
    for (const { mq } of getSizes()) {
      const handleChange = () => {
        mq.matches && onStoreChange();
      };
      mq.addEventListener("change", handleChange), disposeFns.push(() => mq.removeEventListener("change", handleChange));
    }
    return () => {
      for (const disposeFn of disposeFns)
        disposeFn();
    };
  } };
}
function getServerSnapshot() {
  return 0;
}
function useMediaIndex() {
  const { media } = useTheme_v2(), store = useMemo(() => _createMediaStore(media), [media]);
  return useSyncExternalStore(store.subscribe, store.getSnapshot, getServerSnapshot);
}
function usePrefersReducedMotion(getServerSnapshot2 = () => !1) {
  return useMatchMedia("(prefers-reduced-motion: reduce)", getServerSnapshot2);
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  var _a, _b;
  const { card, media } = getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$border,
    (value) => value ? { "&&": { border: borderStyle } } : { "&&": { border: 0 } }
  );
}
function borderTop(props) {
  var _a, _b;
  const { card, media } = getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderTop,
    (value) => value ? { "&&": { borderTop: borderStyle } } : { "&&": { borderTop: 0 } }
  );
}
function borderRight(props) {
  var _a, _b;
  const { card, media } = getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderRight,
    (value) => value ? { "&&": { borderRight: borderStyle } } : { "&&": { borderRight: 0 } }
  );
}
function borderBottom(props) {
  var _a, _b;
  const { card, media } = getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderBottom,
    (value) => value ? { "&&": { borderBottom: borderStyle } } : { "&&": { borderBottom: 0 } }
  );
}
function borderLeft(props) {
  var _a, _b;
  const { card, media } = getTheme_v2(props.theme), borderStyle = `${(_b = (_a = card.border) == null ? void 0 : _a.width) != null ? _b : 1}px solid var(--card-border-color)`;
  return _responsive(
    media,
    props.$borderLeft,
    (value) => value ? { "&&": { borderLeft: borderStyle } } : { "&&": { borderLeft: 0 } }
  );
}
const BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, BOX_SIZING = {
  content: "content-box",
  border: "border-box"
}, BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [
    responsiveBoxSizingStyle,
    responsiveBoxHeightStyle,
    responsiveBoxOverflowStyle,
    responsiveBoxDisplayStyle
  ];
}
function responsiveBoxDisplayStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$display, (display) => ({
    "&:not([hidden])": { display }
  }));
}
function responsiveBoxSizingStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$overflow, (overflow) => ({
    overflow
  }));
}
const BASE_STYLE$3 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [
    BASE_STYLE$3,
    responsiveFlexAlignStyle,
    responsiveFlexGapStyle,
    responsiveFlexWrapStyle,
    responsiveFlexJustifyStyle,
    responsiveFlexDirectionStyle
  ];
}
function responsiveFlexAlignStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (align) => ({ alignItems: align }));
}
function responsiveFlexGapStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap2) => ({
    gap: gap2 ? rem(space2[gap2]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$wrap, (wrap) => ({ flexWrap: wrap }));
}
function responsiveFlexJustifyStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$justify, (justify) => ({ justifyContent: justify }));
}
function responsiveFlexDirectionStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$direction, (direction) => ({ flexDirection: direction }));
}
const BASE_STYLE$2 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$2, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return props.$flex ? _responsive(media, props.$flex, (flex) => ({ flex })) : EMPTY_ARRAY;
}
function focusRingBorderStyle(border2) {
  return `inset 0 0 0 ${border2.width}px ${border2.color}`;
}
function focusRingStyle(opts) {
  const { base, border: border2, focusRing } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [
    focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`,
    border2 && focusRingBorderStyle(border2),
    focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`,
    focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`
  ].filter(Boolean).join(",");
}
const GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
}, GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
}, GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [
    GRID_CSS,
    responsiveGridAutoFlowStyle,
    responsiveGridAutoRowsStyle,
    responsiveGridAutoColsStyle,
    responsiveGridColumnsStyle,
    responsiveGridRowsStyle,
    responsiveGridGapStyle,
    responsiveGridGapXStyle,
    responsiveGridGapYStyle
  ];
}
function responsiveGridAutoFlowStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$columns, (columns) => ({
    gridTemplateColumns: columns && `repeat(${columns},minmax(0,1fr));`
  }));
}
function responsiveGridRowsStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$rows, (rows) => ({
    gridTemplateRows: rows && `repeat(${rows},minmax(0,1fr));`
  }));
}
function responsiveGridGapStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap2) => ({
    gridGap: gap2 ? rem(space2[gap2]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space2[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space2[gapY]) : void 0
  }));
}
function responsiveGridItemStyle() {
  return [
    responsiveGridItemRowStyle,
    responsiveGridItemRowStartStyle,
    responsiveGridItemRowEndStyle,
    responsiveGridItemColumnStyle,
    responsiveGridItemColumnStartStyle,
    responsiveGridItemColumnEndStyle
  ];
}
const GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
}, GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$row, (row) => typeof row == "number" ? { gridRow: `span ${row} / span ${row}` } : { gridRow: GRID_ITEM_ROW[row] });
}
function responsiveGridItemRowStartStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowEnd, (rowEnd) => ({ gridRowEnd: rowEnd }));
}
function responsiveGridItemColumnStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$column, (column2) => typeof column2 == "number" ? { gridColumn: `span ${column2} / span ${column2}` } : { gridColumn: GRID_ITEM_COLUMN[column2] });
}
function responsiveGridItemColumnStartStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
function responsiveInputPaddingStyle(props) {
  const { $fontSize, $iconLeft, $iconRight, $padding, $space } = props, { font, media, space: space2 } = getTheme_v2(props.theme), len = Math.max($padding.length, $space.length, $fontSize.length), _padding = [], _space = [], _fontSize = [];
  for (let i = 0; i < len; i += 1)
    _fontSize[i] = $fontSize[i] === void 0 ? _fontSize[i - 1] : $fontSize[i], _padding[i] = $padding[i] === void 0 ? _padding[i - 1] : $padding[i], _space[i] = $space[i] === void 0 ? _space[i - 1] : $space[i];
  return _responsive(media, _padding, (_2, i) => {
    const size2 = font.text.sizes[_fontSize[i]] || font.text.sizes[2], emSize = size2.lineHeight - size2.ascenderHeight - size2.descenderHeight, p = space2[_padding[i]], s = space2[_space[i]], styles = {
      paddingTop: rem(p - size2.ascenderHeight),
      paddingRight: rem(p),
      paddingBottom: rem(p - size2.descenderHeight),
      paddingLeft: rem(p)
    };
    return $iconRight && (styles.paddingRight = rem(p + emSize + s)), $iconLeft && (styles.paddingLeft = rem(p + emSize + s)), styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({ ...props, $iconRight: !0 });
}
const ROOT_STYLE = lt$2`
  &:not([hidden]) {
    display: flex;
  }

  align-items: center;
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const { $scheme, $tone, $weight } = props, { color: color2, font } = getTheme_v2(props.theme);
  return lt$2`
    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${$weight && font.text.weights[$weight] || font.text.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;

    /* NOTE: This is a hack to disable Chrome’s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    color: var(--input-fg-color);

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --input-fg-color: ${color2.input.default.enabled.fg};
      --input-placeholder-color: ${color2.input.default.enabled.placeholder};

      /* enabled */
      &:not(:invalid):not(:disabled):not(:read-only) {
        --input-fg-color: ${color2.input.default.enabled.fg};
        --input-placeholder-color: ${color2.input.default.enabled.placeholder};
      }

      /* disabled */
      &:not(:invalid):disabled {
        --input-fg-color: ${color2.input.default.disabled.fg};
        --input-placeholder-color: ${color2.input.default.disabled.placeholder};
      }

      /* invalid */
      &:invalid {
        --input-fg-color: ${color2.input.invalid.enabled.fg};
        --input-placeholder-color: ${color2.input.invalid.enabled.placeholder};
      }

      /* readOnly */
      &:read-only {
        --input-fg-color: ${color2.input.default.readOnly.fg};
        --input-placeholder-color: ${color2.input.default.readOnly.placeholder};
      }
    }
  `;
}
function textInputFontSizeStyle(props) {
  const { font, media } = getTheme_v2(props.theme);
  return _responsive(media, props.$fontSize, (sizeIndex) => {
    const size2 = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size2.fontSize),
      lineHeight: size2.lineHeight / size2.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const { $hasPrefix, $hasSuffix, $scheme, $tone, $unstableDisableFocusRing } = props, { color: color2, input } = getTheme_v2(props.theme);
  return lt$2`
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;

    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --card-bg-color: ${color2.input.default.enabled.bg};
      --card-fg-color: ${color2.input.default.enabled.fg};

      /* enabled */
      *:not(:disabled) + &[data-border] {
        --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
      }

      /* invalid */
      *:not(:disabled):invalid + & {
        --card-bg-color: ${color2.input.invalid.enabled.bg};
        --card-fg-color: ${color2.input.invalid.enabled.fg};

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.enabled.border,
    width: input.border.width
  })};
        }
      }

      /* focused */
      *:not(:disabled):focus + & {
        &[data-border] {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: { color: color2.input.default.enabled.border, width: input.border.width },
    focusRing: input.text.focusRing
  })};
        }

        &:not([data-border]) {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({ focusRing: input.text.focusRing })};
        }
      }

      /* disabled */
      *:not(:invalid):disabled + & {
        --card-bg-color: ${color2.input.default.disabled.bg} !important;
        --card-fg-color: ${color2.input.default.disabled.fg} !important;
        --card-icon-color: ${color2.input.default.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.disabled.border,
    width: input.border.width
  })};
        }
      }

      *:invalid:disabled + & {
        --card-bg-color: ${color2.input.invalid.disabled.bg} !important;
        --card-fg-color: ${color2.input.invalid.disabled.fg} !important;
        --card-icon-color: ${color2.input.invalid.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.disabled.border,
    width: input.border.width
  })};
        }
      }

      /* readOnly */
      *:not(:invalid):read-only + & {
        --card-bg-color: ${color2.input.default.readOnly.bg} !important;
        --card-fg-color: ${color2.input.default.readOnly.fg} !important;
      }

      *:invalid:read-only + & {
        --card-bg-color: ${color2.input.invalid.readOnly.bg} !important;
        --card-fg-color: ${color2.input.invalid.readOnly.fg} !important;
      }

      /* hovered */
      @media (hover: hover) {
        *:not(:disabled):not(:read-only):not(:invalid):hover + & {
          --card-bg-color: ${color2.input.default.hovered.bg};
          --card-fg-color: ${color2.input.default.hovered.fg};
        }

        *:invalid:not(:disabled):not(:read-only):hover + & {
          --card-bg-color: ${color2.input.invalid.hovered.bg};
          --card-fg-color: ${color2.input.invalid.hovered.fg};
        }

        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
        }

        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color2.input.invalid.hovered.border,
    width: input.border.width
  })};
        }
      }
    }
  `;
}
function responsiveMarginStyle(props) {
  const { theme } = props;
  return [
    _getResponsiveSpace(theme, ["margin"], props.$margin),
    _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX),
    _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY),
    _getResponsiveSpace(theme, ["marginTop"], props.$marginTop),
    _getResponsiveSpace(theme, ["marginRight"], props.$marginRight),
    _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom),
    _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)
  ].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const { theme } = props;
  return [
    _getResponsiveSpace(theme, ["padding"], props.$padding),
    _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX),
    _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY),
    _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop),
    _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight),
    _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom),
    _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)
  ].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const { media, radius } = getTheme_v2(props.theme);
  return _responsive(media, props.$radius, (value) => {
    let borderRadius = 0;
    return typeof value == "number" && (borderRadius = rem(radius[value])), value === "full" && (borderRadius = "9999px"), { borderRadius };
  });
}
function toBoxShadow(shadow, color2) {
  return `${shadow.map(rem).join(" ")} ${color2}`;
}
function shadowStyle(shadow, outlineWidth = 1) {
  if (!shadow) return EMPTY_RECORD;
  const outline = `0 0 0 ${rem(outlineWidth)} var(--card-shadow-outline-color)`, umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)"), penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)"), ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return { boxShadow: `${outline}, ${umbra}, ${penumbra}, ${ambient}` };
}
function responsiveShadowStyle(props) {
  const { card, media, shadow } = getTheme_v2(props.theme);
  return _responsive(
    media,
    props.$shadow,
    (index2) => shadowStyle(shadow[index2], card.shadow.outline)
  );
}
function labelBaseStyle(props) {
  const { $accent, $muted } = props, { font } = getTheme_v2(props.theme);
  return lt$2`
    text-transform: uppercase;

    ${$accent && lt$2`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt$2`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$C = dt.div(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle), SpanWithTextOverflow$2 = dt.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Label = forwardRef(function(props, ref) {
  const {
    accent,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" ? children = /* @__PURE__ */ jsx(SpanWithTextOverflow$2, { children }) : children = /* @__PURE__ */ jsx("span", { children }), /* @__PURE__ */ jsx(
    Root$C,
    {
      "data-ui": "Label",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      $size: useArrayProp(size2),
      $weight: weight,
      ref,
      children
    }
  );
});
Label.displayName = "ForwardRef(Label)";
const avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const { $color } = props, { avatar } = getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": `var(--card-avatar-${$color}-bg-color)`,
    "--avatar-fg-color": `var(--card-avatar-${$color}-fg-color)`,
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({ focusRing: avatar.focusRing })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const { avatar, media } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
const Root$B = dt.div(
  responsiveAvatarSizeStyle,
  avatarStyle.root
), Arrow$1 = dt.div(avatarStyle.arrow), BgStroke = dt.ellipse(avatarStyle.bgStroke), Stroke = dt.ellipse(avatarStyle.stroke), Initials = dt.div(avatarStyle.initials), InitialsLabel = dt(Label)({
  color: "inherit"
}), Image = dt.svg(avatarStyle.image), Avatar = forwardRef(function(props, ref) {
  const {
    __unstable_hideInnerStroke,
    as: asProp,
    color: color2 = "gray",
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status = "online",
    size: sizeProp = 1,
    ...restProps
  } = props, { avatar } = useTheme_v2(), as = ReactIs.isValidElementType(asProp) ? asProp : "div", size2 = useArrayProp(sizeProp), _sizeRem = (avatar.sizes[size2[0]] || avatar.sizes[0]).size, _radius = _sizeRem / 2, elementId = useId(), [arrowPosition, setArrowPosition] = useState(
    animateArrowFrom || arrowPositionProp || "inside"
  ), [imageFailed, setImageFailed] = useState(!1), imageId = `avatar-image-${elementId}`;
  useEffect(() => {
    if (arrowPosition === arrowPositionProp) return;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, [arrowPosition, arrowPositionProp]), useEffect(() => {
    src && setImageFailed(!1);
  }, [src]);
  const handleImageError = useCallback(() => {
    setImageFailed(!0), onImageLoadError && onImageLoadError(new Error("Avatar: the image failed to load"));
  }, [onImageLoadError]), initialsSize = useMemo(
    () => size2.map((s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0),
    [size2]
  );
  return /* @__PURE__ */ jsxs(
    Root$B,
    {
      as,
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Avatar",
      ...restProps,
      $color: color2,
      $size: size2,
      "aria-label": title,
      "data-arrow-position": arrowPosition,
      "data-status": status,
      ref,
      title,
      children: [
        /* @__PURE__ */ jsx(Arrow$1, { children: /* @__PURE__ */ jsx("svg", { width: "11", height: "7", viewBox: "0 0 11 7", fill: "none", children: /* @__PURE__ */ jsx(
          "path",
          {
            d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z",
            fill: color2
          }
        ) }) }),
        !imageFailed && src && /* @__PURE__ */ jsxs(Image, { viewBox: `0 0 ${_sizeRem} ${_sizeRem}`, fill: "none", children: [
          /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsx("pattern", { id: imageId, patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: /* @__PURE__ */ jsx(
            "image",
            {
              href: src,
              width: "1",
              height: "1",
              onError: handleImageError
            }
          ) }) }),
          /* @__PURE__ */ jsx("circle", { cx: _radius, cy: _radius, r: _radius, fill: `url(#${imageId})` }),
          !__unstable_hideInnerStroke && /* @__PURE__ */ jsx(
            BgStroke,
            {
              cx: _radius,
              cy: _radius,
              rx: _radius,
              ry: _radius,
              vectorEffect: "non-scaling-stroke"
            }
          ),
          /* @__PURE__ */ jsx(
            Stroke,
            {
              cx: _radius,
              cy: _radius,
              rx: _radius,
              ry: _radius,
              vectorEffect: "non-scaling-stroke"
            }
          )
        ] }),
        (imageFailed || !src) && initials && /* @__PURE__ */ jsx(Fragment$1, { children: /* @__PURE__ */ jsx(Initials, { children: /* @__PURE__ */ jsx(InitialsLabel, { forwardedAs: "span", size: initialsSize, weight: "medium", children: initials }) }) })
      ]
    }
  );
});
Avatar.displayName = "ForwardRef(Avatar)";
function _responsiveAvatarCounterSizeStyle(props) {
  const { avatar, media } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    } : EMPTY_RECORD;
  });
}
function _avatarCounterBaseStyle(props) {
  const { space: space2 } = getTheme_v2(props.theme);
  return lt$2`
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    user-select: none;
    color: inherit;
    color: var(--card-fg-color);
    background: var(--card-bg-color);
    box-shadow:
      0 0 0 1px var(--card-bg-color),
      inset 0 0 0 1px var(--card-hairline-hard-color);
    padding: 0 ${rem(space2[2])};

    &:not([hidden]) {
      display: flex;
    }
  `;
}
const Root$A = dt.div(
  _responsiveAvatarCounterSizeStyle,
  _avatarCounterBaseStyle
), AvatarCounter = forwardRef(function(props, ref) {
  const { count, size: sizeProp = 1 } = props, size2 = useArrayProp(sizeProp), fontSize2 = useMemo(
    () => size2.map((s) => s === 1 ? 1 : s === 2 ? 3 : s === 3 ? 5 : 0),
    [size2]
  );
  return /* @__PURE__ */ jsx(Root$A, { $size: size2, "data-ui": "AvatarCounter", ref, children: /* @__PURE__ */ jsx(Label, { as: "span", size: fontSize2, weight: "medium", children: count }) });
});
AvatarCounter.displayName = "ForwardRef(AvatarCounter)";
const BASE_STYLES = lt$2`
  white-space: nowrap;

  & > div {
    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  }
`;
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const { avatar, media } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size2) => {
    const avatarSize = avatar.sizes[size2];
    return avatarSize ? {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    } : EMPTY_RECORD;
  });
}
const Root$z = dt.div(responsiveAvatarStackSizeStyle, avatarStackStyle), AvatarStack = forwardRef(function(props, ref) {
  const {
    children: childrenProp,
    maxLength: maxLengthProp = 4,
    size: sizeProp = 1,
    ...restProps
  } = props, children = useMemo(
    () => Children.toArray(childrenProp).filter(isValidElement),
    [childrenProp]
  ), maxLength = Math.max(maxLengthProp, 0), size2 = useArrayProp(sizeProp), len = children.length, visibleCount = maxLength - 1, extraCount = len - visibleCount, visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children;
  return /* @__PURE__ */ jsxs(Root$z, { "data-ui": "AvatarStack", ...restProps, ref, $size: size2, children: [
    len === 0 && /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(AvatarCounter, { count: len, size: size2 }) }),
    len !== 0 && extraCount > 1 && /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(AvatarCounter, { count: extraCount, size: size2 }) }),
    visibleChildren.map((child, childIndex) => /* @__PURE__ */ jsx("div", { children: cloneElement(child, { size: size2 }) }, String(childIndex)))
  ] });
});
AvatarStack.displayName = "ForwardRef(AvatarStack)";
const Root$y = dt.div(
  boxStyle,
  flexItemStyle,
  responsiveBoxStyle,
  responsiveGridItemStyle,
  responsiveMarginStyle,
  responsivePaddingStyle
), Box = forwardRef(function(props, ref) {
  const {
    as: asProp = "div",
    column: column2,
    columnStart,
    columnEnd,
    display = "block",
    flex,
    height,
    margin = 0,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding = 0,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx(
    Root$y,
    {
      "data-as": typeof asProp == "string" ? asProp : void 0,
      "data-ui": "Box",
      ...restProps,
      $column: useArrayProp(column2),
      $columnStart: useArrayProp(columnStart),
      $columnEnd: useArrayProp(columnEnd),
      $display: useArrayProp(display),
      $flex: useArrayProp(flex),
      $height: useArrayProp(height),
      $margin: useArrayProp(margin),
      $marginX: useArrayProp(marginX),
      $marginY: useArrayProp(marginY),
      $marginTop: useArrayProp(marginTop),
      $marginRight: useArrayProp(marginRight),
      $marginBottom: useArrayProp(marginBottom),
      $marginLeft: useArrayProp(marginLeft),
      $overflow: useArrayProp(overflow),
      $padding: useArrayProp(padding),
      $paddingX: useArrayProp(paddingX),
      $paddingY: useArrayProp(paddingY),
      $paddingTop: useArrayProp(paddingTop),
      $paddingRight: useArrayProp(paddingRight),
      $paddingBottom: useArrayProp(paddingBottom),
      $paddingLeft: useArrayProp(paddingLeft),
      $row: useArrayProp(row),
      $rowStart: useArrayProp(rowStart),
      $rowEnd: useArrayProp(rowEnd),
      $sizing: useArrayProp(sizing),
      as: asProp,
      ref,
      children: props.children
    }
  );
});
Box.displayName = "ForwardRef(Box)";
function textBaseStyle(props) {
  const { $accent, $muted } = props, { font } = getTheme_v2(props.theme);
  return lt$2`
    color: var(--card-fg-color);

    ${$accent && lt$2`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt$2`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
      background-color: var(--card-code-bg-color);
      color: var(--card-code-fg-color);
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.text.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
      color: var(--card-icon-color);

      & path {
        vector-effect: non-scaling-stroke !important;
      }
    }
  `;
}
const Root$x = dt.div(
  responsiveTextFont,
  responsiveTextAlignStyle,
  textBaseStyle
), SpanWithTextOverflow$1 = dt.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Text = forwardRef(function(props, ref) {
  const {
    accent = !1,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" && (children = /* @__PURE__ */ jsx(SpanWithTextOverflow$1, { children })), /* @__PURE__ */ jsx(
    Root$x,
    {
      "data-ui": "Text",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      ref,
      $size: useArrayProp(size2),
      $weight: weight,
      children: /* @__PURE__ */ jsx("span", { children })
    }
  );
});
Text.displayName = "ForwardRef(Text)";
function badgeStyle(props) {
  const { $tone } = props;
  return {
    "--card-bg-color": `var(--card-badge-${$tone}-bg-color)`,
    "--card-fg-color": `var(--card-badge-${$tone}-fg-color)`,
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
const Root$w = dt(Box)(
  responsiveRadiusStyle,
  badgeStyle
), Badge = forwardRef(function(props, ref) {
  const {
    children,
    fontSize: fontSize2 = 1,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    mode: _deprecated_mode,
    padding = 1,
    radius = "full",
    tone = "default",
    ...restProps
  } = props;
  return /* @__PURE__ */ jsx(
    Root$w,
    {
      "data-ui": "Badge",
      ...restProps,
      $tone: tone,
      $radius: useArrayProp(radius),
      padding: useArrayProp(padding),
      ref,
      children: /* @__PURE__ */ jsx(Text, { size: fontSize2, children })
    }
  );
});
Badge.displayName = "ForwardRef(Badge)";
const Root$v = dt(Box)(
  flexItemStyle,
  responsiveFlexStyle
), Flex = forwardRef(function(props, ref) {
  const { align, as, direction = "row", gap: gap2, justify, wrap, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Root$v,
    {
      "data-ui": "Flex",
      ...restProps,
      $align: useArrayProp(align),
      $direction: useArrayProp(direction),
      $gap: useArrayProp(gap2),
      $justify: useArrayProp(justify),
      $wrap: useArrayProp(wrap),
      forwardedAs: as,
      ref
    }
  );
});
Flex.displayName = "ForwardRef(Flex)";
const rotate$1 = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, Root$u = dt(Text)`
  & > span > svg {
    animation: ${rotate$1} 500ms linear infinite;
  }
`, Spinner = forwardRef(function(props, ref) {
  return /* @__PURE__ */ jsx(Root$u, { "data-ui": "Spinner", ...props, ref, children: /* @__PURE__ */ jsx(SpinnerIcon, {}) });
});
Spinner.displayName = "ForwardRef(Spinner)";
function _cardColorStyle(base, color2, checkered = !1) {
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color2.accent.fg,
    "--card-avatar-gray-bg-color": color2.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color2.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color2.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color2.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color2.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color2.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color2.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color2.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color2.avatar.red.bg,
    "--card-avatar-red-fg-color": color2.avatar.red.fg,
    "--card-avatar-orange-bg-color": color2.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color2.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color2.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color2.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color2.avatar.green.bg,
    "--card-avatar-green-fg-color": color2.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color2.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color2.avatar.cyan.fg,
    "--card-bg-color": color2.bg,
    "--card-bg-image": checkered ? `repeating-conic-gradient(${color2.bg} 0% 25%, ${color2.muted.bg} 0% 50%)` : void 0,
    "--card-border-color": color2.border,
    "--card-badge-default-bg-color": color2.badge.default.bg,
    "--card-badge-default-dot-color": color2.badge.default.dot,
    "--card-badge-default-fg-color": color2.badge.default.fg,
    "--card-badge-default-icon-color": color2.badge.default.icon,
    "--card-badge-primary-bg-color": color2.badge.primary.bg,
    "--card-badge-primary-dot-color": color2.badge.primary.dot,
    "--card-badge-primary-fg-color": color2.badge.primary.fg,
    "--card-badge-primary-icon-color": color2.badge.primary.icon,
    "--card-badge-positive-bg-color": color2.badge.positive.bg,
    "--card-badge-positive-dot-color": color2.badge.positive.dot,
    "--card-badge-positive-fg-color": color2.badge.positive.fg,
    "--card-badge-positive-icon-color": color2.badge.positive.icon,
    "--card-badge-caution-bg-color": color2.badge.caution.bg,
    "--card-badge-caution-dot-color": color2.badge.caution.dot,
    "--card-badge-caution-fg-color": color2.badge.caution.fg,
    "--card-badge-caution-icon-color": color2.badge.caution.icon,
    "--card-badge-critical-bg-color": color2.badge.critical.bg,
    "--card-badge-critical-dot-color": color2.badge.critical.dot,
    "--card-badge-critical-fg-color": color2.badge.critical.fg,
    "--card-badge-critical-icon-color": color2.badge.critical.icon,
    "--card-code-bg-color": color2.code.bg,
    "--card-code-fg-color": color2.code.fg,
    "--card-fg-color": color2.fg,
    "--card-icon-color": color2.icon,
    "--card-kbd-bg-color": color2.kbd.bg,
    "--card-kbd-border-color": color2.kbd.border,
    "--card-kbd-fg-color": color2.kbd.fg,
    "--card-link-fg-color": color2.link.fg,
    "--card-muted-bg-color": color2.muted.bg,
    "--card-muted-fg-color": color2.muted.fg,
    "--card-skeleton-color-from": color2.skeleton.from,
    "--card-skeleton-color-to": color2.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color2.muted.bg,
    "--card-link-color": color2.link.fg,
    "--card-hairline-soft-color": color2.border,
    "--card-hairline-hard-color": color2.border
  };
}
function buttonBaseStyles(props) {
  const { $width } = props, { style: style2 } = getTheme_v2(props.theme);
  return lt$2`
    ${style2?.button};

    -webkit-font-smoothing: inherit;
    appearance: none;
    display: inline-flex;
    align-items: center;
    font: inherit;
    border: 0;
    outline: none;
    user-select: none;
    text-decoration: none;
    border: 0;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    white-space: nowrap;
    text-align: left;
    position: relative;
    vertical-align: top;

    ${$width === "fill" && lt$2`
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    `}

    & > span {
      display: block;
      flex: 1;
      min-width: 0;
      border-radius: inherit;
    }

    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  `;
}
function combineBoxShadow(...boxShadows) {
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  var _a;
  const { $mode } = props, { button, color: baseColor, style: style2 } = getTheme_v2(props.theme), shadow = props.$mode === "ghost", mode = baseColor.button[$mode] || baseColor.button.default, color2 = mode[props.$tone] || mode.default, border2 = {
    width: button.border.width,
    color: "var(--card-border-color)"
  }, defaultBoxShadow = void 0;
  return [
    _cardColorStyle(baseColor, color2.enabled),
    {
      backgroundColor: "var(--card-bg-color)",
      color: "var(--card-fg-color)",
      boxShadow: focusRingBorderStyle(border2),
      '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color2.disabled),
      "&:not([data-disabled='true'])": {
        boxShadow: combineBoxShadow(
          focusRingBorderStyle(border2),
          shadow ? defaultBoxShadow : void 0
        ),
        "&:focus": {
          boxShadow: focusRingStyle({
            base: baseColor,
            border: { width: 2, color: baseColor.bg },
            focusRing: button.focusRing
          })
        },
        "&:focus:not(:focus-visible)": {
          boxShadow: combineBoxShadow(
            focusRingBorderStyle(border2),
            shadow ? defaultBoxShadow : void 0
          )
        },
        "@media (hover: hover)": {
          "&:hover": _cardColorStyle(baseColor, color2.hovered),
          "&:active": _cardColorStyle(baseColor, color2.pressed),
          "&[data-hovered]": _cardColorStyle(baseColor, color2.hovered)
        },
        "&[data-selected]": _cardColorStyle(baseColor, color2.pressed)
      }
    },
    (_a = style2?.button) == null ? void 0 : _a.root
  ].filter(Boolean);
}
const Root$t = dt.button(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles), LoadingBox = dt.div`
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background-color: var(--card-bg-color);
  border-radius: inherit;
  z-index: 1;
  box-shadow: inherit;
`, Button = forwardRef(function(props, ref) {
  const {
    children,
    disabled,
    fontSize: fontSize2 = 1,
    icon: IconComponent,
    iconRight: IconRightComponent,
    justify: justifyProp = "center",
    loading,
    mode = "default",
    padding: paddingProp = 3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: radiusProp = 2,
    selected,
    space: spaceProp = 3,
    text,
    textAlign,
    tone = "default",
    type = "button",
    muted = !1,
    width,
    ...restProps
  } = props, { button } = useTheme_v2(), justify = useArrayProp(justifyProp), padding = useArrayProp(paddingProp), paddingX = useArrayProp(paddingXProp), paddingY = useArrayProp(paddingYProp), paddingTop = useArrayProp(paddingTopProp), paddingBottom = useArrayProp(paddingBottomProp), paddingLeft = useArrayProp(paddingLeftProp), paddingRight = useArrayProp(paddingRightProp), radius = useArrayProp(radiusProp), space2 = useArrayProp(spaceProp), boxProps = useMemo(
    () => ({
      // flex: 1,
      padding,
      paddingX,
      paddingY,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight
    }),
    [padding, paddingX, paddingY, paddingTop, paddingBottom, paddingLeft, paddingRight]
  );
  return /* @__PURE__ */ jsxs(
    Root$t,
    {
      "data-ui": "Button",
      ...restProps,
      $mode: mode,
      $radius: radius,
      $tone: tone,
      "data-disabled": !!(loading || disabled),
      "data-selected": selected ? "" : void 0,
      disabled: !!(loading || disabled),
      ref,
      type,
      $width: width,
      children: [
        !!loading && /* @__PURE__ */ jsx(LoadingBox, { children: /* @__PURE__ */ jsx(Spinner, {}) }),
        (IconComponent || text || IconRightComponent) && /* @__PURE__ */ jsx(Box, { as: "span", ...boxProps, children: /* @__PURE__ */ jsxs(Flex, { as: "span", justify, gap: space2, children: [
          IconComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconComponent) && IconComponent,
            reactIsExports.isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
          ] }),
          text && /* @__PURE__ */ jsx(
            Text,
            {
              muted,
              align: textAlign,
              size: fontSize2,
              textOverflow: "ellipsis",
              weight: button.textWeight,
              children: text
            }
          ),
          IconRightComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconRightComponent) && IconRightComponent,
            reactIsExports.isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
          ] })
        ] }) }),
        children && /* @__PURE__ */ jsx(Box, { as: "span", ...boxProps, children })
      ]
    }
  );
});
Button.displayName = "ForwardRef(Button)";
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const { $checkered } = props, { space: space2 } = getTheme_v2(props.theme);
  return lt$2`
    ${$checkered && lt$2`
      background-size: ${space2[3]}px ${space2[3]}px;
      background-position: 50% 50%;
      background-image: var(--card-bg-image);
    `}

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      outline: none;
      text-decoration: none;
    }

    /* &:is(pre) */
    &[data-as='pre'] {
      font: inherit;
    }
  `;
}
function cardColorStyle(props) {
  var _a;
  const { $checkered, $focusRing, $muted } = props, { card, color: color2, style: style2 } = getTheme_v2(props.theme), border2 = { width: card.border.width, color: "var(--card-border-color)" };
  return lt$2`
    color-scheme: ${color2._dark ? "dark" : "light"};

    ${_cardColorStyle(color2, color2, $checkered)}

    background-color: ${$muted ? "var(--card-muted-bg-color)" : "var(--card-bg-color)"};
    color: var(--card-fg-color);

    /* &:is(button) */
    &[data-as='button'] {
      --card-focus-ring-box-shadow: none;

      cursor: default;
      box-shadow: var(--card-focus-ring-box-shadow);

      &:disabled {
        ${_cardColorStyle(color2, color2.selectable.default.disabled, $checkered)}
      }

      &:not(:disabled) {
        &[data-pressed] {
          ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, color2.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, color2.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({ base: color2, border: border2, focusRing: card.focusRing }) : void 0};
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      cursor: pointer;
      box-shadow: var(--card-focus-ring-box-shadow);

      &[data-disabled] {
        ${_cardColorStyle(color2, color2.selectable.default.disabled, $checkered)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, color2.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, color2.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color2, color2.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({ base: color2, border: border2, focusRing: card.focusRing }) : void 0};
        }
      }
    }

    ${(_a = style2?.card) == null ? void 0 : _a.root}
  `;
}
const Root$s = dt(Box)(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle), Card = forwardRef(function(props, ref) {
  const {
    __unstable_checkered: checkered = !1,
    __unstable_focusRing: focusRing = !1,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    muted,
    pressed,
    radius = 0,
    scheme,
    selected,
    shadow,
    tone: toneProp = "default",
    ...restProps
  } = props, as = reactIsExports.isValidElementType(asProp) ? asProp : "div", rootTheme = useRootTheme(), tone = toneProp === "inherit" ? rootTheme.tone : toneProp;
  return /* @__PURE__ */ jsx(ThemeColorProvider, { scheme, tone, children: /* @__PURE__ */ jsx(
    Root$s,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-scheme": rootTheme.scheme,
      "data-ui": "Card",
      "data-tone": tone,
      ...restProps,
      $border: useArrayProp(border2),
      $borderTop: useArrayProp(borderTop2),
      $borderRight: useArrayProp(borderRight2),
      $borderBottom: useArrayProp(borderBottom2),
      $borderLeft: useArrayProp(borderLeft2),
      $checkered: checkered,
      $focusRing: focusRing,
      $muted: muted,
      $radius: useArrayProp(radius),
      $shadow: useArrayProp(shadow),
      $tone: tone,
      "data-checkered": checkered ? "" : void 0,
      "data-pressed": pressed ? "" : void 0,
      "data-selected": selected ? "" : void 0,
      forwardedAs: as,
      ref,
      selected
    }
  ) });
});
Card.displayName = "ForwardRef(Card)";
function checkboxBaseStyles() {
  return lt$2`
    position: relative;
    display: inline-block;
  `;
}
function inputElementStyles(props) {
  const { color: color2, input, radius } = getTheme_v2(props.theme), { focusRing } = input.checkbox;
  return lt$2`
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    opacity: 0;
    z-index: 1;
    padding: 0;
    margin: 0;

    & + span {
      position: relative;
      display: block;
      height: ${rem(input.checkbox.size)};
      width: ${rem(input.checkbox.size)};
      box-sizing: border-box;
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
      border-radius: ${rem(radius[2])};
      line-height: 1;
      background-color: ${color2.input.default.enabled.bg};

      & > svg {
        display: block;
        position: absolute;
        opacity: 0;
        height: 100%;
        width: 100%;

        & > path {
          vector-effect: non-scaling-stroke;
          stroke-width: 1.5px !important;
        }
      }
    }

    &:checked + span {
      background: ${color2.input.default.enabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.fg,
    width: input.border.width
  })};
      color: ${color2.input.default.enabled.bg};
    }

    /* focus */
    &:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({ focusRing })};
    }

    /* focus when checked - uses a different offset */
    &:not(:disabled):focus:focus-visible&:checked + span {
      box-shadow: ${focusRingStyle({ focusRing: { width: 1, offset: 1 } })};
    }

    &[data-error] + span {
      background-color: ${color2.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.invalid.enabled.muted.bg
  })};
      color: ${color2.input.default.disabled.fg};
    }
    &[data-error]&:checked + span {
      background-color: ${color2.input.invalid.enabled.muted.bg};
      color: ${color2.input.default.enabled.bg};
    }
    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color2.input.invalid.readOnly.muted.bg },
    focusRing: { width: 1, offset: 1 }
  })};
    }

    &:disabled + span {
      background-color: ${color2.input.default.disabled.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.default.disabled.border
  })};
      color: ${color2.input.default.disabled.fg};
    }
    &:disabled&:checked + span {
      background-color: ${color2.input.default.disabled.muted.bg};
    }

    &[data-read-only] + span {
      background-color: ${color2.input.default.readOnly.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.default.readOnly.border
  })};
      color: ${color2.input.default.readOnly.fg};
    }

    &[data-read-only]&:checked + span {
      background-color: ${color2.input.default.readOnly.muted.bg};
    }

    &:checked + span > svg:first-child {
      opacity: 1;
    }
    &:indeterminate + span > svg:last-child {
      opacity: 1;
    }
  `;
}
const Root$r = dt.div(checkboxBaseStyles), Input$5 = dt.input(inputElementStyles), Checkbox = forwardRef(function(props, forwardedRef) {
  const {
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style: style2,
    ...restProps
  } = props, ref = useRef(null);
  return useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useEffect(() => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, [indeterminate]), useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxs(Root$r, { className, "data-ui": "Checkbox", style: style2, children: [
    /* @__PURE__ */ jsx(
      Input$5,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-error": customValidity ? "" : void 0,
        ...restProps,
        checked,
        disabled: disabled || readOnly,
        type: "checkbox",
        readOnly,
        ref
      }
    ),
    /* @__PURE__ */ jsxs("span", { children: [
      /* @__PURE__ */ jsx(CheckmarkIcon, {}),
      /* @__PURE__ */ jsx(RemoveIcon, {})
    ] })
  ] });
});
Checkbox.displayName = "ForwardRef(Checkbox)";
function codeSyntaxHighlightingStyle({ theme }) {
  const {
    color: { syntax: color2 }
  } = getTheme_v2(theme);
  return {
    "&.atrule": { color: color2.atrule },
    "&.attr-name": { color: color2.attrName },
    "&.attr-value": { color: color2.attrValue },
    "&.attribute": { color: color2.attribute },
    "&.boolean": { color: color2.boolean },
    "&.builtin": { color: color2.builtin },
    "&.cdata": { color: color2.cdata },
    "&.char": { color: color2.char },
    "&.class": { color: color2.class },
    "&.class-name": { color: color2.className },
    "&.comment": { color: color2.comment },
    "&.constant": { color: color2.constant },
    "&.deleted": { color: color2.deleted },
    "&.doctype": { color: color2.doctype },
    "&.entity": { color: color2.entity },
    "&.function": { color: color2.function },
    "&.hexcode": { color: color2.hexcode },
    "&.id": { color: color2.id },
    "&.important": { color: color2.important },
    "&.inserted": { color: color2.inserted },
    "&.keyword": { color: color2.keyword },
    "&.number": { color: color2.number },
    "&.operator": { color: color2.operator },
    "&.prolog": { color: color2.prolog },
    "&.property": { color: color2.property },
    "&.pseudo-class": { color: color2.pseudoClass },
    "&.pseudo-element": { color: color2.pseudoElement },
    "&.punctuation": { color: color2.punctuation },
    "&.regex": { color: color2.regex },
    "&.selector": { color: color2.selector },
    "&.string": { color: color2.string },
    "&.symbol": { color: color2.symbol },
    "&.tag": { color: color2.tag },
    "&.unit": { color: color2.unit },
    "&.url": { color: color2.url },
    "&.variable": { color: color2.variable }
  };
}
function codeBaseStyle() {
  return lt$2`
    color: var(--card-code-fg-color);

    & code {
      font-family: inherit;

      &.refractor .token {
        ${codeSyntaxHighlightingStyle}
      }
    }

    & a {
      color: inherit;
      text-decoration: underline;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$q = dt.pre(codeBaseStyle, responsiveCodeFontStyle), Code = forwardRef(function(props, ref) {
  const { children, language: languageProp, size: size2 = 2, weight, ...restProps } = props, language = typeof languageProp == "string" ? languageProp : void 0, registered2 = language ? Refractor$1.hasLanguage(language) : !1;
  return /* @__PURE__ */ jsxs(Root$q, { "data-ui": "Code", ...restProps, $size: useArrayProp(size2), $weight: weight, ref, children: [
    !(language && registered2) && /* @__PURE__ */ jsx("code", { children }),
    language && registered2 && /* @__PURE__ */ jsx(Refractor$1, { inline: !0, language, value: String(children) })
  ] });
});
Code.displayName = "ForwardRef(Code)";
const BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const { container, media } = getTheme_v2(props.theme);
  return _responsive(media, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container[val])
  }));
}
const Root$p = dt(Box)(
  containerBaseStyle,
  responsiveContainerWidthStyle
), Container = forwardRef(function(props, ref) {
  const { as, width = 2, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Root$p,
    {
      "data-ui": "Container",
      ...restProps,
      $width: useArrayProp(width),
      forwardedAs: as,
      ref
    }
  );
});
Container.displayName = "ForwardRef(Container)";
const Root$o = dt(Box)(responsiveGridStyle), Grid = forwardRef(function(props, ref) {
  const { as, autoRows, autoCols, autoFlow, columns, gap: gap2, gapX, gapY, rows, children, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Root$o,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Grid",
      ...restProps,
      $autoRows: useArrayProp(autoRows),
      $autoCols: useArrayProp(autoCols),
      $autoFlow: useArrayProp(autoFlow),
      $columns: useArrayProp(columns),
      $gap: useArrayProp(gap2),
      $gapX: useArrayProp(gapX),
      $gapY: useArrayProp(gapY),
      $rows: useArrayProp(rows),
      forwardedAs: as,
      ref,
      children
    }
  );
});
Grid.displayName = "ForwardRef(Grid)";
function headingBaseStyle(props) {
  const { $accent, $muted } = props, { font } = getTheme_v2(props.theme);
  return lt$2`
    ${$accent && lt$2`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt$2`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.heading.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
const Root$n = dt.div(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont), SpanWithTextOverflow = dt.span`
  display: block;
  white-space: nowrap;
  text-overflow: ellipsis;
  overflow: hidden;
  overflow: clip;
`, Heading = forwardRef(function(props, ref) {
  const {
    accent = !1,
    align,
    children: childrenProp,
    muted = !1,
    size: size2 = 2,
    textOverflow,
    weight,
    ...restProps
  } = props;
  let children = childrenProp;
  return textOverflow === "ellipsis" && (children = /* @__PURE__ */ jsx(SpanWithTextOverflow, { children })), /* @__PURE__ */ jsx(
    Root$n,
    {
      "data-ui": "Heading",
      ...restProps,
      $accent: accent,
      $align: useArrayProp(align),
      $muted: muted,
      $size: useArrayProp(size2),
      $weight: weight,
      ref,
      children: /* @__PURE__ */ jsx("span", { children })
    }
  );
});
Heading.displayName = "ForwardRef(Heading)";
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => {
    const _space = rem(spaceIndex === 0.5 ? space2[1] / 2 : space2[spaceIndex]);
    return {
      margin: `-${_space} 0 0 -${_space}`,
      "& > div": { padding: `${_space} 0 0 ${_space}` }
    };
  });
}
const Root$m = dt(Box)(inlineBaseStyle, inlineSpaceStyle), Inline = forwardRef(function(props, ref) {
  const { as, children: childrenProp, space: space2, ...restProps } = props, children = useMemo(
    () => Children.map(childrenProp, (child) => child && /* @__PURE__ */ jsx("div", { children: child })),
    [childrenProp]
  );
  return /* @__PURE__ */ jsx(
    Root$m,
    {
      "data-ui": "Inline",
      ...restProps,
      $space: useArrayProp(space2),
      forwardedAs: as,
      ref,
      children
    }
  );
});
Inline.displayName = "ForwardRef(Inline)";
function kbdStyle() {
  return lt$2`
    --card-bg-color: var(--card-kbd-bg-color);
    --card-border-color: var(--card-kbd-border-color);
    --card-fg-color: var(--card-kbd-fg-color);

    box-shadow: inset 0 0 0 1px var(--card-border-color);
    background: var(--card-bg-color);
    font: inherit;

    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
const Root$l = dt.kbd(responsiveRadiusStyle, kbdStyle), KBD = forwardRef(function(props, ref) {
  const { children, fontSize: fontSize2 = 0, padding = 1, radius = 2, ...restProps } = props;
  return /* @__PURE__ */ jsx(Root$l, { "data-ui": "KBD", ...restProps, $radius: useArrayProp(radius), ref, children: /* @__PURE__ */ jsx(Box, { as: "span", padding, children: /* @__PURE__ */ jsx(Text, { as: "span", size: fontSize2, weight: "semibold", children }) }) });
});
KBD.displayName = "ForwardRef(KBD)";
const origin = {
  name: "@sanity/ui/origin",
  fn({ middlewareData, placement, rects }) {
    var _a, _b;
    const [side] = placement.split("-"), floatingWidth = rects.floating.width, floatingHeight = rects.floating.height, shiftX = ((_a = middlewareData.shift) == null ? void 0 : _a.x) || 0, shiftY = ((_b = middlewareData.shift) == null ? void 0 : _b.y) || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0)
      return {};
    const isVerticalPlacement = ["bottom", "top"].includes(side), { originX, originY } = isVerticalPlacement ? {
      originX: clamp(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: { originX, originY }
    };
  }
};
function clamp(num2, min2, max2) {
  return Math.min(Math.max(num2, min2), max2);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x, height = targetPoint.y - movingPoint.y, distance2 = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance2));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length, cmds = [];
  for (let i = 0; i < len; i += 1) {
    const point = points[i], prevPoint = points[i - 1], nextPoint = points[i + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius), curveEnd = moveTowardsLength(point, nextPoint, point.radius), startControl = moveTowardsFractional(curveStart, point, 0.5), endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      }), cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else
      cmds.push({
        type: "point",
        ...point
      });
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n, idx) => n.type === "point" ? `${idx === 0 ? "M" : "L"} ${n.x} ${n.y}` : n.type === "curve" ? `C ${n.startControl.x} ${n.startControl.y} ${n.endControl.x} ${n.endControl.y} ${n.curveEnd.x} ${n.curveEnd.y}` : "").join(" ");
}
const Root$k = dt.div(
  ({ $w: w2 }) => lt$2`
    position: absolute;
    width: ${w2}px;
    height: ${w2}px;

    :empty + & {
      display: none;
    }

    & > svg {
      display: block;
      line-height: 0;
      transform-origin: ${w2 / 2}px ${w2 / 2}px;
    }

    [data-placement^='top'] > & {
      bottom: -${w2}px;

      & > svg {
        transform: rotate(0);
      }
    }

    [data-placement^='right'] > & {
      left: -${w2}px;

      & > svg {
        transform: rotate(90deg);
      }
    }

    [data-placement^='left'] > & {
      right: -${w2}px;

      & > svg {
        transform: rotate(-90deg);
      }
    }

    [data-placement^='bottom'] > & {
      top: -${w2}px;

      & > svg {
        transform: rotate(180deg);
      }
    }
  `
), StrokePath = dt.path`
  stroke: var(--card-shadow-outline-color);
`, ShapePath = dt.path`
  fill: var(--card-bg-color);
`, Arrow = forwardRef(function(props, ref) {
  const { width: w2, height: h2, radius = 0, ...restProps } = props, { card } = useTheme_v2(), strokeWidth = card.shadow.outline, center = w2 / 2, points = [
    {
      x: 0,
      y: 0
    },
    {
      x: radius,
      y: 0,
      radius
    },
    {
      x: center,
      y: h2 - 1,
      radius
    },
    {
      x: w2 - radius,
      y: 0,
      radius
    },
    {
      x: w2,
      y: 0
    }
  ], cmds = getRoundedCommands(points), path = compileCommands(cmds), strokePath = `${path}`, fillPath = `${path} M ${w2} -1 M 0 -1 Z`;
  return /* @__PURE__ */ jsx(Root$k, { ...restProps, $w: w2, ref, children: /* @__PURE__ */ jsxs("svg", { width: w2, height: w2, viewBox: `0 0 ${w2} ${w2}`, children: [
    /* @__PURE__ */ jsx("mask", { id: "stroke-mask", children: /* @__PURE__ */ jsx("rect", { x: 0, y: strokeWidth, width: w2, height: w2, fill: "white" }) }),
    /* @__PURE__ */ jsx(StrokePath, { d: strokePath, mask: "url(#stroke-mask)", strokeWidth: strokeWidth * 2 }),
    /* @__PURE__ */ jsx(ShapePath, { d: fillPath })
  ] }) });
});
Arrow.displayName = "ForwardRef(Arrow)";
const BoundaryElementContext = createGlobalScopedContext(
  "@sanity/ui/context/boundaryElement",
  null
);
function isRecord(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
const DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = useContext(BoundaryElementContext);
  if (value && (!isRecord(value) || value.version !== 0))
    throw new Error("useBoundaryElement(): the context value is not compatible");
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper({
  children,
  condition,
  wrapper
}) {
  return condition ? wrapper(children) : children;
}
ConditionalWrapper.displayName = "ConditionalWrapper";
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] > width && ret.push(i);
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i = 0; i < media.length; i += 1)
    media[i] <= width && ret.push(i);
  return ret;
}
const ElementQuery = forwardRef(function(props, forwardedRef) {
  const theme = useTheme_v2(), { children, media = theme.media, ...restProps } = props, ref = useRef(null), [element, setElement] = useState(null), elementSize = useElementSize(element), width = useMemo(() => {
    var _a;
    return (_a = elementSize?.border.width) != null ? _a : window.innerWidth;
  }, [elementSize]), max2 = useMemo(() => findMaxBreakpoints(media, width), [media, width]), min2 = useMemo(() => findMinBreakpoints(media, width), [media, width]);
  useImperativeHandle(forwardedRef, () => ref.current);
  const setRef = useCallback((el2) => {
    ref.current = el2, setElement(el2);
  }, []);
  return /* @__PURE__ */ jsx(
    "div",
    {
      "data-ui": "ElementQuery",
      ...restProps,
      "data-eq-max": max2.length ? max2.join(" ") : void 0,
      "data-eq-min": min2.length ? min2.join(" ") : void 0,
      ref: setRef,
      children
    }
  );
});
ElementQuery.displayName = "ForwardRef(ElementQuery)";
function getLayerContext(contextValue) {
  if (!isRecord(contextValue) || contextValue.version !== 0)
    throw new Error("the context value is not compatible");
  if (!contextValue)
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  if (contextValue.version === 0)
    return contextValue;
  throw new Error("could not get layer context");
}
const LayerContext = createGlobalScopedContext(
  "@sanity/ui/context/layer",
  null
);
function useLayer() {
  const value = useContext(LayerContext);
  if (!value)
    throw new Error("useLayer(): missing context value");
  try {
    return getLayerContext(value);
  } catch (err) {
    throw err instanceof Error ? new Error(`useLayer(): ${err.message}`) : new Error(`useLayer(): ${err}`);
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement(node2) {
  return node2 instanceof Node && node2.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node2) {
  return element.contains(node2) || element === node2;
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? !0 : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : !1;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return !1;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return !0;
  }
  return !1;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return !0;
  }
  return !1;
}
function _isScrollable(el2) {
  if (!(el2 instanceof Element)) return !1;
  const style2 = window.getComputedStyle(el2);
  return style2.overflowX.includes("auto") || style2.overflowX.includes("scroll") || style2.overflowY.includes("auto") || style2.overflowY.includes("scroll");
}
function LayerProvider(props) {
  var _a;
  const { children, zOffset: zOffsetProp = 0 } = props, parentContextValue = useContext(LayerContext), parent = parentContextValue && getLayerContext(parentContextValue), parentRegisterChild = parent?.registerChild, level = ((_a = parent?.level) != null ? _a : 0) + 1, zOffset = useArrayProp(zOffsetProp), maxMediaIndex = zOffset.length - 1, mediaIndex = Math.min(useMediaIndex(), maxMediaIndex), zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex], [, setChildLayers] = useState({}), [size2, setSize] = useState(0), isTopLayer2 = size2 === 0, registerChild = useCallback(
    (childLevel) => {
      const parentDispose = parentRegisterChild?.(childLevel);
      return childLevel !== void 0 ? setChildLayers((state) => {
        var _a2;
        const prevLen = (_a2 = state[childLevel]) != null ? _a2 : 0, nextState = { ...state, [childLevel]: prevLen + 1 };
        return setSize(Object.keys(nextState).length), nextState;
      }) : setSize((v2) => v2 + 1), () => {
        childLevel !== void 0 ? setChildLayers((state) => {
          const nextState = { ...state };
          return nextState[childLevel] === 1 ? (delete nextState[childLevel], setSize(Object.keys(nextState).length)) : nextState[childLevel] -= 1, nextState;
        }) : setSize((v2) => v2 - 1), parentDispose?.();
      };
    },
    [parentRegisterChild]
  );
  useEffect(() => parentRegisterChild?.(level), [level, parentRegisterChild]);
  const value = useMemo(
    () => ({
      version: 0,
      isTopLayer: isTopLayer2,
      level,
      registerChild,
      size: size2,
      zIndex
    }),
    [isTopLayer2, level, registerChild, size2, zIndex]
  );
  return /* @__PURE__ */ jsx(LayerContext.Provider, { value, children });
}
LayerProvider.displayName = "LayerProvider";
const Root$j = dt.div({ position: "relative" }), LayerChildren = forwardRef(function(props, forwardedRef) {
  const { children, onActivate, onFocus, style: style2 = EMPTY_RECORD, ...restProps } = props, { zIndex, isTopLayer: isTopLayer2 } = useLayer(), lastFocusedRef = useRef(null), ref = useRef(null), isTopLayerRef = useRef(isTopLayer2);
  useImperativeHandle(forwardedRef, () => ref.current), useEffect(() => {
    isTopLayerRef.current !== isTopLayer2 && isTopLayer2 && onActivate?.({ activeElement: lastFocusedRef.current }), isTopLayerRef.current = isTopLayer2;
  }, [isTopLayer2, onActivate]);
  const handleFocus = useCallback(
    (event) => {
      onFocus?.(event);
      const rootElement = ref.current, target2 = document.activeElement;
      !isTopLayer2 || !rootElement || !target2 || isHTMLElement(target2) && containsOrEqualsElement(rootElement, target2) && (lastFocusedRef.current = target2);
    },
    [isTopLayer2, onFocus]
  );
  return /* @__PURE__ */ jsx(Root$j, { ...restProps, "data-ui": "Layer", onFocus: handleFocus, ref, style: { ...style2, zIndex }, children });
}), Layer = forwardRef(function(props, ref) {
  const { children, zOffset = 1, ...restProps } = props;
  return /* @__PURE__ */ jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsx(LayerChildren, { ...restProps, ref, children }) });
});
Layer.displayName = "ForwardRef(Layer)";
const key = "@sanity/ui/context/portal", elementKey = Symbol.for(`${key}/element`);
globalScope[elementKey] = null;
const defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    return typeof document > "u" ? null : (globalScope[elementKey] || (globalScope[elementKey] = document.createElement("div"), globalScope[elementKey].setAttribute("data-portal", ""), document.body.appendChild(globalScope[elementKey])), globalScope[elementKey]);
  }
}, PortalContext = createGlobalScopedContext(key, defaultContextValue);
function usePortal() {
  const value = useContext(PortalContext);
  if (!value)
    throw new Error("usePortal(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("usePortal(): the context value is not compatible");
  return value;
}
function Portal(props) {
  var _a;
  const { children, __unstable_name: name2 } = props, portal = usePortal(), portalElement = (name2 ? portal.elements && portal.elements[name2] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  return portalElement ? reactDomExports.createPortal(children, portalElement) : null;
}
Portal.displayName = "Portal";
const Root$i = dt.div`
  display: block;
  width: 0;
  height: 0;
  position: absolute;
  overflow: hidden;
  overflow: clip;
`, SrOnly = forwardRef(function(props, ref) {
  const { as, children } = props;
  return /* @__PURE__ */ jsx(Root$i, { "aria-hidden": !0, as, "data-ui": "SrOnly", ref, children });
});
SrOnly.displayName = "ForwardRef(SrOnly)";
const Root$h = dt.div`
  position: relative;
`, ItemWrapper = dt.div`
  position: absolute;
  left: 0;
  right: 0;
`, VirtualList = forwardRef(function(props, forwardedRef) {
  const { as = "div", gap: gap2 = 0, getItemKey, items = [], onChange, renderItem, ...restProps } = props, { space: space2 } = useTheme_v2(), ref = useRef(null), wrapperRef = useRef(null), [scrollTop, setScrollTop] = useState(0), [scrollHeight, setScrollHeight] = useState(0), [itemHeight, setItemHeight] = useState(-1);
  useImperativeHandle(forwardedRef, () => ref.current), useEffect(() => {
    if (!wrapperRef.current) return;
    const firstElement = wrapperRef.current.firstChild;
    firstElement instanceof HTMLElement && setItemHeight(firstElement.offsetHeight);
  }, [renderItem]), useEffect(() => {
    if (!ref.current) return;
    let _scrollEl = ref.current.parentNode;
    for (; _scrollEl && !_isScrollable(_scrollEl); )
      _scrollEl = _scrollEl.parentNode;
    if (_scrollEl) {
      const scrollEl = _scrollEl;
      if (!(scrollEl instanceof HTMLElement)) return;
      const handleScroll2 = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll2, { passive: !0 });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      return ro.observe(scrollEl), handleScroll2(), () => {
        scrollEl.removeEventListener("scroll", handleScroll2), ro.unobserve(scrollEl), ro.disconnect();
      };
    }
    const handleScroll = () => {
      setScrollTop(window.scrollY);
    }, handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    return window.addEventListener("scroll", handleScroll, { passive: !0 }), window.addEventListener("resize", handleResize), setScrollHeight(window.innerHeight), handleScroll(), () => {
      window.removeEventListener("scroll", handleScroll), window.removeEventListener("resize", handleResize);
    };
  }, []);
  const len = items.length, height = itemHeight ? len * (itemHeight + space2[gap2]) - space2[gap2] : 0, fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0, toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  useEffect(() => {
    onChange && onChange({ fromIndex, gap: space2[gap2], itemHeight, scrollHeight, scrollTop, toIndex });
  }, [fromIndex, gap2, itemHeight, onChange, scrollHeight, scrollTop, space2, toIndex]);
  const children = useMemo(() => !renderItem || items.length === 0 ? null : itemHeight === -1 ? [/* @__PURE__ */ jsx(ItemWrapper, { children: renderItem(items[0]) }, 0)] : items.slice(fromIndex, toIndex).map((item, _itemIndex) => {
    const itemIndex = fromIndex + _itemIndex, node2 = renderItem(item), key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
    return /* @__PURE__ */ jsx(ItemWrapper, { style: { top: itemIndex * (itemHeight + space2[gap2]) }, children: node2 }, key2);
  }), [fromIndex, gap2, getItemKey, itemHeight, items, renderItem, space2, toIndex]), wrapperStyle = useMemo(() => ({ height }), [height]);
  return /* @__PURE__ */ jsx(Root$h, { as, "data-ui": "VirtualList", ...restProps, ref, children: /* @__PURE__ */ jsx("div", { ref: wrapperRef, style: wrapperStyle, children }) });
});
VirtualList.displayName = "ForwardRef(VirtualList)";
const DEFAULT_POPOVER_DISTANCE = 4, DEFAULT_POPOVER_PADDING = 4, DEFAULT_POPOVER_ARROW_WIDTH = 19, DEFAULT_POPOVER_ARROW_HEIGHT = 8, DEFAULT_POPOVER_ARROW_RADIUS = 2, DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0], DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size(options) {
  const { apply, margins, padding = 0 } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const { elements, placement, platform: platform2, rects } = args, { floating, reference } = rects, overflow = await detectOverflow(args, {
        altBoundary: !0,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = 1 / 0, maxHeight = 1 / 0;
      const floatingW = floating.width, floatingH = floating.height;
      placement.includes("top") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.top), placement.includes("right") && (maxWidth = floatingW - overflow.right, maxHeight = floatingH - (overflow.top + overflow.bottom)), placement.includes("bottom") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.bottom), placement.includes("left") && (maxWidth = floatingW - overflow.left, maxHeight = floatingH - (overflow.top + overflow.bottom)), apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform2.getDimensions(elements.floating), targetH = nextDimensions.height, targetW = nextDimensions.width;
      return floatingW !== targetW || floatingH !== targetH ? { reset: { rects: !0 } } : {};
    }
  };
}
function calcCurrentWidth(params) {
  const { container, mediaIndex, width } = params, w2 = width[mediaIndex], currentWidth = w2 === void 0 ? width[width.length - 1] : w2;
  return typeof currentWidth == "number" ? container[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const { boundaryWidth, currentWidth } = params;
  if (!(currentWidth === void 0 && boundaryWidth === void 0))
    return Math.min(
      currentWidth ?? 1 / 0,
      (boundaryWidth || 1 / 0) - DEFAULT_POPOVER_PADDING * 2
    );
}
const MotionCard$1 = dt(motion(Card))`
  &:not([hidden]) {
    display: flex;
  }
  flex-direction: column;
  width: max-content;
  min-width: min-content;
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, PopoverCard = memo$1(
  forwardRef(function(props, ref) {
    const {
      __unstable_margins: marginsProp,
      animate,
      arrow: arrow2,
      arrowRef,
      arrowX,
      arrowY,
      children,
      padding,
      placement,
      originX,
      originY,
      overflow,
      radius,
      scheme,
      shadow,
      strategy,
      style: style2,
      tone,
      width,
      x: xProp,
      y: yProp,
      ...restProps
    } = props, { zIndex } = useLayer(), margins = useMemo(
      () => marginsProp || DEFAULT_POPOVER_MARGINS,
      [marginsProp]
    ), x2 = (xProp ?? 0) + margins[3], y2 = (yProp ?? 0) + margins[0], rootStyle2 = useMemo(
      () => ({
        left: x2,
        originX,
        originY,
        position: strategy,
        top: y2,
        width,
        zIndex,
        willChange: animate ? "transform" : void 0,
        ...style2
      }),
      [animate, originX, originY, strategy, style2, width, x2, y2, zIndex]
    ), arrowStyle = useMemo(
      () => ({
        left: arrowX !== null ? arrowX : void 0,
        top: arrowY !== null ? arrowY : void 0,
        right: void 0,
        bottom: void 0
      }),
      [arrowX, arrowY]
    );
    return /* @__PURE__ */ jsxs(
      MotionCard$1,
      {
        "data-ui": "Popover",
        ...restProps,
        "data-placement": placement,
        radius,
        ref,
        scheme,
        shadow,
        sizing: "border",
        style: rootStyle2,
        tone,
        ...animate ? POPOVER_MOTION_PROPS : {},
        children: [
          /* @__PURE__ */ jsx(Flex, { "data-ui": "Popover__wrapper", direction: "column", flex: 1, overflow, children: /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, padding, children }) }),
          arrow2 && /* @__PURE__ */ jsx(
            Arrow,
            {
              ref: arrowRef,
              style: arrowStyle,
              width: DEFAULT_POPOVER_ARROW_WIDTH,
              height: DEFAULT_POPOVER_ARROW_HEIGHT,
              radius: DEFAULT_POPOVER_ARROW_RADIUS
            }
          )
        ]
      }
    );
  })
);
PopoverCard.displayName = "Memo(ForwardRef(PopoverCard))";
const Popover = memo$1(
  forwardRef(function(props, forwardedRef) {
    var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
    const { container, layer } = useTheme_v2(), boundaryElementContext = useBoundaryElement(), {
      __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
      animate: _animate = !1,
      arrow: arrowProp = !1,
      boundaryElement = boundaryElementContext.element,
      children: childProp,
      constrainSize = !1,
      content,
      disabled,
      fallbackPlacements = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS$1[(_a = props.placement) != null ? _a : "bottom"],
      matchReferenceWidth,
      floatingBoundary = (_c = props.boundaryElement) != null ? _c : boundaryElementContext.element,
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onActivate,
      open,
      overflow = "hidden",
      padding: paddingProp,
      placement: placementProp = "bottom",
      portal,
      preventOverflow = !0,
      radius: radiusProp = 3,
      referenceBoundary = (_d = props.boundaryElement) != null ? _d : boundaryElementContext.element,
      referenceElement,
      scheme,
      shadow: shadowProp = 3,
      tone = "inherit",
      width: widthProp = "auto",
      zOffset: zOffsetProp = layer.popover.zOffset,
      updateRef,
      ...restProps
    } = props, animate = usePrefersReducedMotion() ? !1 : _animate, boundarySize = (_e2 = useElementSize(boundaryElement)) == null ? void 0 : _e2.border, padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), widthArrayProp = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), ref = useRef(null), arrowRef = useRef(null), rootBoundary = "viewport";
    useImperativeHandle(
      forwardedRef,
      () => ref.current
    );
    const mediaIndex = useMediaIndex(), boundaryWidth = constrainSize || preventOverflow ? boundarySize?.width : void 0, width = calcCurrentWidth({
      container,
      mediaIndex,
      width: widthArrayProp
    }), widthRef = useRef(width);
    useEffect(() => {
      widthRef.current = width;
    }, [width]);
    const maxWidth = calcMaxWidth({ boundaryWidth, currentWidth: width }), maxWidthRef = useRef(maxWidth);
    useEffect(() => {
      maxWidthRef.current = maxWidth;
    }, [maxWidth]);
    const referenceWidthRef = useRef();
    useEffect(() => {
      const floatingElement = ref.current;
      if (!open || !floatingElement) return;
      const referenceWidth = referenceWidthRef.current;
      matchReferenceWidth ? referenceWidth !== void 0 && (floatingElement.style.width = `${referenceWidth}px`) : width !== void 0 && (floatingElement.style.width = `${width}px`), typeof maxWidth == "number" && (floatingElement.style.maxWidth = `${maxWidth}px`);
    }, [width, matchReferenceWidth, maxWidth, open]);
    const middleware2 = useMemo(() => {
      const ret = [];
      return (constrainSize || preventOverflow) && ret.push(
        flip({
          boundary: floatingBoundary || void 0,
          fallbackPlacements,
          padding: DEFAULT_POPOVER_PADDING,
          rootBoundary
        })
      ), ret.push(offset({ mainAxis: DEFAULT_POPOVER_DISTANCE })), (constrainSize || matchReferenceWidth) && ret.push(
        size({
          apply({ availableWidth, availableHeight, elements, referenceWidth }) {
            referenceWidthRef.current = referenceWidth;
            const _currentWidth = widthRef.current, _maxWidth = maxWidthRef.current;
            matchReferenceWidth ? elements.floating.style.width = `${referenceWidth}px` : _currentWidth !== void 0 && (elements.floating.style.width = `${_currentWidth}px`), constrainSize && (elements.floating.style.maxWidth = `${Math.min(
              availableWidth,
              _maxWidth ?? 1 / 0
            )}px`, elements.floating.style.maxHeight = `${availableHeight}px`);
          },
          boundaryElement: floatingBoundary || void 0,
          constrainSize,
          margins,
          matchReferenceWidth,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), preventOverflow && ret.push(
        shift({
          boundary: floatingBoundary || void 0,
          rootBoundary,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), arrowProp && ret.push(
        arrow({
          element: arrowRef,
          padding: DEFAULT_POPOVER_PADDING
        })
      ), animate && ret.push(origin), ret.push(
        hide({
          boundary: referenceBoundary || void 0,
          padding: DEFAULT_POPOVER_PADDING,
          strategy: "referenceHidden"
        })
      ), ret;
    }, [
      animate,
      arrowProp,
      constrainSize,
      fallbackPlacements,
      floatingBoundary,
      margins,
      matchReferenceWidth,
      preventOverflow,
      referenceBoundary
    ]), { x: x2, y: y2, middlewareData, placement, refs, strategy, update } = useFloating({
      middleware: middleware2,
      placement: placementProp,
      whileElementsMounted: autoUpdate
    }), referenceHidden = (_f = middlewareData.hide) == null ? void 0 : _f.referenceHidden, arrowX = (_g = middlewareData.arrow) == null ? void 0 : _g.x, arrowY = (_h = middlewareData.arrow) == null ? void 0 : _h.y, originX = (_i = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _i.originX, originY = (_j = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _j.originY, setArrow = useCallback((arrowEl) => {
      arrowRef.current = arrowEl;
    }, []), setFloating = useCallback(
      (node2) => {
        ref.current = node2, refs.setFloating(node2);
      },
      [refs]
    ), setReference = useCallback(
      (node2) => {
        refs.setReference(node2);
        const childRef = childProp?.ref;
        typeof childRef == "function" ? childRef(node2) : childRef && (childRef.current = node2);
      },
      [childProp, refs]
    ), child = useMemo(() => !childProp || referenceElement ? null : cloneElement(childProp, { ref: setReference }), [childProp, referenceElement, setReference]);
    if (useEffect(() => {
      updateRef && (typeof updateRef == "function" ? updateRef(update) : updateRef && (updateRef.current = update));
    }, [update, updateRef]), useEffect(() => {
      child || refs.setReference(referenceElement || null);
    }, [referenceElement, refs, child]), disabled)
      return childProp || /* @__PURE__ */ jsx(Fragment$1, {});
    const popover = /* @__PURE__ */ jsx(LayerProvider, { zOffset, children: /* @__PURE__ */ jsx(
      PopoverCard,
      {
        ...restProps,
        __unstable_margins: margins,
        animate,
        arrow: arrowProp,
        arrowRef: setArrow,
        arrowX,
        arrowY,
        hidden: referenceHidden,
        overflow,
        padding,
        placement,
        radius,
        ref: setFloating,
        scheme,
        shadow,
        originX,
        originY,
        strategy,
        tone,
        width: matchReferenceWidth ? referenceWidthRef.current : width,
        x: x2,
        y: y2,
        children: content
      }
    ) });
    return /* @__PURE__ */ jsxs(Fragment$1, { children: [
      /* @__PURE__ */ jsx(
        ConditionalWrapper,
        {
          condition: animate,
          wrapper: (children) => /* @__PURE__ */ jsx(AnimatePresence, { children }),
          children: open && /* @__PURE__ */ jsx(
            ConditionalWrapper,
            {
              condition: !!portal,
              wrapper: (children) => /* @__PURE__ */ jsx(Portal, { __unstable_name: typeof portal == "string" ? portal : void 0, children }),
              children: popover
            }
          )
        }
      ),
      child
    ] });
  })
);
Popover.displayName = "Memo(ForwardRef(Popover))";
function radioBaseStyle() {
  return lt$2`
    position: relative;

    &:not([hidden]) {
      display: inline-block;
    }

    &[data-read-only] {
      outline: 1px solid red;
    }
  `;
}
function inputElementStyle(props) {
  const { color: color2, input } = getTheme_v2(props.theme), dist = (input.radio.size - input.radio.markSize) / 2;
  return lt$2`
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    z-index: 1;
    padding: 0;
    margin: 0;
    border-radius: ${rem(input.radio.size / 2)};
    border: none;

    /* enabled */
    & + span {
      display: block;
      position: relative;
      height: ${rem(input.radio.size)};
      width: ${rem(input.radio.size)};
      border-radius: ${rem(input.radio.size / 2)};
      background: ${color2.input.default.enabled.bg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

      &::after {
        content: '';
        position: absolute;
        top: ${rem(dist)};
        left: ${rem(dist)};
        height: ${rem(input.radio.markSize)};
        width: ${rem(input.radio.markSize)};
        border-radius: ${rem(input.radio.markSize / 2)};
        background: ${color2.input.default.enabled.fg};
        opacity: 0;
      }
    }

    /* focused */
    &:not(:disabled):focus + span {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color2.input.default.enabled.border },
    focusRing: input.radio.focusRing
  })};
    }

    &:not(:disabled):focus:not(:focus-visible) + span {
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};
    }

    &:checked + span::after {
      opacity: 1;
    }

    /* customValidity */
    &[data-error] + span {
      background-color: ${color2.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color2.input.invalid.enabled.muted.bg
  })};
      &::after {
        background: ${color2.input.invalid.enabled.muted.bg};
      }
    }

    /* read only */
    &[data-read-only] + span {
      box-shadow: 0 0 0 1px ${color2.input.default.readOnly.border};
      background: ${color2.input.default.readOnly.bg};

      &::after {
        background: ${color2.input.default.readOnly.border};
      }
    }

    /* disabled */
    &:not([data-read-only]):disabled + span {
      box-shadow: 0 0 0 1px ${color2.input.default.disabled.border};
      background: ${color2.input.default.disabled.bg};

      &::after {
        background: ${color2.input.default.disabled.border};
      }
    }
  `;
}
const Root$g = dt.div(radioBaseStyle), Input$4 = dt.input(inputElementStyle), Radio = forwardRef(function(props, forwardedRef) {
  const { className, disabled, style: style2, customValidity, readOnly, ...restProps } = props, ref = useRef(null);
  return useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxs(Root$g, { className, "data-ui": "Radio", style: style2, children: [
    /* @__PURE__ */ jsx(
      Input$4,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-error": customValidity ? "" : void 0,
        ...restProps,
        disabled: disabled || readOnly,
        readOnly,
        ref,
        type: "radio"
      }
    ),
    /* @__PURE__ */ jsx("span", {})
  ] });
});
Radio.displayName = "ForwardRef(Radio)";
function rootStyle() {
  return lt$2`
    position: relative;
    width: -moz-available;
    width: -webkit-fill-available;
    width: stretch;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function inputBaseStyle(props) {
  const { font } = getTheme_v2(props.theme);
  return lt$2`
    -webkit-font-smoothing: antialiased;
    appearance: none;
    border: 0;
    font-family: ${font.text.family};
    color: inherit;
    width: 100%;
    outline: none;
    margin: 0;

    &:disabled {
      opacity: 1;
    }
  `;
}
function inputColorStyle(props) {
  const { color: color2, input } = getTheme_v2(props.theme);
  return lt$2`
    /* enabled */
    background-color: ${color2.input.default.enabled.bg};
    color: ${color2.input.default.enabled.fg};
    box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.enabled.border,
    width: input.border.width
  })};

    /* hovered */
    @media (hover: hover) {
      &:not(:disabled):hover {
        background-color: ${color2.input.default.hovered.bg};
        color: ${color2.input.default.hovered.fg};
        box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.hovered.border,
    width: input.border.width
  })};
      }
    }

    /* focused */
    &:not(:disabled):focus {
      box-shadow: ${focusRingStyle({
    border: { width: input.border.width, color: color2.input.default.enabled.border },
    focusRing: input.select.focusRing
  })};
    }

    /* read-only */
    &[data-read-only] {
      background-color: ${color2.input.default.readOnly.bg};
      color: ${color2.input.default.readOnly.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.readOnly.border,
    width: input.border.width
  })};
    }

    /* disabled */
    &:not([data-read-only]):disabled {
      background-color: ${color2.input.default.disabled.bg};
      color: ${color2.input.default.disabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color2.input.default.disabled.border,
    width: input.border.width
  })};
    }
  `;
}
function textSize(size2) {
  return { fontSize: rem(size2.fontSize), lineHeight: rem(size2.lineHeight) };
}
function inputTextSizeStyle(props) {
  const { $fontSize } = props, { font, media } = getTheme_v2(props.theme);
  return _responsive(
    media,
    $fontSize,
    (sizeIndex) => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2])
  );
}
function inputStyle() {
  return [
    responsiveRadiusStyle,
    inputBaseStyle,
    inputColorStyle,
    inputTextSizeStyle,
    responsiveInputPaddingIconRightStyle
  ];
}
function iconBoxStyle(props) {
  const { color: color2 } = getTheme_v2(props.theme);
  return lt$2`
    pointer-events: none;
    position: absolute;
    top: 0;
    right: 0;

    /* enabled */
    --card-fg-color: ${color2.input.default.enabled.fg};

    /* hover */
    @media (hover: hover) {
      select:not(disabled):not(:read-only):hover + && {
        --card-fg-color: ${color2.input.default.hovered.fg};
      }
    }

    /* disabled */
    select:disabled + && {
      --card-fg-color: ${color2.input.default.disabled.fg};
    }

    /* read-only */
    select[data-read-only] + && {
      --card-fg-color: ${color2.input.default.readOnly.fg};
    }
  `;
}
const selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
}, Root$f = dt.div(selectStyle.root), Input$3 = dt.select(selectStyle.input), IconBox = dt(Box)(selectStyle.iconBox), Select = forwardRef(function(props, forwardedRef) {
  const {
    children,
    customValidity,
    disabled,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 2,
    readOnly,
    space: space2 = 3,
    ...restProps
  } = props, ref = useRef(null);
  return useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useCustomValidity(ref, customValidity), /* @__PURE__ */ jsxs(Root$f, { "data-ui": "Select", children: [
    /* @__PURE__ */ jsx(
      Input$3,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        "data-ui": "Select",
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $radius: useArrayProp(radius),
        $space: useArrayProp(space2),
        disabled: disabled || readOnly,
        ref,
        children
      }
    ),
    /* @__PURE__ */ jsx(IconBox, { padding, children: /* @__PURE__ */ jsx(Text, { size: fontSize2, children: /* @__PURE__ */ jsx(ChevronDownIcon, {}) }) })
  ] });
});
Select.displayName = "ForwardRef(Select)";
const BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const { media, space: space2 } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => ({
    gridGap: rem(space2[spaceIndex])
  }));
}
const Root$e = dt(Box)(stackBaseStyle, responsiveStackSpaceStyle), Stack = forwardRef(function(props, ref) {
  const { as, space: space2, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Root$e,
    {
      "data-as": typeof as == "string" ? as : void 0,
      "data-ui": "Stack",
      ...restProps,
      $space: useArrayProp(space2),
      forwardedAs: as,
      ref
    }
  );
});
Stack.displayName = "ForwardRef(Stack)";
function switchBaseStyles() {
  return lt$2`
    position: relative;
    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function switchInputStyles() {
  return lt$2`
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
    margin: 0;

    /* Place the input element above the representation element */
    z-index: 1;
  `;
}
function switchRepresentationStyles(props) {
  const { color: color2, input } = getTheme_v2(props.theme);
  return lt$2`
    --switch-bg-color: ${color2.input.default.enabled.border};
    --switch-fg-color: ${color2.input.default.enabled.bg};
    --switch-box-shadow: none;

    &:not([hidden]) {
      display: block;
    }
    position: relative;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};

    /* Make sure it’s not possible to interact with the wrapper element */
    pointer-events: none;

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      box-shadow: var(--switch-box-shadow);
      border-radius: inherit;
    }

    /* Focus styles */
    input:focus + && {
      --switch-box-shadow: ${focusRingStyle({ focusRing: input.switch.focusRing })};
    }

    input:focus:not(:focus-visible) + && {
      --switch-box-shadow: none;
    }

    input:checked + && {
      --switch-bg-color: ${color2.input.default.enabled.fg};
      --switch-fg-color: ${color2.input.default.enabled.bg};
    }

    @media (hover: hover) {
      input:not(:disabled):hover + && {
        --switch-bg-color: ${color2.input.default.hovered.border};
        --switch-fg-color: ${color2.input.default.hovered.bg};
      }

      input:not(:disabled):checked:hover + && {
        --switch-bg-color: ${color2.input.default.enabled.fg};
        --switch-fg-color: ${color2.input.default.enabled.bg};
      }
    }

    input:not([data-read-only]):disabled + && {
      --switch-bg-color: ${color2.input.default.disabled.border};
      --switch-fg-color: ${color2.input.default.disabled.bg};
    }

    input[data-read-only]:disabled + && {
      --switch-bg-color: ${color2.input.default.readOnly.border};
      --switch-fg-color: ${color2.input.default.readOnly.bg};
    }

    input:checked[data-read-only]:disabled + && {
      --switch-bg-color: ${color2.input.default.readOnly.fg};
      --switch-fg-color: ${color2.input.default.readOnly.bg};
    }
  `;
}
function switchTrackStyles(props) {
  const { input } = getTheme_v2(props.theme);
  return lt$2`
    &:not([hidden]) {
      display: block;
    }
    background-color: var(--switch-bg-color);
    position: absolute;
    left: 0;
    top: 0;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};
  `;
}
function switchThumbStyles(props) {
  const { $indeterminate } = props, { input } = getTheme_v2(props.theme), trackWidth = input.switch.width, trackHeight = input.switch.height, trackPadding = input.switch.padding, size2 = trackHeight - input.switch.padding * 2, checkedOffset = trackWidth - trackPadding * 2 - size2, indeterminateOffset = trackWidth / 2 - size2 / 2 - trackPadding, checked = $indeterminate !== !0 && props.$checked === !0;
  return lt$2`
    &:not([hidden]) {
      display: block;
    }
    position: absolute;
    left: ${rem(trackPadding)};
    top: ${rem(trackPadding)};
    height: ${rem(size2)};
    width: ${rem(size2)};
    border-radius: ${rem(size2 / 2)};
    transition-property: transform;
    transition-duration: ${input.switch.transitionDurationMs}ms;
    transition-timing-function: ${input.switch.transitionTimingFunction};
    background: var(--switch-fg-color);
    transform: translate3d(0, 0, 0);
    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);

    ${checked && lt$2`
      transform: translate3d(${checkedOffset}px, 0, 0);
    `}

    ${$indeterminate && lt$2`
      transform: translate3d(${indeterminateOffset}px, 0, 0);
    `}
  `;
}
const Root$d = dt.span(switchBaseStyles), Input$2 = dt.input(switchInputStyles), Representation = dt.span(switchRepresentationStyles), Track = dt.span(switchTrackStyles), Thumb = dt.span(switchThumbStyles), Switch = forwardRef(function(props, forwardedRef) {
  const { checked, className, disabled, indeterminate, readOnly, style: style2, ...restProps } = props, ref = useRef(null);
  return useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useEffect(() => {
    ref.current && (ref.current.indeterminate = indeterminate || !1);
  }, [indeterminate]), /* @__PURE__ */ jsxs(Root$d, { className, "data-ui": "Switch", style: style2, children: [
    /* @__PURE__ */ jsx(
      Input$2,
      {
        "data-read-only": !disabled && readOnly ? "" : void 0,
        ...restProps,
        checked: indeterminate !== !0 && checked,
        disabled: disabled || readOnly,
        type: "checkbox",
        ref
      }
    ),
    /* @__PURE__ */ jsxs(Representation, { "aria-hidden": !0, "data-name": "representation", children: [
      /* @__PURE__ */ jsx(Track, {}),
      /* @__PURE__ */ jsx(Thumb, { $checked: checked, $indeterminate: indeterminate })
    ] })
  ] });
});
Switch.displayName = "ForwardRef(Switch)";
const Root$c = dt.span(textInputRootStyle), InputRoot$1 = dt.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Input$1 = dt.textarea(
  responsiveInputPaddingStyle,
  textInputBaseStyle,
  textInputFontSizeStyle
), Presentation$1 = dt.div(
  responsiveRadiusStyle,
  textInputRepresentationStyle
), TextArea = forwardRef(function(props, forwardedRef) {
  const {
    border: border2 = !0,
    customValidity,
    disabled = !1,
    fontSize: fontSize2 = 2,
    padding = 3,
    radius = 2,
    weight,
    __unstable_disableFocusRing,
    ...restProps
  } = props, ref = useRef(null), rootTheme = useRootTheme();
  return useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useCustomValidity(ref, customValidity), /* @__PURE__ */ jsx(Root$c, { "data-ui": "TextArea", children: /* @__PURE__ */ jsxs(InputRoot$1, { children: [
    /* @__PURE__ */ jsx(
      Input$1,
      {
        "data-as": "textarea",
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        ...restProps,
        $fontSize: useArrayProp(fontSize2),
        $padding: useArrayProp(padding),
        $scheme: rootTheme.scheme,
        $space: useArrayProp(0),
        $tone: rootTheme.tone,
        $weight: weight,
        disabled,
        ref
      }
    ),
    /* @__PURE__ */ jsx(
      Presentation$1,
      {
        $radius: useArrayProp(radius),
        $unstableDisableFocusRing: __unstable_disableFocusRing,
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone
      }
    )
  ] }) });
});
TextArea.displayName = "ForwardRef(TextArea)";
const CLEAR_BUTTON_BOX_STYLE = { zIndex: 2 }, Root$b = dt(Card).attrs({ forwardedAs: "span" })(textInputRootStyle), InputRoot = dt.span`
  flex: 1;
  min-width: 0;
  display: block;
  position: relative;
`, Prefix = dt(Card).attrs({ forwardedAs: "span" })`
  border-top-right-radius: 0;
  border-bottom-right-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Suffix = dt(Card).attrs({ forwardedAs: "span" })`
  border-top-left-radius: 0;
  border-bottom-left-radius: 0;

  & > span {
    display: block;
    margin: -1px;
  }
`, Input = dt.input(
  responsiveInputPaddingStyle,
  textInputBaseStyle,
  textInputFontSizeStyle
), Presentation = dt.span(
  responsiveRadiusStyle,
  textInputRepresentationStyle
), LeftBox = dt(Box)`
  position: absolute;
  top: 0;
  left: 0;
`, RightBox = dt(Box)`
  position: absolute;
  top: 0;
  right: 0;
`, RightCard = dt(Card)`
  background-color: transparent;
  position: absolute;
  top: 0;
  right: 0;
`, TextInputClearButton = dt(Button)({
  "&:not([hidden])": {
    display: "block"
  }
}), TextInput = forwardRef(function(props, forwardedRef) {
  const {
    __unstable_disableFocusRing,
    border: border2 = !0,
    clearButton,
    disabled = !1,
    fontSize: fontSizeProp = 2,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClear,
    padding: paddingProp = 3,
    prefix: prefix2,
    radius: radiusProp = 2,
    readOnly,
    space: spaceProp = 3,
    suffix,
    customValidity,
    type = "text",
    weight,
    ...restProps
  } = props, ref = useRef(null), rootTheme = useRootTheme(), fontSize2 = useArrayProp(fontSizeProp), padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), space2 = useArrayProp(spaceProp), $hasClearButton = !!clearButton, $hasIcon = !!IconComponent, $hasIconRight = !!IconRightComponent, $hasSuffix = !!suffix, $hasPrefix = !!prefix2;
  useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useCustomValidity(ref, customValidity);
  const handleClearMouseDown = useCallback((event) => {
    event.preventDefault(), event.stopPropagation();
  }, []), handleClearClick = useCallback(
    (event) => {
      var _a;
      event.preventDefault(), event.stopPropagation(), onClear && onClear(), (_a = ref.current) == null || _a.focus();
    },
    [onClear, ref]
  ), prefixNode = useMemo(
    () => prefix2 && /* @__PURE__ */ jsx(Prefix, { borderTop: !0, borderLeft: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsx("span", { children: prefix2 }) }),
    [prefix2, radius]
  ), presentationNode = useMemo(
    () => /* @__PURE__ */ jsxs(
      Presentation,
      {
        $hasPrefix,
        $unstableDisableFocusRing: __unstable_disableFocusRing,
        $hasSuffix,
        $radius: radius,
        $scheme: rootTheme.scheme,
        $tone: rootTheme.tone,
        "data-border": border2 ? "" : void 0,
        "data-scheme": rootTheme.scheme,
        "data-tone": rootTheme.tone,
        children: [
          IconComponent && /* @__PURE__ */ jsx(LeftBox, { padding, children: /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconComponent) && IconComponent,
            reactIsExports.isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
          ] }) }),
          !$hasClearButton && IconRightComponent && /* @__PURE__ */ jsx(RightBox, { padding, children: /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconRightComponent) && IconRightComponent,
            reactIsExports.isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
          ] }) })
        ]
      }
    ),
    [
      __unstable_disableFocusRing,
      border2,
      fontSize2,
      IconComponent,
      IconRightComponent,
      padding,
      radius,
      rootTheme,
      $hasClearButton,
      $hasPrefix,
      $hasSuffix
    ]
  ), clearButtonBoxPadding = useMemo(
    () => padding.map((v2) => v2 === 0 ? 0 : v2 === 1 || v2 === 2 ? 1 : v2 - 2),
    [padding]
  ), clearButtonPadding = useMemo(
    () => padding.map((v2) => v2 === 0 || v2 === 1 ? 0 : v2 === 2 ? 1 : v2 - 1),
    [padding]
  ), clearButtonProps = useMemo(
    () => typeof clearButton == "object" ? clearButton : EMPTY_RECORD,
    [clearButton]
  ), clearButtonNode = useMemo(
    () => !disabled && !readOnly && clearButton && /* @__PURE__ */ jsx(
      RightCard,
      {
        forwardedAs: "span",
        padding: clearButtonBoxPadding,
        style: CLEAR_BUTTON_BOX_STYLE,
        tone: customValidity ? "critical" : "inherit",
        children: /* @__PURE__ */ jsx(
          TextInputClearButton,
          {
            "aria-label": "Clear",
            "data-qa": "clear-button",
            fontSize: fontSize2,
            icon: CloseIcon,
            mode: "bleed",
            padding: clearButtonPadding,
            radius,
            ...clearButtonProps,
            onClick: handleClearClick,
            onMouseDown: handleClearMouseDown
          }
        )
      }
    ),
    [
      clearButton,
      clearButtonBoxPadding,
      clearButtonPadding,
      clearButtonProps,
      customValidity,
      disabled,
      fontSize2,
      handleClearClick,
      handleClearMouseDown,
      radius,
      readOnly
    ]
  ), suffixNode = useMemo(
    () => suffix && /* @__PURE__ */ jsx(Suffix, { borderTop: !0, borderRight: !0, borderBottom: !0, radius, sizing: "border", tone: "inherit", children: /* @__PURE__ */ jsx("span", { children: suffix }) }),
    [radius, suffix]
  );
  return /* @__PURE__ */ jsxs(Root$b, { "data-ui": "TextInput", tone: rootTheme.tone, children: [
    prefixNode,
    /* @__PURE__ */ jsxs(InputRoot, { children: [
      /* @__PURE__ */ jsx(
        Input,
        {
          "data-as": "input",
          "data-scheme": rootTheme.scheme,
          "data-tone": rootTheme.tone,
          ...restProps,
          $fontSize: fontSize2,
          $iconLeft: $hasIcon,
          $iconRight: $hasIconRight || $hasClearButton,
          $padding: padding,
          $scheme: rootTheme.scheme,
          $space: space2,
          $tone: rootTheme.tone,
          $weight: weight,
          disabled,
          readOnly,
          ref,
          type
        }
      ),
      presentationNode,
      clearButtonNode
    ] }),
    suffixNode
  ] });
});
TextInput.displayName = "ForwardRef(TextInput)";
function useDelayedState(initialState) {
  const [state, setState] = useState(initialState), delayedAction = useRef(), onStateChange = useCallback((nextState, delay2) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current && (clearTimeout(delayedAction.current), delayedAction.current = void 0), !delay2) return action();
    delayedAction.current = setTimeout(action, delay2);
  }, []);
  return [state, onStateChange];
}
const DEFAULT_TOOLTIP_ARROW_WIDTH = 15, DEFAULT_TOOLTIP_ARROW_HEIGHT = 6, DEFAULT_TOOLTIP_ARROW_RADIUS = 2, DEFAULT_TOOLTIP_DISTANCE = 4, DEFAULT_TOOLTIP_PADDING = 4, DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
}, MotionCard = dt(motion(Card))`
  & > * {
    opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
    will-change: opacity;
  }
`, TooltipCard = memo$1(
  forwardRef(function(props, ref) {
    const {
      animate,
      arrow: arrow2,
      arrowRef,
      arrowX,
      arrowY,
      children,
      originX,
      originY,
      padding,
      placement,
      radius,
      scheme,
      shadow,
      style: style2,
      ...restProps
    } = props, rootStyle2 = useMemo(
      () => ({
        originX,
        originY,
        willChange: animate ? "transform" : void 0,
        ...style2
      }),
      [animate, originX, originY, style2]
    ), arrowStyle = useMemo(
      () => ({
        left: arrowX !== null ? arrowX : void 0,
        top: arrowY !== null ? arrowY : void 0,
        right: void 0,
        bottom: void 0
      }),
      [arrowX, arrowY]
    );
    return /* @__PURE__ */ jsxs(
      MotionCard,
      {
        "data-ui": "Tooltip__card",
        ...restProps,
        "data-placement": placement,
        padding,
        radius,
        ref,
        scheme,
        shadow,
        style: rootStyle2,
        ...animate ? POPOVER_MOTION_PROPS : {},
        children: [
          children,
          arrow2 && /* @__PURE__ */ jsx(
            Arrow,
            {
              ref: arrowRef,
              style: arrowStyle,
              width: DEFAULT_TOOLTIP_ARROW_WIDTH,
              height: DEFAULT_TOOLTIP_ARROW_HEIGHT,
              radius: DEFAULT_TOOLTIP_ARROW_RADIUS
            }
          )
        ]
      }
    );
  })
);
TooltipCard.displayName = "Memo(ForwardRef(TooltipCard))";
const TooltipDelayGroupContext = createGlobalScopedContext(
  "@sanity/ui/context/tooltipDelayGroup",
  null
);
function useTooltipDelayGroup() {
  return useContext(TooltipDelayGroupContext);
}
const Root$a = dt(Layer)`
  pointer-events: none;
`, Tooltip = forwardRef(function(props, forwardedRef) {
  var _a, _b, _c, _d, _e2, _f, _g;
  const boundaryElementContext = useBoundaryElement(), { layer } = useTheme_v2(), {
    animate: _animate = !1,
    arrow: arrowProp = !1,
    boundaryElement = boundaryElementContext?.element,
    children: childProp,
    content,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = (_b = props.fallbackPlacements) != null ? _b : DEFAULT_FALLBACK_PLACEMENTS[(_a = props.placement) != null ? _a : "bottom"],
    padding = 2,
    placement: placementProp = "bottom",
    portal: portalProp,
    radius = 2,
    scheme,
    shadow = 2,
    zOffset = layer.tooltip.zOffset,
    delay: delay2,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, fallbackPlacements = useArrayProp(fallbackPlacementsProp), ref = useRef(null), [referenceElement, setReferenceElement] = useState(null), arrowRef = useRef(null), rootBoundary = "viewport", [tooltipMaxWidth, setTooltipMaxWidth] = useState(0);
  useImperativeHandle(forwardedRef, () => ref.current);
  const portal = usePortal(), portalElement = typeof portalProp == "string" ? ((_c = portal.elements) == null ? void 0 : _c[portalProp]) || null : portal.element, middleware2 = useMemo(() => {
    const ret = [];
    return ret.push(
      flip({
        boundary: boundaryElement || void 0,
        fallbackPlacements,
        padding: DEFAULT_TOOLTIP_PADDING,
        rootBoundary
      })
    ), ret.push(offset({ mainAxis: DEFAULT_TOOLTIP_DISTANCE })), ret.push(
      shift({
        boundary: boundaryElement || void 0,
        rootBoundary,
        padding: DEFAULT_TOOLTIP_PADDING
      })
    ), arrowProp && ret.push(arrow({ element: arrowRef, padding: DEFAULT_TOOLTIP_PADDING })), animate && ret.push(origin), ret;
  }, [animate, arrowProp, boundaryElement, fallbackPlacements]), { floatingStyles, placement, middlewareData, refs, update } = useFloating({
    middleware: middleware2,
    placement: placementProp,
    whileElementsMounted: autoUpdate
  }), arrowX = (_d = middlewareData.arrow) == null ? void 0 : _d.x, arrowY = (_e2 = middlewareData.arrow) == null ? void 0 : _e2.y, originX = (_f = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _f.originX, originY = (_g = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _g.originY, tooltipId = useId(), [isOpen, setIsOpen] = useDelayedState(!1), delayGroupContext = useTooltipDelayGroup(), showTooltip = isOpen || delayGroupContext?.openTooltipId === tooltipId, isInsideGroup = delayGroupContext !== null, openDelayProp = typeof delay2 == "number" ? delay2 : delay2?.open || 0, closeDelayProp = typeof delay2 == "number" ? delay2 : delay2?.close || 0, openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp, closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp, handleIsOpenChange = useCallback(
    (open, immediate) => {
      if (isInsideGroup)
        if (open) {
          const groupedOpenDelay = immediate ? 0 : openDelay;
          delayGroupContext.setIsGroupActive(open, groupedOpenDelay), delayGroupContext.setOpenTooltipId(tooltipId, groupedOpenDelay);
        } else {
          const groupDeactivateDelay = closeDelay > 200 ? closeDelay : 200;
          delayGroupContext.setIsGroupActive(open, groupDeactivateDelay), delayGroupContext.setOpenTooltipId(null, immediate ? 0 : closeDelay);
        }
      else
        setIsOpen(open, immediate ? 0 : open ? openDelay : closeDelay);
    },
    [isInsideGroup, delayGroupContext, openDelay, tooltipId, closeDelay, setIsOpen]
  ), handleBlur = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1), (_b2 = (_a2 = childProp?.props) == null ? void 0 : _a2.onBlur) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  ), handleClick = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1, !0), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onClick) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  ), handleContextMenu = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1, !0), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onContextMenu) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  ), handleFocus = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!0), (_b2 = (_a2 = childProp?.props) == null ? void 0 : _a2.onFocus) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  ), handleMouseEnter = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!0), (_b2 = (_a2 = childProp?.props) == null ? void 0 : _a2.onMouseEnter) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  ), handleMouseLeave = useCallback(
    (e) => {
      var _a2, _b2;
      handleIsOpenChange(!1), (_b2 = (_a2 = childProp?.props) == null ? void 0 : _a2.onMouseLeave) == null || _b2.call(_a2, e);
    },
    [childProp?.props, handleIsOpenChange]
  );
  useCloseOnMouseLeave({ handleIsOpenChange, referenceElement, showTooltip }), useEffect(() => {
    disabled && showTooltip && handleIsOpenChange(!1);
  }, [disabled, handleIsOpenChange, showTooltip]), useEffect(() => {
    !content && showTooltip && handleIsOpenChange(!1);
  }, [content, handleIsOpenChange, showTooltip]), useEffect(() => refs.setReference(referenceElement), [referenceElement, refs]), useEffect(() => {
    if (!showTooltip) return;
    function handleWindowKeyDown(event) {
      event.key === "Escape" && handleIsOpenChange(!1, !0);
    }
    return window.addEventListener("keydown", handleWindowKeyDown), () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]), useLayoutEffect(() => {
    const availableWidths = [
      ...boundaryElement ? [boundaryElement.offsetWidth] : [],
      portalElement?.offsetWidth || document.body.offsetWidth
    ];
    setTooltipMaxWidth(Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2);
  }, [boundaryElement, portalElement]);
  const setArrow = useCallback(
    (arrowEl) => {
      arrowRef.current = arrowEl, update();
    },
    [update]
  ), setFloating = useCallback(
    (node2) => {
      ref.current = node2, refs.setFloating(node2);
    },
    [refs]
  ), childRef = useRef(null);
  useImperativeHandle(childProp?.ref, () => childRef.current);
  const child = useMemo(() => childProp ? cloneElement(childProp, {
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onContextMenu: handleContextMenu,
    ref: childRef
  }) : null, [
    childProp,
    handleBlur,
    handleClick,
    handleContextMenu,
    handleFocus,
    handleMouseEnter,
    handleMouseLeave
  ]);
  if (useEffect(() => {
    if (child)
      return setReferenceElement(childRef.current), () => setReferenceElement(null);
  }, [child]), !child) return /* @__PURE__ */ jsx(Fragment$1, {});
  if (disabled) return child;
  const tooltip = /* @__PURE__ */ jsx(
    Root$a,
    {
      "data-ui": "Tooltip",
      ...restProps,
      ref: setFloating,
      style: {
        ...floatingStyles,
        maxWidth: tooltipMaxWidth > 0 ? `${tooltipMaxWidth}px` : void 0
      },
      zOffset,
      children: /* @__PURE__ */ jsx(
        TooltipCard,
        {
          ...restProps,
          animate,
          arrow: arrowProp,
          arrowRef: setArrow,
          arrowX,
          arrowY,
          originX,
          originY,
          padding,
          placement,
          radius,
          ref: setFloating,
          scheme,
          shadow,
          children: content
        }
      )
    }
  );
  return /* @__PURE__ */ jsxs(Fragment$1, { children: [
    /* @__PURE__ */ jsx(
      ConditionalWrapper,
      {
        condition: animate,
        wrapper: (children) => /* @__PURE__ */ jsx(AnimatePresence, { children }),
        children: showTooltip && /* @__PURE__ */ jsx(
          ConditionalWrapper,
          {
            condition: !!portalProp,
            wrapper: (children) => /* @__PURE__ */ jsx(Portal, { __unstable_name: typeof portalProp == "string" ? portalProp : void 0, children }),
            children: tooltip
          }
        )
      }
    ),
    child
  ] });
});
Tooltip.displayName = "ForwardRef(Tooltip)";
function useCloseOnMouseLeave({
  handleIsOpenChange,
  referenceElement,
  showTooltip
}) {
  const onMouseMove = useEffectEvent((target2, teardown) => {
    referenceElement && (referenceElement === target2 || target2 instanceof Node && referenceElement.contains(target2) || (handleIsOpenChange(!1), teardown()));
  });
  useEffect(() => {
    if (!showTooltip) return;
    const handleMouseMove = (event) => {
      onMouseMove(event.target, () => window.removeEventListener("mousemove", handleMouseMove));
    };
    return window.addEventListener("mousemove", handleMouseMove), () => window.removeEventListener("mousemove", handleMouseMove);
  }, [onMouseMove, showTooltip]);
}
const Root$9 = dt.div`
  line-height: 0;
`, ListBox = dt(Box)`
  & > ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }
`, rotate = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = dt(SpinnerIcon)`
  animation: ${rotate} 500ms linear infinite;
`;
function AutocompleteOption(props) {
  const { children, id: id2, onSelect, selected, value } = props, handleClick = useCallback(() => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, [onSelect, value]), handleKeyDown = useCallback(
    (event) => {
      event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
    },
    [handleClick]
  );
  return /* @__PURE__ */ jsx(
    "li",
    {
      "aria-selected": selected,
      "data-ui": "AutocompleteOption",
      id: id2,
      role: "option",
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      children
    }
  );
}
function autocompleteReducer(state, msg2) {
  return msg2.type === "input/change" ? { ...state, activeValue: null, focused: !0, query: msg2.query } : msg2.type === "input/focus" ? { ...state, focused: !0 } : msg2.type === "root/blur" ? { ...state, focused: !1, query: null } : msg2.type === "root/clear" ? { ...state, activeValue: null, query: null, value: null } : msg2.type === "root/escape" ? { ...state, focused: !1, query: null } : msg2.type === "root/open" ? { ...state, query: state.query || msg2.query } : msg2.type === "root/setActiveValue" ? { ...state, activeValue: msg2.value, listFocused: msg2.listFocused || state.listFocused } : msg2.type === "root/setListFocused" ? { ...state, listFocused: msg2.listFocused } : msg2.type === "value/change" ? { ...state, activeValue: msg2.value, query: null, value: msg2.value } : state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = [
  "Control",
  "Shift",
  "Alt",
  "Enter",
  "Home",
  "End",
  "PageUp",
  "PageDown",
  "Meta",
  "Tab",
  "CapsLock"
], AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start", AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"], DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value, DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1, InnerAutocomplete = forwardRef(function(props, forwardedRef) {
  const {
    border: border2 = !0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id: id2,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix: prefix2,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props, [state, dispatch] = useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: !1,
    listFocused: !1,
    query: null,
    value: valueProp || null
  }), { activeValue, focused, listFocused, query, value } = state, defaultRenderOption = useCallback(
    ({ value: value2 }) => /* @__PURE__ */ jsx(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsx(Text, { size: fontSize2, textOverflow: "ellipsis", children: value2 }) }),
    [fontSize2, paddingProp]
  ), renderOption = typeof renderOptionProp == "function" ? renderOptionProp : defaultRenderOption, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = useRef(null), resultsPopoverElementRef = useRef(null), inputElementRef = useRef(null), listBoxElementRef = useRef(null), listFocusedRef = useRef(!1), valueRef = useRef(value), valuePropRef = useRef(valueProp), popoverMouseWithinRef = useRef(!1);
  useImperativeHandle(
    forwardedRef,
    () => inputElementRef.current
  );
  const listBoxId = `${id2}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = useArrayProp(paddingProp), currentOption = useMemo(
    () => value !== null ? options.find((o) => o.value === value) : void 0,
    [options, value]
  ), filteredOptions = useMemo(
    () => options.filter((option) => query ? filterOption(query, option) : !0),
    [filterOption, options, query]
  ), filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id2}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null, handleRootBlur = useCallback(
    (event) => {
      setTimeout(() => {
        if (popoverMouseWithinRef.current)
          return;
        const elements = (relatedElements || []).concat(
          rootElementRef.current ? [rootElementRef.current] : [],
          resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []
        );
        let focusInside = !1;
        if (document.activeElement) {
          for (const e of elements)
            if (e === document.activeElement || e.contains(document.activeElement)) {
              focusInside = !0;
              break;
            }
        }
        focusInside === !1 && (dispatch({ type: "root/blur" }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
      }, 0);
    },
    [onBlur, onQueryChange, relatedElements]
  ), handleRootFocus = useCallback((event) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event.target instanceof HTMLElement ? event.target : null, listFocused2 = listBoxElement?.contains(focusedElement) || !1;
    listFocused2 !== listFocusedRef.current && (listFocusedRef.current = listFocused2, dispatch({ type: "root/setListFocused", listFocused: listFocused2 }));
  }, []), handleOptionSelect = useCallback(
    (v2) => {
      var _a;
      dispatch({ type: "value/change", value: v2 }), popoverMouseWithinRef.current = !1, onSelect && onSelect(v2), valueRef.current = v2, onChange && onChange(v2), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
    },
    [onChange, onSelect, onQueryChange]
  ), handleRootKeyDown = useCallback(
    (event) => {
      var _a, _b;
      if (event.key === "ArrowDown") {
        if (event.preventDefault(), !filteredOptionsLen) return;
        const activeOption = filteredOptions.find((o) => o.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
        nextActiveOption && dispatch({ type: "root/setActiveValue", value: nextActiveOption.value, listFocused: !0 });
        return;
      }
      if (event.key === "ArrowUp") {
        if (event.preventDefault(), !filteredOptionsLen) return;
        const activeOption = filteredOptions.find((o) => o.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[activeIndex === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex - 1) % filteredOptionsLen];
        nextActiveOption && dispatch({ type: "root/setActiveValue", value: nextActiveOption.value, listFocused: !0 });
        return;
      }
      if (event.key === "Escape") {
        dispatch({ type: "root/escape" }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
        return;
      }
      const target2 = event.target, listEl = listBoxElementRef.current;
      if ((listEl === target2 || listEl != null && listEl.contains(target2)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event.key)) {
        (_b = inputElementRef.current) == null || _b.focus();
        return;
      }
    },
    [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]
  ), handleInputChange = useCallback(
    (event) => {
      const nextQuery = event.currentTarget.value;
      dispatch({ type: "input/change", query: nextQuery }), onQueryChange && onQueryChange(nextQuery);
    },
    [onQueryChange]
  ), dispatchOpen = useCallback(() => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, [currentOption, renderValue, value]), handleInputFocus = useCallback(
    (event) => {
      focused || (dispatch({ type: "input/focus" }), onFocus && onFocus(event), openOnFocus && dispatchOpen());
    },
    [focused, onFocus, openOnFocus, dispatchOpen]
  ), handlePopoverMouseEnter = useCallback(() => {
    popoverMouseWithinRef.current = !0;
  }, []), handlePopoverMouseLeave = useCallback(() => {
    popoverMouseWithinRef.current = !1;
  }, []), handleClearButtonClick = useCallback(() => {
    var _a;
    dispatch({ type: "root/clear" }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null || _a.focus();
  }, [onChange, onQueryChange]), handleClearButtonFocus = useCallback(() => {
    dispatch({ type: "input/focus" });
  }, []);
  useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({ type: "value/change", value: valueProp }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({ type: "value/change", value: valueProp || null }));
  }, [valueProp]), useEffect(() => {
    !focused && valueRef.current && dispatch({ type: "root/setActiveValue", value: valueRef.current });
  }, [focused]), useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption = filteredOptions.find((o) => o.value === activeValue);
    if (activeOption) {
      const activeIndex = filteredOptions.indexOf(activeOption), activeItemElement = listElement.childNodes[activeIndex];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const clearButton = useMemo(() => {
    if (!loading && !disabled && value)
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
  }, [disabled, handleClearButtonFocus, loading, value]), openButtonBoxPadding = useMemo(
    () => padding.map((v2) => v2 === 0 ? 0 : v2 === 1 || v2 === 2 ? 1 : v2 - 2),
    [padding]
  ), openButtonPadding = useMemo(() => padding.map((v2) => Math.max(v2 - 1, 0)), [padding]), openButtonProps = useMemo(
    () => typeof openButton == "object" ? openButton : EMPTY_RECORD,
    [openButton]
  ), handleOpenClick = useCallback(
    (event) => {
      dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event), _raf(() => {
        var _a;
        return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      });
    },
    [openButtonProps, dispatchOpen]
  ), openButtonNode = useMemo(
    () => !disabled && !readOnly && openButton ? /* @__PURE__ */ jsx(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: /* @__PURE__ */ jsx(
      Button,
      {
        "aria-label": "Open",
        disabled: expanded,
        fontSize: fontSize2,
        icon: ChevronDownIcon,
        mode: "bleed",
        padding: openButtonPadding,
        ...openButtonProps,
        onClick: handleOpenClick
      }
    ) }) : void 0,
    [
      disabled,
      expanded,
      fontSize2,
      handleOpenClick,
      openButton,
      openButtonBoxPadding,
      openButtonPadding,
      openButtonProps,
      readOnly
    ]
  ), inputValue = useMemo(() => query === null ? value !== null ? renderValue(value, currentOption) : "" : query, [currentOption, query, renderValue, value]), input = /* @__PURE__ */ jsx(
    TextInput,
    {
      ...restProps,
      "aria-activedescendant": activeItemId,
      "aria-autocomplete": "list",
      "aria-expanded": expanded,
      "aria-owns": listBoxId,
      autoCapitalize: "off",
      autoComplete: "off",
      autoCorrect: "off",
      border: border2,
      clearButton,
      customValidity,
      disabled,
      fontSize: fontSize2,
      icon,
      iconRight: loading && AnimatedSpinnerIcon,
      id: id2,
      inputMode: "search",
      onChange: handleInputChange,
      onClear: handleClearButtonClick,
      onFocus: handleInputFocus,
      padding,
      prefix: prefix2,
      radius,
      readOnly,
      ref: inputElementRef,
      role: "combobox",
      spellCheck: !1,
      suffix: suffix || openButtonNode,
      value: inputValue
    }
  ), handleListBoxKeyDown = useCallback(
    (event) => {
      var _a;
      event.key === "Tab" && listFocused && ((_a = inputElementRef.current) == null || _a.focus());
    },
    [listFocused]
  ), content = useMemo(() => filteredOptions.length === 0 ? null : /* @__PURE__ */ jsx(
    ListBox,
    {
      "data-ui": "AutoComplete__results",
      onKeyDown: handleListBoxKeyDown,
      padding: 1,
      ...listBox,
      tabIndex: -1,
      children: /* @__PURE__ */ jsx(
        Stack,
        {
          as: "ul",
          "aria-multiselectable": !1,
          "data-ui": "AutoComplete__resultsList",
          id: listBoxId,
          ref: listBoxElementRef,
          role: "listbox",
          space: 1,
          children: filteredOptions.map((option) => {
            const active = activeValue !== null ? option.value === activeValue : currentOption === option;
            return /* @__PURE__ */ jsx(
              AutocompleteOption,
              {
                id: `${id2}-option-${option.value}`,
                onSelect: handleOptionSelect,
                selected: active,
                value: option.value,
                children: cloneElement(renderOption(option), {
                  disabled: loading,
                  selected: active,
                  tabIndex: listFocused && active ? 0 : -1
                })
              },
              option.value
            );
          })
        }
      )
    }
  ), [
    activeValue,
    currentOption,
    filteredOptions,
    handleOptionSelect,
    handleListBoxKeyDown,
    id2,
    listBox,
    listBoxId,
    listFocused,
    loading,
    renderOption
  ]), results = useMemo(() => renderPopover ? renderPopover(
    {
      content,
      hidden: !expanded,
      inputElement: inputElementRef.current,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave
    },
    resultsPopoverElementRef
  ) : filteredOptionsLen === 0 ? null : /* @__PURE__ */ jsx(
    Popover,
    {
      arrow: !1,
      constrainSize: !0,
      content,
      fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS,
      matchReferenceWidth: !0,
      onMouseEnter: handlePopoverMouseEnter,
      onMouseLeave: handlePopoverMouseLeave,
      open: expanded,
      overflow: "auto",
      placement: AUTOCOMPLETE_POPOVER_PLACEMENT,
      portal: !0,
      radius,
      ref: resultsPopoverElementRef,
      referenceElement: inputElementRef.current,
      ...popover
    }
  ), [
    content,
    expanded,
    filteredOptionsLen,
    handlePopoverMouseEnter,
    handlePopoverMouseLeave,
    popover,
    radius,
    renderPopover
  ]);
  return /* @__PURE__ */ jsxs(
    Root$9,
    {
      "data-ui": "Autocomplete",
      onBlur: handleRootBlur,
      onFocus: handleRootFocus,
      onKeyDown: handleRootKeyDown,
      ref: rootElementRef,
      children: [
        input,
        results
      ]
    }
  );
});
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
const Root$8 = dt.ol`
  margin: 0;
  padding: 0;
  display: flex;
  list-style: none;
  align-items: center;
  white-space: nowrap;
  line-height: 0;
`, ExpandButton = dt(Button)`
  appearance: none;
  margin: -4px;
`, Breadcrumbs = forwardRef(function(props, ref) {
  const { children, maxLength, separator, space: spaceRaw = 2, ...restProps } = props, space2 = useArrayProp(spaceRaw), [open, setOpen] = useState(!1), expandElementRef = useRef(null), popoverElementRef = useRef(null), collapse = useCallback(() => setOpen(!1), []), expand = useCallback(() => setOpen(!0), []);
  useClickOutsideEvent(collapse, () => [expandElementRef.current, popoverElementRef.current]);
  const rawItems = useMemo(() => Children.toArray(children).filter(isValidElement), [children]), items = useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
      return [
        ...rawItems.slice(0, beforeLength - 1),
        /* @__PURE__ */ jsx(
          Popover,
          {
            constrainSize: !0,
            content: /* @__PURE__ */ jsx(Stack, { as: "ol", overflow: "auto", padding: space2, space: space2, children: rawItems.slice(beforeLength - 1, len - afterLength) }),
            open,
            placement: "top",
            portal: !0,
            ref: popoverElementRef,
            children: /* @__PURE__ */ jsx(
              ExpandButton,
              {
                fontSize: 1,
                mode: "bleed",
                onClick: open ? collapse : expand,
                padding: 1,
                ref: expandElementRef,
                selected: open,
                text: "\u2026"
              }
            )
          },
          "button"
        ),
        ...rawItems.slice(len - afterLength)
      ];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space2]);
  return /* @__PURE__ */ jsx(Root$8, { "data-ui": "Breadcrumbs", ...restProps, ref, children: items.map((item, itemIndex) => /* @__PURE__ */ jsxs(Fragment, { children: [
    itemIndex > 0 && /* @__PURE__ */ jsx(Box, { "aria-hidden": !0, as: "li", paddingX: space2, children: separator || /* @__PURE__ */ jsx(Text, { muted: !0, children: "/" }) }),
    /* @__PURE__ */ jsx(Box, { as: "li", children: item })
  ] }, itemIndex)) });
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function dialogStyle({ theme }) {
  const { color: color2 } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color2.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const { media } = getTheme_v2(props.theme);
  return _responsive(media, props.$position, (position2) => ({ "&&": { position: position2 } }));
}
function animationDialogStyle(props) {
  return props.$animate ? lt$2`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : lt$2``;
}
const DialogContext = createGlobalScopedContext(
  "@sanity/ui/context/dialog",
  { version: 0 }
);
function useDialog() {
  return useContext(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target2) {
  return !boundaryElement || !portalElement ? !0 : containsOrEqualsElement(boundaryElement, target2) || containsOrEqualsElement(portalElement, target2);
}
const Root$7 = dt(Layer)(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle), DialogContainer = dt(Container)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  height: 100%;
  flex-direction: column;
  align-items: center;
  justify-content: center;
`, DialogCardRoot = dt(Card)`
  &:not([hidden]) {
    display: flex;
  }
  width: 100%;
  min-height: 0;
  max-height: 100%;
  overflow: hidden;
  overflow: clip;
`, DialogLayout = dt(Flex)`
  flex: 1;
  min-height: 0;
  width: 100%;
`, DialogHeader = dt(Box)`
  position: relative;
  z-index: 2;
`, DialogContent = dt(Box)`
  position: relative;
  z-index: 1;
  overflow: auto;
  outline: none;
`, DialogFooter = dt(Box)`
  position: relative;
  z-index: 3;
`, DialogCard = forwardRef(function(props, forwardedRef) {
  var _a;
  const {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id: id2,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), width = useArrayProp(widthProp), ref = useRef(null), contentRef = useRef(null), layer = useLayer(), { isTopLayer: isTopLayer2 } = layer, labelId = `${id2}_label`, showCloseButton = !!onClose && hideCloseButton === !1, showHeader = !!header || showCloseButton;
  return useImperativeHandle(forwardedRef, () => ref.current), useImperativeHandle(
    forwardedContentRef,
    () => contentRef.current
  ), useEffect(() => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, [autoFocus, ref]), useGlobalKeyDown(
    useCallback(
      (event) => {
        if (!isTopLayer2 || !onClose) return;
        const target2 = document.activeElement;
        target2 && !isTargetWithinScope(boundaryElement, portalElement, target2) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
      },
      [boundaryElement, isTopLayer2, onClose, portalElement]
    )
  ), useClickOutsideEvent(
    isTopLayer2 && onClickOutside && ((event) => {
      const target2 = event.target;
      target2 && !isTargetWithinScope(boundaryElement, portalElement, target2) || onClickOutside();
    }),
    () => [ref.current]
  ), /* @__PURE__ */ jsx(DialogContainer, { "data-ui": "DialogCard", width, children: /* @__PURE__ */ jsx(DialogCardRoot, { radius, ref, scheme, shadow, children: /* @__PURE__ */ jsxs(DialogLayout, { direction: "column", children: [
    showHeader && /* @__PURE__ */ jsx(DialogHeader, { children: /* @__PURE__ */ jsxs(Flex, { align: "center", padding: 3, children: [
      /* @__PURE__ */ jsx(Box, { flex: 1, padding: 2, children: header && /* @__PURE__ */ jsx(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
      showCloseButton && /* @__PURE__ */ jsx(Box, { flex: "none", children: /* @__PURE__ */ jsx(
        Button,
        {
          "aria-label": "Close dialog",
          disabled: !onClose,
          icon: CloseIcon,
          mode: "bleed",
          onClick: onClose,
          padding: 2
        }
      ) })
    ] }) }),
    /* @__PURE__ */ jsx(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }),
    footer && /* @__PURE__ */ jsx(DialogFooter, { children: footer })
  ] }) }) });
});
DialogCard.displayName = "ForwardRef(DialogCard)";
const Dialog = forwardRef(function(props, ref) {
  var _a;
  const dialog = useDialog(), { layer } = useTheme_v2(), {
    __unstable_autoFocus: autoFocus = !0,
    __unstable_hideCloseButton: hideCloseButton = !1,
    cardRadius: cardRadiusProp = 4,
    cardShadow = 3,
    children,
    contentRef,
    footer,
    header,
    id: id2,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: paddingProp = 3,
    portal: portalProp,
    position: positionProp = dialog.position || "fixed",
    scheme,
    width: widthProp = 0,
    zOffset: zOffsetProp = dialog.zOffset || layer.dialog.zOffset,
    animate: _animate = !1,
    ...restProps
  } = props, animate = usePrefersReducedMotion() ? !1 : _animate, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, cardRadius = useArrayProp(cardRadiusProp), padding = useArrayProp(paddingProp), position2 = useArrayProp(positionProp), width = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), preDivRef = useRef(null), postDivRef = useRef(null), cardRef = useRef(null), focusedElementRef = useRef(null), handleFocus = useCallback(
    (event) => {
      onFocus?.(event);
      const target2 = event.target, cardElement = cardRef.current;
      if (cardElement && target2 === preDivRef.current) {
        focusLastDescendant(cardElement);
        return;
      }
      if (cardElement && target2 === postDivRef.current) {
        focusFirstDescendant(cardElement);
        return;
      }
      isHTMLElement(event.target) && (focusedElementRef.current = event.target);
    },
    [onFocus]
  ), labelId = `${id2}_label`, rootClickTimeoutRef = useRef(), handleRootClick = useCallback(() => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target2 = focusedElementRef.current;
        if (!target2 || !document.body.contains(target2)) {
          const cardElement = cardRef.current;
          cardElement && focusFirstDescendant(cardElement);
          return;
        }
        target2.focus();
      }
    }, 0);
  }, [boundaryElement, portalElement]);
  return /* @__PURE__ */ jsx(Portal, { __unstable_name: portalProp, children: /* @__PURE__ */ jsxs(
    Root$7,
    {
      ...restProps,
      $animate: animate,
      $padding: padding,
      $position: position2,
      "aria-labelledby": labelId,
      "aria-modal": !0,
      "data-ui": "Dialog",
      id: id2,
      onActivate,
      onClick: handleRootClick,
      onFocus: handleFocus,
      ref,
      role: "dialog",
      zOffset,
      children: [
        /* @__PURE__ */ jsx("div", { ref: preDivRef, tabIndex: 0 }),
        /* @__PURE__ */ jsx(
          DialogCard,
          {
            __unstable_autoFocus: autoFocus,
            __unstable_hideCloseButton: hideCloseButton,
            contentRef,
            footer,
            header,
            id: id2,
            onClickOutside,
            onClose,
            portal: portalProp,
            radius: cardRadius,
            ref: cardRef,
            scheme,
            shadow: cardShadow,
            width,
            children
          }
        ),
        /* @__PURE__ */ jsx("div", { ref: postDivRef, tabIndex: 0 })
      ]
    }
  ) });
});
Dialog.displayName = "ForwardRef(Dialog)";
const Root$6 = dt.kbd`
  font: inherit;
  padding: 1px;

  &:not([hidden]) {
    display: block;
  }
`, Key = dt(KBD)`
  &:not([hidden]) {
    display: block;
  }
`, Hotkeys = forwardRef(function(props, ref) {
  const { fontSize: fontSize2, keys, padding, radius, space: spaceProp = 0.5, ...restProps } = props, space2 = useArrayProp(spaceProp);
  return !keys || keys.length === 0 ? /* @__PURE__ */ jsx(Fragment$1, {}) : /* @__PURE__ */ jsx(Root$6, { "data-ui": "Hotkeys", ...restProps, ref, children: /* @__PURE__ */ jsx(Inline, { as: "span", space: space2, children: keys.map((key2, i) => /* @__PURE__ */ jsx(Key, { fontSize: fontSize2, padding, radius, children: key2 }, i)) }) });
});
Hotkeys.displayName = "ForwardRef(Hotkeys)";
const MenuContext = createGlobalScopedContext(
  "@sanity/ui/context/menu",
  null
);
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el2) {
  const path = [];
  let e = el2;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const index2 = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index2), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
const EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map2 = /* @__PURE__ */ new WeakMap();
  for (const el2 of elements)
    map2.set(el2, _getDOMPath(rootElement, el2));
  const _sort = (a, b) => {
    const _a = map2.get(a) || EMPTY_PATH, _b = map2.get(b) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i = 0; i < len; i += 1) {
      const aIndex = _a[i] || -1, bIndex = _b[i] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const { onKeyDown, originElement, shouldFocus, rootElementRef } = props, elementsRef = useRef([]), [activeIndex, _setActiveIndex] = useState(-1), activeIndexRef = useRef(activeIndex), activeElement = useMemo(() => elementsRef.current[activeIndex] || null, [activeIndex]), mounted = !!rootElementRef.current, setActiveIndex = useCallback((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex), activeIndexRef.current = nextActiveIndex;
  }, []), mount = useCallback(
    (element, selected) => {
      if (!element) return () => {
      };
      if (elementsRef.current.indexOf(element) === -1 && (elementsRef.current.push(element), _sortElements(rootElementRef.current, elementsRef.current)), selected) {
        const selectedIndex = elementsRef.current.indexOf(element);
        setActiveIndex(selectedIndex);
      }
      return () => {
        const idx = elementsRef.current.indexOf(element);
        idx > -1 && elementsRef.current.splice(idx, 1);
      };
    },
    [rootElementRef, setActiveIndex]
  ), handleKeyDown = useCallback(
    (event) => {
      if (event.key === "Tab") {
        originElement && originElement.focus();
        return;
      }
      if (event.key === "Home") {
        event.preventDefault(), event.stopPropagation();
        const el2 = _getFocusableElements(elementsRef.current)[0];
        if (!el2) return;
        const currentIndex = elementsRef.current.indexOf(el2);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "End") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), el2 = focusableElements[focusableElements.length - 1];
        if (!el2) return;
        const currentIndex = elementsRef.current.indexOf(el2);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), focusableLen = focusableElements.length;
        if (focusableLen === 0) return;
        const focusedElement = elementsRef.current[activeIndexRef.current];
        let focusedIndex = focusableElements.indexOf(focusedElement);
        focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
        const el2 = focusableElements[focusedIndex], currentIndex = elementsRef.current.indexOf(el2);
        setActiveIndex(currentIndex);
        return;
      }
      if (event.key === "ArrowDown") {
        event.preventDefault(), event.stopPropagation();
        const focusableElements = _getFocusableElements(elementsRef.current), focusableLen = focusableElements.length;
        if (focusableLen === 0) return;
        const focusedElement = elementsRef.current[activeIndexRef.current];
        let focusedIndex = focusableElements.indexOf(focusedElement);
        focusedIndex = (focusedIndex + 1) % focusableLen;
        const el2 = focusableElements[focusedIndex], currentIndex = elementsRef.current.indexOf(el2);
        setActiveIndex(currentIndex);
        return;
      }
      onKeyDown && onKeyDown(event);
    },
    [onKeyDown, originElement, setActiveIndex]
  ), handleItemMouseEnter = useCallback(
    (event) => {
      const element = event.currentTarget, currentIndex = elementsRef.current.indexOf(element);
      setActiveIndex(currentIndex);
    },
    [setActiveIndex]
  ), handleItemMouseLeave = useCallback(() => {
    var _a;
    setActiveIndex(-2), (_a = rootElementRef.current) == null || _a.focus();
  }, [rootElementRef, setActiveIndex]);
  return useEffect(() => {
    if (!mounted) return;
    const rafId = requestAnimationFrame(() => {
      if (activeIndex === -1) {
        if (shouldFocus === "first") {
          const el2 = _getFocusableElements(elementsRef.current)[0];
          if (el2) {
            const currentIndex = elementsRef.current.indexOf(el2);
            setActiveIndex(currentIndex);
          }
        }
        if (shouldFocus === "last") {
          const focusableElements = _getFocusableElements(elementsRef.current), el2 = focusableElements[focusableElements.length - 1];
          if (el2) {
            const currentIndex = elementsRef.current.indexOf(el2);
            setActiveIndex(currentIndex);
          }
        }
        return;
      }
      const element = elementsRef.current[activeIndex] || null;
      element?.focus();
    });
    return () => cancelAnimationFrame(rafId);
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  };
}
const Root$5 = dt(Box)`
  outline: none;
  overflow: auto;
`, Menu = forwardRef(function(props, forwardedRef) {
  const {
    children,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusFirst,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    focusLast,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemSelect,
    onKeyDown,
    originElement,
    padding = 1,
    registerElement,
    shouldFocus = props.focusFirst && "first" || props.focusLast && "last" || null,
    space: space2 = 1,
    ...restProps
  } = props, ref = useRef(null);
  useImperativeHandle(forwardedRef, () => ref.current);
  const { isTopLayer: isTopLayer2 } = useLayer(), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  } = useMenuController({ onKeyDown, originElement, shouldFocus, rootElementRef: ref }), unregisterElementRef = useRef(null), handleRefChange = useCallback(
    (el2) => {
      unregisterElementRef.current && (unregisterElementRef.current(), unregisterElementRef.current = null), ref.current = el2, ref.current && registerElement && (unregisterElementRef.current = registerElement(ref.current));
    },
    [registerElement]
  );
  useEffect(() => {
    onItemSelect && onItemSelect(activeIndex);
  }, [activeIndex, onItemSelect]), useClickOutsideEvent(isTopLayer2 && onClickOutside, () => [ref.current]), useGlobalKeyDown(
    useCallback(
      (event) => {
        isTopLayer2 && event.key === "Escape" && (event.stopPropagation(), onEscape && onEscape());
      },
      [isTopLayer2, onEscape]
    )
  );
  const value = useMemo(
    () => ({
      version: 0,
      activeElement,
      activeIndex,
      mount,
      onClickOutside,
      onEscape,
      onItemClick,
      onItemMouseEnter: handleItemMouseEnter,
      onItemMouseLeave: handleItemMouseLeave,
      registerElement,
      // deprecated
      onMouseEnter: handleItemMouseEnter,
      onMouseLeave: handleItemMouseLeave
    }),
    [
      activeElement,
      activeIndex,
      mount,
      handleItemMouseEnter,
      handleItemMouseLeave,
      onClickOutside,
      onEscape,
      onItemClick,
      registerElement
    ]
  );
  return /* @__PURE__ */ jsx(MenuContext.Provider, { value, children: /* @__PURE__ */ jsx(
    Root$5,
    {
      "data-ui": "Menu",
      ...restProps,
      onKeyDown: handleKeyDown,
      padding,
      ref: handleRefChange,
      role: "menu",
      tabIndex: -1,
      children: /* @__PURE__ */ jsx(Stack, { space: space2, children })
    }
  ) });
});
Menu.displayName = "ForwardRef(Menu)";
const MenuButton = forwardRef(function(props, forwardedRef) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = !1,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id: id2,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = !0,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, [open, setOpen] = useState(!1), [shouldFocus, setShouldFocus] = useState(null), [buttonElement, setButtonElement] = useState(null), [menuElements, setChildMenuElements] = useState([]), openRef = useRef(open);
  useEffect(() => {
    onOpen && open && !openRef.current && onOpen();
  }, [onOpen, open]), useEffect(() => {
    onClose && !open && openRef.current && onClose();
  }, [onClose, open]), useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = useCallback(() => {
    setOpen((v2) => !v2), setShouldFocus(null);
  }, []), handleMouseDown = useCallback(
    (event) => {
      open && event.preventDefault();
    },
    [open]
  ), handleButtonKeyDown = useCallback((event) => {
    if (event.key === "ArrowDown" || event.key === "Enter" || event.key === " ") {
      event.preventDefault(), setOpen(!0), setShouldFocus("first");
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault(), setOpen(!0), setShouldFocus("last");
      return;
    }
  }, []), handleMenuClickOutside = useCallback(
    (event) => {
      const target2 = event.target;
      if (target2 instanceof Node && !(buttonElement && (target2 === buttonElement || buttonElement.contains(target2)))) {
        for (const el2 of menuElements)
          if (target2 === el2 || el2.contains(target2))
            return;
        setOpen(!1);
      }
    },
    [buttonElement, menuElements]
  ), handleMenuEscape = useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), handleBlur = useCallback(
    (event) => {
      const target2 = event.relatedTarget;
      if (target2 instanceof Node) {
        for (const el2 of menuElements)
          if (el2 === target2 || el2.contains(target2))
            return;
        setOpen(!1);
      }
    },
    [menuElements]
  ), handleItemClick = useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), registerElement = useCallback((el2) => (setChildMenuElements((els2) => els2.concat([el2])), () => setChildMenuElements((els2) => els2.filter((_el) => _el !== el2))), []), menuProps = useMemo(
    () => ({
      "aria-labelledby": id2,
      onBlurCapture: handleBlur,
      onClickOutside: handleMenuClickOutside,
      onEscape: handleMenuEscape,
      onItemClick: handleItemClick,
      originElement: buttonElement,
      registerElement,
      shouldFocus
    }),
    [
      buttonElement,
      handleMenuClickOutside,
      handleMenuEscape,
      handleItemClick,
      id2,
      handleBlur,
      registerElement,
      shouldFocus
    ]
  ), menu = menuProp && cloneElement(menuProp, menuProps), ref = useRef(null), button = useMemo(
    () => {
      var _a;
      return buttonProp && cloneElement(buttonProp, {
        "data-ui": "MenuButton",
        id: id2,
        onClick: handleButtonClick,
        onKeyDown: handleButtonKeyDown,
        onMouseDown: handleMouseDown,
        "aria-haspopup": !0,
        "aria-expanded": open,
        ref,
        selected: (_a = buttonProp.props.selected) != null ? _a : open
      });
    },
    [buttonProp, handleButtonClick, handleButtonKeyDown, handleMouseDown, id2, open]
  );
  useImperativeHandle(
    forwardedRef,
    () => ref.current
  ), useEffect(() => {
    if (button)
      return setButtonElement(ref.current), () => setButtonElement(null);
  }, [button]);
  const popoverProps = useMemo(
    () => ({
      boundaryElement: deprecated_boundaryElement,
      overflow: "auto",
      placement: deprecated_placement,
      portal: deprecated_portal,
      preventOverflow: deprecated_preventOverflow,
      radius: deprecated_popoverRadius,
      scheme: deprecated_popoverScheme,
      ...popover || {}
    }),
    [
      deprecated_boundaryElement,
      deprecated_placement,
      deprecated_popoverRadius,
      deprecated_popoverScheme,
      deprecated_portal,
      deprecated_preventOverflow,
      popover
    ]
  );
  return /* @__PURE__ */ jsx(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: button || /* @__PURE__ */ jsx(Fragment$1, {}) });
});
MenuButton.displayName = "ForwardRef(MenuButton)";
const MenuDivider = dt.hr`
  height: 1px;
  border: 0;
  background: var(--card-hairline-soft-color);
  margin: 0;
`;
MenuDivider.displayName = "MenuDivider";
function selectableBaseStyle() {
  return lt$2`
    background-color: inherit;
    color: inherit;

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function selectableColorStyle(props) {
  var _a;
  const { $tone } = props, { color: color2, style: style2 } = getTheme_v2(props.theme), tone = color2.selectable[$tone];
  return lt$2`
    ${_cardColorStyle(color2, tone.enabled)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);
    outline: none;

    /* &:is(button) */
    &[data-as='button'] {
      &:disabled {
        ${_cardColorStyle(color2, tone.disabled)}
      }

      &:not(:disabled) {
        &[aria-pressed='true'] {
          ${_cardColorStyle(color2, tone.pressed)}
        }

        &[data-selected],
        &[aria-selected='true'] > & {
          ${_cardColorStyle(color2, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, tone.hovered)}
            }

            &:active {
              ${_cardColorStyle(color2, tone.pressed)}
            }
          }
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      &[data-disabled] {
        ${_cardColorStyle(color2, tone.disabled)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color2, tone.pressed)}
        }

        &[data-selected] {
          ${_cardColorStyle(color2, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color2, tone.hovered)}
            }
            &:active {
              ${_cardColorStyle(color2, tone.pressed)}
            }
          }
        }
      }
    }

    ${(_a = style2?.card) == null ? void 0 : _a.root}
  `;
}
const Selectable = dt(Box)(
  responsiveRadiusStyle,
  selectableBaseStyle,
  selectableColorStyle
);
Selectable.displayName = "Selectable";
function useMenu() {
  const value = useContext(MenuContext);
  if (!value)
    throw new Error("useMenu(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useMenu(): the context value is not compatible");
  return value;
}
const MenuItem = forwardRef(function(props, forwardedRef) {
  const {
    as = "button",
    children,
    disabled,
    fontSize: fontSize2 = 1,
    hotkeys,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClick,
    padding = 3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius = 2,
    selected: selectedProp,
    space: space2 = 3,
    text,
    tone = "default",
    ...restProps
  } = props, { scheme } = useRootTheme(), menu = useMenu(), {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter = menu.onMouseEnter,
    onItemMouseLeave = menu.onMouseLeave
  } = menu, [rootElement, setRootElement] = useState(null), active = !!activeElement && activeElement === rootElement, ref = useRef(null);
  useImperativeHandle(forwardedRef, () => ref.current), useEffect(() => mount(rootElement, selectedProp), [mount, rootElement, selectedProp]);
  const handleClick = useCallback(
    (event) => {
      disabled || (onClick && onClick(event), onItemClick && onItemClick());
    },
    [disabled, onClick, onItemClick]
  ), paddingProps = useMemo(
    () => ({
      padding,
      paddingX,
      paddingY,
      paddingTop,
      paddingRight,
      paddingBottom,
      paddingLeft
    }),
    [padding, paddingX, paddingY, paddingTop, paddingRight, paddingBottom, paddingLeft]
  ), hotkeysFontSize = useArrayProp(fontSize2).map((s) => s - 1), setRef = useCallback((el2) => {
    ref.current = el2, setRootElement(el2);
  }, []);
  return /* @__PURE__ */ jsxs(
    Selectable,
    {
      "data-ui": "MenuItem",
      ...restProps,
      "aria-pressed": as === "button" && pressed,
      "data-pressed": as !== "button" && pressed ? "" : void 0,
      "data-selected": active ? "" : void 0,
      "data-disabled": disabled ? "" : void 0,
      forwardedAs: as,
      $radius: useArrayProp(radius),
      $padding: useArrayProp(0),
      $tone: disabled ? "default" : tone,
      $scheme: scheme,
      disabled,
      onClick: handleClick,
      onMouseEnter: onItemMouseEnter,
      onMouseLeave: onItemMouseLeave,
      ref: setRef,
      role: "menuitem",
      tabIndex: -1,
      type: as === "button" ? "button" : void 0,
      children: [
        (IconComponent || text || IconRightComponent) && /* @__PURE__ */ jsxs(Flex, { as: "span", gap: space2, align: "center", ...paddingProps, children: [
          IconComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconComponent) && IconComponent,
            reactIsExports.isValidElementType(IconComponent) && /* @__PURE__ */ jsx(IconComponent, {})
          ] }),
          text && /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
          hotkeys && /* @__PURE__ */ jsx(
            Hotkeys,
            {
              fontSize: hotkeysFontSize,
              keys: hotkeys,
              style: { marginTop: -4, marginBottom: -4 }
            }
          ),
          IconRightComponent && /* @__PURE__ */ jsxs(Text, { size: fontSize2, children: [
            isValidElement(IconRightComponent) && IconRightComponent,
            reactIsExports.isValidElementType(IconRightComponent) && /* @__PURE__ */ jsx(IconRightComponent, {})
          ] })
        ] }),
        children && /* @__PURE__ */ jsx(Box, { as: "span", ...paddingProps, children })
      ]
    }
  );
});
MenuItem.displayName = "ForwardRef(MenuItem)";
const keyframe = mt`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`, animation = lt$2`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`, skeletonStyle = lt$2`
  opacity: ${({ $visible }) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({ $animated }) => $animated ? animation : lt$2`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`, Root$4 = dt(Box)(
  responsiveRadiusStyle,
  skeletonStyle
), Skeleton = forwardRef(function(props, ref) {
  const { animated = !1, delay: delay2, radius, ...restProps } = props, [visible, setVisible] = useState(!delay2);
  return useEffect(() => {
    if (!delay2)
      return setVisible(!0);
    const timeout = setTimeout(() => {
      setVisible(!0);
    }, delay2);
    return () => {
      clearTimeout(timeout);
    };
  }, [delay2]), /* @__PURE__ */ jsx(
    Root$4,
    {
      ...restProps,
      $animated: animated,
      $radius: useArrayProp(radius),
      $visible: visible,
      ref
    }
  );
});
Skeleton.displayName = "ForwardRef(Skeleton)";
const Root$3 = dt(Skeleton)((props) => {
  const { $size, $style } = props, { font, media } = getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = fontStyle.sizes[sizeIndex];
    return { height: fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight };
  });
}), TextSkeleton = forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "text" });
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
const LabelSkeleton = forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "label" });
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
const HeadingSkeleton = forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "heading" });
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
const CodeSkeleton = forwardRef(function(props, ref) {
  const { size: size2 = 2, ...restProps } = props, $size = useArrayProp(size2);
  return /* @__PURE__ */ jsx(Root$3, { ...restProps, $size, ref, $style: "code" });
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
const CustomButton = dt(Button)`
  max-width: 100%;
`, Tab = forwardRef(function(props, forwardedRef) {
  const {
    icon,
    id: id2,
    focused,
    fontSize: fontSize2 = 1,
    label,
    onClick,
    onFocus,
    padding = 2,
    selected,
    ...restProps
  } = props, ref = useRef(null), focusedRef = useRef(!1);
  useImperativeHandle(
    forwardedRef,
    () => ref.current
  );
  const handleBlur = useCallback(() => {
    focusedRef.current = !1;
  }, []), handleFocus = useCallback(
    (event) => {
      focusedRef.current = !0, onFocus && onFocus(event);
    },
    [onFocus]
  );
  return useEffect(() => {
    focused && !focusedRef.current && (ref.current && ref.current.focus(), focusedRef.current = !0);
  }, [focused]), /* @__PURE__ */ jsx(
    CustomButton,
    {
      "data-ui": "Tab",
      ...restProps,
      "aria-selected": selected ? "true" : "false",
      fontSize: fontSize2,
      icon,
      id: id2,
      mode: "bleed",
      onClick,
      onBlur: handleBlur,
      onFocus: handleFocus,
      padding,
      ref,
      role: "tab",
      selected,
      tabIndex: selected ? 0 : -1,
      text: label,
      type: "button"
    }
  );
});
Tab.displayName = "ForwardRef(Tab)";
function _isReactElement(node2) {
  return !!node2;
}
const CustomInline = dt(Inline)`
  & > div {
    display: inline-block;
    vertical-align: middle;
    max-width: 100%;
    box-sizing: border-box;
  }
`, TabList = forwardRef(function(props, ref) {
  const { children: childrenProp, ...restProps } = props, [focusedIndex, setFocusedIndex] = useState(-1), tabs = useMemo(() => childrenProp.filter(_isReactElement), [childrenProp]).map(
    (child, childIndex) => cloneElement(child, {
      focused: focusedIndex === childIndex,
      key: childIndex,
      onFocus: () => handleTabFocus(childIndex)
    })
  ), numTabs = tabs.length, handleTabFocus = useCallback((tabIdx) => {
    setFocusedIndex(tabIdx);
  }, []), handleKeyDown = useCallback(
    (event) => {
      event.key === "ArrowLeft" && setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs), event.key === "ArrowRight" && setFocusedIndex((prevIndex) => (prevIndex + 1) % numTabs);
    },
    [numTabs]
  );
  return /* @__PURE__ */ jsx(
    CustomInline,
    {
      "data-ui": "TabList",
      ...restProps,
      onKeyDown: handleKeyDown,
      ref,
      role: "tablist",
      children: tabs
    }
  );
});
TabList.displayName = "ForwardRef(TabList)";
const TabPanel = forwardRef(function(props, ref) {
  const { flex, ...restProps } = props;
  return /* @__PURE__ */ jsx(
    Box,
    {
      "data-ui": "TabPanel",
      ...restProps,
      flex,
      ref,
      role: "tabpanel",
      tabIndex: props.tabIndex === void 0 ? 0 : props.tabIndex,
      children: props.children
    }
  );
});
TabPanel.displayName = "ForwardRef(TabPanel)";
dt(Flex)`
  overflow-x: auto;
`;
const loadingAnimation = mt`
  0% {
    width: 0;
  }
  100% {
    width: 100%;
  }
`, LOADING_BAR_HEIGHT = 2;
function rootStyles(props) {
  const { color: color2 } = getTheme_v2(props.theme), loadingBarColor = color2.button.default[props.tone].enabled.bg;
  return props.$duration ? lt$2`
    pointer-events: all;
    width: 100%;
    position: relative;
    overflow: hidden;
    overflow: clip;
    padding-bottom: ${LOADING_BAR_HEIGHT}px;
    &::before {
      content: '';
      position: absolute;
      bottom: 0px;
      height: ${LOADING_BAR_HEIGHT}px;
      background: ${loadingBarColor};
      animation-name: ${loadingAnimation};
      animation-duration: ${props.$duration}ms;
      animation-fill-mode: both;
    }

    & > * {
      opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
      will-change: opacity;
    }
  ` : lt$2`
      pointer-events: all;
      & > * {
        opacity: var(${POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
        will-change: opacity;
      }
    `;
}
dt(Card)(
  rootStyles
);
const ToastContext = createGlobalScopedContext(
  "@sanity/ui/context/toast",
  null
);
dt(Layer)`
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
`;
dt.div`
  box-sizing: border-box;
  position: absolute;
  right: 0;
  bottom: 0;
  max-width: 420px;
  width: 100%;
`;
function useToast() {
  const value = useContext(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els2 = itemElements.slice(0, idx), len = els2.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els2[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j2 = 0; j2 < segments.length; j2 += 1) {
      p.push(segments[j2]);
      const k2 = p.join("/");
      if (!((_a = state[k2]) != null && _a.expanded)) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els2[i];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els2 = itemElements.slice(idx), len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els2[i])
      continue;
    const itemKey = els2[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j2 = 0; j2 < segments.length; j2 += 1) {
      p.push(segments[j2]);
      const k2 = p.join("/");
      if (!((_a = state[k2]) != null && _a.expanded)) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els2[i];
  }
  return null;
}
function _focusItemElement(el2) {
  if (el2.getAttribute("role") === "treeitem" && el2.focus(), el2.getAttribute("role") === "none") {
    const firstChild = el2.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
const TreeContext = createGlobalScopedContext(
  "@sanity/ui/context/tree",
  null
), Tree = memo$1(
  forwardRef(function(props, forwardedRef) {
    const { children, space: space2 = 1, onFocus, ...restProps } = props, ref = useRef(null), [focusedElement, setFocusedElement] = useState(null), focusedElementRef = useRef(focusedElement), path = useMemo(() => [], []), [itemElements, setItemElements] = useState([]), [state, setState] = useState({}), stateRef = useRef(state);
    useImperativeHandle(
      forwardedRef,
      () => ref.current
    ), useEffect(() => {
      focusedElementRef.current = focusedElement;
    }, [focusedElement]), useEffect(() => {
      stateRef.current = state;
    }, [state]);
    const registerItem = useCallback(
      (element, path2, expanded, selected) => (setState((s) => ({ ...s, [path2]: { element, expanded } })), selected && setFocusedElement(element), () => {
        setState((s) => {
          const newState = { ...s };
          return delete newState[path2], newState;
        });
      }),
      []
    ), setExpanded = useCallback((path2, expanded) => {
      setState((s) => {
        const itemState = s[path2];
        return itemState ? { ...s, [path2]: { ...itemState, expanded } } : s;
      });
    }, []), contextValue = useMemo(
      () => ({
        version: 0,
        focusedElement: focusedElement || itemElements[0] || null,
        level: 0,
        path,
        registerItem,
        setExpanded,
        setFocusedElement,
        space: space2,
        state
      }),
      [focusedElement, itemElements, path, registerItem, setExpanded, space2, state]
    ), handleKeyDown = useCallback(
      (event) => {
        var _a;
        if (focusedElementRef.current) {
          if (event.key === "ArrowDown") {
            event.preventDefault();
            const nextEl = _findNextItemElement(
              stateRef.current,
              itemElements,
              focusedElementRef.current
            );
            nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
            return;
          }
          if (event.key === "ArrowUp") {
            event.preventDefault();
            const prevEl = _findPrevItemElement(
              stateRef.current,
              itemElements,
              focusedElementRef.current
            );
            prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
            return;
          }
          if (event.key === "ArrowLeft") {
            event.preventDefault();
            const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
            if (!itemKey) return;
            const itemState = stateRef.current[itemKey];
            if (!itemState) return;
            if (itemState.expanded)
              setState((s) => {
                const itemState2 = s[itemKey];
                return itemState2 ? { ...s, [itemKey]: { ...itemState2, expanded: !1 } } : s;
              });
            else {
              const itemPath = itemKey.split("/");
              itemPath.pop();
              const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
              parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
            }
            return;
          }
          if (event.key === "ArrowRight") {
            event.preventDefault();
            const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
            if (!focusedKey) return;
            (_a = stateRef.current[focusedKey]) != null && _a.expanded || setState((s) => {
              const itemState = s[focusedKey];
              return itemState ? { ...s, [focusedKey]: { ...itemState, expanded: !0 } } : s;
            });
            return;
          }
        }
      },
      [itemElements]
    ), handleFocus = useCallback(
      (event) => {
        setFocusedElement(event.target), onFocus?.(event);
      },
      [onFocus]
    );
    return useEffect(() => {
      if (!ref.current) return;
      const _itemElements = Array.from(
        ref.current.querySelectorAll('[data-ui="TreeItem"]')
      );
      setItemElements(_itemElements);
    }, [children]), /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: /* @__PURE__ */ jsx(
      Stack,
      {
        as: "ul",
        "data-ui": "Tree",
        ...restProps,
        onFocus: handleFocus,
        onKeyDown: handleKeyDown,
        ref,
        role: "tree",
        space: space2,
        children
      }
    ) });
  })
);
Tree.displayName = "Memo(ForwardRef(Tree))";
function treeItemRootStyle() {
  return lt$2`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", { color: color2 } = getTheme_v2(props.theme), tone = color2.selectable[$tone];
  return lt$2`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color2, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color2, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color2, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color2, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color2, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color2, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color2, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color2, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const { $level } = props, { space: space2 } = getTheme_v2(props.theme);
  return lt$2`
    padding-left: ${rem(space2[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = useContext(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
const TreeGroup = memo$1(function(props) {
  const { children, expanded = !1, ...restProps } = props, tree = useTree();
  return /* @__PURE__ */ jsx(
    Stack,
    {
      as: "ul",
      "data-ui": "TreeGroup",
      ...restProps,
      hidden: !expanded,
      marginTop: tree.space,
      role: "group",
      space: tree.space,
      children
    }
  );
}), Root = memo$1(dt.li(treeItemRootStyle, treeItemRootColorStyle)), TreeItemBox = dt(Box).attrs({ forwardedAs: "a" })(treeItemBoxStyle), ToggleArrowText = dt(Text)`
  & > svg {
    transition: transform 100ms;
  }
`, TreeItem = memo$1(function(props) {
  const {
    children,
    expanded: expandedProp = !1,
    fontSize: fontSize2 = 1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = !1,
    space: space2 = 2,
    text,
    weight,
    ...restProps
  } = props, rootRef = useRef(null), treeitemRef = useRef(null), tree = useTree(), { path, registerItem, setExpanded, setFocusedElement } = tree, _id = useId(), id2 = idProp || _id, itemPath = useMemo(() => path.concat([id2 || ""]), [id2, path]), itemKey = itemPath.join("/"), itemState = tree.state[itemKey], focused = tree.focusedElement === rootRef.current, expanded = itemState?.expanded === void 0 ? expandedProp : itemState?.expanded || !1, tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1, contextValue = useMemo(
    () => ({ ...tree, level: tree.level + 1, path: itemPath }),
    [itemPath, tree]
  ), handleClick = useCallback(
    (event) => {
      onClick && onClick(event);
      const target2 = event.target;
      target2 instanceof HTMLElement && (target2.getAttribute("data-ui") === "TreeItem" || target2.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootRef.current));
    },
    [expanded, itemKey, onClick, setExpanded, setFocusedElement]
  ), handleKeyDown = useCallback(
    (event) => {
      if (focused && event.key === "Enter") {
        const el2 = treeitemRef.current || rootRef.current;
        el2?.click();
      }
    },
    [focused]
  );
  useEffect(() => {
    if (rootRef.current)
      return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */ jsxs(Flex, { padding, children: [
    /* @__PURE__ */ jsxs(
      Box,
      {
        marginRight: space2,
        style: {
          visibility: IconComponent || children ? "visible" : "hidden",
          pointerEvents: "none"
        },
        children: [
          IconComponent && /* @__PURE__ */ jsx(Text, { muted, size: fontSize2, weight, children: /* @__PURE__ */ jsx(IconComponent, {}) }),
          !IconComponent && /* @__PURE__ */ jsx(ToggleArrowText, { muted, size: fontSize2, weight, children: /* @__PURE__ */ jsx(ToggleArrowRightIcon, { style: { transform: expanded ? "rotate(90deg)" : void 0 } }) })
        ]
      }
    ),
    /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { muted, size: fontSize2, textOverflow: "ellipsis", weight, children: text }) })
  ] });
  return href ? /* @__PURE__ */ jsxs(
    Root,
    {
      "data-selected": selected ? "" : void 0,
      "data-tree-id": id2,
      "data-tree-key": itemKey,
      "data-ui": "TreeItem",
      ...restProps,
      onClick: handleClick,
      ref: rootRef,
      role: "none",
      children: [
        /* @__PURE__ */ jsx(
          TreeItemBox,
          {
            $level: tree.level,
            "aria-expanded": expanded,
            as: linkAs,
            "data-ui": "TreeItem__box",
            href,
            ref: treeitemRef,
            role: "treeitem",
            tabIndex,
            children: content
          }
        ),
        /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsx(TreeGroup, { hidden: !expanded, children }) })
      ]
    }
  ) : /* @__PURE__ */ jsxs(
    Root,
    {
      "data-selected": selected ? "" : void 0,
      "data-ui": "TreeItem",
      "data-tree-id": id2,
      "data-tree-key": itemKey,
      ...restProps,
      "aria-expanded": expanded,
      onClick: handleClick,
      onKeyDown: handleKeyDown,
      ref: rootRef,
      role: "treeitem",
      tabIndex,
      children: [
        /* @__PURE__ */ jsx(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content }),
        /* @__PURE__ */ jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsx(TreeGroup, { expanded, children }) })
      ]
    }
  );
});
TreeItem.displayName = "Memo(TreeItem)";
const NOTES_KEY = "shared_notes_content", ContentEditable = ({ onChange, html: html2 }) => {
  const ref = useRef(null), handleInput = (e) => {
    const newHtml = e.target.innerHTML;
    newHtml !== html2 && onChange(newHtml);
  };
  return useEffect(() => {
    ref.current && ref.current.innerHTML !== html2 && (ref.current.innerHTML = html2);
  }, [html2]), /* @__PURE__ */ jsx(
    "div",
    {
      ref,
      onInput: handleInput,
      contentEditable: !0,
      style: {
        flex: 1,
        overflowY: "auto",
        padding: "2rem",
        fontFamily: "sans-serif",
        fontSize: "16px",
        lineHeight: 1.5,
        background: "#13141b",
        color: "#ffffff",
        minHeight: "calc(100vh - 200px)",
        outline: "none",
        border: "none",
        whiteSpace: "pre-wrap",
        wordWrap: "break-word"
      }
    }
  );
}, NotesPanel = () => {
  const [notes, setNotes] = useState(""), [isExpanded, setIsExpanded] = useState(!1), [isSaving, setIsSaving] = useState(!1), client = useClient(), toast = useToast();
  return useEffect(() => {
    client.fetch(`*[_id == "${NOTES_KEY}"][0].content`).then((fetchedNotes) => {
      setNotes(fetchedNotes || "");
    });
  }, []), /* @__PURE__ */ jsx(
    Card,
    {
      shadow: 2,
      style: {
        position: "fixed",
        bottom: isExpanded ? "20px" : "0",
        left: "50%",
        transform: "translateX(-50%)",
        width: isExpanded ? "90%" : "200px",
        maxWidth: "1400px",
        height: isExpanded ? "calc(100vh - 40px)" : "40px",
        transition: "all 0.3s ease",
        overflow: "hidden",
        zIndex: 1e3,
        borderRadius: isExpanded ? "8px" : "8px 8px 0 0"
      },
      children: /* @__PURE__ */ jsxs(Flex, { direction: "column", style: { height: "100%" }, children: [
        /* @__PURE__ */ jsxs(
          Flex,
          {
            align: "center",
            justify: "space-between",
            style: {
              padding: "0 5rem",
              alignItems: "center",
              marginTop: isExpanded ? "20px" : "0",
              justifyContent: isExpanded ? "space-between" : "center"
            },
            children: [
              /* @__PURE__ */ jsx(
                Button,
                {
                  mode: "bleed",
                  onClick: () => setIsExpanded(!isExpanded),
                  style: { display: "flex", padding: "3px" },
                  children: /* @__PURE__ */ jsxs(Text, { weight: "semibold", children: [
                    " ",
                    isExpanded ? "Shared Notepad" : "Open Shared Notepad",
                    " "
                  ] })
                }
              ),
              isExpanded && /* @__PURE__ */ jsxs(Flex, { children: [
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    mode: "ghost",
                    tone: "primary",
                    onClick: async () => {
                      setIsSaving(!0);
                      try {
                        await client.createOrReplace({
                          _type: "system.metadata",
                          _id: NOTES_KEY,
                          content: notes
                        }), toast.push({
                          status: "success",
                          title: "Notes saved successfully"
                        });
                      } catch (error) {
                        console.error("Error saving notes:", error), toast.push({
                          status: "error",
                          title: "Failed to save notes"
                        });
                      }
                      setIsSaving(!1);
                    },
                    disabled: isSaving,
                    style: { marginRight: "10px", borderRadius: "50px", padding: "0 20px" },
                    children: isSaving ? "Saving..." : "Save"
                  }
                ),
                /* @__PURE__ */ jsx(
                  Button,
                  {
                    mode: "ghost",
                    tone: "critical",
                    style: { borderRadius: "50px", padding: "0 20px" },
                    onClick: () => setIsExpanded(!1),
                    children: "Close"
                  }
                )
              ] })
            ]
          }
        ),
        isExpanded && /* @__PURE__ */ jsx(Flex, { direction: "column", flex: 1, padding: 4, children: /* @__PURE__ */ jsx(ContentEditable, { html: notes, onChange: setNotes }) })
      ] })
    }
  );
}, sharedNotesNotepadPlugin = definePlugin({
  name: "shared-notes-notepad",
  studio: {
    components: {
      layout: (props) => /* @__PURE__ */ jsxs(React__default.Fragment, { children: [
        props.renderDefault(props),
        /* @__PURE__ */ jsx(NotesPanel, {})
      ] })
    }
  }
});
export {
  sharedNotesNotepadPlugin
};
//# sourceMappingURL=index.mjs.map
